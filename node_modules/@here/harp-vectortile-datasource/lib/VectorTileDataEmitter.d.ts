import { DecodedTile, IndexedTechnique } from "@here/harp-datasource-protocol";
import { StyleSetEvaluator } from "@here/harp-datasource-protocol/index-decoder";
import { AttrEvaluationContext } from "@here/harp-datasource-protocol/lib/TechniqueAttr";
import * as THREE from "three";
import { DecodeInfo } from "./DecodeInfo";
import { ILineGeometry, IPolygonGeometry } from "./IGeometryProcessor";
/**
 * Options for VectorTileDataEmitter, see {@link DecoderOptions} and {@link OmvDecoderOptions}.
 * @internal
 */
export interface VectorTileDataEmitterOptions {
    gatherFeatureAttributes?: boolean;
    skipShortLabels?: boolean;
    enableElevationOverlay?: boolean;
    languages?: string[];
}
export declare class VectorTileDataEmitter {
    private readonly m_decodeInfo;
    private readonly m_styleSetEvaluator;
    private readonly m_options;
    private readonly m_meshBuffers;
    private readonly m_geometries;
    private readonly m_textGeometries;
    private readonly m_textPathGeometries;
    private readonly m_pathGeometries;
    private readonly m_poiGeometries;
    private readonly m_simpleLines;
    private readonly m_solidLines;
    private readonly m_sources;
    private m_maxGeometryHeight;
    private m_minGeometryHeight;
    constructor(m_decodeInfo: DecodeInfo, m_styleSetEvaluator: StyleSetEvaluator, m_options?: VectorTileDataEmitterOptions);
    get projection(): import("@here/harp-geoutils").Projection;
    get center(): THREE.Vector3;
    /**
     * Creates the Point of Interest geometries for the given feature.
     *
     * @param layer - Tile's layer to be processed.
     * @param extents - Tile's layer extents.
     * @param geometry - The feature geometry in local webMercator coordinates.
     * @param env - The [[MapEnv]] containing the environment information for the map.
     * @param techniques - The array of [[Technique]] that will be applied to the geometry.
     */
    processPointFeature(layer: string, extents: number, geometry: THREE.Vector3[], context: AttrEvaluationContext, techniques: IndexedTechnique[]): void;
    /**
     *
     * Creates the line geometries for the given feature.
     *
     * @param layer - Tile's layer to be processed.
     * @param extents - Tile's layer extents.
     * @param geometry - The current feature containing the main geometry.
     * @param env - The [[MapEnv]] containing the environment information for the map.
     * @param techniques - The array of [[Technique]] that will be applied to the geometry.
     */
    processLineFeature(layer: string, extents: number, geometry: ILineGeometry[], context: AttrEvaluationContext, techniques: IndexedTechnique[]): void;
    /**
     * Creates the polygons geometries for the given feature.
     *
     * @param layer - Tile's layer to be processed.
     * @param extents - Tile's layer extents.
     * @param geometry - The current feature containing the main geometry.
     * @param feature - The [[MapEnv]] containing the environment information for the map.
     * @param techniques - The array of [[Technique]] that will be applied to the geometry.
     */
    processPolygonFeature(layer: string, extents: number, geometry: IPolygonGeometry[], context: AttrEvaluationContext, techniques: IndexedTechnique[]): void;
    /**
     * Creates the geometries that belongs to the [[Tile].
     *
     * @returns The [[DecodedTile]]
     */
    getDecodedTile(): DecodedTile;
    /**
     * Split the lines array into multiple parts if there are sharp corners. Reject parts that are
     * too short to display the label text.
     *
     * @param {number[][]} lines Array containing the points of the paths.
     * @param {number} minEstimatedLabelLengthSqr Minimum label size squared.
     * @param {number} maxCornerAngle Maximum angle between consecutive path segments in radians.
     * @returns The split and filtered lines array.
     */
    protected splitJaggyLines(lines: number[][], minEstimatedLabelLengthSqr: number, maxCornerAngle: number): number[][];
    private getTextureCoordinateType;
    private getComputeTexCoordsFunc;
    private applyLineTechnique;
    private applyPolygonTechnique;
    private createGeometries;
    private processLines;
    private processSimpleLines;
    private findOrCreateMeshBuffers;
    private processFeatureCommon;
    private isColorStringValid;
    private addEdges;
    private addWalls;
    private findRelativePositionInLine;
}
//# sourceMappingURL=VectorTileDataEmitter.d.ts.map