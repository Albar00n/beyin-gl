"use strict";
/*
 * Copyright (C) 2020-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoJsonDataAdapter = void 0;
const ClipLineString_1 = require("@here/harp-geometry/lib/ClipLineString");
const harp_geoutils_1 = require("@here/harp-geoutils");
const three_1 = require("three");
const OmvUtils_1 = require("../../OmvUtils");
const DEFAULT_EXTENTS = 4 * 1024;
const worldP = new three_1.Vector3();
/**
 * Converts a `geoPoint` to local tile space.
 *
 * @param geoPoint - The input [[GeoPointLike]].
 * @param decodeInfo - The [[DecodeInfo]].
 * @param target - A [[VectorLike]] used as target of the converted coordinates.
 * @return A [[VectorLike]] with the converted point.
 * @hidden
 */
function convertPoint(geoPoint, decodeInfo, target) {
    harp_geoutils_1.webMercatorProjection.projectPoint(harp_geoutils_1.GeoCoordinates.fromGeoPoint(geoPoint), worldP);
    return OmvUtils_1.world2tile(DEFAULT_EXTENTS, decodeInfo, worldP, false, target);
}
function convertLineStringGeometry(coordinates, decodeInfo) {
    const untiledPositions = coordinates.map(geoPoint => {
        return harp_geoutils_1.GeoCoordinates.fromGeoPoint(geoPoint);
    });
    const positions = coordinates.map(geoPoint => convertPoint(geoPoint, decodeInfo, new three_1.Vector2()));
    return { untiledPositions, positions };
}
function convertLineGeometry(geometry, decodeInfo) {
    if (geometry.type === "LineString") {
        return [convertLineStringGeometry(geometry.coordinates, decodeInfo)];
    }
    return geometry.coordinates.map(lineString => convertLineStringGeometry(lineString, decodeInfo));
}
function convertRings(coordinates, decodeInfo) {
    const rings = coordinates.map((ring, i) => {
        const isOuterRing = i === 0;
        const { positions } = convertLineStringGeometry(ring, decodeInfo);
        const isClockWise = three_1.ShapeUtils.area(positions) > 0;
        if ((isOuterRing && !isClockWise) || (!isOuterRing && isClockWise)) {
            positions.reverse();
        }
        return positions;
    });
    return { rings };
}
function convertPolygonGeometry(geometry, decodeInfo) {
    if (geometry.type === "Polygon") {
        return [convertRings(geometry.coordinates, decodeInfo)];
    }
    return geometry.coordinates.map(polygon => convertRings(polygon, decodeInfo));
}
function convertPointGeometry(geometry, decodeInfo) {
    if (geometry.type === "Point") {
        return [convertPoint(geometry.coordinates, decodeInfo, new three_1.Vector3())];
    }
    return geometry.coordinates.map(geoPoint => convertPoint(geoPoint, decodeInfo, new three_1.Vector3()));
}
class GeoJsonDataAdapter {
    /**
     * @override
     */
    canProcess(featureCollection) {
        return (featureCollection &&
            featureCollection.type === "FeatureCollection" &&
            Array.isArray(featureCollection.features));
    }
    /** @override */
    process(featureCollection, decodeInfo, geometryProcessor, layer = "geojson") {
        if (!Array.isArray(featureCollection.features) || featureCollection.features.length === 0) {
            return;
        }
        for (const feature of featureCollection.features) {
            switch (feature.geometry.type) {
                case "LineString":
                case "MultiLineString": {
                    let geometry = convertLineGeometry(feature.geometry, decodeInfo);
                    const clippedGeometries = [];
                    const DEFAULT_BORDER = 100;
                    geometry.forEach(g => {
                        const clipped = ClipLineString_1.clipLineString(g.positions, -DEFAULT_BORDER, -DEFAULT_BORDER, DEFAULT_EXTENTS + DEFAULT_BORDER, DEFAULT_EXTENTS + DEFAULT_BORDER);
                        clipped.forEach(positions => {
                            clippedGeometries.push({ positions });
                        });
                    });
                    geometry = clippedGeometries;
                    if (geometry.length > 0) {
                        geometryProcessor.processLineFeature(layer, DEFAULT_EXTENTS, clippedGeometries, feature.properties, feature.id);
                    }
                    break;
                }
                case "Polygon":
                case "MultiPolygon": {
                    const geometry = convertPolygonGeometry(feature.geometry, decodeInfo);
                    geometryProcessor.processPolygonFeature(layer, DEFAULT_EXTENTS, geometry, feature.properties, feature.id);
                    break;
                }
                case "Point":
                case "MultiPoint": {
                    const geometry = convertPointGeometry(feature.geometry, decodeInfo);
                    geometryProcessor.processPointFeature(layer, DEFAULT_EXTENTS, geometry, feature.properties, feature.id);
                    break;
                }
            }
        }
    }
}
exports.GeoJsonDataAdapter = GeoJsonDataAdapter;
//# sourceMappingURL=GeoJsonDataAdapter.js.map