import { ValueMap } from "@here/harp-datasource-protocol/index-decoder";
import { DataAdapter } from "../../DataAdapter";
import { DecodeInfo } from "../../DecodeInfo";
import { IGeometryProcessor } from "../../IGeometryProcessor";
declare type VTJsonPosition = [number, number];
declare enum VTJsonGeometryType {
    Unknown = 0,
    Point = 1,
    LineString = 2,
    Polygon = 3
}
interface VTJsonFeatureInterface {
    geometry: VTJsonPosition[] | VTJsonPosition[][];
    id: string;
    tags: ValueMap;
    type: VTJsonGeometryType;
}
interface VTJsonSourceInterface {
    geometry: number[];
    length: number;
    id: string;
    maxX: number;
    maxY: number;
    minX: number;
    minY: number;
    tags: ValueMap;
    type: string;
}
interface VTJsonTileInterface {
    features: VTJsonFeatureInterface[];
    maxX: number;
    maxY: number;
    minX: number;
    minY: number;
    numFeatures: number;
    numPoints: number;
    numSimplified: number;
    source: VTJsonSourceInterface[];
    transformed: boolean;
    x: number;
    y: number;
    z: number;
    layer: string;
}
/**
 * The class `GeoJsonVtDataAdapter` converts VT-json data to geometries for the given
 * {@link IGeometryProcessor}.
 */
export declare class GeoJsonVtDataAdapter implements DataAdapter {
    /**
     * @override
     */
    canProcess(data: ArrayBufferLike | {}): boolean;
    /**
     * @override
     */
    process(tile: VTJsonTileInterface, decodeInfo: DecodeInfo, geometryProcessor: IGeometryProcessor): void;
}
export {};
//# sourceMappingURL=GeoJsonVtDataAdapter.d.ts.map