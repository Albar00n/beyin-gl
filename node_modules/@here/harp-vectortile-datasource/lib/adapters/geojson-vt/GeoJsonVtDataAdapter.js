"use strict";
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoJsonVtDataAdapter = void 0;
const harp_geoutils_1 = require("@here/harp-geoutils");
const three_1 = require("three");
const OmvUtils_1 = require("../../OmvUtils");
const VT_JSON_EXTENTS = 4096;
var VTJsonGeometryType;
(function (VTJsonGeometryType) {
    VTJsonGeometryType[VTJsonGeometryType["Unknown"] = 0] = "Unknown";
    VTJsonGeometryType[VTJsonGeometryType["Point"] = 1] = "Point";
    VTJsonGeometryType[VTJsonGeometryType["LineString"] = 2] = "LineString";
    VTJsonGeometryType[VTJsonGeometryType["Polygon"] = 3] = "Polygon";
})(VTJsonGeometryType || (VTJsonGeometryType = {}));
const worldPos = new three_1.Vector3();
/**
 * The class `GeoJsonVtDataAdapter` converts VT-json data to geometries for the given
 * {@link IGeometryProcessor}.
 */
class GeoJsonVtDataAdapter {
    /**
     * @override
     */
    canProcess(data) {
        if (OmvUtils_1.isArrayBufferLike(data)) {
            return false;
        }
        const tile = data;
        if (tile.features === undefined ||
            tile.source === undefined ||
            tile.x === undefined ||
            tile.y === undefined ||
            tile.z === undefined) {
            return false;
        }
        return true;
    }
    /**
     * @override
     */
    process(tile, decodeInfo, geometryProcessor) {
        for (const feature of tile.features) {
            switch (feature.type) {
                case VTJsonGeometryType.Point: {
                    for (const pointGeometry of feature.geometry) {
                        const x = pointGeometry[0];
                        const y = pointGeometry[1];
                        const position = new three_1.Vector3(x, y, 0);
                        geometryProcessor.processPointFeature(tile.layer, VT_JSON_EXTENTS, [position], feature.tags, feature.id);
                    }
                    break;
                }
                case VTJsonGeometryType.LineString: {
                    const lineGeometries = feature.geometry;
                    let lastLine;
                    const lines = [];
                    lineGeometries.forEach(lineGeometry => {
                        const lastPos = lastLine === null || lastLine === void 0 ? void 0 : lastLine.positions[lastLine.positions.length - 1];
                        const [startx, starty] = lineGeometry[0];
                        if ((lastPos === null || lastPos === void 0 ? void 0 : lastPos.x) === startx && (lastPos === null || lastPos === void 0 ? void 0 : lastPos.y) === starty) {
                            // continue the last line
                            for (let i = 1; i < lineGeometry.length; ++i) {
                                const [x, y] = lineGeometry[i];
                                lastLine === null || lastLine === void 0 ? void 0 : lastLine.positions.push(new three_1.Vector2(x, y));
                            }
                        }
                        else {
                            // start a new line
                            const positions = lineGeometry.map(([x, y]) => new three_1.Vector2(x, y));
                            lines.push({ positions });
                            lastLine = lines[lines.length - 1];
                        }
                    });
                    lines.forEach(line => {
                        line.untiledPositions = line.positions.map(tilePos => {
                            OmvUtils_1.tile2world(VT_JSON_EXTENTS, decodeInfo, tilePos, false, worldPos);
                            return harp_geoutils_1.webMercatorProjection.unprojectPoint(worldPos);
                        });
                    });
                    geometryProcessor.processLineFeature(tile.layer, VT_JSON_EXTENTS, lines, feature.tags, feature.id);
                    break;
                }
                case VTJsonGeometryType.Polygon: {
                    const polygons = [];
                    let polygon;
                    for (const outline of feature.geometry) {
                        const ring = [];
                        for (const [currX, currY] of outline) {
                            const position = new three_1.Vector2(currX, currY);
                            ring.push(position);
                        }
                        // MVT spec defines that each exterior ring signals the beginning of a new polygon.
                        // See https://github.com/mapbox/vector-tile-spec/tree/master/2.1
                        if (three_1.ShapeUtils.area(ring) > 0) {
                            // Create a new polygon and push it into the collection of polygons
                            polygon = { rings: [] };
                            polygons.push(polygon);
                        }
                        // Push the ring into the current polygon
                        polygon === null || polygon === void 0 ? void 0 : polygon.rings.push(ring);
                    }
                    geometryProcessor.processPolygonFeature(tile.layer, VT_JSON_EXTENTS, polygons, feature.tags, feature.id);
                    break;
                }
                case VTJsonGeometryType.Unknown: {
                    break;
                }
            }
        }
    }
}
exports.GeoJsonVtDataAdapter = GeoJsonVtDataAdapter;
//# sourceMappingURL=GeoJsonVtDataAdapter.js.map