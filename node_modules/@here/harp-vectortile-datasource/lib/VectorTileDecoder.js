"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorTileDecoderService = exports.VectorTileDecoder = exports.VectorTileDataProcessor = void 0;
/*
 * Copyright (C) 2019-2022 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const index_decoder_1 = require("@here/harp-datasource-protocol/index-decoder");
const index_worker_1 = require("@here/harp-mapview-decoder/index-worker");
const harp_utils_1 = require("@here/harp-utils");
const GeoJsonDataAdapter_1 = require("./adapters/geojson/GeoJsonDataAdapter");
const GeoJsonVtDataAdapter_1 = require("./adapters/geojson-vt/GeoJsonVtDataAdapter");
const OmvDataAdapter_1 = require("./adapters/omv/OmvDataAdapter");
const DecodeInfo_1 = require("./DecodeInfo");
const OmvDecoderDefs_1 = require("./OmvDecoderDefs");
const VectorTileDataEmitter_1 = require("./VectorTileDataEmitter");
const logger = harp_utils_1.LoggerManager.instance.create("VectorTileDecoder", { enabled: false });
/**
 * Geometry processor for vector tiles.
 * @internal
 */
class VectorTileDataProcessor {
    constructor(m_tileKey, m_projection, m_styleSetEvaluator, m_dataAdapter, m_options = {}, m_dataFilter) {
        var _a, _b;
        this.m_tileKey = m_tileKey;
        this.m_projection = m_projection;
        this.m_styleSetEvaluator = m_styleSetEvaluator;
        this.m_dataAdapter = m_dataAdapter;
        this.m_options = m_options;
        this.m_dataFilter = m_dataFilter;
        m_options.storageLevelOffset = (_a = m_options.storageLevelOffset) !== null && _a !== void 0 ? _a : 0;
        m_options.showMissingTechniques = (_b = m_options.showMissingTechniques) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Decodes the given tile data.
     *
     * @param data - The tile data to decode.
     * @returns A [[DecodedTile]]
     */
    getDecodedTile(data) {
        this.m_styleSetEvaluator.resetTechniques();
        const decodeInfo = new DecodeInfo_1.DecodeInfo(this.m_projection, this.m_tileKey, this.m_options.storageLevelOffset);
        this.m_decodedTileEmitter = new VectorTileDataEmitter_1.VectorTileDataEmitter(decodeInfo, this.m_styleSetEvaluator, this.m_options);
        this.m_dataAdapter.process(data, decodeInfo, this);
        return this.m_decodedTileEmitter.getDecodedTile();
    }
    /** @override */
    processPointFeature(layer, extents, geometry, properties, featureId) {
        harp_utils_1.assert(this.m_decodedTileEmitter !== undefined);
        this.processFeature(layer, extents, geometry, "point", properties, featureId, this.m_decodedTileEmitter.processPointFeature, harp_datasource_protocol_1.GeometryKind.Label);
    }
    /** @override */
    processLineFeature(layer, extents, geometry, properties, featureId) {
        harp_utils_1.assert(this.m_decodedTileEmitter !== undefined);
        this.processFeature(layer, extents, geometry, "line", properties, featureId, this.m_decodedTileEmitter.processLineFeature, harp_datasource_protocol_1.GeometryKind.Line);
    }
    /** @override */
    processPolygonFeature(layer, extents, geometry, properties, featureId) {
        harp_utils_1.assert(this.m_decodedTileEmitter !== undefined);
        this.processFeature(layer, extents, geometry, "polygon", properties, featureId, this.m_decodedTileEmitter.processPolygonFeature, harp_datasource_protocol_1.GeometryKind.Area);
    }
    processFeature(layer, extents, geometry, geometryType, properties, featureId, emitterFunc, geometryKind) {
        const env = this.createMapEnv(properties, featureId, layer, geometryType);
        const techniques = this.applyKindFilter(this.m_styleSetEvaluator.getMatchingTechniques(env, layer, geometryType), geometryKind);
        if (techniques.length === 0) {
            if (this.m_options.showMissingTechniques) {
                logger.log("VectorTileDataProcessor#processFeature: no techniques for object:", JSON.stringify(env.unmap()));
            }
            return;
        }
        const context = {
            env,
            cachedExprResults: new Map()
        };
        if (this.m_decodedTileEmitter) {
            emitterFunc.apply(this.m_decodedTileEmitter, [
                layer,
                extents,
                geometry,
                context,
                techniques
            ]);
        }
    }
    createMapEnv(properties, featureId, layer, geometryType) {
        const level = this.m_tileKey.level;
        return new index_decoder_1.MapEnv(Object.assign({ $layer: layer, $id: featureId !== null && featureId !== void 0 ? featureId : null, $level: level, $zoom: Math.max(0, level - this.m_options.storageLevelOffset), $geometryType: geometryType }, properties));
    }
    applyKindFilter(techniques, defaultKind) {
        if (this.m_dataFilter !== undefined && this.m_dataFilter.hasKindFilter) {
            techniques = techniques.filter(technique => {
                const kind = technique.kind === undefined ? defaultKind : technique.kind;
                return this.m_dataFilter.wantsKind(kind);
            });
        }
        return techniques;
    }
}
exports.VectorTileDataProcessor = VectorTileDataProcessor;
/**
 * The vector tile decoder.
 */
class VectorTileDecoder extends index_worker_1.ThemedTileDecoder {
    constructor() {
        super();
        this.m_roundUpCoordinatesIfNeeded = false;
        this.m_options = { map: {}, changed: false };
        this.m_defaultDataAdapters = [];
        this.m_defaultDataAdapters.push(new OmvDataAdapter_1.OmvDataAdapter(), new GeoJsonVtDataAdapter_1.GeoJsonVtDataAdapter(), new GeoJsonDataAdapter_1.GeoJsonDataAdapter());
    }
    /** @override */
    connect() {
        return Promise.resolve();
    }
    /** @override */
    decodeThemedTile(data, tileKey, styleSetEvaluator, projection) {
        const startTime = harp_utils_1.PerformanceTimer.now();
        if (!this.m_dataAdapter) {
            this.m_dataAdapter = this.getDataAdapter(data);
            if (!this.m_dataAdapter) {
                return Promise.reject(new Error("Unsupported data format."));
            }
        }
        const dataAdapter = this.m_dataAdapter;
        harp_utils_1.assert(dataAdapter.canProcess(data));
        if (this.m_options.changed) {
            if (dataAdapter instanceof OmvDataAdapter_1.OmvDataAdapter) {
                const omvOptions = this.m_options.map;
                dataAdapter.configure(omvOptions, styleSetEvaluator);
                this.m_featureFilter = dataAdapter.dataFilter;
            }
            this.m_options.changed = false;
        }
        const decoder = new VectorTileDataProcessor(tileKey, projection, styleSetEvaluator, dataAdapter, this.m_options.map, this.m_featureFilter);
        const decodedTile = decoder.getDecodedTile(data);
        decodedTile.decodeTime = harp_utils_1.PerformanceTimer.now() - startTime;
        return Promise.resolve(decodedTile);
    }
    /** @override */
    configure(options, customOptions) {
        super.configure(options, customOptions);
        this.m_options.map = Object.assign(Object.assign(Object.assign({}, this.m_options.map), options), customOptions);
        this.m_options.changed = true;
    }
    /**
     * Returns the appropiate data adapter to convert the given data into the format expected by
     * VectorTileDecoder.
     * @note Default adapters are available for GeoJson and OMV formats.
     * Child classes may override this function to support additional formats.
     *
     * @param data - The input data to be coverted.
     * @returns The DataAdapter to convert the data, or undefined if there's no adapter for that
     * data format.
     */
    getDataAdapter(data) {
        for (const adapter of this.m_defaultDataAdapters) {
            if (adapter.canProcess(data)) {
                return adapter;
            }
        }
        return undefined;
    }
}
exports.VectorTileDecoder = VectorTileDecoder;
/**
 * Vector Tile Decoder Service.
 */
class VectorTileDecoderService {
    /**
     * Register a vector tile decoder service.
     *
     * @remarks
     * Has to be called during initialization of decoder bundle.
     */
    static start() {
        index_worker_1.WorkerServiceManager.getInstance().register({
            serviceType: OmvDecoderDefs_1.VECTOR_TILE_DECODER_SERVICE_TYPE,
            factory: (serviceId) => index_worker_1.TileDecoderService.start(serviceId, new VectorTileDecoder())
        });
    }
}
exports.VectorTileDecoderService = VectorTileDecoderService;
//# sourceMappingURL=VectorTileDecoder.js.map