{"version":3,"sources":["webpack://harp/../harp-fetch/index.web.js","webpack://harp/../harp-geoutils/index.js","webpack://harp/../harp-mapview/node_modules/rbush/rbush.min.js","webpack://harp/../harp-utils/index.js","webpack://harp/../node_modules/csscolorparser/csscolorparser.js","webpack://harp/../harp-datasource-protocol/index-decoder.ts","webpack://harp/../harp-datasource-protocol/index.ts","webpack://harp/../harp-datasource-protocol/lib/ColorUtils.ts","webpack://harp/../harp-datasource-protocol/lib/DecodedTile.ts","webpack://harp/../harp-datasource-protocol/lib/Env.ts","webpack://harp/../harp-datasource-protocol/lib/Expr.ts","webpack://harp/../harp-datasource-protocol/lib/ExprEvaluator.ts","webpack://harp/../harp-datasource-protocol/lib/ExprInstantiator.ts","webpack://harp/../harp-datasource-protocol/lib/ExprParser.ts","webpack://harp/../harp-datasource-protocol/lib/ExprPool.ts","webpack://harp/../harp-datasource-protocol/lib/GeoJsonDataType.ts","webpack://harp/../harp-datasource-protocol/lib/InterpolatedPropertyDefs.ts","webpack://harp/../harp-datasource-protocol/lib/Outliner.ts","webpack://harp/../harp-datasource-protocol/lib/Pixels.ts","webpack://harp/../harp-datasource-protocol/lib/PropertyValue.ts","webpack://harp/../harp-datasource-protocol/lib/RGBA.ts","webpack://harp/../harp-datasource-protocol/lib/StringEncodedNumeral.ts","webpack://harp/../harp-datasource-protocol/lib/StyleSetEvaluator.ts","webpack://harp/../harp-datasource-protocol/lib/TechniqueAttr.ts","webpack://harp/../harp-datasource-protocol/lib/TechniqueDescriptors.ts","webpack://harp/../harp-datasource-protocol/lib/TechniqueParams.ts","webpack://harp/../harp-datasource-protocol/lib/Techniques.ts","webpack://harp/../harp-datasource-protocol/lib/Theme.ts","webpack://harp/../harp-datasource-protocol/lib/ThemeVisitor.ts","webpack://harp/../harp-datasource-protocol/lib/ThreeBufferUtils.ts","webpack://harp/../harp-datasource-protocol/lib/WorkerDecoderProtocol.ts","webpack://harp/../harp-datasource-protocol/lib/WorkerServiceProtocol.ts","webpack://harp/../harp-datasource-protocol/lib/WorkerTilerProtocol.ts","webpack://harp/../harp-datasource-protocol/lib/operators/ArrayOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/CastOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/ColorOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/ComparisonOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/FeatureOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/FlowOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/MapOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/MathOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/MiscOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/ObjectOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/StringOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/TypeOperators.ts","webpack://harp/../harp-datasource-protocol/lib/operators/VectorOperators.ts","webpack://harp/../harp-debug-datasource/index.ts","webpack://harp/../harp-debug-datasource/lib/DebugTileDataSource.ts","webpack://harp/../harp-features-datasource/index.ts","webpack://harp/../harp-features-datasource/lib/Features.ts","webpack://harp/../harp-features-datasource/lib/FeaturesDataSource.ts","webpack://harp/../harp-geojson-datasource/index.ts","webpack://harp/../harp-geojson-datasource/lib/GeoJsonDataProvider.ts","webpack://harp/../harp-geojson-datasource/lib/GeoJsonDataSource.ts","webpack://harp/../harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier.ts","webpack://harp/../harp-geometry/lib/SphericalGeometrySubdivisionModifier.ts","webpack://harp/../harp-geometry/lib/SubdivisionModifier.ts","webpack://harp/../harp-geoutils/lib/coordinates/GeoBox.ts","webpack://harp/../harp-geoutils/lib/coordinates/GeoBoxExtentLike.ts","webpack://harp/../harp-geoutils/lib/coordinates/GeoCoordLike.ts","webpack://harp/../harp-geoutils/lib/coordinates/GeoCoordinates.ts","webpack://harp/../harp-geoutils/lib/coordinates/GeoCoordinatesLike.ts","webpack://harp/../harp-geoutils/lib/coordinates/GeoPointLike.ts","webpack://harp/../harp-geoutils/lib/coordinates/GeoPolygon.ts","webpack://harp/../harp-geoutils/lib/coordinates/GeoPolygonLike.ts","webpack://harp/../harp-geoutils/lib/coordinates/LatLngLike.ts","webpack://harp/../harp-geoutils/lib/math/Box3Like.ts","webpack://harp/../harp-geoutils/lib/math/MathUtils.ts","webpack://harp/../harp-geoutils/lib/math/OrientedBox3.ts","webpack://harp/../harp-geoutils/lib/math/OrientedBox3Like.ts","webpack://harp/../harp-geoutils/lib/math/TransformLike.ts","webpack://harp/../harp-geoutils/lib/math/Vector2Like.ts","webpack://harp/../harp-geoutils/lib/math/Vector3Like.ts","webpack://harp/../harp-geoutils/lib/projection/EarthConstants.ts","webpack://harp/../harp-geoutils/lib/projection/EquirectangularProjection.ts","webpack://harp/../harp-geoutils/lib/projection/IdentityProjection.ts","webpack://harp/../harp-geoutils/lib/projection/MercatorProjection.ts","webpack://harp/../harp-geoutils/lib/projection/Projection.ts","webpack://harp/../harp-geoutils/lib/projection/SphereProjection.ts","webpack://harp/../harp-geoutils/lib/projection/TransverseMercatorProjection.ts","webpack://harp/../harp-geoutils/lib/tiling/FlatTileBoundingBoxGenerator.ts","webpack://harp/../harp-geoutils/lib/tiling/HalfQuadTreeSubdivisionScheme.ts","webpack://harp/../harp-geoutils/lib/tiling/HereTilingScheme.ts","webpack://harp/../harp-geoutils/lib/tiling/MercatorTilingScheme.ts","webpack://harp/../harp-geoutils/lib/tiling/PolarTilingScheme.ts","webpack://harp/../harp-geoutils/lib/tiling/QuadTree.ts","webpack://harp/../harp-geoutils/lib/tiling/QuadTreeSubdivisionScheme.ts","webpack://harp/../harp-geoutils/lib/tiling/SubTiles.ts","webpack://harp/../harp-geoutils/lib/tiling/TileKey.ts","webpack://harp/../harp-geoutils/lib/tiling/TileKeyUtils.ts","webpack://harp/../harp-geoutils/lib/tiling/TileTreeTraverse.ts","webpack://harp/../harp-geoutils/lib/tiling/TilingScheme.ts","webpack://harp/../harp-geoutils/lib/tiling/WebMercatorTilingScheme.ts","webpack://harp/../harp-lines/index.ts","webpack://harp/../harp-lines/lib/HighPrecisionLines.ts","webpack://harp/../harp-lines/lib/HighPrecisionPoints.ts","webpack://harp/../harp-lines/lib/HighPrecisionUtils.ts","webpack://harp/../harp-lines/lib/Lines.ts","webpack://harp/../harp-lines/lib/TriangulateLines.ts","webpack://harp/../harp-lrucache/index.ts","webpack://harp/../harp-lrucache/lib/LRUCache.ts","webpack://harp/../harp-map-controls/lib/MapControls.ts","webpack://harp/../harp-map-controls/lib/MapControlsUI.ts","webpack://harp/../harp-map-controls/lib/Utils.ts","webpack://harp/../harp-mapview-decoder/index.ts","webpack://harp/../harp-mapview-decoder/lib/DataProvider.ts","webpack://harp/../harp-mapview-decoder/lib/TileDataSource.ts","webpack://harp/../harp-mapview-decoder/lib/TileLoader.ts","webpack://harp/../harp-mapview/index.ts","webpack://harp/../harp-mapview/lib/AnimatedExtrusionHandler.ts","webpack://harp/../harp-mapview/lib/BackgroundDataSource.ts","webpack://harp/../harp-mapview/lib/BaseTileLoader.ts","webpack://harp/../harp-mapview/lib/BoundsGenerator.ts","webpack://harp/../harp-mapview/lib/CameraMovementDetector.ts","webpack://harp/../harp-mapview/lib/CameraUtils.ts","webpack://harp/../harp-mapview/lib/ClipPlanesEvaluator.ts","webpack://harp/../harp-mapview/lib/ColorCache.ts","webpack://harp/../harp-mapview/lib/ConcurrentDecoderFacade.ts","webpack://harp/../harp-mapview/lib/ConcurrentTilerFacade.ts","webpack://harp/../harp-mapview/lib/ConcurrentWorkerSet.ts","webpack://harp/../harp-mapview/lib/DataSource.ts","webpack://harp/../harp-mapview/lib/DebugContext.ts","webpack://harp/../harp-mapview/lib/DecodedTileHelpers.ts","webpack://harp/../harp-mapview/lib/DepthPrePass.ts","webpack://harp/../harp-mapview/lib/ElevationRangeSource.ts","webpack://harp/../harp-mapview/lib/EventDispatcher.ts","webpack://harp/../harp-mapview/lib/FixedClipPlanesEvaluator.ts","webpack://harp/../harp-mapview/lib/FovCalculation.ts","webpack://harp/../harp-mapview/lib/FrustumIntersection.ts","webpack://harp/../harp-mapview/lib/ITileLoader.ts","webpack://harp/../harp-mapview/lib/MapAnchors.ts","webpack://harp/../harp-mapview/lib/MapMaterialAdapter.ts","webpack://harp/../harp-mapview/lib/MapObjectAdapter.ts","webpack://harp/../harp-mapview/lib/MapTileCuller.ts","webpack://harp/../harp-mapview/lib/MapView.ts","webpack://harp/../harp-mapview/lib/MapViewAtmosphere.ts","webpack://harp/../harp-mapview/lib/MapViewEnvironment.ts","webpack://harp/../harp-mapview/lib/MapViewFog.ts","webpack://harp/../harp-mapview/lib/MapViewPoints.ts","webpack://harp/../harp-mapview/lib/MapViewTaskScheduler.ts","webpack://harp/../harp-mapview/lib/MapViewThemeManager.ts","webpack://harp/../harp-mapview/lib/PathBlockingElement.ts","webpack://harp/../harp-mapview/lib/PickHandler.ts","webpack://harp/../harp-mapview/lib/PickListener.ts","webpack://harp/../harp-mapview/lib/PickingRaycaster.ts","webpack://harp/../harp-mapview/lib/PlaneViewBounds.ts","webpack://harp/../harp-mapview/lib/PolarTileDataSource.ts","webpack://harp/../harp-mapview/lib/ScreenCollisions.ts","webpack://harp/../harp-mapview/lib/ScreenProjector.ts","webpack://harp/../harp-mapview/lib/SkyBackground.ts","webpack://harp/../harp-mapview/lib/SkyCubemapTexture.ts","webpack://harp/../harp-mapview/lib/SkyGradientTexture.ts","webpack://harp/../harp-mapview/lib/SphereHorizon.ts","webpack://harp/../harp-mapview/lib/SphereViewBounds.ts","webpack://harp/../harp-mapview/lib/Statistics.ts","webpack://harp/../harp-mapview/lib/TextureLoader.ts","webpack://harp/../harp-mapview/lib/ThemeHelpers.ts","webpack://harp/../harp-mapview/lib/ThemeLoader.ts","webpack://harp/../harp-mapview/lib/Tile.ts","webpack://harp/../harp-mapview/lib/TileObjectsRenderer.ts","webpack://harp/../harp-mapview/lib/Utils.ts","webpack://harp/../harp-mapview/lib/VisibleTileSet.ts","webpack://harp/../harp-mapview/lib/WorkerBasedDecoder.ts","webpack://harp/../harp-mapview/lib/WorkerBasedTiler.ts","webpack://harp/../harp-mapview/lib/composing/LowResRenderPass.ts","webpack://harp/../harp-mapview/lib/composing/MSAARenderPass.ts","webpack://harp/../harp-mapview/lib/composing/MapRenderingManager.ts","webpack://harp/../harp-mapview/lib/composing/Outline.ts","webpack://harp/../harp-mapview/lib/composing/Pass.ts","webpack://harp/../harp-mapview/lib/composing/UnrealBloomPass.ts","webpack://harp/../harp-mapview/lib/composing/index.ts","webpack://harp/../harp-mapview/lib/copyrights/CopyrightCoverageProvider.ts","webpack://harp/../harp-mapview/lib/copyrights/CopyrightElementHandler.ts","webpack://harp/../harp-mapview/lib/copyrights/CopyrightInfo.ts","webpack://harp/../harp-mapview/lib/copyrights/UrlCopyrightProvider.ts","webpack://harp/../harp-mapview/lib/geometry/AddGroundPlane.ts","webpack://harp/../harp-mapview/lib/geometry/DisplacedBufferAttribute.ts","webpack://harp/../harp-mapview/lib/geometry/DisplacedBufferGeometry.ts","webpack://harp/../harp-mapview/lib/geometry/DisplacedMesh.ts","webpack://harp/../harp-mapview/lib/geometry/LodMesh.ts","webpack://harp/../harp-mapview/lib/geometry/Object3DUtils.ts","webpack://harp/../harp-mapview/lib/geometry/ProjectTilePlaneCorners.ts","webpack://harp/../harp-mapview/lib/geometry/RegisterTileObject.ts","webpack://harp/../harp-mapview/lib/geometry/SolidLineMesh.ts","webpack://harp/../harp-mapview/lib/geometry/TileDataAccessor.ts","webpack://harp/../harp-mapview/lib/geometry/TileGeometry.ts","webpack://harp/../harp-mapview/lib/geometry/TileGeometryCreator.ts","webpack://harp/../harp-mapview/lib/geometry/TileGeometryLoader.ts","webpack://harp/../harp-mapview/lib/geometry/TileGeometryManager.ts","webpack://harp/../harp-mapview/lib/geometry/VertexCache.ts","webpack://harp/../harp-mapview/lib/geometry/overlayOnElevation.ts","webpack://harp/../harp-mapview/lib/image/Image.ts","webpack://harp/../harp-mapview/lib/image/ImageCache.ts","webpack://harp/../harp-mapview/lib/image/MapViewImageCache.ts","webpack://harp/../harp-mapview/lib/image/MipMapGenerator.ts","webpack://harp/../harp-mapview/lib/poi/BoxBuffer.ts","webpack://harp/../harp-mapview/lib/poi/PixelPicker.ts","webpack://harp/../harp-mapview/lib/poi/PoiBuilder.ts","webpack://harp/../harp-mapview/lib/poi/PoiManager.ts","webpack://harp/../harp-mapview/lib/poi/PoiRenderer.ts","webpack://harp/../harp-mapview/lib/poi/PoiTableManager.ts","webpack://harp/../harp-mapview/lib/text/FontCatalogLoader.ts","webpack://harp/../harp-mapview/lib/text/LayoutState.ts","webpack://harp/../harp-mapview/lib/text/MapViewState.ts","webpack://harp/../harp-mapview/lib/text/Placement.ts","webpack://harp/../harp-mapview/lib/text/PlacementStats.ts","webpack://harp/../harp-mapview/lib/text/RenderState.ts","webpack://harp/../harp-mapview/lib/text/SimplePath.ts","webpack://harp/../harp-mapview/lib/text/TextCanvasFactory.ts","webpack://harp/../harp-mapview/lib/text/TextElement.ts","webpack://harp/../harp-mapview/lib/text/TextElementBuilder.ts","webpack://harp/../harp-mapview/lib/text/TextElementGroup.ts","webpack://harp/../harp-mapview/lib/text/TextElementGroupPriorityList.ts","webpack://harp/../harp-mapview/lib/text/TextElementGroupState.ts","webpack://harp/../harp-mapview/lib/text/TextElementState.ts","webpack://harp/../harp-mapview/lib/text/TextElementStateCache.ts","webpack://harp/../harp-mapview/lib/text/TextElementType.ts","webpack://harp/../harp-mapview/lib/text/TextElementsRenderer.ts","webpack://harp/../harp-mapview/lib/text/TextElementsRendererOptions.ts","webpack://harp/../harp-mapview/lib/text/TextStyleCache.ts","webpack://harp/../harp-mapview/lib/text/TileTextStyleCache.ts","webpack://harp/../harp-mapview/lib/text/UpdateStats.ts","webpack://harp/../harp-mapview/lib/workers/WorkerBootstrapDefs.ts","webpack://harp/../harp-mapview/lib/workers/WorkerLoader.ts","webpack://harp/../harp-materials/index.ts","webpack://harp/../harp-materials/lib/CirclePointsMaterial.ts","webpack://harp/../harp-materials/lib/CopyMaterial.ts","webpack://harp/../harp-materials/lib/DisplacementFeature.ts","webpack://harp/../harp-materials/lib/EdgeMaterial.ts","webpack://harp/../harp-materials/lib/GroundAtmosphereMaterial.ts","webpack://harp/../harp-materials/lib/HighPrecisionLineMaterial.ts","webpack://harp/../harp-materials/lib/HighPrecisionPointMaterial.ts","webpack://harp/../harp-materials/lib/IconMaterial.ts","webpack://harp/../harp-materials/lib/LuminosityHighPassShader.ts","webpack://harp/../harp-materials/lib/MSAAMaterial.ts","webpack://harp/../harp-materials/lib/MapMeshMaterials.ts","webpack://harp/../harp-materials/lib/MapMeshMaterialsDefs.ts","webpack://harp/../harp-materials/lib/RawShaderMaterial.ts","webpack://harp/../harp-materials/lib/SepiaShader.ts","webpack://harp/../harp-materials/lib/ShaderChunks/AtmosphereChunks.ts","webpack://harp/../harp-materials/lib/ShaderChunks/ExtrusionChunks.ts","webpack://harp/../harp-materials/lib/ShaderChunks/FadingChunks.ts","webpack://harp/../harp-materials/lib/ShaderChunks/LinesChunks.ts","webpack://harp/../harp-materials/lib/ShaderChunks/ShadowChunks.ts","webpack://harp/../harp-materials/lib/SkyAtmosphereMaterial.ts","webpack://harp/../harp-materials/lib/SolidLineMaterial.ts","webpack://harp/../harp-materials/lib/Utils.ts","webpack://harp/../harp-materials/lib/VignetteShader.ts","webpack://harp/../harp-omv-datasource/index.ts","webpack://harp/../harp-omv-datasource/lib/OmvDataSource.ts","webpack://harp/../harp-text-canvas/index.ts","webpack://harp/../harp-text-canvas/lib/TextCanvas.ts","webpack://harp/../harp-text-canvas/lib/rendering/FontCatalog.ts","webpack://harp/../harp-text-canvas/lib/rendering/GlyphData.ts","webpack://harp/../harp-text-canvas/lib/rendering/GlyphTextureCache.ts","webpack://harp/../harp-text-canvas/lib/rendering/TextBufferObject.ts","webpack://harp/../harp-text-canvas/lib/rendering/TextGeometry.ts","webpack://harp/../harp-text-canvas/lib/rendering/TextMaterials.ts","webpack://harp/../harp-text-canvas/lib/rendering/TextStyle.ts","webpack://harp/../harp-text-canvas/lib/typesetting/LineTypesetter.ts","webpack://harp/../harp-text-canvas/lib/typesetting/PathTypesetter.ts","webpack://harp/../harp-text-canvas/lib/utils/ContextualArabicConverter.ts","webpack://harp/../harp-text-canvas/lib/utils/MaterialUtils.ts","webpack://harp/../harp-text-canvas/lib/utils/TypesettingUtils.ts","webpack://harp/../harp-text-canvas/lib/utils/UnicodeUtils.ts","webpack://harp/../harp-transfer-manager/index.ts","webpack://harp/../harp-transfer-manager/src/DeferredPromise.ts","webpack://harp/../harp-transfer-manager/src/TransferManager.ts","webpack://harp/../harp-utils/index-common.ts","webpack://harp/../harp-utils/lib/ContextLogger.ts","webpack://harp/../harp-utils/lib/DOMUtils.ts","webpack://harp/../harp-utils/lib/Functions.ts","webpack://harp/../harp-utils/lib/GlslUtils.ts","webpack://harp/../harp-utils/lib/GroupedPriorityList.ts","webpack://harp/../harp-utils/lib/Logger/ConsoleChannel.ts","webpack://harp/../harp-utils/lib/Logger/ILogger.ts","webpack://harp/../harp-utils/lib/Logger/Logger.ts","webpack://harp/../harp-utils/lib/Logger/LoggerManager.ts","webpack://harp/../harp-utils/lib/Logger/LoggerManagerImpl.ts","webpack://harp/../harp-utils/lib/Logger/MultiChannel.ts","webpack://harp/../harp-utils/lib/Logger/WorkerChannel.ts","webpack://harp/../harp-utils/lib/Logger/index.ts","webpack://harp/../harp-utils/lib/Math2D.ts","webpack://harp/../harp-utils/lib/MathUtils.ts","webpack://harp/../harp-utils/lib/Mixins.ts","webpack://harp/../harp-utils/lib/ObjectUtils.ts","webpack://harp/../harp-utils/lib/OptionsUtils.ts","webpack://harp/../harp-utils/lib/PerformanceTimer.ts","webpack://harp/../harp-utils/lib/SampleBilinear.ts","webpack://harp/../harp-utils/lib/TaskQueue.ts","webpack://harp/../harp-utils/lib/UriResolver.ts","webpack://harp/../harp-utils/lib/UrlPlatformUtils.ts","webpack://harp/../harp-utils/lib/UrlUtils.ts","webpack://harp/../harp-utils/lib/assert.ts","webpack://harp/../harp-vectortile-datasource/index.ts","webpack://harp/../harp-vectortile-datasource/lib/GeoJsonDataProvider.ts","webpack://harp/../harp-vectortile-datasource/lib/OmvDataFilter.ts","webpack://harp/../harp-vectortile-datasource/lib/OmvDebugLabelsTile.ts","webpack://harp/../harp-vectortile-datasource/lib/OmvDecoderDefs.ts","webpack://harp/../harp-vectortile-datasource/lib/OmvRestClient.ts","webpack://harp/../harp-vectortile-datasource/lib/VectorTileDataSource.ts","webpack://harp/../harp-webtile-datasource/index.ts","webpack://harp/../harp-webtile-datasource/lib/HereWebTileDataSource.ts","webpack://harp/../harp-webtile-datasource/lib/WebTileDataSource.ts","webpack://harp/../harp-webtile-datasource/lib/WebTileLoader.ts","webpack://harp/./lib/BundleMain.ts","webpack://harp/./lib/index.ts","webpack://harp/external \"THREE\"","webpack://harp/webpack/bootstrap","webpack://harp/webpack/startup"],"names":["Object","defineProperty","exports","value","__createBinding","this","create","o","m","k","k2","undefined","enumerable","get","__exportStar","p","prototype","hasOwnProperty","call","module","t","r","e","a","h","n","s","l","Math","log","f","exp","u","sqrt","max","floor","min","d","x","i","length","_maxEntries","_minEntries","ceil","clear","indexOf","children","minX","minY","maxX","maxY","leaf","c","height","pop","push","all","_all","data","search","toBBox","collides","load","insert","_build","slice","_splitRoot","_insert","remove","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","pow","_chooseSubtree","_split","_adjustParentBBoxes","_chooseSplitAxis","_chooseSplitIndex","v","M","_allDistMargin","sort","kCSSColorTable","clamp_css_byte","round","clamp_css_float","parse_css_int","str","parseFloat","parseInt","parse_css_float","css_hue_to_rgb","m1","m2","parseCSSColor","css_str","iv","replace","toLowerCase","substr","op","ep","fname","params","split","alpha","HEX_FULL_CHANNEL","tmpColor","THREE","Color","ColorUtils","getHexFromRgba","g","b","assert","getHexFromRgb","getHexFromHsl","setHSL","getHex","getRgbaFromHex","hex","target","RGBA","hasAlphaInHex","getAlphaFromHex","removeAlphaFromHex","getFeatureName","env","basePropName","useAbbreviation","useIsoCode","languages","name","abbreviation","lookup","isoCode","lang","GeometryType","attr","Float32Array","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","projectionName","mercatorProjection","webMercatorProjection","sphereProjection","normalizedEquirectangularProjection","equirectangularProjection","Error","projection","attributeMap","id","$id","context","technique","Env","propName","isTextTechnique","isPoiTechnique","isLineMarkerTechnique","text","evaluateTechniqueAttr","label","tileLevel","constantHeight","object","entries","parent","super","obj","unmap","key","exprEvaluator","ExprEvaluator","exprInstantiator","ExprInstantiator","ExprDependencies","properties","Set","ComputeExprDependencies","expr","dependencies","accept","instance","add","args","forEach","childExpr","volatile","featureState","visitCallExpr","branches","_","branch","fallback","condition","input","defaultValue","stops","isJsonExpr","Array","isArray","ExprScope","Expr","code","ExprParser","parse","json","definitions","definitionExprCache","parseNode","lockedNames","cache","Map","scope","Value","ExprEvaluatorContext","m_dependencies","of","pool","ExprSerializer","serialize","m_isDynamic","exprIsDynamic","VarExpr","visitor","visitVarExpr","LiteralExpr","BooleanLiteralExpr","NumberLiteralExpr","StringLiteralExpr","NullLiteralExpr","ObjectLiteralExpr","visitNullLiteralExpr","visitBooleanLiteralExpr","visitNumberLiteralExpr","m_promotedValue","Pixels","visitStringLiteralExpr","visitObjectLiteralExpr","HasAttributeExpr","visitHasAttributeExpr","CallExpr","descriptor","getOperator","isDynamicOperator","some","isDynamic","LookupExpr","node","referenceResolverState","lookupTableNode","lookupTableExpr","lookupTable","map","unshift","visitLookupExpr","MatchExpr","elementTy","every","visitMatchExpr","CaseExpr","visitCaseExpr","cond","StepExpr","visitStepExpr","InterpolateExpr","mode","visitInterpolateExpr","Vector2","y","Vector3","z","Vector4","w","body","result","parseCall","JSON","stringify","has","cachedEntry","definitionEntry","definitionValue","getDefinitionValue","isInterpolatedPropertyDefinition","interpolatedPropertyDefinitionToJsonExpr","delete","set","resolveReference","makeCallExpr","parseGetExpr","parseHasExpr","parseLiteralExpr","conditions","isValidMatchLabel","parseMatchExpr","caseFallback","parseCaseExpr","isInterpolationMode","isExpr","parseInterpolateExpr","parseStepExpr","parseArray","operatorDescriptors","promoteValue","promotedValue","evaluate","evaluator","cachedResult","fromValue","builtin","builtins","getOwnPropertyNames","defineOperator","match","includes","firstDynamicCondition","findIndex","evaluatedCondition","evaluatedBody","Boolean","wrapValue","partialEvaluate","arg","index","param","interp","i1","stop","i0","iP","iN","tP","t0","t1","dt","wP","wN","pp","ppp","cP","c0","c1","cN","vP","v0","v1","vN","MathUtils","clamp","N","cubicInterpolate","keyIndex","prevKey","prevValue","base","lerp","clone","defineOperators","CastOperators","ComparisonOperators","MathOperators","StringOperators","ColorOperators","TypeOperators","MiscOperators","FlowOperators","ArrayOperators","ObjectOperators","FeatureOperators","MapOperators","VectorOperators","emptyEnv","_context","preserve","constructor","visitCallExprImpl","changed","newBranch","newCondition","deps","size","Condition","instantiatedBranch","Character","Token","isSpace","codepoint","Tab","Lf","Cr","Space","isNumber","_0","_9","isLetter","A","Z","isIdentChar","isLetterOrNumber","Dollar","Dot","LBracket","RBracket","tokenSpell","token","Eof","Identifier","Number","String","Comma","LParen","RParen","Exclaim","TildeEqual","CaretEqual","DollarEqual","EqualEqual","ExclaimEqual","Less","Greater","LessEqual","GreaterEqual","BarBar","AmpAmp","Lexer","m_token","m_index","m_char","m_text","yylex","codePointAt","yyinp","ch","SingleQuote","DoubleQuote","start","substring","Equal","Caret","Tilde","Bar","Amp","getEqualityOp","getRelationalOp","lex","next","parseLogicalOr","yyexpect","hasAttribute","parseLiteral","parseUnary","parsePrimary","elements","right","parseRelational","parseEquality","expressions","parseLogicalAnd","m_booleanLiterals","m_numberLiterals","m_stringLiterals","m_objectLiterals","m_arrayLiterals","m_varExprs","m_hasAttributeExprs","m_matchExprs","m_caseExprs","m_interpolateExprs","m_stepExprs","m_callExprs","array","find","literal","candidate","branchesMatching","calls","step","type","InterpolationMode","interpolationMode","values","zoomLevels","property","interpolation","exponent","currEdgeStart","currEdgeGoal","prevEdgeStart","prevEdgeGoal","indexBuffer","vertexOffset","vertexStride","polygonContour","polygonContourEdges","isExtruded","addFootprintEdges","wallEdgeSlope","vFootprint0","vRoof0","vFootprint1","vRoof1","prevEdgeIdx","v0x","v0y","v1x","v1y","sub","normalize","dot","vFoot0","RX","exec","logger","LoggerManager","Dynamic","error","pixelToMeters","parseStringEncodedNumeral","color","parseStringEncodedColor","StringEncodedNumeralType","StringEncodedMeters","Meters","regExp","decoder","encodedValue","StringEncodedPixels","mask","StringEncodedHex","Hex","charAt","StringEncodedMetricFormats","StringEncodedMetricFormatMaxSize","reduce","StringEncodedColorFormats","StringEncodedColorFormatMaxSize","StringEncodedNumeralFormats","StringEncodedNumeralFormatMaxSize","tmpBuffer","parseStringLiteral","formats","matchedFormat","format","components","isNaN","numeral","DEFAULT_TECHNIQUE_ATTR_SCOPE","AttrScope","TechniqueGeometry","StyleConditionClassifier","style","_whenExpr","savedStyle","switchStyle","_style","enclosingExpr","filter","matched","matchVarStringComparison","layer","_geometryType","left","saved","OptimizedSubSetKey","geometryType","keyUpdateNeeded","envLayer","envGeometryType","updateKey","cachedStyleSet","makeDecodedTechnique","attrName","attrValue","isVector2","isVector3","isVector4","m_options","styleSet","m_techniques","m_exprPool","ExprPool","m_cachedResults","m_styleConditionClassifier","m_subStyleSetCache","m_definitionExprCache","m_tmpOptimizedSubSetKey","m_emptyEnv","m_featureDependencies","m_nextArrayBufferId","m_definitions","resolveStyleReferences","techniqueRenderOrder","styleSetIndex","_styleSetIndex","renderOrder","computeDefaultRenderOrder","compileStyleSet","m_previousResult","m_previousEnv","optimizedSubSetKey","m_layer","m_geometryType","m_zoomLevel","searchedStyleSet","getOptimizedStyleSet","currStyle","processStyle","techinque","_index","subSetKey","optimizedStyleSet","createPreFilteredStyleSet","compileStyle","checkStyleDynamicAttributes","when","classify","intern","prop","minZoomLevel","_minZoomLevelExpr","maxZoomLevel","_maxZoomLevelExpr","err","checkZoomLevel","getTechniqueForStyleMatch","final","zoomLevel","_dynamicTechniques","dynamicAttributes","evaluateTechniqueProperties","getDynamicTechniqueKey","createTechnique","_staticTechnique","dynamicAttrKey","_attrName","ArrayBuffer","arrayBufferId","join","_dynamicTechniqueAttributes","_dynamicFeatureAttributes","_dynamicForwardedAttributes","_staticAttributes","dynamicFeatureAttributes","dynamicTechniqueAttributes","dynamicForwardedAttributes","targetStaticAttributes","processAttribute","_usesFeatureState","attrScope","vertexColors","getTechniqueAttributeDescriptor","getStyleAttributeScope","FeatureGeometry","TechniqueRendering","replacement","startsWith","attrExpr","dynamicAttrs","_styleSet","setTechniqueRenderOrderOrPriority","priorities","labelPriorities","isEnv","getPropertyValue","cachedExprResults","mergeTechniqueDescriptor","descriptors","attrDescriptors","attrTransparencyColor","baseTechniqueParamsDescriptor","enabled","fadeFar","fadeNear","transparent","automatic","side","pointTechniquePropTypes","opacity","squaresTechniquePropTypes","circlesTechniquePropTypes","lineMarkerTechniquePropTypes","poiName","imageTexture","iconColor","iconBrightness","backgroundColor","backgroundSize","backgroundOpacity","polygonalTechniqueDescriptor","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","depthTest","lineColor","lineFadeFar","lineFadeNear","solidLineTechniqueDescriptor","lineWidth","secondaryWidth","secondaryColor","dashSize","gapSize","outlineColor","caps","drawRangeStart","drawRangeEnd","dashes","dashColor","lineTechniqueDescriptor","fillTechniqueDescriptor","wireframe","standardTechniqueDescriptor","roughness","metalness","alphaTest","emissive","emissiveIntensity","refractionRatio","normalMapType","normalMap","displacementMap","roughnessMap","emissiveMap","bumpMap","metalnessMap","alphaMap","techniqueDescriptors","floorHeight","defaultColor","defaultHeight","boundaryWalls","footprint","maxSlope","animateExtrusion","terrain","standard","squares","circles","line","segments","fill","priority","shader","getTechniqueDescriptor","techniqueDescriptor","automaticAttributeCache","descr","StandardGeometryKind","Pickability","PlacementToken","PoiStackMode","TextureCoordinateType","GeometryKind","GeometryKindSet","subset","elem","hasIntersection","transient","pickability","onlyVisible","buffer","isExtrudedLineTechnique","isStandardExtrudedLineTechnique","shading","isFillTechnique","isExtrudedPolygonTechnique","isStandardTechnique","isTerrainTechnique","isShaderTechnique","supportsTextures","TEXTURE_PROPERTY_KEYS","TRANSPARENCY_PROPERTY_KEYS","textureCoordinateType","transferList","texturePropertyKey","textureProperty","isTextureBuffer","imageName","textureName","imageTexturePrefix","imageTexturePostfix","_category","computeRenderOrder","category","entry","group","_secondaryCategory","secondaryRenderOrder","isVerboseDefinition","definition","theme","visitFunc","visit","styles","styleSetName","ThreeBufferUtils","getBufferElementType","fromThreeBufferAttribute","bufferAttribute","itemCount","itemSize","normalized","fromThreeInterleavedBufferAttribute","fromThreeBufferGeometry","bufferGeometry","techniqueIndex","vertexAttributes","attributeNames","attributes","vertexAttribute","count","posAttr","position","Unspecified","groups","abortController","AbortController","signal","abort","WorkerDecoderProtocol","DecoderMessageName","Requests","isConfigurationMessage","message","service","Configuration","isDecodeTileRequest","DecodeTileRequest","isTileInfoRequest","TileInfoRequest","WorkerServiceProtocol","ServiceMessageName","WORKER_SERVICE_MANAGER_SERVICE_ID","isInitializedMessage","Initialized","isUnknownServiceError","isRequestMessage","Request","isResponseMessage","Response","WorkerTilerProtocol","isRegisterIndexRequest","RegisterIndex","isUpdateIndexRequest","UpdateIndex","isTileRequest","TileRequest","VALID_ELEMENT_TYPES","checkElementTypes","ty","element","checkArray","operators","checkArrayLength","at","end","rgba","rgbaToHex","rgb","rgbToHex","hsl","euclideanModulo","hslToHex","compare","strict","state","conditionalCast","any","none","boolean","number","string","pixels","scaleFactor","zoom","ppi","abs","acos","asin","atan","cos","E","ln","ln2","log2","log10","pi","PI","sin","tan","joinKeyValues","keys","stringifyKeyValue","getAllCombinations","combinations","initLength","getKeyCombinations","lookupExpr","reverse","lhs","rhs","joinCombinations","coalesce","keyCombinations","table","lookupArray","createLookupMap","lookupMapExpr","matchAttributes","searchLookupMap","LookupMode","lookupMember","lookupMode","memberName","in","concat","downcase","toLocaleLowerCase","upcase","toLocaleUpperCase","endsWith","typeof","isVector","ctor","toVector","VectorCtor","fromArray","_value","vector2","vector3","vector4","debugMaterial","LineBasicMaterial","linewidth","PRIORITY_ALWAYS","MAX_SAFE_INTEGER","DebugTile","Tile","dataSource","tileKey","gridColor","geometry","BufferGeometry","m_labelPositions","BufferAttribute","tilingScheme","getTilingScheme","worldBox","boundingBoxGenerator","getWorldBox","geoCoordinates","unprojectPoint","middlePoint","vertices","geoPoint","pt","projectPoint","center","toArray","setAttribute","divideScalar","lineObject","Line","objects","setXYZ","textPosition","ProjectionType","Planar","getAttribute","getX","getY","getZ","multiplyScalar","m_textLayoutStyle","TextLayoutStyle","verticalAlignment","VerticalAlignment","Below","horizontalAlignment","HorizontalAlignment","Left","copy","Center","m_textRenderStyle","TextRenderStyle","fontSize","unit","FontUnit","Pixel","mortonCode","row","column","level","textElement","TextElement","mayOverlap","reserveSpace","alwaysOnTop","ignoreDistance","addTextElement","DebugTileDataSource","DataSource","m_tilingScheme","maxDbgZoomLevel","minDataLevel","maxDataLevel","storageLevelOffset","cacheable","enablePicking","canGetTile","MapViewFeature","coordinates","uuid","generateUUID","DEFAULT_GEOJSON","features","FeaturesDataSource","VectorTileDataSource","options","dataProvider","GeoJsonDataProvider","addGroundPlane","m_isAttached","m_featureCollection","emptyGeojson","geojson","setFromGeojson","TypeError","geometries","update","feature","addFeature","removeFeature","connect","mapView","attach","detach","addPoint","geoJsonCoords","coords","GeoCoordinates","GeoBox","growToContain","segment","polygon","_feature","__mapViewUuid","geojsonFeature","ready","updateInput","markTilesDirty","GeoJsonDataSource","VERTEX_POSITION_CACHE","SubdivisionMode","EdgeLengthGeometrySubdivisionModifier","SubdivisionModifier","subdivision","geoBox","subdivisionMode","All","northEast","southWest","m_projectedBox","m_maxLengthX","m_maxLengthY","m_maxLength","shouldSplitAB","shouldSplitEdge","shouldSplitBC","shouldSplitCA","ab","distanceTo","bc","ca","maxDistance","NoDiagonals","SphericalGeometrySubdivisionModifier","angle","aa","reprojectPoint","bb","cc","angleTo","beta","gamma","tmpVectorA","tmpVectorB","tmpVectorC","positionAttr","from","uvAttr","uv","edgeAttr","edge","wallAttr","wall","indexAttr","getIndex","indices","middleVertex","j","lerpVectors","newIndices","shift","v2","shouldSplitTriangle","v3","Float64Array","needsUpdate","setIndex","west","east","longitude","extent","latitude","latitudeSpan","longitudeSpan","altitude","south","north","minAltitude","altitudeSpan","degToRad","maxAltitude","width","point","containsHelper","isFlat","isSameAltitude","isWithinAltitudeRange","MAX_LONGITUDE","coord","isGeoCoordinatesLike","isLatLngLike","lat","lng","isGeoPointLike","MAX_LATITUDE","MIN_LATITUDE","MIN_LONGITUDE","tmpV0","tmpV1","radToDeg","latLng","fromGeoPoint","fromDegrees","geoCoords0","geoCoords1","factor","wrap","geoCoordsEnd","dividend","divisor","modulo","mod","other","minLongitude","maxLongitude","computeLonSpanAcrossGreewich","lonA","lonB","isLeftToRightAntimeridianCrossing","lonStart","lonEnd","sign","needsSort","needsWrapping","m_coordinates","geoCoordLikeToGeoCoordinatesLike","sortCCW","wrapCoordinatesAround","centroid","getCentroid","fromCoordinates","getEastAndWest","getNorthAndSouth","area","getArea","previousIndex","coordinate","previousCoordinate","polyCenter","getPolyAverageCenter","veca","firstAntimerCrossIndex","val","prevLonIndex","wrapAround","currentLon","nextLon","polySum","prev","curr","vecb","ccw","long","isValid","isGeoCoordLike","box3","normalizeAngleDeg","angleDistanceDeg","newEmptyBox3","Infinity","newVector3","copyVector3","to","normalizeLongitudeDeg","interpolateAnglesDeg","p0","p1","intersectsSlab","rayDir","axis","finv","t2","tmpVec","tmpT","OrientedBox3","rotationMatrix","extents","xAxis","yAxis","zAxis","extractBasis","newBox","matrix","Matrix4","makeBasis","frustumOrPlanes","planes","plane","normal","distanceToPoint","ray","origin","direction","dx","dy","dz","distanceToPointSquared","subVectors","lengths","getComponent","dd","obb","transform","EarthConstants","EQUATORIAL_CIRCUMFERENCE","EQUATORIAL_RADIUS","MIN_ELEVATION","MAX_ELEVATION","MAX_BUILDING_HEIGHT","EquirectangularProjection","Projection","_worldPoint","Box3","unitScale","geoToWorldScale","worldPoint","fromRadians","worldToGeoScale","worldCenter","latitudeSpanInRadians","longitudeSpanInRadians","sizeX","sizeY","isBox3Like","isOrientedBox3Like","EPSILON","minGeo","maxGeo","IdentityProjection","identityProjection","MercatorProjection","MercatorConstants","MAXIMUM_LATITUDE","latitudeProject","latitudeClamp","cosh","geoPointLike","latitudeClampProject","latitudeInRadians","unprojectLatitude","worldNorth","worldSouth","worldYCenter","sourceProjection","worldPos","sy","projectBox","getLongitudeQuadrant","oneOverPI","quadrantIndex","lengthOfVector3","makeBox3","halfEquatorialRadius","minLongitudeQuadrant","maxLongitudeQuadrant","xMin","xMax","yMin","yMax","cosMaxLongitude","sinMaxLongitude","xCenter","xExtent","yCenter","yExtent","minLatitude","maxLatutide","zMax","zMin","zCenter","zExtent","SphereProjection","Spherical","_minElevation","maxElevation","radius","worldpoint","cosLatitude","project","parallelRadiusSq","parallelRadius","atan2","bounds","mid","midX","midY","cosSouth","sinSouth","cosWest","sinWest","cosNorth","sinNorth","cosEast","sinEast","cosMidX","sinMidX","cosMidY","sinMidY","rMax","rMin","minZ","_worldBox","scale","mx","my","gx","gy","cosLongitude","sinLongitude","sinLatitude","TransverseMercatorProjection","m_phi0","m_lambda0","_unitScale","lon","TransverseMercatorUtils","POLE_RADIUS","rsq","POLE_RADIUS_SQ","nearestQuarter","deltaLon","deltaLat","distanceToPoleSq","distanceToPole","dir","offsetLon","clamped","clampGeoPoint","normalLon","offset","phi","lambda","B","atanh","outScale","tau","nx","ny","D","sinh","pointsToCheck","POLE_EDGE_DEG","containsEastCut","containsCenterX","containsCenterY","alignLatitude","projected","vx","vy","vz","maxZ","lowerQ","upperQ","containsLowerQY","containsUpperQY","geoPoints","alignLongitude","latitudes","longitudes","altitudes","points","referencePoint","bad","good","POLE_EDGE","transverseMercatorProjection","minElevation","m_worldBox","worldExtent","m_worldDimensions","subdivisionScheme","levelDimensionX","getLevelDimensionX","levelDimensionY","getLevelDimensionY","originX","originY","unprojectBox","halfQuadTreeSubdivisionScheme","hereTilingScheme","TilingScheme","mercatorTilingScheme","quadTreeSubdivisionScheme","polarTilingScheme","visitTileKey","TileKey","fromRowColumnLevel","getGeoBox","subTileKey","getSubTileKeys","SubTiles","Symbol","iterator","ZCurveIterator","RowColumnIterator","parentKey","powerOfTwo","quadkey","quadKey64","quadKey","m_mortonCode","quadkey64","fromMortonCode","m_hereTile","coordX","coordY","totalWidth","totalHeight","rowsAtLevel","columnsAtLevel","delta","changedLevelBy","toString","col","qnr","subQuad","fromQuadKey","child","fromHereTile","msb","TileKeyUtils","worldCoordinatesToTileKey","cx","cy","worldSizeX","worldSizeY","getKeyForTileKeyAndOffset","bitshift","shiftedOffset","offsetBits","totalOffsetsToStore","getShiftedOffset","extractOffsetAndMortonKeyFromKey","num","geoCoordinatesToTileKey","geoRectangleToTileKeys","lower","upper","minVal","maxVal","southWestLongitude","longitudeInRadians","southWestLatitude","northEastLongitude","northEastLatitude","minTileKey","maxTileKey","columnCount","minColumn","maxColumn","minRow","maxRow","getParentKeyFromKey","calculatedKey","parentMortonCode","m_subdivisionScheme","divX","getSubdivisionX","divY","getSubdivisionY","FlatTileBoundingBoxGenerator","tileTreeTraverse","TileTreeTraverse","subTiles","webMercatorTilingScheme","HighPrecisionWireFrameLine","material","positions","matrixWorldInverse","setPositions","HighPrecisionUtils","onBeforeRender","_renderer","_scene","camera","_geometry","_material","_group","updateHpUniforms","shaderMaterial","force","doUpdateMatrixWorldInverse","matrixWorldNeedsUpdate","updateMatrixWorld","matrixWorld","invert","HighPrecisionLine","Mesh","HighPrecisionPoints","Points","HighPrecisionPointMaterial","DEFAULT_COLOR","isHighPrecisionPointsMaterial","dimensionality","setDimensionality","doubleToFloatVec","fround","createHighPrecisionCameraPos","objectInverseWorldMatrix","mvp","projectionMatrix","multiply","eyePos","applyMatrix4","eyePosFloat","viewProjection","eyePosHi","eyePosLo","createAttributes","positionVec","positionVecLow","addHPValue","major","addHPVector","vec","positionHigh","Float32BufferAttribute","positionLow","addInterleavedAttributes3","stride","positionOffset","newPositions","majorX","minorX","majorY","minorY","majorZ","minorZ","makeFloatVec","minorVec","highPrecisionCameraInfo","isMaterial","uniforms","u_mvp","u_eyepos","u_eyepos_lowpart","convertPositions","vAny","returnPositions","createLine","linePositions","addCircles","wireFrame","triangulateLine","hpLineGeometry","hpPositions","InterleavedBuffer","positionAttribute","InterleavedBufferAttribute","positionLowAttribute","hpSolidMaterial","HighPrecisionLineMaterial","HPL","setupForRendering","createPoints","pointPositions","materialParameters","hpPointsGeometry","hpPointsMaterial","isHighPrecisionPointMaterial","pointsObject","HPP","tmpV","tmpNormal","tmpTangent0","tmpTangent1","tmpBitangent","LINE_VERTEX_ATTRIBUTES","NORMAL_UV_VERTEX_ATTRIBUTES","LINE_VERTEX_ATTRIBUTES_NUV","HP_LINE_VERTEX_ATTRIBUTES","HP_LINE_VERTEX_ATTRIBUTES_NUV","LineGeometry","getVertexDescriptor","hasNormalsAndUvs","highPrecision","createLineGeometry","polyline","offsets","uvs","colors","pointCount","tangents","baseVertex","hasSegmentOffsets","hasTexCoords","sum","sqrLength","lineCoverage","lineLength","isClosed","tmpVertices","addVertexPair","T1","T2","extrusionCoord","highComp","lowComp","setComponent","surfaceNormal","bt","equals","cross","computeBitangent","createSimpleLineGeometry","LineGroup","isSimple","m_geometry","vertexDescriptor","attribute","createGeometry","UNIT_Z","POINTS","BEVEL_POINTS","STEP","addCircle","lineAngle","SECTORS_IN_CIRCLE","startWithCircle","endWithCircle","angleVec","prevBt","averageBt","p2","p3","useBevel","inclineWidth","inBuffer","startOffset","outBuffer","i2","startIndex","xd","yd","zd","Entry","newer","older","cacheCapacity","sizeFunction","m_size","m_map","m_newest","m_oldest","m_capacity","m_sizeFunction","callbackfn","thisArg","newCapacity","evict","sizeMeasure","shrinkToCapacity","entrySize","valueSize","promoteEntry","newest","cb","evictionCallback","selector","entryOlder","deleteEntry","evictOldest","oldest","itemToRemove","canEvict","isOk","State","TiltState","EventNames","MAPCONTROL_EVENT","Update","MAPCONTROL_EVENT_BEGIN_INTERACTION","BeginInteraction","MAPCONTROL_EVENT_END_INTERACTION","EndInteraction","DEFAULT_MAX_TILT_ANGLE","MapControls","EventDispatcher","disposeWithMapView","rotationMouseDeltaFactor","orbitingMouseDeltaFactor","DEG2RAD","orbitingTouchDeltaFactor","zoomEnabled","panEnabled","tiltEnabled","rotateEnabled","inertiaEnabled","zoomInertiaDampingDuration","panInertiaDampingDuration","tiltToggleDuration","tiltAngle","northResetAnimationDuration","zoomLevelDeltaOnControl","minCameraHeight","zoomLevelDeltaOnDoubleClick","doubleTapTime","m_currentViewDirection","m_lastMousePosition","m_initialMousePosition","m_mouseDelta","m_needsRenderLastFrame","m_panIsAnimated","m_panDistanceFrameDelta","m_panAnimationTime","m_panAnimationStartTime","m_lastAveragedPanDistanceOrAngle","m_currentInertialPanningSpeed","m_lastPanVector","m_rotateGlobeQuaternion","Quaternion","m_lastRotateGlobeAxis","m_lastRotateGlobeAngle","m_lastRotateGlobeFromVector","m_recentPanDistancesOrAngles","m_currentPanDistanceOrAngleIndex","m_zoomIsAnimated","m_zoomDeltaRequested","m_zoomTargetNormalizedCoordinates","m_zoomAnimationTime","m_zoomAnimationStartTime","m_startZoom","m_tiltIsAnimated","m_tiltRequested","m_tiltAnimationTime","m_tiltAnimationStartTime","m_startTilt","m_state","NONE","m_tmpVector2","m_tmpVector3","m_tapStartTime","m_lastSingleTapTime","m_fingerMoved","m_isDoubleTap","m_resetNorthStartTime","m_resetNorthIsAnimated","m_resetNorthAnimationDuration","m_currentAzimuth","m_lastAzimuth","m_startAzimuth","m_maxTiltAngle","m_touchState","touches","currentRotation","initialRotation","dispose","domElement","renderer","bindInputEvents","handleZoom","bind","handlePan","tilt","resetNorth","assignZoomAfterTouchZoomRender","addEventListener","MapViewEventNames","Dispose","m_zoomLevelDeltaOnMouseWheel","attitude","MapViewUtils","extractAttitude","yaw","pitch","roll","extractSphericalCoordinatesFromLocation","azimuth","stopExistingAnimations","performance","now","targetPositionOnScreenXinNDC","targetPositionOnScreenYinNDC","zoomOnTargetPosition","screenTarget","dispatchEvent","currentZoom","zoomLevelTargeted","currentTilt","aimTilt","m_tiltState","Tilted","Down","setZ","m_targetedZoom","m_currentZoom","m_currentTilt","m_targetedTilt","removeEventListener","AfterRender","stopResetNorth","stopZoom","stopPan","stopTilt","animationTime","easeOutCubic","deltaAzimuth","orbitAroundScreenPoint","maxTiltAngle","updateMapView","tiltAnimationFinished","currentTime","targetedTilt","initialTilt","deltaTilt","startValue","endValue","time","resetZoomState","easeOutCirc","success","applyInertia","geoUtils","setLength","setFromAxisAngle","panDistanceOrAngle","panCameraAboveFlatMap","panCameraAroundGlobe","applyQuaternion","onContextMenu","contextMenu","onMouseDown","mouseDown","onMouseWheel","mouseWheel","onTouchStart","touchStart","onTouchEnd","touchEnd","onTouchMove","touchMove","onMouseDoubleClick","mouseDoubleClick","event","mousePos","getPointerPosition","zoomOnDoubleClickOrTap","shiftKey","stopPropagation","button","ctrlKey","PAN","ROTATE","ORBIT","altKey","utils","getWidthAndHeightFromCanvas","calculateNormalizedDeviceCoordinates","CameraUtils","getPrincipalPoint","onMouseMove","mouseMove","onMouseUp","mouseUp","window","m_cleanupMouseEventListeners","vectors","getWorldPositionWithElevation","fromWorld","toWorld","panFromTo","rotate","preventDefault","offsetX","offsetY","setZoomLevel","zoomLevelDeltaOnMouseWheel","deltaY","currentWorldPosition","currentTouchPoint","previousDistance","initialWorldPosition","touch","oldTouchState","newTouchPoint","oldTouchPoint","TOUCH","lastTouchPoint","setTouchState","rayCastWorldCoordinates","touchState","convertTouchPoint","updateCurrentRotation","newTouchState","ndcCoords","updateTouches","ndcPoint","pinchDistance","calculatePinchDistanceInWorldSpace","newZL","calculateZoomLevelFromDistance","targetDistance","firstTouch","diff","handleDoubleTap","fromX","fromY","toX","toY","elevationProviderResult","elevationProvider","rayCast","fromGeoAltitude","unprojectAltitude","crossVectors","canvasSize","rect","getBoundingClientRect","scaleX","scaleY","clientX","clientY","top","controls","document","createElement","m_buttonsElement","m_zoomLevelElement","m_projectionSwitchElement","m_onMapViewRenderEvent","toFixed","tagName","innerHTML","m_onWindowClick","contains","blur","verticalAligner","className","appendChild","zoomInButton","innerText","classList","zoomOutButton","tiltButton","title","compassButton","compass","Render","updateZoom","projectionSwitch","switcher","getTitle","globeSVG","flatMapSVG","toggleTilt","pointToNorth","heading","disableDefaultStyle","initStyle","cssText","getElementById","createTextNode","head","safeParseDecimalInt","integerRe","screenCoordinateX","screenCoordinateY","screenSizeX","screenSizeY","cosAltitude","setX","setY","canvas","clientWidth","clientHeight","DataProvider","m_clients","client","m_connectPromise","m_modelConstructor","tile","tileLoader","TileLoader","TileDataSource","m_tileFactory","m_isReady","m_decoder","concurrentDecoderServiceName","ConcurrentDecoderFacade","getTileDecoder","concurrentDecoderScriptUrl","concurrentDecoderWorkerCount","workerConnectionTimeout","useGeometryLoader","m_unregisterClearTileCache","onDidInvalidate","unregister","Promise","register","customOptions","configure","clearTileCache","ThemeLoader","delayLoad","copyrightInfo","copyrightProvider","getCopyrights","then","requestUpdate","resolve","reject","TileInfoLoader","loadAndDecode","loaderState","TileLoaderState","Ready","tileInfo","BaseTileLoader","tileDecoder","m_priority","requestController","abortSignal","onDone","onError","getTile","payload","aborted","onLoaded","catch","Decoding","RequestController","decodeTile","decodedTile","onDecoded","Loaded","byteLength","techniques","startDecodeTile","getTileInfo","AnimatedExtrusionState","m_mapView","duration","m_minZoomLevel","m_forceEnabled","m_dataSourceMap","None","m_startTime","forceEnabled","animateExtrusionDuration","animateExtrusionValue","extrusionVisible","Started","resetAnimation","materials","addDisposeCallback","removeTile","animated","skipAnimation","setTileExtrusionRatio","Finished","getOrCreateTileMap","tileMap","wasAnyAncestorAnimated","wasAnyDescendantAnimated","minLevel","getDataZoomLevel","distanceToMinLevel","levelsUp","visibleTileSet","quadTreeSearchDistanceUp","getTileMap","lastTileKey","deltaUp","distanceToMaxLevel","levelsDown","quadTreeSearchDistanceDown","nextTileKeys","childTileKeys","deltaDown","childTileKey","Date","timeProgress","extrusionRatio","easeInOutCubic","ExtrusionFeatureDefs","DEFAULT_RATIO_MIN","DEFAULT_RATIO_MAX","setExtrusionRatio","resetTiles","BackgroundDataSource","DEFAULT_TILING_SCHEME","dataSources","ds","newScheme","updateStorageLevelOffset","forceHasGeometry","GROUND_RENDER_ORDER","MIN_SAFE_INTEGER","loadAbortController","Loading","donePromise","Failed","Canceled","cancelImpl","loadImpl","resolveDonePromise","rejectedDonePromise","doneState","m_view","createViewBounds","m_viewBounds","generate","PlaneViewBounds","SphereViewBounds","m_throttlingTimeout","m_movementStartedFunc","m_movementFinishedFunc","m_lastCameraPos","m_newCameraPos","m_throttlingTimerId","m_movementDetectorDeadline","onDeadlineTimer","movementFinished","startMovementFinishedTimer","newAttitude","newCameraPos","getWorldPosition","m_lastAttitude","cameraMoved","m_cameraMovedLastFrame","movementStarted","NaN","removeMovementFinishedTimer","remainingTime","setTimeout","clearTimeout","computePosSideFov","focalLength","ppOffset","viewportSide","computeFov","getFovs","userData","fovs","setCameraParams","ppalPoint","viewportHeight","verticalFov","viewportWidth","aspect","hFov","MIN_FOV_RAD","MAX_FOV_RAD","computeFocalLengthFromFov","fov","principalPoint","horizontal","halfSide","ppOffsetSq","tanFov","getFocalLength","getVerticalFov","setVerticalFov","getHorizontalFov","getTopFov","getRightFov","setFocalLength","vFov","convertWorldToScreenSize","distance","worldSize","convertScreenToWorldSize","screenSize","setPrincipalPoint","maxNdcCoord","setViewOffset","getBottomFov","getLeftFov","epsilon","SphericalProj","tmpVectors","raycaster","Raycaster","sphere","Sphere","getHorizonDistance","getFarDistanceFromElevatedHorizon","minR","maxR","te","normalToTanAngle","fwdToTanAngle","getNormalToFwdAngle","getProjNearPlaneTanDistance","bottomFov","R","fwdDir","getWorldDirection","camToTanVec","near","getProjSphereIntersectionDistance","ndcDir","setFromCamera","intersection","intersectSphere","cosAngle","negate","ElevationBasedClipPlanesEvaluator","m_minElevation","m_maxElevation","elevation","TopViewClipPlanesEvaluator","nearMin","nearFarMarginRatio","farMaxRatio","m_tmpVectors","m_tmpQuaternion","nearFarMargin","m_minimumViewRange","far","minimum","maximum","PerspectiveCamera","persCamera","evaluateDistanceSphericalProj","evaluateDistancePlanarProj","minimumViewRange","nearPlane","farPlane","groundDistance","farMax","cameraAltitude","halfFovAngle","calculateHorizontalFovByVerticalFov","farTangent","getFovBasedFarPlane","farMin","fovAngle","dVec","cameraFwdVec","tVec","cta","a2","r2","TiltViewClipPlanesEvaluator","m_tmpV2","viewRanges","halfPiLimit","cameraTilt","extractCameraTilt","topFov","topAngle","bottomAngle","topDist","bottomDist","applyViewRangeConstraints","computeNearDistSphericalProj","computeFarDistSphericalProj","defaultNear","nearPlaneTanDist","checkTopIntersection","ndcX","checkBottomIntersection","largestDist","getTargetAndDistance","createDefaultClipPlanesEvaluator","ColorCache","m_instance","colorCode","padStart","decoderServiceType","scriptUrl","workerCount","workerSet","getWorkerSet","WorkerBasedDecoder","defaultScriptUrl","workerSets","workerConnectionTimeoutInMs","ConcurrentWorkerSet","defaultWorkerCount","destroy","allWorkerSetsTerminated","terminated","ConcurrentTilerFacade","tilerServiceType","WorkerBasedTiler","isLoggingMessage","WORKERCHANNEL_MSG_TYPE","DEFAULT_WORKER_INITIALIZATION_TIMEOUT","m_workerChannelLogger","m_eventListeners","m_workers","m_availableWorkers","m_workerPromises","m_readyPromises","m_requests","m_workerRequestQueue","m_nextMessageId","m_stopped","m_referenceCount","onWorkerMessage","workerId","response","messageId","worker","checkWorkerRequestQueue","errorMessage","errorStack","stack","resolver","readyPromise","getReadyPromise","LogLevel","Trace","trace","Debug","debug","Log","Info","info","Warn","warn","eventHandler","m_workerCount","getOptionValue","navigator","hardwareConcurrency","timeout","workerPromise","WorkerLoader","startWorker","listener","evt","waitForAllResponses","terminateWorkers","serviceId","ensureStarted","promise","callback","request","postRequestMessage","promises","postMessage","buffers","workerEntry","terminate","newPromise","that","UPDATE_EVENT","minDisplayLevel","maxDisplayLevel","allowOverlappingTiles","dataSourceOrder","exprPool","m_maxGeometryHeight","m_minGeometryHeight","m_storageLevelOffset","m_featureStateMap","minGeometryHeight","maxGeometryHeight","uniqueNameCounter","featureId","m_styleSetName","clearCache","pov","levelOffset","enable","isNode","DebugOption","SET_EVENT_TYPE","DebugContext","m_optionsMap","__debugContext","opt","hasEventListener","option","debugContext","createTextureFromURL","url","onLoad","isObjectURL","texture","TextureLoader","URL","revokeObjectURL","createTexture","texturePropertyName","wrapS","toWrappingMode","wrapT","magFilter","toTextureFilter","minFilter","flipY","repeatU","repeat","repeatV","initTextureProperties","textureBuffer","dataTextureProperties","textureDataType","toTextureDataType","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","getTextureBuffer","DataTexture","toPixelFormat","createTextureFromRawImage","textureBlob","Blob","createObjectURL","nodeName","CanvasTexture","Texture","getMaterialConstructor","shadowsEnabled","MapMeshStandardMaterial","MapMeshBasicMaterial","SolidLineMaterial","PointsMaterial","CirclePointsMaterial","ShaderMaterial","buildMetricValueEvaluator","metricUnit","applySecondaryColorToMaterial","materialColor","techniqueColor","evaluateColorProperty","setHex","applyBaseColorToMaterial","colorValue","tech","evaluateProperty","RawShaderMaterial","setOpacity","setRGB","disableBlending","enableBlending","parsed","getBaseColorPropName","rendererCapabilities","onTextureCreated","Constructor","settings","fog","removeDiffuseLight","flatShading","texturePromise","baseColorPropName","hasBaseColor","propertyName","techniqueAttrValue","applyTechniquePropertyToMaterial","propColor","applyShaderTechniqueToMaterial","MapMaterialAdapter","automaticAttributes","getTechniqueAutomaticAttrs","baseProps","pick","outlineWidth","getMainMaterialStyledProps","elevationEnabled","DisplacedMesh","elevationRange","SolidLineMesh","raycast","Circles","Squares","LineSegments","primitive","Object3D","BASE_TECHNIQUE_NON_MATERIAL_PROPS","baseColorProp","getBaseColorProp","createDepthPrePassMaterial","baseMaterial","depthWrite","depthFunc","EqualDepth","colorWrite","enforceBlending","depthPassMaterial","isDepthPrepassMaterial","LessDepth","blending","NoBlending","DEPTH_PRE_PASS_STENCIL_MASK","enableDepthPrePass","evaluateBaseColorProperty","isMesh","mesh","originalGeometry","depthPassGeometry","uvAttribute","normalAttribute","extrusionAxisAttribute","materialIndex","addGroup","depthPassMesh","depthMesh","colorMesh","setupDepthMaterialStencil","depthMeshMaterial","depthMaterial","stencilWrite","stencilFail","KeepStencilOp","stencilZFail","stencilZPass","ReplaceStencilOp","stencilFunc","AlwaysStencilFunc","stencilRef","stencilFuncMask","setupColorMaterialStencil","colorMeshMaterial","colorMaterial","ZeroStencilOp","EqualStencilFunc","CalculationStatus","m_listeners","removeAllEventListeners","listeners","events","minNear","minFarOffset","minFar","m_nearPlane","m_farPlane","fixedNear","invalidatePlanes","fixedFar","nearDist","farDist","DEFAULT_FOV_CALCULATION","MIN_FOV_DEG","MAX_FOV_DEG","tmpVectors3","tmpVector4","TileKeyEntry","m_camera","m_extendedFrustumCulling","m_tileWrappingEnabled","m_enableMixedLod","m_tilePixelSize","m_frustum","Frustum","m_viewProjectionMatrix","m_rootTileKeys","m_tileKeyEntries","m_mapTileCuller","MapTileCuller","projectionMatrixOverride","multiplyMatrices","setFromProjectionMatrix","setup","computeRequiredInitialRootTileKeys","elevationRangeSource","targetTileArea","useElevationRangeSource","obbIntersections","uniqueZoomLevels","calculationFinal","tileBounds","tileEntry","tileKeyEntry","getTileKeyEntry","workList","shouldSubdivide","tileKeyAndOffset","subTileEntry","subTileKeyAndOffset","tileKeyEntries","longitudeOffset","range","getElevationRange","calculationStatus","FinalPrecise","computeTileAreaAndDistance","frustumIntersectsTileBox","intersectsBox","intersects","getCenter","projectedPoint","objectSize","getSize","rootTileKey","worldGeoPoint","cameraPitch","totalAngleRad","worldLengthHorizontal","worldLeftPoint","worldLeftGeoPoint","offsetRange","SQRT2","m_anchors","m_priorities","mapAnchor","cameraPosition","rootNode","overlayRootNode","worldPosition","anchor","geoPosition","isVector3Like","overlay","isTextureProperty","styledProperties","m_lastUpdateFrameNumber","currentStyledProperties","m_dynamicProperties","propDefinition","setupStaticProperties","mapAdapter","objData","install","ensureUpdated","frameNumber","updateDynamicProperties","updateBaseColor","currentValue","applyMaterialGenericProp","applyMaterialBaseColor","somethingChanged","newValue","applyMaterialTextureProp","oldTexture","newTexture","isImage","isCanvas","complete","rgbValue","actualOpacity","MapObjectAdapter","m_notCompletlyTransparent","kind","m_pickability","getObjectMaterials","updateMaterials","visible","isVisible","m_globalFrustumMin","m_globalFrustumMax","m_frustumCorners","frustumCorners","getFrustumCorners","MAX_VALUE","frustumCorner","globalFrustumMin","globalFrustumMax","invProjMatrix","projectionMatrixInverse","cornerIndex","TileTaskGroups","setLogLevelForAll","DEFAULT_CAM_FAR_PLANE","rayCaster","groundPlane","Plane","groundSphere","matrix4","MapViewPowerPreference","MapViewDefaults","addBackgroundDatasource","maxVisibleDataSourceTiles","extendedFrustumCulling","tileCacheSize","resourceComputationType","ResourceComputationType","EstimationInMb","pixelRatio","devicePixelRatio","maxTilesPerFrame","MapView","RENDER_EVENT","DID_RENDER_EVENT","FIRST_FRAME_EVENT","FirstFrame","FRAME_COMPLETE_EVENT","FrameComplete","THEME_LOADED_EVENT","ThemeLoaded","ANIMATION_STARTED_EVENT","AnimationStarted","ANIMATION_FINISHED_EVENT","AnimationFinished","MOVEMENT_STARTED_EVENT","MovementStarted","MOVEMENT_FINISHED_EVENT","MovementFinished","CONTEXT_LOST_EVENT","ContextLost","CONTEXT_RESTORED_EVENT","ContextRestored","COPYRIGHT_CHANGED_EVENT","CopyrightChanged","DISPOSE_EVENT","m_renderLabels","m_visibleTileSetLock","m_maxZoomLevel","m_minCameraHeight","m_rteCamera","m_yaw","m_pitch","m_roll","m_targetDistance","m_targetGeoPos","fromObject","m_targetWorldPos","m_viewRanges","m_scene","Scene","m_overlayScene","m_sceneRoot","m_overlaySceneRoot","m_mapAnchors","MapAnchors","m_animationCount","m_drawing","m_updatePending","m_frameNumber","m_forceCameraAspect","m_taskSchedulerTimeout","m_tileDataSources","m_connectedDataSources","m_failedDataSources","m_enablePolarDataSource","m_raycaster","m_plane","m_sphere","m_firstFrameRendered","m_firstFrameComplete","m_userImageCache","MapViewImageCache","m_env","MapEnv","m_poiManager","PoiManager","m_poiTableManager","PoiTableManager","m_lastTileIds","m_copyrightInfo","m_disposed","onWebGLContextLost","onWebGLContextRestored","m_renderer","textElementsRenderer","restoreRenderers","getTheme","m_sceneEnvironment","updateClearColor","clearColor","clearAlpha","m_uriResolver","uriResolver","maxBounds","m_geoMaxBounds","decoderUrl","resolveUri","decoderCount","m_visibleTileSetOptions","clipPlanesEvaluator","enablePolarDataSource","m_pixelRatio","maxFps","enableStatistics","m_languages","m_politicalView","politicalView","handleRequestAnimationFrame","renderLoop","tileWrappingEnabled","setupStats","WebGL1Renderer","WebGLRenderer","antialias","nativeWebglAntialiasEnabled","preserveDrawingBuffer","powerPreference","Default","autoClear","checkShaderErrors","autoReset","m_tileObjectRenderer","TileObjectRenderer","setupRenderer","fovCalculation","getCanvasClientSize","up","setFovOnCamera","m_screenProjector","ScreenProjector","m_taskScheduler","MapViewTaskScheduler","m_tileGeometryManager","TileGeometryManager","enableMixedLod","lodMinTilePixelSize","m_lodMinTilePixelSize","m_visibleTiles","createVisibleTileSet","MapViewEnvironment","setupCamera","m_pickHandler","PickHandler","enablePickTechnique","m_movementDetector","CameraMovementDetector","movementThrottleTimeout","mapPassAntialiasSettings","customAntialiasSettings","mapRenderingManager","MapRenderingManager","dynamicPixelRatio","m_animatedExtrusionHandler","AnimatedExtrusionHandler","polarStyleSetName","m_polarDataSource","PolarTileDataSource","geometryLevelOffset","polarGeometryLevelOffset","updatePolarDataSource","throttlingEnabled","m_themeManager","MapViewThemeManager","m_textElementsRenderer","createTextRenderer","setTheme","lights","taskQueue","delayLabelsUntilMovementFinished","freeContext","m_movementFinishedUpdateTimerId","m_animationFrameHandle","cancelAnimationFrame","clearRenderStates","forceContextLoss","destroyIfTerminated","clearQueuedTasks","getDataSourceCacheSize","numVisibleTiles","setDataSourceCacheSize","setNumberOfVisibleTiles","updateCache","invalidateCache","m_pointOfView","pointOfView","postEffectsFile","fetch","postEffects","m_postEffects","setPostEffects","newTheme","setLanguages","setPoliticalView","disable","disableFading","m_previousFrameTimeStamp","m_collisionDebugCanvas","rendererClearColor","getClearColor","setClearColor","rendererClearAlpha","getClearAlpha","setClearAlpha","geoMaxBounds","lookAtImpl","geoCenter","imageCache","m_worldMaxBounds","enableNativeWebglAntialias","updateCameras","dataSourceName","getDataSourceByName","setEnableElevationOverlay","m_elevationProvider","conflictingDataSource","console","updateBackgroundDataSource","DataSourceConnect","dsIndex","removeDataSource","textElements","addOverlayText","clearOverlayText","targetOrParams","tiltDeg","headingDeg","geoPos","yawDeg","pitchDeg","limitedPitch","MAX_TILT_DEG","maxPitchRadWithCurvature","calculateDistanceToGroundFromZoomLevel","maxPitchDegWithCurvature","setRotation","cameraIsMoving","allVisibleTilesLoaded","isUpdating","animating","isAnimating","isUpdatePending","loading","m_pixelToWorld","lookAtDistance","pixelToWorld","getPixelRatio","setPixelRatio","ratio","lowResPixelRatio","pos","getNormalizedScreenCoordinates","intersectPlane","cosAlpha","getWorldPositionAt","parameters","intersectMapObjects","setSize","collisionDebugCanvas","Resize","frameStartTime","PerformanceTimer","render","disposed","startRenderLoop","fun","forEachVisibleTile","forEachCachedTile","elevationSource","m_elevationSource","addDataSource","m_elevationRangeSource","setTileUpdateCallback","overlayOnElevation","bloom","outline","vignette","sepia","updateOutline","enableShadows","shadowMap","PCFSoftShadowMap","cameraPos","tangentSpaceMatrix","setFromMatrixPosition","localTangentSpace","setFromMatrixColumn","calculateDistanceFromZoomLevel","geoBoxToGeoPoints","GeoPolygon","isGeoBoxExtentLike","box","fromCenterAndExtents","wrapGeoPointsToScreen","worldPoints","worldTarget","setFromPoints","scalePointToSurface","getFitBoundsLookAtParams","minDistance","getCameraRotationAtTarget","quaternion","getCameraPositionFromTargetCoordinates","updateLookAtSettings","twinDataSource","projectionScale","getScaleFactor","maxGeometryHeightScaled","minGeometryHeightScaled","assign","updateClipPlanes","updateProjectionMatrix","setScalar","updateCamera","constrainTargetAndDistanceToViewBounds","$zoom","$pixelToMeters","$frameNumber","vector","synchronousRendering","fudgeTimeInMs","frameInterval","isDynamicFrame","requestAnimationFrame","enabledDataSources","isDataSourceEnabled","currentFrameEvent","prepareRender","stats","PerformanceStatistics","gatherStatistics","currentFrame","timeSincePreviousFrame","setValue","storeAndClearFrameInfo","setupTime","cullTime","textPlacementTime","drawTime","textDrawTime","endTime","reset","m_thisFrameTilesChanged","updateEnv","lockVisibleTileSet","viewRangesStatus","updateRenderList","storageLevel","getEnabledTileDataSources","viewRangesChanged","renderList","dataSourceTileList","renderedTiles","frameNumLastVisible","addValue","visibleTiles","numTilesLoading","checkCameraMoved","CameraPositionChanged","renderLabels","placeText","renderText","appResults","disposePendingTiles","checkCopyrightUpdates","processPending","frameRenderTime","addWebGLInfo","addMemoryInfo","resize","VisibleTileSet","FrustumIntersection","tileIdList","newTileIds","checkIfTilesChanged","newCopyrightInfo","getRenderedTilesCopyrightInfo","allEqual","tileList","tileCopyrightInfo","CopyrightInfo","mergeArrays","tileObjectRenderer","TextElementsRenderer","MapViewState","userImageCache","fontCatalogs","textStyles","defaultTextStyle","updateFontCatalogs","updateTextStyles","fovRad","AtmosphereVariant","AtmosphereShadingVariant","AtmosphereLightMode","clipPlanes","MapViewAtmosphere","m_sceneCamera","m_projection","m_rendererCapabilities","m_updateCallback","m_atmosphereVariant","SkyAndGround","m_materialVariant","ScatteringShader","m_enabled","m_clipPlanesEvaluator","m_lightDirection","Sky","createSkyGeometry","Ground","createGroundGeometry","addToMapAnchors","mapAnchors","SkyAtmosphereUserName","GroundAtmosphereUserName","m_skyMesh","m_groundMesh","isAdded","isPresent","removeFromMapAnchors","lightMode","dynamicLight","LightDynamic","m_groundMaterial","setDynamicLighting","m_skyMaterial","m_skyGeometry","m_groundGeometry","createMapAnchor","SphereGeometry","PlaneGeometry","translate","SkyAtmosphereMaterial","SimpleColor","MeshBasicMaterial","BackSide","NormalBlending","MeshStandardMaterial","normalScale","setupSkyForRendering","GroundAtmosphereMaterial","FrontSide","setupGroundForRendering","onBeforeCallback","overrideClipPlanes","mat","updateUniforms","onAfterRender","revertClipPlanes","rteCamera","sceneCam","evaluateClipPlanes","pickable","DEFAULT_CLEAR_COLOR","frustumPoints","m_fog","MapViewFog","scene","m_backgroundDataSource","backgroundTilingScheme","setTilingScheme","m_createdLights","m_skyBackground","updateLights","sky","SkyBackground","updateSkyBackgroundColors","addNewSkyBackground","removeSkyBackGround","light","m_overlayCreatedLights","overlayScene","DirectionalLight","lightDescription","createLight","isDirectionalLight","directionalLight","clonedLight","transformedPoints","ndcToView","lightDirection","lightPosHyp","addScaledVector","shadow","updateMatrices","pointsInLightSpace","viewToLightSpace","expandByPoint","bottom","groundColor","background","updateTexture","viewPos","Fog","m_fogIsDefined","enableFog","m_cachedFog","startRatio","viewDistance","viewRange","horizontalDensity","verticalDensity","endRatio","density","smoothStep","setFogInRawShaderMaterials","traverse","Material","invalidateFog","MapViewPoints","enableRayTesting","mouseCoords","ndcToScreen","testPoint","pointInfo","ndc","pointIsOnScreen","absoluteScreenPosition","getPointInfo","il","screenPosition","pickCoordinates","halfSize","m_maxFps","m_throttlingEnabled","m_taskQueue","TaskQueue","FETCH_AND_DECODE","CREATE","prioSortFn","getPriority","fps","startTime","numItemsLeft","availableTime","spaceInFrame","counter","shouldProcess","task","estimatedProcessTime","tag","processNext","passedTime","m_abortControllers","m_theme","m_imageCache","cancelThemeUpdate","m_updatePromise","loadTheme","async","updateTheme","loadedTheme","isThemeLoaded","createAbortController","environment","sceneEnvironment","updateSkyBackground","updateLighting","images","imageTextures","updateImages","poiTables","loadPoiTables","resetTextRenderer","setPriorities","clearBackgroundDataSource","poiTableManager","poiManager","image","addImage","preload","atlas","addTextureAtlas","addImageTexture","screenSpaceLines","Line3","PickObjectType","tmpV3","tmpOBB","intersectDependentObjects","checkedDependencies","otherTile","getCachedTile","intersectObjects","m_pickingRaycaster","PickingRaycaster","setupRaycaster","pickListener","PickListener","screenX","screenY","scenePosition","pickTextElements","intersectedTiles","getIntersectedTiles","done","furthestResult","intersect","addResult","createResult","intersectObject","finish","results","pickResult","featureData","addObjInfo","getFeatureId","pickObjectType","Point","Text","ExtrudedLine","SolidLine","TextPath","Polygon","ExtrudedPolygon","Area","tiles","boundingBox","worldOffsetX","computeWorldOffsetX","intersectsRay","objInfos","starts","faceIndex","intersectIndex","objInfosIndex","featureStartIndex","raycasterFromScreenPoint","furthestIntersection","furthestDistance","threshold","calculateWorldSizeByFocalLength","defaultSort","lDataSourceOrder","rDataSourceOrder","distanceDiff","haveRenderOrder","m_parameters","m_results","m_sorted","m_finished","foundFeatureIdx","otherResult","sameType","sameDataSource","sameId","noId","sameUserData","oldResult","maxResults","sortResults","maxCount","maxResultCount","zeroDistanceGroup","nonZeroDistanceGroup","recursive","layers","test","mapObjectAdapter","isPickable","optionalTarget","m_groundPlaneNormal","m_groundPlane","addCanvasCornerIntersection","createPolygon","addHorizonIntersection","frustum","worldCorners","getWorldConers","ne","nw","se","sw","corner","addPointInFrustum","directionEast","directionWest","Ray","addFrustumIntersection","ndcPoints","geoPolygon","validateAndAddToGeoPolygon","verticalHorizonPosition","getVerticalHorizonPositionInNDC","addNDCRayIntersection","isInVisibleMap","containsPoint","intersectsPlane","intersectsLine","intersectLine","closeToFrustum","geoIntersection","bottomMidFarPoint","unproject","topMidFarPoint","farPlaneVerticalCenterLine","debugTiles","m_maxLatitude","m_geometryLevelOffset","m_debugTiles","m_northPoleEntry","m_southPoleEntry","m_styleSetEvaluator","$geometryType","$layer","getMatchingTechniques","createMaterial","capabilities","StyleSetEvaluator","createTechiqueEntry","createTileGeometry","latA","latB","isNorthPole","techniqueEntry","srcProjection","dstProjection","maxLat","poleLat","pBL","pBR","pTR","pTL","needsGeometryCut","isLeftHalf","poleX","poleY","pPole","pXX","lats","lmax","lmin","nearest","centerX","centerY","inPointB","inPointD","cutStart","intersectEdge","cutEnd","cutIndexStart","cutIndexEnd","Water","Background","RBush","CollisionBox","Math2D","Box","Box2","DetailedCollisionBox","detailBoxes","isLineWithBound","tmpCollisionBox","ScreenCollisions","screenBounds","rtree","bbox","collisionBox","intersectsDetails","containsBox","testBox","boxes","detailBox","boundedLine","lineXDiffTransformed","signBL","signBR","signTL","signTR","lineYDiffTransformed","normalX","normalY","debugCanvas","m_renderContext","m_renderingEnabled","m_numAllocations","m_numSuccessfulTests","m_numFailedTests","m_numSuccessfulVisibilityTests","m_numFailedVisibilityTests","getContext","getValue","allocate","strokeStyle","strokeRect","boundsArray","allocateIBoxes","collisionFound","padding","isInRange","m_width","m_height","source","projectVector","tempV3","halfWidth","halfHeight","screenCoords","tempV2","m_sky","m_projectionType","m_skyTexture","SkyGradientTexture","SkyCubemapTexture","projectionType","isSameSkyType","SkyCubemapFaceId","SKY_CUBEMAP_FACE_COUNT","faces","createCubemapFaceArray","m_skybox","CubeTextureLoader","CubeTexture","face","DEFAULT_TEXTURE_SIZE","DEFAULT_MONOMIAL_POWER","cameraDir","cameraRight","cameraUp","topColor","bottomColor","m_faceCount","m_faces","fillTextureData","monomialPower","RGBFormat","unpackAlignment","m_farClipPlaneDividedVertically","m_bottomMidFarPoint","m_topMidFarPoint","m_horizonPosition","m_farClipPlaneCorners","setHorizonPosition","updateTexturePosition","faceIdx","upDir","skyRatio","twoPi","CanvasSide","nextCanvasSide","m_cornerIntersects","m_intersections","m_isFullyVisible","earthRadiusSq","cameraHeight","m_normalToTangentAngle","tangentDistance","m_distanceToHorizonCenter","horizonCenterLength","m_radius","m_cameraPitch","horizonCenter","m_matrix","setPosition","computeIntersections","arcStart","arcEnd","startAngle","tStart","tEnd","maxNumPoints","numPoints","getPoint","Top","eyeToTangentAngle","Bottom","Right","yBottom","tTopRight","tBottomRight","isTangentVisible","getTangentOnSide","sideIntersections","computeTBIntersections","rightFov","intersections","computeLRIntersections","yTop","leftFov","isections","hasCorners","radiusSq","sideFov","eyeToHorizon","yMiddle","xMiddle","xBottom","intersectLineAndCircle","yTopRight","y1","x1","x2","y2","computeEdgeDivisions","geoStart","geoEnd","minLongitudeSpanTo","ccwCanvasCornersNDC","findBoundsIntersections","wrapAroundPoles","NDCStart","NDCEnd","divisionCount","NDCStep","NDCDivision","geoStartCorner","geoEndCorner","horizon","startNDCCorner","endNDCCorner","addSideSegmentSubdivisions","horizonIntersections","getSideIntersections","worldHorizonPoint","geoHorizonPoint","prevSide","previousCanvasSide","prevSideIntersections","getDivisionPoints","worldHorizonStart","worldHorizonEnd","geoHorizonStart","geoHorizonEnd","cornerCoordinates","numCorners","SphereHorizon","isFullyVisible","startCorner","endCorner","addSideIntersections","northPoleCenter","southPoleCenter","northPoleInView","southPoleInView","camLon","wrapLat","wrapLon","geoWrapTopRight","geoWrapTopRightNorm","crossLon","prevLon","isGwAntimerCross","hSphereCrossEndIndex","crossesAntimer","isAntimeridianCrossing","wrapSideOffset","wrapCornerOffset","geoWrapRight","geoWrapBottom","geoWrapLeft","geoWrapTopLeft","crossStart","crossEnd","crossLerp","geoCorners","numIntersections","RingBuffer","capacity","tail","enqOne","previous","Iterator","m_buffer","SimpleTimer","statistics","running","m_currentValue","SampledTimer","numResets","maxNumSamples","samples","getStats","computeArrayStats","asArray","median","median75","median90","median95","median97","median99","median999","avg","numSamples","stages","stage","hasTimer","getTimer","currentStage","timers","nullTimer","keepSamples","timer","addTimer","header","footer","maxNameLength","print","simpleStats","FrameStats","messages","oldValue","FrameStatsArray","frameEntries","frameStats","currentSize","enq","maxNumFrames","configs","m_frameEvents","clearFrames","webGlInfo","lines","triangles","memory","textures","programs","totalJSHeapSize","usedJSHeapSize","jsHeapSizeLimit","addFrame","onlyLastFrame","frames","plainObject","getAsPlainObject","simpleStatistics","m_textureLoader","requestHeaders","crossOrigin","loadWithThreeLoader","headers","blob","isJPEG","RGBAFormat","setCrossOrigin","AlphaFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","DepthStencilFormat","RedFormat","dataType","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","AmbientLight","intensity","castShadow","bias","mapSize","DEFAULT_MAX_THEME_INTHERITANCE_DEPTH","themeUrl","ok","statusText","resolveUrls","getAppBaseUrl","convertFlatTheme","checkTechniqueSupport","resolveDefinitions","resolveBaseThemes","contextLoader","ContextLogger","resolveThemeReferences","extends","childUrlResolver","composeUriResolvers","RelativeUriResolver","resolveIncludes","resolveIncludeUris","baseTheme","resolveResourceUris","resolveResources","contextLogger","pushAttr","resolveStyleSet","currentStyle","pushIndex","resolvedStyle","resolveStyle","resolvedWhen","resolveExpressionReferences","resolvedValue","failed","resolveInternal","isJsonExprReference","defName","def","maxInheritanceDepth","baseThemes","baseThemesMerged","actualBaseTheme","mergeThemes","currentStyleSets","incomingStyleSets","baseStyleSet","newStyleSet","styleIdMap","baseStyleIndex","baseStyle","styleIndex","mergeImageTextures","faceUrl","font","poiTable","numBytes","frameNumLastRequested","frameNumVisible","numFramesVisible","visibilityCounter","skipRendering","delayRendering","m_boundingBox","m_forceHasGeometry","m_textElementGroups","TextElementGroupPriorityList","m_pathBlockingElements","m_worldCenter","m_visibleArea","m_elevationRange","m_ownedTextures","WeakSet","updateBoundingBox","m_localTangentSpace","m_textStyleCache","TileTextStyleCache","m_offset","m_uniqueKey","m_tileGeometryLoader","TileGeometryLoader","attachGeometryLoadedCallback","isSettled","cancel","m_resourceInfo","computeResourceInfo","heapSize","HIGHEST_PRIORITY","TextElementGroup","removeTextElement","textElementGroups","m_textElementsChanged","textElementsChanged","blockingElement","_zoomLevel","elevateGeoBox","m_decodedTile","invalidateResourceInfo","decodeTime","copyrightHolderIds","isFinished","hasGeometry","m_tileLoader","wasSettled","tileLoaderState","disposeMaterial","materialProperty","shouldDisposeTexture","disposeObject","shouldDisposeObjectGeometry","shouldDisposeObjectMaterial","rootObject","preparedTextPaths","clearTextElements","hasTextElements","m_disposeCallback","chainCallbacks","LodMesh","setLevelOfDetail","enabledKinds","disabledKinds","isDetached","availableGeometryKinds","waitFinished","loadingFinished","removeDecodedTile","disposeTile","newBoundingBox","num3dObjects","numTextElements","aggregatedObjSize","gpuSize","visitedObjects","Object3DUtils","estimateSize","numUserTextElements","m_renderOrderStencilValues","m_stencilValue","willRender","processTileObject","updateStencilRef","displacement","setRotationFromMatrix","getRotationMatrix","frustumCulled","didRender","stableSort","groupOrder","program","setOpaqueSort","mapObjectAdapterA","mapObjectAdapterB","otherDataSourceOrder","eitherIsBuilding","getStencilValue","stencilValue","allocateStencilValue","processTileObjectFeatures","isBufferGeometry","finalIndex","endOfLastGroup","clearGroups","featureIndex","getFeatureState","$state","parentEnv","groundNormalPlanarProj","space","tangentSpace","obox3","quaternions","transforms","tmpCamera","TileOffsetUtils","offsetXOrOrbitParams","mapTargetWorld","orbitCenter","rotationTargetWorld","headingAxis","headingQuat","premultiply","applyAzimuthAroundTarget","tiltAxis","posBackup","quatBackup","tiltQuat","applyTiltAroundTarget","extractTiltAngleFromLocation","rotationCenterTilt","maxRotationTiltAngle","angleBetweenNormals","projectedRotationTargetNormal","projectOnPlane","mapTargetNormal","ninetyRad","maxTilt","computeClampedDeltaTilt","getWorldTargetFromCamera","cameraLookAt","constant","targetWorldPos","unconstrained","worldMaxBounds","boundsSize","viewHeight","viewWidth","viewHalfSize","constrained","expandByVector","clampPoint","targetMaxBounds","rotMatrix","localTarget","transpose","constrainedLocalTarget","targetHeightSq","lengthSq","constTargetDistSq","distanceToSquared","constTargetDistToGround","targetCoordinates","pitchRad","yawRad","wrapWorldPointsToView","cameraPosNormalized","pointLen","getFitBoundsDistance","targetDist","newDistance","getDistanceFactor","pointNDC","ppNDC","pEyeZ","maxFactor","constDist","newPEyeZ","pointOnScreenXinNDC","pointOnScreenYinNDC","pointInNDCPosition","extractRotation","pointInCameraSpace","setFromUnitVectors","makeRotationFromQuaternion","setFromRotationMatrix","lookAt","cosTheta","targetGeoCoords","getGeoTargetFromCamera","MAX_TILT_RAD","location","dirVec","dirLen","tileSize","targetNDCx","targetNDCy","getHeight","zoomTarget","cameraTarget","newCameraDistance","newZoomTarget","heightAboveTerrain","fallbackTarget","startPosition","lonCenter","lonSpan","relToCenter","geoTarget","startDistance","getCameraCoordinatesFromTargetCoordinates","deltaYawDeg","deltaPitchDeg","maxTiltAngleRad","rotateOnWorldAxis","newPitch","maxPitch","rotateX","getCameraFrustumPlanes","view","fullWidth","fullHeight","filmOffset","getFilmWidth","rayCastGeoCoordinates","worldCoordinates","ceiling","snapToCeilingZoomLevel","calculateDepthFromClipDistance","clipDistance","perspCam","cameraRange","viewSpaceDistance","cameraToWorldDistance","calculateVerticalFovByHorizontalFov","calculateFocalLengthByVerticalFov","calculateFovByFocalLength","calculateScreenSizeByFocalLength","estimateObject3dSize","mapViewIsLoading","allGeometryLoaded","isLoading","finishedLoading","eps","getBrowserLanguages","DOMUtils","SearchDirection","MB_FACTOR","DataSourceCache","cacheSize","rct","m_disposedTiles","m_resourceComputationType","m_tileCache","LRUCache","memoryUsage","getKey","setCapacityAndMeasure","getKeyForTile","deleteByKey","evictAll","evictSelected","inDataSource","compareDistances","minDiff","m_frustumIntersection","m_cameraOverride","m_viewRange","m_coveringMap","m_dataSourceCache","computationType","setCapacity","visibleTileKeysResult","getVisibleTileKeysForDataSources","visibleTileKeys","tileKeys","dataZoomLevel","visibleResult","processVisibleTiles","newTilesPerFrame","dependentResult","dependentTiles","updateTiles","allVisibleTileLoaded","allDataSourceTilesLoaded","allBoundingBoxesFinal","populateRenderedTiles","renderListEntry","min2","max2","oldViewRanges","newViewRanges","getTileImpl","dataSourceVisibleTileList","list","visibleLevel","visibleTileKey","getTileKey","searchLevelsUp","searchLevelsDown","getSearchDirection","parentTileKey","childLevel","markDataSourceTilesDirty","disposeTiles","listEntry","refs","processDependentTiles","skipOverlappedTiles","processDelayTileRendering","visibleArea","isNewTile","isFullyCovering","uniqueKey","searchDirection","BOTH","DOWN","UP","incompleteTiles","checkedTiles","tileKeyCode","findUp","findDown","childTileCode","childTile","nextLevelDiff","parentCode","exists","parentTile","foundUp","cacheOnly","touchTile","tileToUpdate","resultTile","addToTaskQueue","tileCache","execute","isExpired","dataSourceCache","retainedTiles","markTileDirty","dataSourceBuckets","bucket","updateFrustum","compute","nextUniqueServiceId","m_serviceCreated","addReference","broadcastRequest","DestroyService","targetServiceId","removeReference","CreateService","targetServiceType","getProjectionName","invokeRequest","broadcastMessage","indexId","href","LowResRenderPass","Pass","m_renderTarget","m_localCamera","OrthographicCamera","m_quadScene","m_quadUniforms","CopyShader","m_quadMaterial","CopyMaterial","m_quad","PlaneBufferGeometry","m_savedWidth","m_savedHeight","writeBuffer","readBuffer","WebGLRenderTarget","depthBuffer","stencilBuffer","tDiffuse","oldRenderTarget","getRenderTarget","setRenderTarget","renderToScreen","MSAASampling","MSAARenderPass","samplingLevel","Level_1","MSAAMaterial","m_tmpColor","OffsetVectors","oldClearColor","oldView","uniformCenteredDistribution","sampleWeight","DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL","DEFAULT_STATIC_MSAA_SAMPLING_LEVEL","Level_4","antialiasSettings","msaaEnabled","strength","thickness","ghostExtrudedPolygons","darkness","amount","m_renderPass","RenderPass","m_target1","m_target2","m_sepiaPass","ShaderPass","SepiaShader","m_vignettePass","VignetteShader","m_readBuffer","m_msaaPass","m_dynamicMsaaSamplingLevel","dynamicMsaaSamplingLevel","m_staticMsaaSamplingLevel","staticMsaaSamplingLevel","m_lowResPass","isStaticFrame","usePostEffects","activeTarget","clearDepth","m_outlineEffect","OutlineEffect","nextEffectEnabled","m_bloomPass","BloomPass","oldTarget","m_defaultThickness","m_defaultColor","m_defaultAlpha","m_defaultKeepAlive","m_ghostExtrudedPolygons","m_cache","m_removeThresholdCount","m_originalMaterials","m_originalOnBeforeRenders","m_shaderIDs","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshPhysicalMaterial","m_uniformsChunk","outlineThickness","outlineAlpha","ghost","depth","stencil","updateStyle","setViewport","setScissor","setScissorTest","renderTarget","currentAutoClear","renderOutline","currentSceneAutoUpdate","autoUpdate","currentSceneBackground","currentShadowMapEnabled","setOutlineMaterial","restoreOriginalMaterial","cleanupCache","originalMaterial","EdgeMaterial","createInvisibleMaterial","shaderID","originalVertexShader","originalUniforms","shaderUniforms","ShaderLib","vertexShader","isRawShaderMaterial","isShaderMaterial","isExtrusionMaterial","isFadingMaterial","FadingFeature","isDefined","vertexShaderChunk","vertexShaderChunk2","defines","DECLARE_TRANSFORMED","USE_EXTRUSION","DEFAULT_FADE_NEAR","DEFAULT_FADE_FAR","USE_FADING","fragmentShader","morphTargets","morphNormals","CustomBlending","blendSrc","SrcAlphaFactor","blendDst","OneMinusSrcAlphaFactor","blendSrcAlpha","OneFactor","blendDstAlpha","used","keepAlive","outlineMaterial","getOutlineMaterialFromCache","updateOutlineMaterial","getOutlineMaterial","outlineParameters","outlineUniforms","skinning","textureID","UniformsUtils","fsQuad","FullScreenQuad","m_mesh","BlurDirectionX","BlurDirectionY","resolution","m_renderTargetsHorizontal","m_renderTargetsVertical","m_nMips","m_separableBlurMaterials","m_basic","m_bloomTintColors","pars","resx","resy","m_renderTargetBright","generateMipmaps","renderTargetHorizonal","renderTargetVertical","m_highPassUniforms","LuminosityHighPassShader","m_materialHighPassFilter","kernelSizeArray","getSeperableBlurMaterial","m_compositeMaterial","getCompositeMaterial","m_copyUniforms","m_materialCopy","AdditiveBlending","rt","inputRenderTarget","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","nMips","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","dirtTexture","bloomStrength","bloomFactors","bloomTintColors","bloomRadius","m_cachedTreePromise","getCopyrightCoverageData","coverageInfo","initRBush","matchingEntries","getTree","maxLevel","item","tree","alt","CopyrightElementHandler","m_defaults","m_mapViews","mergedCopyrightInfo","staticInfo","m_element","display","sourceInfo","defaults","year","link","deduped","formatAsHtml","htmlElement","existingInfo","findItem","filtered","UrlCopyrightProvider","CopyrightCoverageProvider","m_fetchURL","m_baseScheme","m_requestHeaders","m_transferManager","TransferManager","m_cachedCopyrightResponse","downloadJson","toLocalTargetCoords","geom","oldArray","newArray","fromBufferAttribute","materialOrColor","createTexCoords","receiveShadow","createMultiLod","useLocalTargetCoords","createGroundPlaneMaterial","tileCorners","projectTilePlaneCorners","cornersArray","bufferArray","copyVector3sArray","normAttr","createGroundPlaneGeometry","sphericalModifier","modify","zoomLevelOffset","zoomLevelGeometry","createGroundPlane","registerTileObject","DisplacedBufferAttribute","originalAttribute","m_normals","m_uvs","m_textureWidth","m_textureHeight","VertexCache","MAX_CACHE_SIZE","m_lastPos","m_tmpNormal","resetTexture","normals","m_lastBufferIndex","getDisplacedCoordinate","m_texture","bufferIndex","displacePosition","sampleBilinear","tmpV2","tmpBox","displaceBox","displacementRange","displacementDir","tmpNormalMin","tmpNormalMax","union","DisplacedBufferGeometry","displacedPositions","m_originalBoundingBox","m_displacedPositions","resetAttributes","displacementRangeChanged","resetBoundingVolumes","computeBoundingBox","origBBox","boundingSphere","getBoundingSphere","needsBoundingBoxUpdate","computeBoundingSphere","drawRange","m_getDisplacementRange","m_raycastStrategy","firstMaterial","isDisplacementFeature","hasDisplacementFeature","isDisplacementMaterial","isDataTexture","isDataTextureMap","displacedGeometry","getDisplacedPositionAttribute","m_geometries","disposeGeometries","estimateTextureSize","imageBytes","estimateMaterialSize","rawMaterial","uniform","meshMaterial","aoMap","specularMap","envMap","standardMaterial","lightMap","LineDashedMaterial","estimateAttributeSize","attrBytes","bytesPerElement","BYTES_PER_ELEMENT","estimateGeometrySize","parentSize","isObject3D","isLine","isPoints","getFeatureDataSize","estimateMeshSize","geometryKind","mapAdapterParams","resetVisibilityCounter","tmpSphere","tmpInverseMatrix","tmpRay","tmpLine1","tmpPlane","tmpV4","computeFeatureBoundingSphere","featureBeginIndex","featureEndIndex","makeEmpty","vertex","vExtrusion","hWidth","hWidthSq","interPlane","outInterLine","extrLineT","intersectExtrudedLine","endCapT","startCapT","intersectClosestEndCap","minT","closestPointToPoint","intersectFeature","localRay","lHalfWidth","lHalfWidthSq","beginIdx","endIdx","bSphere","vExt","bitangent","biTangent","intersectsSphere","setFromCoplanarPoints","manhattanLength","interLine","interLineWorld","singleFeatureStart","MAX_SCALE_RATIO_DIFF","intersectGroup","firstFeatureIdx","groupEndIdx","bVolumes","boundingVolumes","isSolidLineMaterial","solidLineMaterial","localHalfWidth","localHalfWidthSq","featureStarts","featureIdx","lastFeatureIdx","bVolumeIdx","attributeInfo","attrInfo","isBufferAttribute","version","attributeChanged","getAttributeInfo","nextFeatureIdx","wantsAll","m_wantsPoints","wantsPoints","m_wantsLines","wantsLines","m_wantsAreas","wantsAreas","m_wantsObject3D","wantsObject3D","visitObject","wantsFeature","visitMesh","BufferedGeometryLineAccessor","BufferedGeometryObject3dAccessor","IndexedBufferedGeometryLineAccessor","meshObject","geometryAccessor","featureStart","featureEnd","getBufferGeometry","getIndexedGeometryAccessor","getGeometryAccessor","getCount","setRange","visitPoint","isLineAccessor","visitLine","visitArea","isObject3dAccessor","visitObject3D","BufferedGeometryAccessorBase","startCapSize","endCapSize","getColor","rawShaderMaterial","diffuseColor","BufferedGeometryAccessor","checkSetUp","positionsArray","subarray","getVertices","IndexedBufferedGeometryAccessor","positionArray","reconstructLineWidth","tmpVector3","tmpVector2","AttachmentCache","bufferAttributes","interleavedAttributes","MemoCallExpr","m_cachedProperties","m_deps","m_cachedValue","AttachmentInfo","description","getBufferAttribute","getArrayConstructor","interleavedBuffer","attrs","interleavedAttr","addToExtrudedMaterials","extrudedMaterials","TileGeometryCreator","_kindState","hasOrIntersects","srcGeometry","createdOffsets","texturesReady","createObjects","addOwnedTexture","onUpdate","initTexture","preparePois","createTextElements","createLabelRejectionElements","pathGeometries","path","addBlockingElement","PathBlockingElement","initDecodedTile","textPathGeometries","textFilter","processedPaths","newPaths","textPath","discreteZoomLevel","discreteZoomEnv","textElementBuilder","TextElementBuilder","textStyleCache","prepareTextPaths","withTechnique","build","pathLengthSqr","textGeometries","stringCatalog","numPositions","texts","techniqueFilter","animatedExtrusionHandler","attachment","getAttachments","groupCount","groupIndex","usesObject3D","extrusionAnimationEnabled","setAnimationProperties","hasExtrusionFeature","techniqueKind","setupTerrainMaterial","interleavedVertexAttributes","getInterleavedBufferAttributes","needsVertexNormals","computeVertexNormals","isSolidLineTechnique","isHighPrecisionLineMaterial","lineMaterial","clipping","clipTileSize","setShaderMaterialDefine","hasSolidLinesOutlines","hasFeatureGroups","buildObject","geometryId","isCirclesTechnique","isSquaresTechnique","isLineTechnique","isSegmentsTechnique","fadingParams","getFadingParams","addRenderHelper","addUserData","isRenderDepthPrePassEnabled","createDepthPrePassMesh","setDepthPrePassStencil","techniquePickability","transientToPickability","edgeIndex","hasEdgeFeatureGroups","edgeFeatureStarts","buildingTechnique","edgeGeometry","colorAttribute","extrusionAttribute","extrudedPolygonTechnique","getPolygonFadingParams","materialParams","colorMix","edgeMaterial","edgeObj","objectColor","frameMapView","customDepthMaterial","MapMeshDepthMaterial","depthPacking","RGBADepthPacking","outlineGeometry","fillTechnique","outlineObj","outlineTechnique","secondaryCaps","mainMaterialAdapter","outlineMaterialAdapter","mainLineWidth","secondaryLineWidth","poiGeometries","addPois","mainAttachment","attachments","terrainColor","stdMaterial","setDisplacementMapToMaterial","onBeforeCompile","tileDisplacementMap","xCountVertices","yCountVertices","isOutline","DEFAULT_COLOR_MIX","lineColorMix","addDiscardedTileToStats","reason","addMessage","TileGeometryLoaderState","m_tile","m_finishedPromise","m_resolveFinishedPromise","m_rejectFinishedPromise","foundSet","compileGeometryKind","Building","Label","isCanceled","isDisposed","hasDecodedTile","m_availableGeometryKinds","prepareAvailableGeometryKinds","compareGeometryKinds","processTechniques","setGeometryKinds","setDecodedTile","queueGeometryCreation","Disposed","m_enabledKinds","m_disabledKinds","CreationQueued","CreatingGeometry","geometryCreator","createAllGeometries","addStats","geometryCreationTime","enabledSame","disabledSame","enabledEmpty","disabledEmpty","enableFilterByKind","hiddenKinds","m_visibilityCounter","kinds","incrementVisibilityCounter","prio","tilePriority","updateGeometry","enabledGeometryKinds","disabledGeometryKinds","m_tileUpdateCallback","updateTileObjectVisibility","addOrRemoveToEnabledSet","enableDisableKinds","addOrRemoveToDisabledSet","addOrRemoveToHiddenSet","visibilityHasChanged","oneKind","visibilityChange","addRemove","visibleKinds","tileKinds","loadedGeometryKinds","needUpdate","objectAdapter","nowVisible","addToSet","kindSet","kindsSet","Field","Invalid","maxVertexCount","m_vertexCount","m_oldestIdx","m_newestIdx","Count","vertexId","vertexIdx","getVertex","setVertex","newerIdx","getNewerIdx","olderIdx","getOlderIdx","setOlderIdx","setNewerIdx","OlderIdx","NewerIdx","X","Y","overlayObject","setDisplacementMap","overlayPosition","worldCoords","geoCoords","sampleHeight","elevated","overlayPath","firstObject","Terrain","getDisplacementMap","mipMapGenerator","MipMapGenerator","mipMaps","loadingPromise","loaded","HTMLImageElement","finalizeImage","cancelled","ImageLoader","errorEvent","generateTextureAtlasMipMap","ImageCache","m_images","owner","imageCacheItem","findImageCacheItem","owners","imageItem","ImageItem","cacheItem","unlinkCacheItem","ownerIndex","cancelLoading","m_name2Url","m_urlNameCount","urlOrImage","startLoading","registerImage","loadImage","nameCount","removeImage","findImage","hasName","m_paddingCanvas","m_paddingContext","m_resizeCanvas","m_resizeContext","ceilPowerOfTwo","imageData","paddedWidth","paddedHeight","getPaddedSize","copyImageWithPadding","getImageData","previousImage","resizeImage","clearRect","ImageData","putImageData","drawImage","paddedImage","BoxBufferMesh","BoxBuffer","m_material","m_renderOrder","startElementCount","m_maxElementCount","resizeBuffer","m_pickInfos","m_positionAttribute","m_colorAttribute","m_uvAttribute","m_indexAttribute","glyphCount","indexAttribute","newSize","positionAttributeCount","colorAttributeCount","uvAttributeCount","indexAttributeCount","pickInfoCount","screenBox","uvBox","pickInfo","canAddElements","s0","s1","baseIndex","setXYZW","setXY","updateRange","clearAttributes","isEmpty","pickCallback","pickInfos","pickInfoIndex","positionIndex","poiInfo","isPixelTransparent","forceResize","xScreenPos","yScreenPos","screenToUvCoordinates","SVGImageElement","getBBox","pixel","getPixelFromImage","newPositionArray","setUsage","DynamicDrawUsage","newColorArray","newUvArray","numIndexValues","newIndexArray","getPixelFromCanvasImageSource","xPos","yPos","pixelData","getPixelFromImageData","imgData","strd","Uint8ClampedArray","getPixel","m_imageTextureName","composeTechniqueTextureName","getImageTexture","m_iconMinZoomLevel","iconMinZoomLevel","m_iconMaxZoomLevel","iconMaxZoomLevel","m_textMinZoomLevel","textMinZoomLevel","m_textMaxZoomLevel","textMaxZoomLevel","m_technique","imageTextureName","shieldGroupIndex","m_shieldGroupIndex","textIsOptional","iconIsOptional","renderTextDuringMovements","iconMayOverlap","textMayOverlap","iconReserveSpace","textReserveSpace","iconColorRaw","poiTableName","poiGeometry","textureNameIndex","getAttributes","getPosition","getText","stringIndex","m_imageTextures","m_poiShieldGroups","m_missingPoiTableName","loadedOk","m_missingPoiName","assertExists","intZoomEnv","poiBuilder","showOnMap","addLineMarker","addPoi","jsonAtlas","imageTextureDef","xOffset","yOffset","pointLabel","getPoiTable","notifyMissingPoiTable","poiTableEntry","getEntry","iconName","iconMinLevel","iconMaxLevel","textMinLevel","textMaxLevel","alignZoomLevelRanges","notifyMissingPoi","groupKey","withIcon","offsetDirection","offsetDirections","neutralColor","tmpIconColor","PoiBuffer","m_onDispose","m_refCount","PoiBatch","UVMapping","trilinear","mipmaps","premultiplyAlpha","IconMaterial","m_poiBuffers","poiBuffer","increaseRefCount","boxBuffer","disposeBuffer","updateBufferGeometry","pickBoxes","updateMemoryUsage","PoiBatchRegistry","m_batchMap","batchKey","batch","deleteBatch","getBuffer","addBox","missingTextureName","PoiRenderer","m_imageCaches","m_tempScreenBox","m_layers","m_poiBatchRegistry","computedWidth","computedHeight","iconXOffset","iconYOffset","preparePoi","screenCollisions","allocateScreenSpace","computeIconScreenBox","layerId","getLayer","updatePoiFromPoiTable","imageCaches","findImageByName","missingTextureCount","findImageItem","setupPoiInfo","loadedImageItem","imageWidth","imageHeight","paddedSize","trilinearFiltering","paddedImageWidth","paddedImageHeight","iconWidth","iconHeight","minS","maxS","maxT","iconScaleH","iconScale","iconScaleV","screenWidth","screenHeight","registerPoi","addLayer","PoiTableEntry","jsonEntry","isOK","altNames","stackMode","Show","Hide","ShowParent","PoiTable","useAltNamesForKey","poiList","poiDict","m_isLoading","m_loadedOk","entryIdx","poiTableUrl","jsonPoiTable","tableEntry","verifyJSON","newPoiEntry","altName","ex","m_poiTables","loadPromises","poiTableRef","addTable","finally","finishLoading","fontCatalogConfig","onSuccess","FontCatalog","placement","m_hAlign","DefaultTextStyle","DEFAULT_HORIZONTAL_ALIGNMENT","m_vAlign","DEFAULT_VERTICAL_ALIGNMENT","textPlacement","hAlignFromPlacement","vAlignFromPlacement","hPlacementFromAlignment","vPlacementFromAlignment","layoutStyle","m_renderedTilesChangeCheck","m_lookAtVector","tileGeometryManager","hiddenGeometryKinds","tmpPosition","tmpCameraDir","tmpPointDir","computeViewDistance","poiIndex","eyePosition","eyeLookAt","pointToPlaneDistance","viewDistance0","viewDistance1","pointPos","planePos","planeNorm","PrePlacementResult","viewState","farDistanceLimitRatio","maxVisibilityDist","tmpPlacementPosition","maxViewDistance","isClamped","lookAtVector","textDistance","checkViewDistance","TooFar","Ok","Invisible","NotReady","tmpBounds","tmpBoxes","tmpMeasurementParams","tmpCollisionBoxes","tmpScreenPosition","tmpTextOffset","tmp2DBox","tmpCenter","tmpSize","PlacementResult","placePointLabelAtAnchor","labelState","textCanvas","forceInvalidation","outScreenPosition","glyphs","measureText","labelBounds","applyTextPlacement","outputCharacterBounds","pathOverflow","letterCaseArray","glyphCaseArray","textOffset","textBounds","TextElementType","PoiLabel","LineMarker","HorizontalPlacement","VerticalPlacement","poiIsRenderable","hAlign","vAlign","hAlignDiff","vAlignDiff","relOffsetX","relOffsetY","computePointTextOffset","renderDistance","persistentPointLabelTextMargin","newPointLabelTextMarginPercent","isAllocated","Rejected","textReservesSpace","textBufferObject","textLayoutStyle","iconRenderState","multiAnchor","placements","persistent","lastPlacement","placementsNum","matchIdx","allInvisible","isLastPlacement","placementResult","placePointLabelChoosingAnchor","placePointLabelAtCurrentAnchor","candidateBoxes","checkGlyphCollision","glyphBox","screenProjector","outScreenPoints","PathLabel","anyPointVisible","projectToScreen","minScreenSpace","dbgPathTooSmall","tmpOrientedBox","poiLabel","outWorldPosition","worldOffsetShiftValue","worldOffset","offsetDirectionVector","offsetDirectionRad","applyAxisAngle","m_logger","totalGroups","resortedGroups","total","uninitialized","tooFar","numNotVisible","numPathTooSmall","numCannotAdd","numRenderedPoiIcons","numRenderedPoiTexts","numPoiTextsInvisible","numRenderedTextElements","numNotRendered","FadingState","DEFAULT_FADE_TIME","fadeTime","Undefined","FadingIn","FadingOut","FadedIn","FadedOut","fadingTime","smootherStep","isFading","SimpleLineCurve","LineCurve","m_lengths","PathParam","curves","m_point","curve","SimplePath","Path","lineCurve","getLength","curveLengths","getCurveLengths","segmentLength","m_minGlyphCount","m_maxGlyphCount","fontCatalog","TextCanvas","minGlyphCount","maxGlyphCount","LoadingState","renderParams","layoutParams","tileOffset","distanceScale","renderStyle","m_poiInfo","poiRenderOrder","m_renderStyle","m_layoutStyle","decreaseRefCount","m_styleCache","m_baseRenderOrder","m_distanceScale","DEFAULT_TEXT_DISTANCE_SCALE","isInteger","renderOrderUpBound","RENDER_ORDER_UP_BOUND","absBaseRenderOrder","isValidRenderOrder","baseRenderOrder","m_fadeNear","m_fadeFar","getRenderStyle","m_layoutStype","getLayoutStyle","m_xOffset","m_yOffset","msg","composeRenderOrder","withTextTechnique","withPoiTechnique","m_poiBuilder","ContextualArabicConverter","convert","m_mayOverlap","m_reserveSpace","textFadeTime","m_alwaysOnTop","PoiBuilder","PriorityListGroup","GroupedPriorityList","m_visited","m_textElementStates","TextElementState","visited","elementState","updateFading","visibleElementsCallback","m_lineMarkerIndex","m_textRenderState","m_iconRenderState","themeLayout","stateLayout","m_textLayoutState","isBaseTextPlacement","LayoutState","m_viewDistance","predecessor","initialized","initializeRenderStates","setViewDistance","RenderState","techniqueIconFadeTime","iconFadeTime","tmpCachedDuplicate","getCacheKey","hasFeatureId","isBetterPathDuplicate","newCandidate","_newDistance","oldCandidate","_oldDistance","isBetterPointDuplicate","_newCandidate","_oldCandidate","oldDistance","m_referenceMap","m_textMap","textElementGroup","textElementFilter","groupState","updateElements","TextElementGroupState","m_sortedGroupStates","findReplacements","replaceCallback","replaceElement","anyEviction","traverseVisibleElements","cacheResult","findDuplicate","cachedDuplicate","textElementGroupState","cachedEntries","candidates","duplicateIndex","findDuplicateById","maxSqDistError","getDedupSqDistTolerance","entryCount","elementPosition","elementVisible","isLineMarker","isLineMarkerElementState","duplicate","dupIndex","dupDistSquared","isBetterDuplicate","candidateEntry","cachedElement","areDiffType","areBothVisible","distSquared","findDuplicateByText","DEFAULT_FONT_CATALOG_NAME","tempPosition","tempScreenPosition","tempScreenPoints","tempPoiScreenPosition","tmpTextBufferCreationParams","tmpAdditionParams","tmpBufferAdditionParams","TileTextElements","TextElementLists","lists","addTextToCanvas","pickingData","addText","isPlacementTimeExceeded","m_viewState","textCanvasFactory","poiRenderer","m_loadPromisesCount","m_textCanvases","m_tmpVector","m_cameraLookAt","m_overloaded","m_cacheInvalidated","m_addNewLabels","m_forceNewLabelsPass","m_textElementStateCache","TextElementStateCache","TextStyleCache","m_screenCollisions","m_isUpdatePending","initializeDefaultOptions","ScreenCollisionsDebug","m_textCanvasFactory","TextCanvasFactory","setGlyphCountLimits","minNumGlyphs","maxNumGlyphs","m_poiRenderer","initializeCamera","initializeDefaultFontCatalog","updateTextCanvases","delay","showReplacementGlyphs","m_defaultFontCatalogConfig","config","catalog","addTextCanvas","waitLoaded","previousLayer","updateGlyphDebugMesh","poiLayer","tileTextElementsChanged","checkIfTextElementsChanged","textElementsAvailable","hasOverlayText","_key","renderedTilesChanged","updateTextElements","clearVisited","anyTextGroupEvicted","prepopulateScreenWithBlockingElements","placeNewTextElements","placeTextElements","placeOverlayTextElements","m_overlayTextElements","pickHandler","pickData","pickText","Icon","m_loadPromise","getMemoryUsage","startLinePointProj","endLinePointProj","pathBlockingElement","blockingElements","project3","lineWithBound","maxNumPlacedLabels","pass","shieldGroups","elevationMap","textElementState","textElementStates","PersistentLabels","NewLabels","textElementStyle","getTextElementStyle","overlayTextElement","elementType","isPathLabelTooSmall","forceNewPassOnLoaded","initializeGlyphs","DEFAULT_TEXT_CANVAS_LAYER","storage","drawCount","textRenderStyle","addPoiLabel","addLineMarkerLabel","addPathLabel","loadingState","Requested","newLoadPromise","loadCharset","getGlyphs","defaultFontCatalogUrl","addDefaultTextCanvas","catalogCallback","loadedTextCanvas","createTextCanvas","errorCallback","loadFontCatalog","debugGlyphs","m_debugGlyphTextureCacheMesh","initializeGlyphDebugMesh","m_debugGlyphTextureCacheWireMesh","defaultTextCanvas","defaultFontCatalog","planeGeometry","textureSize","maxWidth","maxHeight","WireframeGeometry","wireframeMaterial","clearTextCache","checkIfOverloaded","updateStartTime","overloaded","updateTextElementsFromSource","tileDataSource","sortedTiles","sortedGroups","createSortedGroupsForSorting","numTextElementsUpdated","textElementLists","selectTextElementsToUpdateByDistance","found","getOrSet","checkReadyForPlacement","lineMarkerIndex","deduplicateElement","Duplicate","tilesToRender","shouldRenderText","groupedPriorityLists","foundGroup","maxDistanceRatioForTextLabels","maxDistanceRatioForPoiLabels","getMaxViewDistance","tileTextElements","prepareTextElementGroup","fadeAnimationRunning","placeStartTime","placeNew","maxNumPlacedTextElements","maxNumVisibleLabels","groupStates","sortedGroupStates","currentPriority","currentPriorityBegin","newPriority","placeTextElementGroup","beginGroupIndex","endGroupIndex","screenXOrigin","screenYOrigin","screenPoints","pX","pY","labelDistanceScaleMin","labelDistanceScaleMax","distanceFadeValue","textRenderState","iconRejected","renderIcon","distanceScaleFactor","getDistanceScalingFactor","iconReady","iconInvisible","placeIcon","distanceFadeFactor","getDistanceFadingFactor","poiTextMaxDistance","shouldRenderPointText","newLabel","placeResult","placePointLabel","textInvisible","textRejected","startFadeOut","shouldRenderPoiText","startFadeIn","fadeFactor","createTextBufferObject","backgroundIsVisible","addTextBufferObject","addTextBufferToCanvas","allocateSpace","labelPotentiallyVisible","addPointLabel","lineMarkerLabel","shieldGroup","lineTechnique","minDistanceSqr","numShieldsVisible","tooClose","textMaxDistance","pathLabel","textRenderDistance","prevSize","placePathLabel","prevOpacity","prevBgOpacity","numTextElementsInScene","newOverloaded","outPoint","maxPoiDistanceToBorder","projectAreaToScreen","defaultTextRenderStyle","defaultTextLayoutStyle","DEFAULT_STYLE_NAME","parseAlignmentAndPlacements","hAlignment","vAlignment","placementsTokens","placementsString","toUpperCase","modifier","North","South","East","West","parseTechniquePlacementValue","parseTechniquePlacements","resolvePlacementAndAlignment","parseTechniqueHAlignValue","parseTechniqueVAlignValue","m_textStyles","m_defaultStyle","updateDefaultTextStyle","textStyleDefinitions","defaultTextStyleDefinition","createTextElementStyle","textCanvases","initializeTextCanvas","styleId","defaultRenderParams","defaultOpacity","hexColor","defaultBackgroundSize","hasBackgroundDefined","defaultBackgroundOpacity","hexBgColor","fontName","fontStyle","FontStyle","fontVariant","FontVariant","rotation","DEFAULT_BACKGROUND_COLOR","themeRenderParams","floorZoomLevel","defaultLayoutParams","textPlacements","wrapping","wrappingMode","WrappingMode","tracking","leading","maxLines","canvasRotation","lineRotation","themeLayoutParams","styledTextCanvas","alternativeTextCanvas","styleName","fontCatalogName","Word","textRenderStyles","textLayoutStyles","styleCache","createRenderStyle","createLayoutStyle","newGroups","totalLabels","resolvedDependencies","startWorkerImmediately","directlyFallbackToBlobBasedLoading","startWorkerBlob","pageUrl","fullScriptUrl","getUrlOrigin","Worker","waitWorkerInitialized","fetchScriptSourceToBlobUrl","blobUrl","sourceLoaderCache","scriptSource","firstMessageCallback","isWorkerBootstrapRequest","dependency","resolved","dependencyUrlMapping","cleanup","filename","lineno","timerId","sizeValue","opacityValue","shaderParameters","shaderParams","merge","Uniform","DEFAULT_CIRCLE_SIZE","UniformsLib","extensions","derivatives","premultipliedAlpha","hasExtrusion","setShaderDefine","edgeColor","edgeColorMix","patchGlobalShaderChunks","ExtrusionFeature","useExtrusion","useDisplacementMap","GroundAtmosphereShader","u_eyePositionWorld","u_lightDirectionWorld","u_modelViewProjection","u_atmosphereEnv","u_hsvCorrection","fogColor","fogNear","fogFar","atmosphere_vertex_utils","atmosphere_fragment_utils","enableLighting","cameraInfo","getCameraInfo","modelViewProjection","eyeHeight","cameraInSpace","outerRadius","needsUpdate0","needsUpdate1","modelMatrix","identity","viewMatrix","mvpMatrix","objectPos","ShaderChunk","DEFAULT_OPACITY","updateTransparencyFeature","points_frag","DEFAULT_SIZE","DEFAULT_SCALE","uvTransform","Matrix3","luminosityThreshold","smoothWidth","emptyTexture","visibilityRange","linkMixinWithMaterial","mixin","shaderDefines","linkMixinWithShader","DisplacementFeature","isEnabled","displacementMaterial","updateDisplacementFeature","insertShaderInclude","DisplacementFeatureMixin","m_displacementMap","displacementScale","displacementBias","fadingMaterial","fading_pars_vertex","updateFadingFeature","useFading","additionalCallback","FadingFeatureMixin","getFadeNear","setFadeNear","getFadeFar","setFadeFar","extrusionMaterial","extrusion_pars_vertex","updateExtrusionFeature","ExtrusionFeatureMixin","m_extrusion","getExtrusionRatio","zFightingWorkaround","ZFIGHTING_WORKAROUND","addFadingProperties","applyFadingParameters","addExtrusionProperties","applyExtrusionParameters","addDisplacementProperties","applyDisplacementParameters","copyFadingParameters","copyExtrusionParameters","copyDisplacementParameters","MeshDepthMaterial","meshphysical_frag","simpleLightingShadowChunk","applyMixinsWithoutProperties","MIN_BUILDING_HEIGHT","isWebGL2","glslVersion","GLSL3","GLSL1","convertVertexShaderToWebGL2","convertFragmentShaderToWebGL2","getShaderMaterialDefine","MIN_BUILDING_HEIGHT_SQUARED","extrusion_vertex","extrusion_normal_fragment_begin","extrusion_pars_fragment","extrusion_fragment","fading_vertex","fading_pars_fragment","fading_fragment","LineCapsModes","extrude_line_vert_func","round_edges_and_add_caps","CAPS_NONE","CAPS_SQUARE","CAPS_ROUND","CAPS_TRIANGLE_IN","CAPS_TRIANGLE_OUT","tile_clip_func","high_precision_vert_func","SkyAtmosphereShader","LineCapsDefinesMapping","Square","Round","TriangleIn","TriangleOut","DefinesLineCapsMapping","lineCapsName","defineKey","LineDashesModes","LineDashesDefinesMapping","DASHES_SQUARE","DASHES_ROUND","Diamond","DASHES_DIAMOND","DefinesLineDashesMapping","lineDashesName","fragmentSource","CAPS_MODE","DASHES_MODE","fogParam","opacityParam","extrusionWidth","DEFAULT_WIDTH","DEFAULT_OUTLINE_WIDTH","DEFAULT_OFFSET","DEFAULT_DRAW_RANGE_START","DEFAULT_DRAW_RANGE_END","DEFAULT_DASH_SIZE","DEFAULT_GAP_SIZE","NotEqualStencilFunc","capsMode","dashesMode","useTileClip","forcedBlending","fallbackValue","getShaderDefine","updated","DEFINE_BOOL_TRUE","DEFINE_BOOL_FALSE","shaderContent","shaderName","insertedShaderName","addTab","tabChar","APIFormat","AuthenticationMethod","OmvDataSource","tempTextPosition","tempTextBounds","tempVertexBuffer","m_fontCatalog","m_ownsMaterial","createSdfTextMaterial","backgroundMaterial","m_ownsBgMaterial","m_bgMaterial","isBackground","m_defaultLayer","TextGeometry","m_currentTextRenderStyle","m_currentTextLayoutStyle","m_lineTypesetter","LineTypesetter","m_pathTypesetter","PathTypesetter","sdfTexture","sdfParams","distanceRange","MSDF","bgMaterial","backgroundMesh","lowerLayerId","higherLayerId","outputBounds","upperCaseArray","pathOrigin","textPathOverflow","individualBounds","targetLayer","tempLayer","prevDrawCount","updatePosition","addPickingData","m_drawCount","glyphArray","smallCapsEnabled","SmallCaps","characterBounds","storeStyles","computeTextBuffer","TextBufferObject","bgColor","bgOpacity","smallCapsTransformations","glyphBounds","QUAD_VERTEX_MEMORY_FOOTPRINT","isPath","typesettingParams","smallCapsArray","globalBounds","vertexBuffer","arrangeGlyphs","BOLD_ASSETS_PATH","ITALIC_ASSETS_PATH","fonts","unicodeBlocks","maxCodePointCount","m_replacementGlyph","m_glyphTextureCache","GlyphTextureCache","m_loadingJson","m_loadingPages","m_loadingGlyphs","m_loadedJson","m_loadedPages","m_loadedGlyphs","loadJSON","replacementDirUrl","replacementJson","replacementTexture","loadTexture","replacementFont","replacementGlyph","GlyphData","chars","xadvance","xoffset","yoffset","lastIndexOf","supportedBlocks","rawJSON","block","loadPages","assetsPath","getAssetsPath","jsonPath","jsonPromise","pagePromises","page","pages","loadPage","pagePath","charset","AllCaps","glyphPromises","char","codePoint","getFont","fontHash","glyphHash","fontGlyphMap","glyph","glyphPromise","fromCodePoint","createReplacementGlyph","charUnicodeBlock","loadAssets","loadedGlyph","shouldTransform","character","transformedCharacter","glyphData","getGlyph","isReplacement","selectedFontName","textureBytes","loadedPage","UnicodeUtils","isPrintable","loadBlock","sourceGlyphData","texturePath","pagePromise","fontStylePath","Bold","bold","Italic","italic","BoldItalic","boldItalic","advanceX","u0","u1","sourceTextureCoordinates","dynamicTextureCoordinates","copyIndex","isInCache","getDirection","metrics","lineHeight","entryWidth","entryHeight","nRows","m_cacheHeight","m_cacheWidth","m_textureSize","m_entryCache","initCacheEntries","m_rt","m_copyTextureSet","m_copyTransform","m_copyPositions","m_copyVertexBuffer","m_copyPositionAttribute","m_copyUVAttribute","m_copyGeometry","copyIndexBuffer","m_copyMesh","m_copyGeometryDrawCount","m_clearPositionAttribute","m_clearGeometry","clearIndexBuffer","m_clearMesh","m_clearGeometryDrawCount","m_clearMaterial","m_copyMaterial","hash","oldestEntry","clearCacheEntry","copyGlyphToCache","willClearGeometry","willCopyGeometry","GlyphClearMaterial","setDrawRange","GlyphCopyMaterial","srcPages","nCopies","pageOffset","pageIndex","dummyGlyphData","DEFAULT_IMAGE","lineGap","capHeight","xHeight","dummyEntry","cacheLocation","copyTextureIndex","applyMatrix3","MAX_CAPACITY","VERTEX_BUFFER_STRIDE","INDEX_BUFFER_STRIDE","VERTICES_PER_QUAD","INDICES_PER_QUAD","QUAD_INDEX_MEMORY_FOOTPRINT","initialSize","m_pickingDataArray","m_currentCapacity","m_updateOffset","m_vertexBuffer","m_bgColorAttribute","m_indexBuffer","m_bgMesh","corners","weight","bgWeight","mirrored","resizeBuffers","mirroredUVIdx","cosR","sinR","rotSign","red","green","blue","bgRed","bgGreen","bgBlue","bgAlpha","targetOffset","srcOffset","bw","startIdx","newVertexBuffer","newIndexBuffer","sdf_attributes","sdf_varying","sdf_varying_computation","sdf_frag_uniforms","sdf_sampling_functions","page0","page1","page2","page3","page4","page5","page6","page7","vertexSource","isMsdf","BG_TEXT","DoubleSide","hP","hA","vA","DEFAULT_FONT_NAME","DEFAULT_FONT_SIZE","freeze","DEFAULT_FONT_STYLE","Regular","DEFAULT_FONT_VARIANT","DEFAULT_ROTATION","DEFAULT_BACKGROUND_OPACITY","DEFAULT_TRACKING","DEFAULT_LEADING","DEFAULT_MAX_LINES","DEFAULT_LINE_WIDTH","DEFAULT_CANVAS_ROTATION","DEFAULT_LINE_ROTATION","DEFAULT_WRAPPING_MODE","Above","DEFAULT_PLACEMENTS","m_params","placementsOpt","m_tempTransform","m_tempCorners","m_tempLineDirection","Direction","LTR","m_tempRunDirection","m_tempPixelSize","m_tempPixelBgSize","m_tempScale","m_tempSmallCaps","m_currentParams","TypesettingUtils","getPixelSize","isOnlyMeasured","lineStartIdx","glyphWrapIdx","wordWrapIdx","lineStartX","lineCurrX","glyphWrapX","wordWrapX","lineCount","isBidirectionalLine","isNewLine","isWhiteSpace","getSmallCapsScale","wrapPointIdx","wrapPointX","lineAlignment","RTL","placeLine","isBidirectional","placeRun","glyphDataArray","isRTL","runStart","Neutral","neutralIdx","Weak","weakRunStart","weakGlyph","glyphFont","glyphFontMetrics","isBoldEmulated","isItalicEmulated","isSmallCaps","smallCapsScale","glyphScale","emulationWeight","isMirrored","isRtlMirrored","verticalOffset","computeGlyphTransform","glyphVertexPosition","horizontalOffset","OBLIQUE_OFFSET","updateBounds","addToBuffer","m_tempPathPosition","m_tempPathLength","m_tempPathOffset","pathWidth","defaultGlyphRotation","normalDisplacement","textPoint","tangent","getTangent","ContextualForm","CombinedForm","m_singleCharactersMap","m_combinedCharactersMap","m_neutralCharacters","output","currentCodePoint","charCodeAt","isArabicCharacter","prevIndex","isNeutral","prevCodePoint","prevMap","getCharacterMap","Initial","Medial","nextIndex","nextCodePoint","nextMap","Final","combinedMap","getCombinedCharacterMap","fromCharCode","Connected","Isolated","SdfTextMaterial","EM_TO_PX","PT_TO_PX","OBLIQUE_ANGLE","originalSize","Em","Percent","localRotation","sinAngle","localCosAngle","localSinAngle","whiteSpaceRanges","newLineRanges","nonPrintableRanges","rtlBlocks","neutralBidirectionalRanges","weakBidirectionalRanges","weakRange","neutralRange","rtlMirroredCodePoints","executor","resolveFunc","rejectFunc","fetchFunction","maxRetries","activeDownloadCount","downloadQueue","activeDownloads","defaultInstance","retryCount","init","status","responseText","waitFor","retryTimeout","fetchRepeatedly","milliseconds","downloadAs","download","arrayBuffer","maxParallelDownloads","deferred","DeferredPromise","doDownload","onDownloadDone","execDeferredDownload","future","converter","cacheKey","pendingFetch","newFetch","headerMessage","m_headerLogged","createLogMethod","severity","rest","getIsoLanguageCode","language","languageList","f1","f2","foundIndex","getGroup","findGroup","otherGroup","normalizedPriority","optionalParams","m_channel","prefix","LoggerManagerImpl","m_loggers","channel","self","ConsoleChannel","WorkerChannel","loggerName","m_levelSetForAll","Logger","channels","workerMessage","ax","ay","bx","by","xmax","ymax","computeSquaredLineLength","squaredLineLength","xDiff","yDiff","distToSegmentSquared","px","py","l0x","l0y","l1x","l1y","lineLengthSuared","xLine1","yLine1","xLine2","yLine2","dSq","cp","discriminantSquared","xMid","yMid","discriminant","xDist","yDist","intersectLines","x3","y3","x4","y4","edge0","edge1","inMin","inMax","outMin","outMax","lowerBound","upperBound","derivedCtor","baseCtors","baseCtor","getOwnPropertyDescriptor","cloneInternal","src","cached","getTime","RegExp","flags","props","nowFunc","getNowFunc","maxXIndex","maxYIndex","xIndex","xIndexFloor","yIndex","yIndexFloor","swIndex","seIndex","nwIndex","neIndex","swElevation","seElevation","nwElevation","neElevation","xFrac","xFracInverse","yFrac","yFracInverse","m_taskLists","taskList","updateTaskList","getTaskList","numLeft","tasklist","nextTask","pull","checkIfExpired","uri","parentUri","resolveReferenceUri","resolvers","originalUrl","process","cwd","baseUrl","childUri","absoluteUrlWithOriginRe","idx","getUrlHostAndProtocol","protocol","host","urlOriginRe","INVALIDATED","missingTilerServiceInfoEmitted","m_registered","m_tiler","tiler","getTiler","GEOJSON_TILER_SERVICE_TYPE","workerTilerUrl","registerIndex","updateIndex","m_processLayersDefault","m_processPointsDefault","m_processLinesDefault","m_processPolygonsDefault","m_layersToProcess","m_layersToIgnore","m_pointsToProcess","m_ignoredPoints","m_linesToProcess","m_linesToIgnore","m_polygonsToProcess","m_polygonsToIgnore","m_kindsToProcess","m_kindsToIgnore","processLayersDefault","processPointsDefault","processLinesDefault","processPolygonsDefault","OmvFilterString","StringMatch","Match","addItem","addItems","layersToProcess","layersToIgnore","pointsToProcess","pointsToIgnore","linesToProcess","linesToIgnore","polygonsToProcess","polygonsToIgnore","kindsToProcess","kindsToIgnore","items","layerName","matchLayer","geometryTypes","geomType","classes","featureClass","matchClass","featureAttribute","geomTypes","featureClasses","OmvGenericFeatureFilter","layerItems","layerItem","matchString","itemsToProcess","itemsToIgnore","defaultResult","filters","hasKindFilter","wantsLayer","wantsPointFeature","wantsLineFeature","wantsPolygonFeature","wantsKind","OmvGenericFeatureModifier","doProcessFeature","featureClassThing","matchItems","matchAttribute","NeverDepth","debugCircleMaterial","debugBlackCircleMaterial","debugBlueCircleMaterial","debugOrangeCircleMaterial","DebugGeometry","zPos","debugGeometry","addObject","priorityOffset","factory","OmvDebugLabelsTile","debugTextPaths","debugTextPathsFull","debugTextPoisFull","debugLineMarkers","tileGeometryCreator","colorMap","indexFilter","centerZ","pointScale","pointLabelIndex","bluePoints","orangePoints","addedTextElements","pointSize","addLabel","offsetXY","labelElement","_isDebug","redPoints","blackPoints","elementIndex","pathIndex","isRedPoint","OmvGeometryType","FeatureModifierId","filterString","Any","StartsWith","EndsWith","VECTOR_TILE_DECODER_SERVICE_TYPE","AuthenticationTypeBearer","method","AuthorizationHeader","AuthenticationTypeTomTomV1","QueryString","AuthenticationTypeAccessToken","OmvRestClient","downloadManager","urlParams","tileUrl","dataUrl","authenticationCode","getActualAuthenticationCode","applyAuthCode","addQueryParams","apiFormat","XYZJson","downloadArrayBuffer","getBearerToken","HereV1","MapboxV4","XYZOMV","XYZMVT","XYZSpace","TomtomV1","authMethod","authenticationMethod","getDefaultAuthMethod","Headers","authType","append","authParams","queryParams","queryString","sep","encodeURIComponent","getDataProvider","missingOmvDecoderServiceInfoEmitted","hereVectorTileBaseUrl","hereVectorTileDefaultOptions","getFullYear","defaultOptions","tileFactory","TileFactory","completedParams","completeDataSourceParameters","roundUpCoordinatesIfNeeded","m_decoderOptions","showMissingTechniques","filterDescription","filterDescr","gatherFeatureAttributes","featureModifiers","featureModifierId","skipShortLabels","enableElevationOverlay","configureDecoder","textureLoader","WEBTILE_LANGUAGE_DICTIONARY","eu","zh","cs","da","nl","en","fi","fr","de","ga","el","he","hi","it","no","fa","pl","ru","si","es","sv","th","tr","uk","ur","vi","HereTileProvider","HERE_COPYRIGHT_INFO","m_ppi","WebTileDataSource","ppiValue","ppi72","m_resolution","resolutionValue","resolution512","m_tileBaseAddress","tileBaseAddress","TILE_BASE_NORMAL","TILE_AERIAL_SATELLITE","mapTileParams","parseBaseUrl","baseHostName","mapId","mapVersion","baseScheme","scheme","getCopyrightRequestParams","m_copyrightProvider","toQuadKey","getImageRequestParams","getRequestHeaders","getTileCopyright","Authorization","gatherCopyrightInfo","setRequestHeaders","fullPath","pathname","maptilePathRegexp","tileType","apikey","appId","appCode","getAuthParams","requestParams","additionalRequestParameters","TILE_AERIAL_HYBRID","TILE_TRAFFIC_NORMAL","HereWebTileDataSource","mapIsoLanguageToWebTile","m_opacity","m_transparent","renderingOptions","WebTileLoader","getTexture","planeMaterial","getBundleScriptUrl","bundleScriptUrl","currentScript","baseScriptUrl","BUNDLE_SCRIPT_BASENAME","getScriptUrl","scriptElement","querySelector","DEFAULT_DECODER_SCRIPT_URL","HARP_GL_BUNDLED_ASSETS_PREFIX","BundledUriResolver","bundleSriptUrl","bundledUriResolver","getActualDecoderScriptUrl","three","decoderScriptName","threeUrl","oldDecoderGetWorkerSet","newScriptUrl","oldTilerGetWorkerSet","installDefaultDecoderUrlHook","mapBundleMain","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__"],"mappings":"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","file":"harp.min.js","sourcesContent":["\"use strict\";\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=index.web.js.map","\"use strict\";\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Utility classes for working with geospatial data.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(require(\"./lib/coordinates/GeoBox\"), exports);\n__exportStar(require(\"./lib/coordinates/GeoBoxExtentLike\"), exports);\n__exportStar(require(\"./lib/coordinates/GeoCoordinatesLike\"), exports);\n__exportStar(require(\"./lib/coordinates/GeoCoordinates\"), exports);\n__exportStar(require(\"./lib/coordinates/GeoPointLike\"), exports);\n__exportStar(require(\"./lib/coordinates/GeoPolygonLike\"), exports);\n__exportStar(require(\"./lib/coordinates/GeoPolygon\"), exports);\n__exportStar(require(\"./lib/coordinates/LatLngLike\"), exports);\n__exportStar(require(\"./lib/projection/EarthConstants\"), exports);\n__exportStar(require(\"./lib/projection/EquirectangularProjection\"), exports);\n__exportStar(require(\"./lib/projection/IdentityProjection\"), exports);\n__exportStar(require(\"./lib/projection/Projection\"), exports);\n__exportStar(require(\"./lib/projection/MercatorProjection\"), exports);\n__exportStar(require(\"./lib/projection/TransverseMercatorProjection\"), exports);\n__exportStar(require(\"./lib/projection/SphereProjection\"), exports);\n__exportStar(require(\"./lib/tiling/FlatTileBoundingBoxGenerator\"), exports);\n__exportStar(require(\"./lib/tiling/HalfQuadTreeSubdivisionScheme\"), exports);\n__exportStar(require(\"./lib/tiling/QuadTreeSubdivisionScheme\"), exports);\n__exportStar(require(\"./lib/tiling/QuadTree\"), exports);\n__exportStar(require(\"./lib/tiling/SubTiles\"), exports);\n__exportStar(require(\"./lib/tiling/SubdivisionScheme\"), exports);\n__exportStar(require(\"./lib/tiling/TileKey\"), exports);\n__exportStar(require(\"./lib/tiling/TileKeyUtils\"), exports);\n__exportStar(require(\"./lib/tiling/TileTreeTraverse\"), exports);\n__exportStar(require(\"./lib/tiling/TilingScheme\"), exports);\n__exportStar(require(\"./lib/tiling/HereTilingScheme\"), exports);\n__exportStar(require(\"./lib/tiling/WebMercatorTilingScheme\"), exports);\n__exportStar(require(\"./lib/tiling/MercatorTilingScheme\"), exports);\n__exportStar(require(\"./lib/tiling/PolarTilingScheme\"), exports);\n__exportStar(require(\"./lib/math/Vector2Like\"), exports);\n__exportStar(require(\"./lib/math/Vector3Like\"), exports);\n__exportStar(require(\"./lib/math/Box3Like\"), exports);\n__exportStar(require(\"./lib/math/OrientedBox3Like\"), exports);\n__exportStar(require(\"./lib/math/MathUtils\"), exports);\n__exportStar(require(\"./lib/math/TransformLike\"), exports);\n__exportStar(require(\"./lib/math/OrientedBox3\"), exports);\n//# sourceMappingURL=index.js.map","!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n","\"use strict\";\n/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Provides utilities: logging and debugging.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n__exportStar(require(\"./index-common\"), exports);\n__exportStar(require(\"./lib/UrlPlatformUtils\"), exports);\n//# sourceMappingURL=index.js.map","// (c) Dean McNamee <dean@gmail.com>, 2012.\n//\n// https://github.com/deanm/css-color-parser-js\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// http://www.w3.org/TR/css3-color/\nvar kCSSColorTable = {\n  \"transparent\": [0,0,0,0], \"aliceblue\": [240,248,255,1],\n  \"antiquewhite\": [250,235,215,1], \"aqua\": [0,255,255,1],\n  \"aquamarine\": [127,255,212,1], \"azure\": [240,255,255,1],\n  \"beige\": [245,245,220,1], \"bisque\": [255,228,196,1],\n  \"black\": [0,0,0,1], \"blanchedalmond\": [255,235,205,1],\n  \"blue\": [0,0,255,1], \"blueviolet\": [138,43,226,1],\n  \"brown\": [165,42,42,1], \"burlywood\": [222,184,135,1],\n  \"cadetblue\": [95,158,160,1], \"chartreuse\": [127,255,0,1],\n  \"chocolate\": [210,105,30,1], \"coral\": [255,127,80,1],\n  \"cornflowerblue\": [100,149,237,1], \"cornsilk\": [255,248,220,1],\n  \"crimson\": [220,20,60,1], \"cyan\": [0,255,255,1],\n  \"darkblue\": [0,0,139,1], \"darkcyan\": [0,139,139,1],\n  \"darkgoldenrod\": [184,134,11,1], \"darkgray\": [169,169,169,1],\n  \"darkgreen\": [0,100,0,1], \"darkgrey\": [169,169,169,1],\n  \"darkkhaki\": [189,183,107,1], \"darkmagenta\": [139,0,139,1],\n  \"darkolivegreen\": [85,107,47,1], \"darkorange\": [255,140,0,1],\n  \"darkorchid\": [153,50,204,1], \"darkred\": [139,0,0,1],\n  \"darksalmon\": [233,150,122,1], \"darkseagreen\": [143,188,143,1],\n  \"darkslateblue\": [72,61,139,1], \"darkslategray\": [47,79,79,1],\n  \"darkslategrey\": [47,79,79,1], \"darkturquoise\": [0,206,209,1],\n  \"darkviolet\": [148,0,211,1], \"deeppink\": [255,20,147,1],\n  \"deepskyblue\": [0,191,255,1], \"dimgray\": [105,105,105,1],\n  \"dimgrey\": [105,105,105,1], \"dodgerblue\": [30,144,255,1],\n  \"firebrick\": [178,34,34,1], \"floralwhite\": [255,250,240,1],\n  \"forestgreen\": [34,139,34,1], \"fuchsia\": [255,0,255,1],\n  \"gainsboro\": [220,220,220,1], \"ghostwhite\": [248,248,255,1],\n  \"gold\": [255,215,0,1], \"goldenrod\": [218,165,32,1],\n  \"gray\": [128,128,128,1], \"green\": [0,128,0,1],\n  \"greenyellow\": [173,255,47,1], \"grey\": [128,128,128,1],\n  \"honeydew\": [240,255,240,1], \"hotpink\": [255,105,180,1],\n  \"indianred\": [205,92,92,1], \"indigo\": [75,0,130,1],\n  \"ivory\": [255,255,240,1], \"khaki\": [240,230,140,1],\n  \"lavender\": [230,230,250,1], \"lavenderblush\": [255,240,245,1],\n  \"lawngreen\": [124,252,0,1], \"lemonchiffon\": [255,250,205,1],\n  \"lightblue\": [173,216,230,1], \"lightcoral\": [240,128,128,1],\n  \"lightcyan\": [224,255,255,1], \"lightgoldenrodyellow\": [250,250,210,1],\n  \"lightgray\": [211,211,211,1], \"lightgreen\": [144,238,144,1],\n  \"lightgrey\": [211,211,211,1], \"lightpink\": [255,182,193,1],\n  \"lightsalmon\": [255,160,122,1], \"lightseagreen\": [32,178,170,1],\n  \"lightskyblue\": [135,206,250,1], \"lightslategray\": [119,136,153,1],\n  \"lightslategrey\": [119,136,153,1], \"lightsteelblue\": [176,196,222,1],\n  \"lightyellow\": [255,255,224,1], \"lime\": [0,255,0,1],\n  \"limegreen\": [50,205,50,1], \"linen\": [250,240,230,1],\n  \"magenta\": [255,0,255,1], \"maroon\": [128,0,0,1],\n  \"mediumaquamarine\": [102,205,170,1], \"mediumblue\": [0,0,205,1],\n  \"mediumorchid\": [186,85,211,1], \"mediumpurple\": [147,112,219,1],\n  \"mediumseagreen\": [60,179,113,1], \"mediumslateblue\": [123,104,238,1],\n  \"mediumspringgreen\": [0,250,154,1], \"mediumturquoise\": [72,209,204,1],\n  \"mediumvioletred\": [199,21,133,1], \"midnightblue\": [25,25,112,1],\n  \"mintcream\": [245,255,250,1], \"mistyrose\": [255,228,225,1],\n  \"moccasin\": [255,228,181,1], \"navajowhite\": [255,222,173,1],\n  \"navy\": [0,0,128,1], \"oldlace\": [253,245,230,1],\n  \"olive\": [128,128,0,1], \"olivedrab\": [107,142,35,1],\n  \"orange\": [255,165,0,1], \"orangered\": [255,69,0,1],\n  \"orchid\": [218,112,214,1], \"palegoldenrod\": [238,232,170,1],\n  \"palegreen\": [152,251,152,1], \"paleturquoise\": [175,238,238,1],\n  \"palevioletred\": [219,112,147,1], \"papayawhip\": [255,239,213,1],\n  \"peachpuff\": [255,218,185,1], \"peru\": [205,133,63,1],\n  \"pink\": [255,192,203,1], \"plum\": [221,160,221,1],\n  \"powderblue\": [176,224,230,1], \"purple\": [128,0,128,1],\n  \"rebeccapurple\": [102,51,153,1],\n  \"red\": [255,0,0,1], \"rosybrown\": [188,143,143,1],\n  \"royalblue\": [65,105,225,1], \"saddlebrown\": [139,69,19,1],\n  \"salmon\": [250,128,114,1], \"sandybrown\": [244,164,96,1],\n  \"seagreen\": [46,139,87,1], \"seashell\": [255,245,238,1],\n  \"sienna\": [160,82,45,1], \"silver\": [192,192,192,1],\n  \"skyblue\": [135,206,235,1], \"slateblue\": [106,90,205,1],\n  \"slategray\": [112,128,144,1], \"slategrey\": [112,128,144,1],\n  \"snow\": [255,250,250,1], \"springgreen\": [0,255,127,1],\n  \"steelblue\": [70,130,180,1], \"tan\": [210,180,140,1],\n  \"teal\": [0,128,128,1], \"thistle\": [216,191,216,1],\n  \"tomato\": [255,99,71,1], \"turquoise\": [64,224,208,1],\n  \"violet\": [238,130,238,1], \"wheat\": [245,222,179,1],\n  \"white\": [255,255,255,1], \"whitesmoke\": [245,245,245,1],\n  \"yellow\": [255,255,0,1], \"yellowgreen\": [154,205,50,1]}\n\nfunction clamp_css_byte(i) {  // Clamp to integer 0 .. 255.\n  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parse_css_int(str) {  // int or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_byte(parseFloat(str) / 100 * 255);\n  return clamp_css_byte(parseInt(str));\n}\n\nfunction parse_css_float(str) {  // float or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_float(parseFloat(str) / 100);\n  return clamp_css_float(parseFloat(str));\n}\n\nfunction css_hue_to_rgb(m1, m2, h) {\n  if (h < 0) h += 1;\n  else if (h > 1) h -= 1;\n\n  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n  if (h * 2 < 1) return m2;\n  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;\n  return m1;\n}\n\nfunction parseCSSColor(css_str) {\n  // Remove all whitespace, not compliant, but should just be more accepting.\n  var str = css_str.replace(/ /g, '').toLowerCase();\n\n  // Color keywords (and transparent) lookup.\n  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.\n\n  // #abc and #abc123 syntax.\n  if (str[0] === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.\n      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n              (iv & 0xf0) | ((iv & 0xf0) >> 4),\n              (iv & 0xf) | ((iv & 0xf) << 4),\n              1];\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.\n      return [(iv & 0xff0000) >> 16,\n              (iv & 0xff00) >> 8,\n              iv & 0xff,\n              1];\n    }\n\n    return null;\n  }\n\n  var op = str.indexOf('('), ep = str.indexOf(')');\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op+1, ep-(op+1)).split(',');\n    var alpha = 1;  // To allow case fallthrough.\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'rgb':\n        if (params.length !== 3) return null;\n        return [parse_css_int(params[0]),\n                parse_css_int(params[1]),\n                parse_css_int(params[2]),\n                alpha];\n      case 'hsla':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'hsl':\n        if (params.length !== 3) return null;\n        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parse_css_float(params[1]);\n        var l = parse_css_float(params[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),\n                alpha];\n      default:\n        return null;\n    }\n  }\n\n  return null;\n}\n\ntry { exports.parseCSSColor = parseCSSColor } catch(e) { }\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/StyleSetEvaluator\";\nexport * from \"./lib/IMeshBuffers\";\nexport * from \"./lib/Outliner\";\nexport * from \"./lib/Expr\";\nexport * from \"./lib/ThreeBufferUtils\";\nexport * from \"./lib/GeoJsonDataType\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Components used for the decoding and styling of data that is used by the Datasources.\n *\n * @remarks\n * The DataSource Protocol package contains components used for the decoding and styling\n * of data that is used by the Datasources.\n * This code is shared between the ui-thread and the web-workers which are\n * used to parallelise the decoding of the data.\n * This module contains interfaces for choosing techniques form the techniques\n * catalog that are applied via the {@link Theme} files to draw geometries on the map canvas.\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/ColorUtils\";\nexport * from \"./lib/Expr\";\nexport * from \"./lib/Techniques\";\nexport * from \"./lib/TechniqueParams\";\nexport * from \"./lib/Theme\";\nexport * from \"./lib/PostEffects\";\nexport * from \"./lib/PropertyValue\";\nexport * from \"./lib/InterpolatedPropertyDefs\";\nexport * from \"./lib/WorkerServiceProtocol\";\nexport * from \"./lib/WorkerTilerProtocol\";\nexport * from \"./lib/WorkerDecoderProtocol\";\nexport * from \"./lib/ITileDecoder\";\nexport * from \"./lib/ITiler\";\nexport * from \"./lib/DecodedTile\";\nexport * from \"./lib/TileInfo\";\nexport * from \"./lib/GeoJsonDataType\";\nexport * from \"./lib/ThemeVisitor\";\nexport * from \"./lib/StringEncodedNumeral\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { RGBA } from \"./RGBA\";\n\nconst SHIFT_TRANSPARENCY: number = 24;\nconst SHIFT_RED: number = 16;\nconst SHIFT_GREEN: number = 8;\nconst SHIFT_BLUE: number = 0;\n\n//    Allow bitwise operations for colors decoding\n\nconst HEX_FULL_CHANNEL: number = 0xff;\nconst HEX_RGB_MASK: number = 0xffffff;\nconst HEX_TRGB_MASK: number = 0xffffffff;\n\nconst tmpColor = new THREE.Color();\n\n/**\n * Utilities to convert RGBA colors encoded in custom number (hex) format to THREE.Color objects.\n *\n * The functions provided allows for conversion from and to our custom number based color format,\n * which contains transparency, red, green and blue color channels in a way that each channel\n * occupies 8 bits of resulting number (color format 0xTTRRGGBB).\n * In order to preserve compatibility with THREE.Color class and its hexadecimal color\n * representation, we do not store __alpha__ channel in encoded color's number, but replace it\n * with __transparency__ channel, which is simply opposite to alpha:\n * ```transparency = 0xFF - alpha```\n * Such channel value is stored on the oldest bits (octet) in the integral color (numeric) value,\n * so it is fully compatible with THREE.Color numerical representation (@see [[THREE.Color.getHex]],\n * [[THREE.Color.setHex]]).\n * See also [[getHexFromRgba]] and [[getRgbaFromHex]] for more info about conversion.\n */\nexport namespace ColorUtils {\n    /**\n     * Encodes RGBA channels in custom number coded format (represented in hex as 0xTTRRGGBB).\n     *\n     * We do not use direct alpha channel mapping to hex in order to preserve compatibility\n     * with THREE.js color format (0xRRGGBB). This is done by encoding transparency\n     * (255 - alpha) instead of alpha on the oldest bits, shifted by [[SHIFT_TRANSPARENCY]].\n     * This way simple 0xRRGGBB color is equal to 0x00RRGGBB without transparency and\n     * color defining transparency (alpha < 255) is always recognizable by the oldest\n     * bit set:\n     * ```typescript\n     * (color >> SHIFT_TRANSPARENCY) !== 0.\n     * ```\n     * @note All input components are floating points in <0, 1> range (inclusively).\n     * @note Although method encodes transparency channel in single number value, it is still\n     * compatible with THREE.js number based color coding (0xRRGGBB), so you may pass this value to\n     * [[THREE.Color]] c-tor, but keep in mind that transparency will be silently ignored.\n     */\n    export function getHexFromRgba(r: number, g: number, b: number, a: number): number {\n        assert(a >= 0 && a <= 1);\n        const t = HEX_FULL_CHANNEL - Math.floor(a * HEX_FULL_CHANNEL);\n        return (\n            (t << SHIFT_TRANSPARENCY) ^\n            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE)\n        );\n    }\n\n    /**\n     * Encodes RGB all color channels in single number with format 0xRRGGBB.\n     *\n     * All input channels should be in <0, 1> range (inclusively).\n     * See also [[getHexFromRgba]] for more information about [[THREE.Color]] compatibility.\n     *\n     * @note This method is fully compatible with THREE.js color encoding, so\n     * you may pass this value directly to THREE.Color c-tor.\n     */\n    export function getHexFromRgb(r: number, g: number, b: number): number {\n        assert(r >= 0 && r <= 1);\n        assert(g >= 0 && g <= 1);\n        assert(b >= 0 && b <= 1);\n        return (\n            ((r * HEX_FULL_CHANNEL) << SHIFT_RED) ^\n            ((g * HEX_FULL_CHANNEL) << SHIFT_GREEN) ^\n            ((b * HEX_FULL_CHANNEL) << SHIFT_BLUE)\n        );\n    }\n\n    /**\n     * Encode and convert HSL value to number coded color format (0xRRGGBB).\n     *\n     * @see getHexFromRgb.\n     * @param h - Hue component value between 0 and 1.\n     * @param s - Saturation value between 0 and 1.\n     * @param l - Lightness channel between 0 and 1.\n     */\n    export function getHexFromHsl(h: number, s: number, l: number): number {\n        assert(h >= 0 && h <= 1);\n        assert(s >= 0 && s <= 1);\n        assert(l >= 0 && l <= 1);\n        return tmpColor.setHSL(h, s, l).getHex();\n    }\n\n    /**\n     * Retrieve RGBA channels separately from number encoded custom color format.\n     *\n     * Provides an easy way for channels extraction (r, g, b, a) from custom number coded color\n     * format.\n     *\n     * @see getHexFromRgba.\n     * @param hex - The number encoded color value (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns r, g, b, a channels in simple object, where each channel value is saved as floating\n     * point from 0 to 1 inclusively.\n     */\n    export function getRgbaFromHex(hex: number, target = new RGBA()): RGBA {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        target.r = ((hex >> SHIFT_RED) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.g = ((hex >> SHIFT_GREEN) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.b = ((hex >> SHIFT_BLUE) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL;\n        target.a =\n            (HEX_FULL_CHANNEL - ((hex >> SHIFT_TRANSPARENCY) & HEX_FULL_CHANNEL)) /\n            HEX_FULL_CHANNEL;\n        return target;\n    }\n\n    /**\n     * Determines if number encoded color contains alpha (opacity) defined and different then 255.\n     *\n     * @param hex - The number encoded color (0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns True if color has transparency defined.\n     */\n    export function hasAlphaInHex(hex: number): boolean {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return hex >> SHIFT_TRANSPARENCY !== 0;\n    }\n\n    /**\n     * Retrieves alpha color channel from hex encoded color value.\n     *\n     * @see getHexFromRgba.\n     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns The floating point alpha component in <0, 1> range.\n     */\n    export function getAlphaFromHex(hex: number): number {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return (\n            ((HEX_FULL_CHANNEL - (hex >> SHIFT_TRANSPARENCY)) & HEX_FULL_CHANNEL) / HEX_FULL_CHANNEL\n        );\n    }\n\n    /**\n     * Remove transparency info from the number coded color, makes it compatible with external libs.\n     *\n     * @see getAlphaFromHex.\n     * @param hex - The number encoded color value (representable as 0xRRGGBB or 0xTTRRGGBB in hex).\n     * @returns number coded color value representable as 0xRRGGBB in hex.\n     */\n    export function removeAlphaFromHex(hex: number): number {\n        assert((hex & ~HEX_TRGB_MASK) === 0, \"Wrong hex format\");\n        return hex & HEX_RGB_MASK;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    equirectangularProjection,\n    mercatorProjection,\n    normalizedEquirectangularProjection,\n    OrientedBox3,\n    Projection,\n    sphereProjection,\n    Vector3Like,\n    webMercatorProjection\n} from \"@here/harp-geoutils\";\n\nimport { Env } from \"./Expr\";\nimport { AttrEvaluationContext, evaluateTechniqueAttr } from \"./TechniqueAttr\";\nimport {\n    IndexedTechnique,\n    isLineMarkerTechnique,\n    isPoiTechnique,\n    isTextTechnique,\n    Technique\n} from \"./Techniques\";\nimport { TileInfo } from \"./TileInfo\";\n\n/**\n * This object has geometry data in the form of geometries buffers ready to be used by WebGL.\n * These geometries are not `three.js` objects. They are pure data stored as `ArrayBuffer`s and\n * metadata describing these buffers.\n */\nexport interface DecodedTile {\n    techniques: IndexedTechnique[];\n    geometries: Geometry[];\n    pathGeometries?: PathGeometry[];\n    textPathGeometries?: TextPathGeometry[];\n    textGeometries?: TextGeometry[]; // ### deprecate\n    poiGeometries?: PoiGeometry[];\n    tileInfo?: TileInfo;\n    decodeTime?: number; // time used to decode (in ms)\n\n    /**\n     * The default bounding box in [[Tile]] is based on the geo box of the tile.\n     * For data-sources that have 3d data this is not sufficient so the data-source can provide a\n     * more accurate bounding box once the data is decoded.\n     */\n    boundingBox?: OrientedBox3;\n\n    /**\n     * Data sources not defining a bounding box may define alternatively a maximum geometry height\n     * in meters. The bounding box of the resulting tile will be extended to encompass this height.\n     */\n    maxGeometryHeight?: number;\n\n    /**\n     * Data sources not defining a bounding box may define alternatively a minimum geometry height\n     * in meters. The bounding box of the resulting tile will be extended to encompass this height.\n     */\n    minGeometryHeight?: number;\n\n    /**\n     * Tile data Copyright holder identifiers.\n     *\n     * `id`s should be unique. It is recommended to build them from unique identifiers like\n     * registered domain names.\n     *\n     * @see [[CopyrightInfo]]\n     */\n    copyrightHolderIds?: string[];\n\n    /**\n     * List of {@link @here/harp-geoutils#TileKey}s stored as mortonCodes representing\n     * {@link @here/harp-mapview#Tile}s that have geometry covering this `Tile`.\n     */\n    dependencies?: number[];\n}\n\n/**\n * This object keeps the path of the geometry. Space of the path depends on the\n * use case, so could be either world or local tile space.\n */\nexport interface PathGeometry {\n    path: Vector3Like[];\n}\n\n/**\n * Attributes corresponding to some decoded geometry. It may be either a map\n * of multiple attributes or just a string with the geometry's feature id (id numbers are\n * deprecated).\n */\nexport type AttributeMap = {} | string | number;\n\n/**\n * This object keeps textual data together with metadata to place it on the map.\n */\nexport interface TextPathGeometry {\n    path: number[];\n    pathLengthSqr: number;\n    text: string;\n    technique: number;\n    objInfos?: AttributeMap;\n}\n\n/**\n * Returns an array with the data type specified as parameter.\n *\n * @param attr - specifies which type of data is being stored in the array\n */\nexport function getArrayConstructor(attr: BufferElementType) {\n    switch (attr) {\n        case \"float\":\n            return Float32Array;\n        case \"uint8\":\n            return Uint8Array;\n        case \"uint16\":\n            return Uint16Array;\n        case \"uint32\":\n            return Uint32Array;\n        case \"int8\":\n            return Int8Array;\n        case \"int16\":\n            return Int16Array;\n        case \"int32\":\n            return Int32Array;\n    }\n}\n\n/**\n * Structured clone compliant WebGL interleaved buffer with its metadata attached.\n */\nexport interface InterleavedBufferAttribute {\n    buffer: ArrayBufferLike;\n    stride: number;\n    type: BufferElementType;\n    attributes: Array<{\n        name: string;\n        itemSize: number;\n        offset: number;\n    }>;\n}\n\n/**\n * Geometry types supported by [[Geometry]] objects.\n */\nexport enum GeometryType {\n    Unspecified = 0,\n    Point,\n    Line,\n    SolidLine,\n    Text,\n    TextPath,\n    ExtrudedLine,\n    Polygon,\n    ExtrudedPolygon,\n    Object3D,\n    Other = 1000\n}\n\n/**\n * Structured clone compliant version of a `three.js` geometry object, consisting of buffers with\n * metadata for map features and objects for example roads, trees or parks.\n */\nexport interface Geometry {\n    type: GeometryType;\n    vertexAttributes?: BufferAttribute[];\n    interleavedVertexAttributes?: InterleavedBufferAttribute[];\n    index?: BufferAttribute;\n    edgeIndex?: BufferAttribute;\n    groups: Group[];\n    uuid?: string;\n\n    /**\n     * Optional sorted list of feature start indices. The indices point into the index attribute.\n     * Feature i starts at featureStarts[i] and ends at featureStarts[i+1]-1, except for the last\n     * feature, which ends at index[index.length-1].\n     */\n    featureStarts?: number[];\n\n    /**\n     * Optional sorted list of feature start indices for the outline geometry.\n     * Equivalent to {@link featureStarts} but pointing into the edgeIndex attribute.\n     */\n    edgeFeatureStarts?: number[];\n\n    /**\n     * Optional array of objects. It can be used to pass user data from the geometry to the mesh.\n     */\n    objInfos?: AttributeMap[];\n\n    /**\n     * Optional [[Array]] of [[Attachment]]s.\n     */\n    attachments?: Attachment[];\n}\n\n/**\n * Attachments together with [[Geometry]] define the meshes and the objects\n * of a [[Scene]].\n */\nexport interface Attachment {\n    /**\n     * The unique uuid of this [[Attachment]].\n     */\n    uuid?: string;\n\n    /**\n     * The name of this [[Attachment]].\n     */\n    name?: string;\n\n    /**\n     * The index [[BufferAttribute]]. If not provided the index\n     * buffer of the [[Geometry]] will be used.\n     */\n    index?: BufferAttribute;\n\n    /**\n     * Optional additional buffer index used to create an edge object.\n     */\n    edgeIndex?: BufferAttribute;\n\n    /**\n     * The draw [[Group]]]s of this [[Attachment]].\n     */\n    groups: Group[];\n}\n\n/**\n * The data stored in Buffers' elements can be of the following elementary types: float, signed or\n * unsigned integers (8-bit, 16-bit or 32-bit long).\n */\nexport type BufferElementType =\n    | \"float\"\n    | \"uint8\"\n    | \"uint16\"\n    | \"uint32\"\n    | \"int8\"\n    | \"int16\"\n    | \"int32\";\n\n/**\n * Structured clone compliant WebGL buffer and its metadata.\n */\nexport interface BufferAttribute {\n    name: string;\n    buffer: ArrayBufferLike;\n    type: BufferElementType;\n    itemCount: number;\n    normalized?: boolean;\n}\n\n/**\n * Structured clone compliant version of a `three.js` geometry object with text to be rendered.\n * It is composed of buffers with metadata for text objects.\n */\nexport interface TextGeometry {\n    positions: BufferAttribute;\n    texts: number[];\n    technique?: number;\n    stringCatalog: Array<string | undefined>;\n    objInfos?: AttributeMap[];\n}\n\n/**\n * Structured clone compliant version of a `three.js` geometry object with points of interest (POIs)\n * to be rendered. It is composed of buffers with metadata for POI objects.\n */\nexport interface PoiGeometry extends TextGeometry {\n    /**\n     * Names of the image texture or the name of the POI as indices into the array `stringCatalog`.\n     */\n    imageTextures?: number[];\n    // Angle in degrees from north clockwise specifying the directions the icons can be shifted.\n    offsetDirections?: number[];\n}\n\n/**\n * Structured clone compliant WebGL group object and its metadata.\n * Its purpose is to make working with groups of objects easier.\n */\nexport interface Group {\n    start: number;\n    count: number;\n    technique: number;\n\n    /**\n     * Contains tile offsets if its [[Geometry]] has been created.\n     */\n    createdOffsets?: number[];\n}\n\n/**\n * Returns the projection object specified in the parameter.\n *\n * @param projectionName - string describing projection to be used\n */\nexport function getProjection(projectionName: string): Projection | never {\n    switch (projectionName) {\n        case \"mercator\":\n            return mercatorProjection;\n        case \"webMercator\":\n            return webMercatorProjection;\n        case \"sphere\":\n            return sphereProjection;\n        case \"normalizedEquirectangular\":\n            return normalizedEquirectangularProjection;\n        case \"equirectangular\":\n            return equirectangularProjection;\n        default:\n            throw new Error(`Unknown projection ${projectionName}`);\n    } // switch\n}\n\n/**\n * String with the projection's name.\n *\n * @param projection - `Projection` object containing the name of the projection to retrieve\n */\nexport function getProjectionName(projection: Projection): string | never {\n    if (projection === mercatorProjection) {\n        return \"mercator\";\n    } else if (projection === webMercatorProjection) {\n        return \"webMercator\";\n    } else if (projection === sphereProjection) {\n        return \"sphere\";\n    } else if (projection === normalizedEquirectangularProjection) {\n        return \"normalizedEquirectangular\";\n    } else if (projection === equirectangularProjection) {\n        return \"equirectangular\";\n    }\n    throw new Error(\"Unknown projection\");\n}\n\n/**\n * @returns Feature id from the provided attribute map.\n * @internal\n */\nexport function getFeatureId(attributeMap: AttributeMap | undefined): string | number {\n    if (attributeMap === undefined) {\n        return 0;\n    }\n\n    if (typeof attributeMap === \"string\" || typeof attributeMap === \"number\") {\n        return attributeMap;\n    } else if (attributeMap.hasOwnProperty(\"$id\")) {\n        const id = (attributeMap as any).$id;\n\n        if (typeof id === \"string\" || typeof id === \"number\") {\n            return id;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Determine the name of (OMV) feature. It implements the special handling required\n * to determine the text content of a feature from its tags, which are passed in as the `env`.\n *\n * @param env - Environment containing the tags from the (OMV) feature.\n * @param useAbbreviation - `true` to use the abbreviation if available.\n * @param useIsoCode - `true` to use the tag \"iso_code\".\n * @param languages - List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n *                  as the text of the string. Order reflects priority.\n */\nexport function getFeatureName(\n    env: Env,\n    basePropName: string | undefined,\n    useAbbreviation?: boolean,\n    useIsoCode?: boolean,\n    languages?: string[]\n): string | undefined {\n    let name;\n    if (basePropName === undefined) {\n        basePropName = \"name\";\n    }\n    if (useAbbreviation) {\n        const abbreviation = env.lookup(`${basePropName}:short`);\n        if (typeof abbreviation === \"string\" && abbreviation.length > 0) {\n            return abbreviation;\n        }\n    }\n    if (useIsoCode) {\n        const isoCode = env.lookup(`iso_code`);\n        if (typeof isoCode === \"string\" && isoCode.length > 0) {\n            return isoCode;\n        }\n    }\n    if (languages !== undefined) {\n        for (const lang of languages) {\n            name = env.lookup(`${basePropName}:${lang}`) ?? env.lookup(`${basePropName}_${lang}`);\n            if (typeof name === \"string\" && name.length > 0) {\n                return name;\n            }\n        }\n    }\n    name = env.lookup(basePropName);\n    if (typeof name === \"string\") {\n        return name;\n    }\n    return undefined;\n}\n\n/**\n * Determine the text string of the map feature. It implements the special handling required\n * to determine the text content of a feature from its tags, which are passed in as the `env`.\n *\n * @param feature - Feature, including properties from the (OMV) feature.\n * @param technique - technique defining how text should be created from feature\n * @param languages - List of languages to use, for example: Specify \"en\" to use the tag \"name_en\"\n *                  as the text of the string. Order reflects priority.\n */\nexport function getFeatureText(\n    context: Env | AttrEvaluationContext,\n    technique: Technique,\n    languages?: string[]\n): string | undefined {\n    let useAbbreviation: boolean | undefined;\n    let useIsoCode: boolean | undefined;\n    const env = context instanceof Env ? context : context.env;\n    let propName: string = \"name\";\n    if (\n        isTextTechnique(technique) ||\n        isPoiTechnique(technique) ||\n        isLineMarkerTechnique(technique)\n    ) {\n        if (technique.text !== undefined) {\n            return evaluateTechniqueAttr(context, technique.text);\n        }\n        if (technique.label !== undefined) {\n            propName = evaluateTechniqueAttr(context, technique.label)!;\n            if (typeof propName !== \"string\") {\n                return undefined;\n            }\n        }\n        useAbbreviation = technique.useAbbreviation;\n        useIsoCode = technique.useIsoCode;\n    }\n\n    return getFeatureName(env, propName, useAbbreviation, useIsoCode, languages);\n}\n\n/**\n * Determine whether to scale heights by the projection scale factor for geometry\n * using the given technique.\n * @remarks Unless explicitly defined, the scale factor to convert meters to world space units\n * won't be applied if the tile's level is less than a fixed storage level.\n * @param context - Context for evaluation of technique attributes.\n * @param technique - Technique to be evaluated.\n * @param tileLevel - The level of the tile where the geometry is stored.\n * @returns `true` if height must be scaled, `false` otherwise.\n */\nexport function scaleHeight(\n    context: Env | AttrEvaluationContext,\n    technique: Technique,\n    tileLevel: number\n): boolean {\n    const SCALED_HEIGHT_MIN_STORAGE_LEVEL = 12;\n    const useConstantHeight = evaluateTechniqueAttr(\n        context,\n        technique.constantHeight,\n        tileLevel < SCALED_HEIGHT_MIN_STORAGE_LEVEL\n    );\n    return !useConstantHeight;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * The type representing the value of a property.\n */\nexport type Value = null | boolean | number | string | object;\n\n/**\n * An interface defining a collection of named properties.\n *\n * @example\n * ```typescript\n * const properties: ValueMap = {\n *    $id: 123,\n *    color: \"rgba(255, 0, 0, 1)\"\n * }\n * ```\n */\nexport interface ValueMap {\n    [name: string]: Value;\n}\n\n/**\n * A class used to lookup properties by name.\n *\n * @remarks\n * Concrete implementation of `Env` like {@link MapEnv} are used\n * to resolve the property names used in {@link Expr | style expressions}.\n *\n * @example\n * ```typescript\n * const env = new MapEnv({\n *     kind: \"landuse\",\n * });\n *\n * const expr = Expr.fromJson([\"get\", \"kind\"]);\n *\n * const value = expr.evaluate(env);\n *\n * console.log(`kind is '${value}`);\n * ```\n */\nexport class Env {\n    /**\n     * Returns `true` if the given object is an instance of {@link Env}.\n     *\n     * @param object - The object to test.\n     */\n    static isEnv(object: any): object is Env {\n        return object instanceof Env;\n    }\n\n    /**\n     * Returns property in {@link Env} by name.\n     *\n     * @param name - Name of property.\n     */\n    lookup(name: string): Value | undefined {\n        return undefined;\n    }\n\n    /**\n     * Return an object containing all properties of this environment. (Here: empty object).\n     */\n    unmap(): ValueMap {\n        return {};\n    }\n}\n\n/**\n * `MapEnv` is a concrete implementation of {@link Env} that\n * creates a lookup environment from a set of properties.\n *\n * @example\n * ```typescript\n * const baseEnv = new MapEnv({\n *     $zoom: 14,\n * });\n *\n * // extends baseEnv with a the new binding (kind, \"landuse\").\n * const env = new MapEnv({ kind: \"landuse\" }, baseEnv);\n *\n * const zoom = env.lookup(\"$zoom\"); // zoom is 14\n * const kind = env.lookup(\"kind\"); // kind is is \"landuse\"\n *\n * const expr = Expr.fromJson([\"get\", \"kind\"]);\n * const value = expr.evaluate(env); // value is \"landuse\"\n * ```\n */\nexport class MapEnv extends Env {\n    constructor(readonly entries: ValueMap, private readonly parent?: Env) {\n        super();\n    }\n\n    /**\n     * Returns property in {@link Env} by name.\n     *\n     * @param name - Name of property.\n     * @override\n     */\n    lookup(name: string): Value | undefined {\n        if (this.entries.hasOwnProperty(name)) {\n            const value = this.entries[name];\n            if (value !== undefined) {\n                return value;\n            }\n        }\n        return this.parent ? this.parent.lookup(name) : undefined;\n    }\n\n    /**\n     * Return an object containing all properties of this environment, takes care of the parent\n     * object.\n     * @override\n     */\n    unmap(): ValueMap {\n        const obj: any = this.parent ? this.parent.unmap() : {};\n        for (const key in this.entries) {\n            if (this.entries.hasOwnProperty(key)) {\n                obj[key] = this.entries[key];\n            }\n        }\n        return obj;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { Env, Value } from \"./Env\";\nimport { ExprEvaluator, ExprEvaluatorContext, OperatorDescriptor } from \"./ExprEvaluator\";\nimport { ExprInstantiator, InstantiationContext } from \"./ExprInstantiator\";\nimport { ExprParser } from \"./ExprParser\";\nimport { ExprPool } from \"./ExprPool\";\nimport {\n    interpolatedPropertyDefinitionToJsonExpr,\n    isInterpolatedPropertyDefinition\n} from \"./InterpolatedPropertyDefs\";\nimport { Pixels } from \"./Pixels\";\nimport { RGBA } from \"./RGBA\";\nimport { Definition, Definitions, getDefinitionValue } from \"./Theme\";\n\nexport * from \"./Env\";\n\nconst exprEvaluator = new ExprEvaluator();\n\nconst exprInstantiator = new ExprInstantiator();\n\n/**\n * A visitor for {@link Expr} nodes.\n * @internal\n */\nexport interface ExprVisitor<Result, Context> {\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: Context): Result;\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: Context): Result;\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: Context): Result;\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: Context): Result;\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: Context): Result;\n    visitVarExpr(expr: VarExpr, context: Context): Result;\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: Context): Result;\n    visitCallExpr(expr: CallExpr, context: Context): Result;\n    visitLookupExpr(expr: LookupExpr, context: Context): Result;\n    visitMatchExpr(expr: MatchExpr, context: Context): Result;\n    visitCaseExpr(expr: CaseExpr, context: Context): Result;\n    visitStepExpr(expr: StepExpr, context: Context): Result;\n    visitInterpolateExpr(expr: InterpolateExpr, context: Context): Result;\n}\n\n/**\n * The dependencies of an {@link Expr}.\n * @internal\n */\nexport class ExprDependencies {\n    /**\n     * The properties needed to evaluate the {@link Expr}.\n     */\n    readonly properties = new Set<string>();\n\n    /**\n     * `true` if the expression depends on the feature state.\n     */\n    featureState?: boolean;\n\n    /**\n     * `true` if this expression cannot be cached.\n     */\n    volatile?: boolean;\n}\n\nclass ComputeExprDependencies implements ExprVisitor<void, ExprDependencies> {\n    static instance = new ComputeExprDependencies();\n\n    /**\n     * Gets the dependencies of an {@link Expr}.\n     *\n     * @param expr - The {@link Expr} to process.\n     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param dependencies - The output [[Set]] of dependency names.\n     */\n    static of(expr: Expr) {\n        const dependencies = new ExprDependencies();\n        expr.accept(this.instance, dependencies);\n        return dependencies;\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: ExprDependencies): void {\n        // nothing to do\n    }\n\n    visitVarExpr(expr: VarExpr, context: ExprDependencies): void {\n        context.properties.add(expr.name);\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: ExprDependencies): void {\n        context.properties.add(expr.name);\n    }\n\n    visitCallExpr(expr: CallExpr, context: ExprDependencies): void {\n        expr.args.forEach(childExpr => childExpr.accept(this, context));\n\n        switch (expr.op) {\n            case \"dynamic-properties\":\n                context.volatile = true;\n                break;\n            case \"feature-state\":\n                context.featureState = true;\n                context.properties.add(\"$state\");\n                context.properties.add(\"$id\");\n                break;\n            case \"id\":\n                context.properties.add(\"$id\");\n                break;\n            case \"zoom\":\n            case \"world-ppi-scale\":\n            case \"world-discrete-ppi-scale\":\n                context.properties.add(\"$zoom\");\n                break;\n            case \"geometry-type\":\n                context.properties.add(\"$geometryType\");\n                break;\n            default:\n                break;\n        }\n    }\n\n    visitLookupExpr(expr: LookupExpr, context: ExprDependencies): void {\n        // Same behaviour as call expressions.\n        return this.visitCallExpr(expr, context);\n    }\n\n    visitMatchExpr(expr: MatchExpr, context: ExprDependencies): void {\n        expr.value.accept(this, context);\n        expr.branches.forEach(([_, branch]) => branch.accept(this, context));\n        expr.fallback.accept(this, context);\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: ExprDependencies): void {\n        expr.branches.forEach(([condition, branch]) => {\n            condition.accept(this, context);\n            branch.accept(this, context);\n        });\n        expr.fallback.accept(this, context);\n    }\n\n    visitStepExpr(expr: StepExpr, context: ExprDependencies): void {\n        expr.input.accept(this, context);\n        expr.defaultValue.accept(this, context);\n        expr.stops.forEach(([_, value]) => value.accept(this, context));\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: ExprDependencies): void {\n        expr.input.accept(this, context);\n        expr.stops.forEach(([_, value]) => value.accept(this, context));\n    }\n}\n\n/**\n * A type represeting JSON values.\n */\nexport type JsonValue = null | boolean | number | string | JsonObject | JsonArray;\n\n/**\n * A type representing JSON arrays.\n */\nexport interface JsonArray extends Array<JsonValue> {}\n\n/**\n * A type representing JSON objects.\n */\nexport interface JsonObject {\n    [name: string]: JsonValue;\n}\n\n/**\n * The JSON representation of an {@link Expr} object.\n */\nexport type JsonExpr = JsonArray;\n\nexport function isJsonExpr(v: any): v is JsonExpr {\n    return Array.isArray(v) && v.length > 0 && typeof v[0] === \"string\";\n}\n\n/**\n * Internal state needed by {@link Expr.fromJSON} to resolve `\"ref\"` expressions.\n */\ninterface ReferenceResolverState {\n    definitions: Definitions;\n    lockedNames: Set<string>;\n    cache: Map<string, Expr>;\n}\n\n/**\n * The evaluation scope of an {@link Expr}.\n * @internal\n */\nexport enum ExprScope {\n    /**\n     * The scope of an {@link Expr} used as value of an attribute.\n     */\n    Value,\n\n    /**\n     * The scope of an {@link Expr} used in a [[Technique]] `when` condition.\n     */\n    Condition,\n\n    /**\n     * The scope of an {@link Expr} used as dynamic property attribute value.\n     */\n    Dynamic\n}\n\n/**\n * Abstract class representing the\n * {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md | style expressions}\n * used in {@link Theme}.\n */\nexport abstract class Expr {\n    /**\n     * Tests of given value is an {@link Expr}.\n     *\n     * @param value - The object to test.\n     */\n    static isExpr(value: any): value is Expr {\n        return value instanceof Expr;\n    }\n\n    /**\n     * Creates an expression from the given `code`.\n     *\n     * @param code - The code to parse.\n     * @returns The parsed {@link Expr}.\n     * @deprecated `string` encoded expression are deprecated. Use {@link Expr.fromJSON} instead.\n     */\n    static parse(code: string): Expr | never {\n        const parser = new ExprParser(code);\n        const expr = parser.parse();\n        return expr;\n    }\n\n    /**\n     * Creates a style expression from JSON.\n     *\n     * @remarks\n     * The optional set of {@link Theme.definitions | definitions} is used\n     * to resolve the {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md#ref | ref expressions}.\n     *\n     * @param json - JSON object representing the expression to parse.\n     * @param definitions - Optional set of definitions used to expand references.\n     * @param definitionExprCache - Optional cache of `Expr` instances\n     *\n     * @example\n     * ```typescript\n     * const expr = Expr.fromJSON([\"all\",\n     *     [\"==\", [\"geometry-type\"], \"LineString\"],\n     *     [\"has\", \"text\"]\n     * ]);\n     * ```\n     */\n    static fromJSON(\n        json: JsonValue,\n        definitions?: Definitions,\n        definitionExprCache?: Map<string, Expr>\n    ) {\n        const referenceResolverState: ReferenceResolverState | undefined =\n            definitions !== undefined\n                ? {\n                      definitions,\n                      lockedNames: new Set(),\n                      cache: definitionExprCache ?? new Map<string, Expr>()\n                  }\n                : undefined;\n\n        return parseNode(json, referenceResolverState);\n    }\n\n    private m_dependencies?: ExprDependencies;\n    private m_isDynamic?: boolean;\n\n    /**\n     * Evaluate an expression returning a {@link Value} object.\n     *\n     * @param env - The {@link Env} used to lookup symbols.\n     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].\n     * @param cache - A cache of previously computed results.\n     */\n    evaluate(\n        env: Env,\n        scope: ExprScope = ExprScope.Value,\n        cache?: Map<Expr, Value>\n    ): Value | never {\n        return this.accept(\n            exprEvaluator,\n            new ExprEvaluatorContext(exprEvaluator, env, scope, cache)\n        );\n    }\n\n    /**\n     * Instantiates this {@link Expr}.\n     *\n     * @remarks\n     * references to the `get` and `has` operator using the given instantiation context.\n     *\n     * @param context - The [[InstantationContext]] used to resolve names.\n     */\n    instantiate(context: InstantiationContext): Expr {\n        return this.accept(exprInstantiator, context);\n    }\n\n    /**\n     * Gets the dependencies of this {@link Expr}.\n     */\n    dependencies(): ExprDependencies {\n        if (!this.m_dependencies) {\n            this.m_dependencies = ComputeExprDependencies.of(this);\n        }\n        return this.m_dependencies;\n    }\n\n    /**\n     * Create a unique object that is structurally equivalent to this {@link Expr}.\n     *\n     * @param pool - The [[ExprPool]] used to create a unique\n     * equivalent object of this {@link Expr}.\n     */\n    intern(pool: ExprPool): Expr {\n        return pool.add(this);\n    }\n\n    toJSON(): JsonValue {\n        return new ExprSerializer().serialize(this);\n    }\n\n    /**\n     * Returns `true` if a dynamic execution context is required to evaluate this {@link Expr}.\n     */\n    isDynamic(): boolean {\n        if (this.m_isDynamic === undefined) {\n            this.m_isDynamic = this.exprIsDynamic();\n        }\n        return this.m_isDynamic;\n    }\n\n    /**\n     * Visits this expression.\n     *\n     * @param visitor The visitor used to visit the expression.\n     * @param context The context passed to the vistor.\n     */\n    abstract accept<Result, Context>(\n        visitor: ExprVisitor<Result, Context>,\n        context: Context\n    ): Result;\n\n    /**\n     * Update the dynamic state of this {@link Expr}.\n     *\n     * `exprIsDynamic` must never be called directly.\n     * @internal\n     */\n    protected abstract exprIsDynamic(): boolean;\n}\n\n/**\n * @internal\n */\nexport type RelationalOp = \"<\" | \">\" | \"<=\" | \">=\";\n\n/**\n * @internal\n */\nexport type EqualityOp = \"~=\" | \"^=\" | \"$=\" | \"==\" | \"!=\";\n\n/**\n * @internal\n */\nexport type BinaryOp = RelationalOp | EqualityOp;\n\n/**\n * A node representing a `get` expression.\n * @internal\n */\nexport class VarExpr extends Expr {\n    constructor(readonly name: string) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitVarExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * A node representing a `literal` expression.\n * @internal\n */\nexport abstract class LiteralExpr extends Expr {\n    /**\n     * Create a [[LiteralExpr]] from the given value.\n     *\n     * @param value - A constant value.\n     */\n    static fromValue(value: Value): Expr {\n        switch (typeof value) {\n            case \"boolean\":\n                return new BooleanLiteralExpr(value);\n            case \"number\":\n                return new NumberLiteralExpr(value);\n            case \"string\":\n                return new StringLiteralExpr(value);\n            case \"object\":\n                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);\n            default:\n                throw new Error(`failed to create a literal from '${value}'`);\n        } // switch\n    }\n\n    abstract get value(): Value;\n\n    /** @override */\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * Null literal expression.\n * @internal\n */\nexport class NullLiteralExpr extends LiteralExpr {\n    static instance = new NullLiteralExpr();\n    /** @override */\n    readonly value: Value = null;\n\n    protected constructor() {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitNullLiteralExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * Boolean literal expression.\n * @internal\n */\nexport class BooleanLiteralExpr extends LiteralExpr {\n    constructor(readonly value: boolean) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitBooleanLiteralExpr(this, context);\n    }\n}\n\n/**\n * Number literal expression.\n * @internal\n */\nexport class NumberLiteralExpr extends LiteralExpr {\n    constructor(readonly value: number) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitNumberLiteralExpr(this, context);\n    }\n}\n\n/**\n * String literal expression.\n * @internal\n */\nexport class StringLiteralExpr extends LiteralExpr {\n    private m_promotedValue?: RGBA | Pixels | null;\n\n    constructor(readonly value: string) {\n        super();\n    }\n\n    /**\n     * Returns the value of parsing this string as [[RGBA]] or [[Pixels]] constant.\n     */\n    get promotedValue(): RGBA | Pixels | undefined {\n        if (this.m_promotedValue === undefined) {\n            this.m_promotedValue = RGBA.parse(this.value) ?? Pixels.parse(this.value) ?? null;\n        }\n        return this.m_promotedValue ?? undefined;\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitStringLiteralExpr(this, context);\n    }\n}\n\n/**\n * Object literal expression.\n * @internal\n */\nexport class ObjectLiteralExpr extends LiteralExpr {\n    constructor(readonly value: object) {\n        super();\n    }\n\n    get isArrayLiteral() {\n        return Array.isArray(this.value);\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitObjectLiteralExpr(this, context);\n    }\n}\n\n/**\n * A node reperesenting a `has` expression.\n * @internal\n */\nexport class HasAttributeExpr extends Expr {\n    constructor(readonly name: string) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitHasAttributeExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return false;\n    }\n}\n\n/**\n * A node representing a `call` expression.\n * @internal\n */\nexport class CallExpr extends Expr {\n    descriptor?: OperatorDescriptor;\n\n    constructor(readonly op: string, readonly args: Expr[]) {\n        super();\n    }\n\n    /**\n     * Returns the child nodes of this {@link Expr}.\n     *\n     * @deprecated Use {@link CallExpr.args} instead.\n     */\n    get children() {\n        return this.args;\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitCallExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        const descriptor = this.descriptor ?? ExprEvaluator.getOperator(this.op);\n\n        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {\n            return true;\n        }\n\n        return this.args.some(e => e.isDynamic());\n    }\n}\n\n/**\n * A `lookup` expression is a call expression using the `lookup` operator. Then only difference is\n * that the lookup table definition (first argument) is cached as a map for fast search\n * (see {@link ExprEvaluator.visitLookupExpr}).\n * @internal\n */\n\nexport class LookupExpr extends CallExpr {\n    /**\n     * Creates a lookup expression from a {@link JsonArray}.\n     * @param node The {@link JsonArray} to parse.\n     * @param referenceResolverState Used to resolve references to definitions.\n     * @returns A LookupExpr instance.\n     */\n    static parseArray(node: JsonArray, referenceResolverState?: ReferenceResolverState): Expr {\n        const lookupTableNode = node[1];\n        if (lookupTableNode === undefined) {\n            throw new Error(\"missing lookup table in 'lookup' expression\");\n        }\n\n        const lookupTableExpr = parseNode(lookupTableNode, referenceResolverState);\n        if (!Array.isArray(lookupTableNode) || !(lookupTableExpr instanceof ObjectLiteralExpr)) {\n            throw new Error(\n                `Invalid lookup table expression for operator 'lookup'. It must be a literal or a ref to one.`\n            );\n        }\n        const lookupTable = lookupTableExpr.value;\n        if (!Array.isArray(lookupTable)) {\n            throw new Error(\n                `Invalid lookup table type (${typeof lookupTable}) for operator 'lookup'`\n            );\n        }\n\n        // Skip the operator name and the lookup table and parse the rest of the arguments. Then add\n        // the lookup table expr as first argument.\n        const args = node.slice(2).map(childExpr => parseNode(childExpr, referenceResolverState));\n        args.unshift(lookupTableExpr);\n\n        return new LookupExpr(args);\n    }\n\n    /**\n     * Constructs a LookupExpr instance.\n     * @param args Arguments of the lookup expression. At least an argument for the lookup table.\n     */\n    constructor(readonly args: Expr[]) {\n        super(\"lookup\", args);\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitLookupExpr(this, context);\n    }\n}\n\n/**\n * The labels of a {@link MatchExpr} expression.\n * @internal\n */\nexport type MatchLabel = number | string | number[] | string[];\n\n/**\n * A node representing a `match` expression.\n * @internal\n */\nexport class MatchExpr extends Expr {\n    /**\n     * Tests if the given JSON node is a valid label for the `\"match\"` operator.\n     *\n     * @param node - A JSON value.\n     */\n    static isValidMatchLabel(node: JsonValue): node is MatchLabel {\n        switch (typeof node) {\n            case \"number\":\n            case \"string\":\n                return true;\n            case \"object\":\n                if (!Array.isArray(node) || node.length === 0) {\n                    return false;\n                }\n                const elementTy = typeof node[0];\n                if (elementTy === \"number\" || elementTy === \"string\") {\n                    return node.every(t => typeof t === elementTy);\n                }\n                return false;\n            default:\n                return false;\n        } // switch\n    }\n\n    constructor(\n        readonly value: Expr,\n        readonly branches: Array<[MatchLabel, Expr]>,\n        readonly fallback: Expr\n    ) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitMatchExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return (\n            this.value.isDynamic() ||\n            this.branches.some(([_, branch]) => branch.isDynamic()) ||\n            this.fallback.isDynamic()\n        );\n    }\n}\n\n/**\n * A node representing a `case` expression.\n * @internal\n */\nexport class CaseExpr extends Expr {\n    constructor(readonly branches: Array<[Expr, Expr]>, readonly fallback: Expr) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitCaseExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic() {\n        return (\n            this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||\n            this.fallback.isDynamic()\n        );\n    }\n}\n\n/**\n * A node representing a `step` expression.\n * @internal\n */\nexport class StepExpr extends Expr {\n    constructor(\n        readonly input: Expr,\n        readonly defaultValue: Expr,\n        readonly stops: Array<[number, Expr]>\n    ) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitStepExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic(): boolean {\n        return (\n            this.input.isDynamic() ||\n            this.defaultValue.isDynamic() ||\n            this.stops.some(([_, value]) => value.isDynamic())\n        );\n    }\n}\n\n/**\n * The type of the interpolation mode.\n */\nexport type InterpolateMode = [\"discrete\"] | [\"linear\"] | [\"cubic\"] | [\"exponential\", number];\n\n/**\n * A node representing an `interpolate` expression.\n * @internal\n */\nexport class InterpolateExpr extends Expr {\n    constructor(\n        readonly mode: InterpolateMode,\n        readonly input: Expr,\n        readonly stops: Array<[number, Expr]>\n    ) {\n        super();\n    }\n\n    /** @override */\n    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result {\n        return visitor.visitInterpolateExpr(this, context);\n    }\n\n    /** @override */\n    protected exprIsDynamic(): boolean {\n        return this.input.isDynamic() || this.stops.some(([_, value]) => value.isDynamic());\n    }\n}\n\n/**\n * Serializes the Expr to JSON.\n *\n * @internal\n */\nclass ExprSerializer implements ExprVisitor<JsonValue, void> {\n    serialize(expr: Expr): JsonValue {\n        return expr.accept(this, undefined);\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: void): JsonValue {\n        return null;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: void): JsonValue {\n        return expr.value;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: void): JsonValue {\n        return expr.value;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: void): JsonValue {\n        return expr.value;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: void): JsonValue {\n        if (expr.value instanceof THREE.Vector2) {\n            return [\"make-vector\", expr.value.x, expr.value.y];\n        } else if (expr.value instanceof THREE.Vector3) {\n            return [\"make-vector\", expr.value.x, expr.value.y, expr.value.z];\n        } else if (expr.value instanceof THREE.Vector4) {\n            return [\"make-vector\", expr.value.x, expr.value.y, expr.value.z, expr.value.w];\n        }\n        return [\"literal\", expr.value as JsonObject];\n    }\n\n    visitVarExpr(expr: VarExpr, context: void): JsonValue {\n        return [\"get\", expr.name];\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: void): JsonValue {\n        return [\"has\", expr.name];\n    }\n\n    visitCallExpr(expr: CallExpr, context: void): JsonValue {\n        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];\n    }\n\n    visitLookupExpr(expr: LookupExpr, context: void): JsonValue {\n        // Same serialization as call expressions.\n        return this.visitCallExpr(expr, context);\n    }\n\n    visitMatchExpr(expr: MatchExpr, context: void): JsonValue {\n        const branches: JsonValue[] = [];\n        for (const [label, body] of expr.branches) {\n            branches.push(label, this.serialize(body));\n        }\n        return [\"match\", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: void): JsonValue {\n        const branches: JsonValue[] = [];\n        for (const [condition, body] of expr.branches) {\n            branches.push(this.serialize(condition), this.serialize(body));\n        }\n        return [\"case\", ...branches, this.serialize(expr.fallback)];\n    }\n\n    visitStepExpr(expr: StepExpr, context: void): JsonValue {\n        const result: JsonArray = [\"step\"];\n        result.push(this.serialize(expr.input));\n        result.push(this.serialize(expr.defaultValue));\n        expr.stops.forEach(([key, value]) => {\n            result.push(key);\n            result.push(this.serialize(value));\n        });\n        return result;\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: void): JsonValue {\n        const result: JsonArray = [\"interpolate\", expr.mode];\n        result.push(this.serialize(expr.input));\n        expr.stops.forEach(([key, value]) => {\n            result.push(key);\n            result.push(this.serialize(value));\n        });\n        return result;\n    }\n}\n\nfunction parseNode(\n    node: JsonValue,\n    referenceResolverState: ReferenceResolverState | undefined\n): Expr {\n    if (Array.isArray(node)) {\n        return parseCall(node, referenceResolverState);\n    } else if (node === null) {\n        return NullLiteralExpr.instance;\n    } else if (typeof node === \"boolean\") {\n        return new BooleanLiteralExpr(node);\n    } else if (typeof node === \"number\") {\n        return new NumberLiteralExpr(node);\n    } else if (typeof node === \"string\") {\n        return new StringLiteralExpr(node);\n    }\n    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);\n}\n\nfunction parseCall(node: JsonArray, referenceResolverState?: ReferenceResolverState): Expr {\n    const op = node[0];\n\n    if (typeof op !== \"string\") {\n        throw new Error(\"expected a builtin function name\");\n    }\n\n    switch (op) {\n        case \"!has\":\n        case \"!in\":\n            return new CallExpr(\"!\", [parseCall([op.slice(1), ...node.slice(1)])]);\n\n        case \"ref\":\n            return resolveReference(node, referenceResolverState);\n\n        case \"get\":\n            return parseGetExpr(node, referenceResolverState);\n\n        case \"has\":\n            return parseHasExpr(node, referenceResolverState);\n\n        case \"literal\":\n            return parseLiteralExpr(node);\n\n        case \"match\":\n            return parseMatchExpr(node, referenceResolverState);\n\n        case \"case\":\n            return parseCaseExpr(node, referenceResolverState);\n\n        case \"interpolate\":\n            return parseInterpolateExpr(node, referenceResolverState);\n\n        case \"step\":\n            return parseStepExpr(node, referenceResolverState);\n\n        case \"lookup\":\n            return LookupExpr.parseArray(node, referenceResolverState);\n\n        default:\n            return makeCallExpr(op, node, referenceResolverState);\n    } // switch\n}\n\nfunction parseGetExpr(node: JsonArray, referenceResolverState?: ReferenceResolverState) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"get\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new VarExpr(name);\n}\n\nfunction parseHasExpr(node: JsonArray, referenceResolverState?: ReferenceResolverState) {\n    if (node[2] !== undefined) {\n        return makeCallExpr(\"has\", node, referenceResolverState);\n    }\n    const name = node[1];\n    if (typeof name !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    return new HasAttributeExpr(name);\n}\n\nfunction parseLiteralExpr(node: JsonArray) {\n    const obj = node[1];\n    if (obj === null || typeof obj !== \"object\") {\n        throw new Error(\"expected an object or array literal\");\n    }\n    return new ObjectLiteralExpr(obj);\n}\n\nfunction parseMatchExpr(node: JsonArray, referenceResolverState?: ReferenceResolverState) {\n    if (node.length < 4) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (!(node.length % 2)) {\n        throw new Error(\"fallback is missing in 'match' expression\");\n    }\n    const value = parseNode(node[1], referenceResolverState);\n    const conditions: Array<[MatchLabel, Expr]> = [];\n    for (let i = 2; i < node.length - 1; i += 2) {\n        const label = node[i];\n        if (!MatchExpr.isValidMatchLabel(label)) {\n            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);\n        }\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        conditions.push([label, expr]);\n    }\n    const fallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new MatchExpr(value, conditions, fallback);\n}\n\nfunction parseCaseExpr(node: JsonArray, referenceResolverState?: ReferenceResolverState) {\n    if (node.length < 3) {\n        throw new Error(\"not enough arguments\");\n    }\n    if (node.length % 2) {\n        throw new Error(\"fallback is missing in 'case' expression\");\n    }\n    const branches: Array<[Expr, Expr]> = [];\n    for (let i = 1; i < node.length - 1; i += 2) {\n        const condition = parseNode(node[i], referenceResolverState);\n        const expr = parseNode(node[i + 1], referenceResolverState);\n        branches.push([condition, expr]);\n    }\n    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);\n    return new CaseExpr(branches, caseFallback);\n}\n\nfunction isInterpolationMode(object: any): object is InterpolateMode {\n    if (!Array.isArray(object)) {\n        return false;\n    }\n    switch (object[0]) {\n        case \"discrete\":\n        case \"linear\":\n        case \"cubic\":\n        case \"exponential\":\n            return true;\n        default:\n            return false;\n    }\n}\n\nfunction parseInterpolateExpr(node: JsonArray, referenceResolverState?: ReferenceResolverState) {\n    const mode: InterpolateMode = node[1] as any;\n    if (!isInterpolationMode(mode)) {\n        throw new Error(\"expected an interpolation type\");\n    }\n    if (mode[0] === \"exponential\" && typeof mode[1] !== \"number\") {\n        throw new Error(\"expected the base of the exponential interpolation\");\n    }\n    const input = node[2] !== undefined ? parseNode(node[2], referenceResolverState) : undefined;\n    if (!Expr.isExpr(input)) {\n        throw new Error(`expected the input of the interpolation`);\n    }\n    if (node.length === 3 || !(node.length % 2)) {\n        throw new Error(\"invalid number of samples\");\n    }\n\n    const stops: Array<[number, Expr]> = [];\n    for (let i = 3; i < node.length - 1; i += 2) {\n        const key = node[i] as number;\n        const value = parseNode(node[i + 1], referenceResolverState);\n        stops.push([key, value]);\n    }\n    return new InterpolateExpr(mode, input, stops);\n}\n\nfunction parseStepExpr(node: JsonArray, referenceResolverState?: ReferenceResolverState) {\n    if (node.length < 2) {\n        throw new Error(\"expected the input of the 'step' operator\");\n    }\n    if (node.length < 3 || !(node.length % 2)) {\n        throw new Error(\"not enough arguments\");\n    }\n    const input = parseNode(node[1], referenceResolverState);\n    const defaultValue = parseNode(node[2], referenceResolverState);\n    const stops: Array<[number, Expr]> = [];\n    for (let i = 3; i < node.length; i += 2) {\n        const key = node[i] as number;\n        const value = parseNode(node[i + 1], referenceResolverState);\n        stops.push([key, value]);\n    }\n    return new StepExpr(input, defaultValue, stops);\n}\n\nfunction makeCallExpr(\n    op: string,\n    node: any[],\n    referenceResolverState?: ReferenceResolverState\n): Expr {\n    return new CallExpr(\n        op,\n        node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState))\n    );\n}\n\nfunction resolveReference(node: JsonArray, referenceResolverState?: ReferenceResolverState) {\n    if (typeof node[1] !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n    if (referenceResolverState === undefined) {\n        throw new Error(`ref used with no definitions`);\n    }\n    const name = node[1] as string;\n\n    if (referenceResolverState.lockedNames.has(name)) {\n        throw new Error(`circular referene to '${name}'`);\n    }\n\n    if (!(name in referenceResolverState.definitions)) {\n        throw new Error(`definition '${name}' not found`);\n    }\n\n    const cachedEntry = referenceResolverState.cache.get(name);\n    if (cachedEntry !== undefined) {\n        return cachedEntry;\n    }\n    let definitionEntry = referenceResolverState.definitions[name] as any;\n    let result: Expr;\n    const definitionValue: Definition = getDefinitionValue(definitionEntry);\n    if (isInterpolatedPropertyDefinition(definitionValue)) {\n        // found a reference to an interpolation using\n        // the deprecated object-like syntax.\n        return Expr.fromJSON(interpolatedPropertyDefinitionToJsonExpr(definitionEntry));\n    } else if (isJsonExpr(definitionValue)) {\n        definitionEntry = definitionValue;\n    } else {\n        return Expr.fromJSON(definitionValue);\n    }\n\n    if (isJsonExpr(definitionEntry)) {\n        referenceResolverState.lockedNames.add(name);\n        try {\n            result = parseNode(definitionEntry, referenceResolverState);\n        } finally {\n            referenceResolverState.lockedNames.delete(name);\n        }\n    } else {\n        throw new Error(`unsupported definition ${name}`);\n    }\n    referenceResolverState.cache.set(name, result);\n    return result;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    Env,\n    Expr,\n    ExprScope,\n    ExprVisitor,\n    HasAttributeExpr,\n    InterpolateExpr,\n    LiteralExpr,\n    LookupExpr,\n    MatchExpr,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StepExpr,\n    StringLiteralExpr,\n    Value,\n    VarExpr\n} from \"./Expr\";\nimport { ArrayOperators } from \"./operators/ArrayOperators\";\nimport { CastOperators } from \"./operators/CastOperators\";\nimport { ColorOperators } from \"./operators/ColorOperators\";\nimport { ComparisonOperators } from \"./operators/ComparisonOperators\";\nimport { FeatureOperators } from \"./operators/FeatureOperators\";\nimport { FlowOperators } from \"./operators/FlowOperators\";\nimport { MapOperators } from \"./operators/MapOperators\";\nimport { MathOperators } from \"./operators/MathOperators\";\nimport { MiscOperators } from \"./operators/MiscOperators\";\nimport { ObjectOperators } from \"./operators/ObjectOperators\";\nimport { StringOperators } from \"./operators/StringOperators\";\nimport { TypeOperators } from \"./operators/TypeOperators\";\nimport { VectorOperators } from \"./operators/VectorOperators\";\nimport { Pixels } from \"./Pixels\";\nimport { RGBA } from \"./RGBA\";\n\nexport interface OperatorDescriptor {\n    /**\n     * Returns `true` if this operator requires a dynamic execution context (e.g. [\"zoom\"]).\n     */\n    isDynamicOperator?: (call: CallExpr) => boolean;\n\n    /**\n     * Evaluates the given expression.\n     */\n    call: (context: ExprEvaluatorContext, call: CallExpr) => Value;\n\n    /**\n     * Partial evaluate the `call` expression using the given `context`.\n     */\n    partialEvaluate?: (context: ExprEvaluatorContext, call: CallExpr) => Value;\n}\n\nexport interface OperatorDescriptorMap {\n    [name: string]: OperatorDescriptor;\n}\n\nconst operatorDescriptors = new Map<string, OperatorDescriptor>();\n\n/**\n * Promote string literals and values to color and pixel constants.\n *\n * @hidden\n * @internal\n */\nfunction promoteValue(context: ExprEvaluatorContext, expr: Expr): Value {\n    if (expr instanceof StringLiteralExpr) {\n        return expr.promotedValue ?? expr.value;\n    }\n\n    const value = context.evaluate(expr);\n\n    if (typeof value === \"string\") {\n        return RGBA.parse(value) ?? Pixels.parse(value) ?? value;\n    }\n\n    return value;\n}\n\nfunction cubicInterpolate(\n    context: ExprEvaluatorContext,\n    interp: InterpolateExpr,\n    t: number\n): Value {\n    if (t < interp.stops[0][0]) {\n        return promoteValue(context, interp.stops[0][1]);\n    } else if (t >= interp.stops[interp.stops.length - 1][0]) {\n        return promoteValue(context, interp.stops[interp.stops.length - 1][1]);\n    }\n\n    // indices\n    const i1 = interp.stops.findIndex(stop => stop[0] > t);\n    const i0 = Math.max(0, i1 - 1);\n    const iP = i0 === 0 ? i1 : i0 - 1;\n    const iN = i1 < interp.stops.length - 1 ? i1 + 1 : i1 - 1;\n\n    // keys\n    const tP = interp.stops[iP][0];\n    const t0 = interp.stops[i0][0];\n    const t1 = interp.stops[i1][0];\n    const tN = interp.stops[iN][0];\n\n    const dt = (t1 - t0) * 0.5;\n    const wP = dt / (t0 - tP);\n    const wN = dt / (tN - t1);\n    const p = (t - t0) / (t1 - t0);\n    const pp = p * p;\n    const ppp = pp * p;\n\n    // coefficients\n    const cP = -wP * ppp + 2 * wP * pp - wP * p;\n    const c0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const c1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const cN = wN * ppp - wN * pp;\n\n    // values\n    const vP = promoteValue(context, interp.stops[iP][1]);\n    const v0 = promoteValue(context, interp.stops[i0][1]);\n    const v1 = promoteValue(context, interp.stops[i1][1]);\n    const vN = promoteValue(context, interp.stops[iN][1]);\n\n    if (\n        typeof vP === \"number\" &&\n        typeof v0 === \"number\" &&\n        typeof v1 === \"number\" &&\n        typeof vN === \"number\"\n    ) {\n        return cP * vP + c0 * v0 + c1 * v1 + cN * vN;\n    } else if (\n        vP instanceof RGBA &&\n        v0 instanceof RGBA &&\n        v1 instanceof RGBA &&\n        vN instanceof RGBA\n    ) {\n        return new RGBA(\n            THREE.MathUtils.clamp(cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r, 0, 1),\n            THREE.MathUtils.clamp(cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g, 0, 1),\n            THREE.MathUtils.clamp(cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b, 0, 1),\n            THREE.MathUtils.clamp(cP * vP.a + c0 * v0.a + c1 * v1.a + cN * vN.a, 0, 1)\n        );\n    } else if (\n        vP instanceof Pixels &&\n        v0 instanceof Pixels &&\n        v1 instanceof Pixels &&\n        vN instanceof Pixels\n    ) {\n        return new Pixels(cP * vP.value + c0 * v0.value + c1 * v1.value + cN * vN.value);\n    } else if (\n        vP instanceof THREE.Color &&\n        v0 instanceof THREE.Color &&\n        v1 instanceof THREE.Color &&\n        vN instanceof THREE.Color\n    ) {\n        return new THREE.Color(\n            cP * vP.r + c0 * v0.r + c1 * v1.r + cN * vN.r,\n            cP * vP.g + c0 * v0.g + c1 * v1.g + cN * vN.g,\n            cP * vP.b + c0 * v0.b + c1 * v1.b + cN * vN.b\n        );\n    } else if (\n        vP instanceof THREE.Vector2 &&\n        v0 instanceof THREE.Vector2 &&\n        v1 instanceof THREE.Vector2 &&\n        vN instanceof THREE.Vector2\n    ) {\n        return new THREE.Vector2(\n            cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x,\n            cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y\n        );\n    } else if (\n        vP instanceof THREE.Vector3 &&\n        v0 instanceof THREE.Vector3 &&\n        v1 instanceof THREE.Vector3 &&\n        vN instanceof THREE.Vector3\n    ) {\n        return new THREE.Vector3(\n            cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x,\n            cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y,\n            cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z\n        );\n    } else if (\n        vP instanceof THREE.Vector4 &&\n        v0 instanceof THREE.Vector4 &&\n        v1 instanceof THREE.Vector4 &&\n        vN instanceof THREE.Vector4\n    ) {\n        return new THREE.Vector4(\n            cP * vP.x + c0 * v0.x + c1 * v1.x + cN * vN.x,\n            cP * vP.y + c0 * v0.y + c1 * v1.y + cN * vN.y,\n            cP * vP.z + c0 * v0.z + c1 * v1.z + cN * vN.z,\n            cP * vP.w + c0 * v0.w + c1 * v1.w + cN * vN.w\n        );\n    } else if (Array.isArray(vP) && Array.isArray(v0) && Array.isArray(v1) && Array.isArray(vN)) {\n        const N = vP.length;\n        const r: number[] = [];\n        for (let i = 0; i < N; ++i) {\n            r[i] = cP * vP[i] + c0 * v0[i] + c1 * v1[i] + cN * vN[i];\n        }\n        return r;\n    }\n\n    throw new Error(`failed to interpolate values`);\n}\n\n/*\n * @hidden\n */\nexport class ExprEvaluatorContext {\n    constructor(\n        readonly evaluator: ExprEvaluator,\n        readonly env: Env,\n        readonly scope: ExprScope,\n        readonly cache?: Map<Expr, Value>\n    ) {}\n\n    /**\n     * Evaluate the given expression.\n     *\n     * @param expr - The {@link Expr} to evaluate.\n     */\n    evaluate(expr: Expr | undefined) {\n        if (expr === undefined) {\n            throw new Error(\"Failed to evaluate expression\");\n        }\n\n        const cachedResult = this.cache?.get(expr);\n\n        if (cachedResult !== undefined) {\n            return cachedResult;\n        }\n\n        const result = expr.accept(this.evaluator, this);\n        this.cache?.set(expr, result);\n        return result;\n    }\n\n    /**\n     * Wraps the given value in an {@link Expr} if needed.\n     *\n     * @param value -\n     */\n    wrapValue(value: Value | Expr): Expr {\n        return Expr.isExpr(value) ? value : LiteralExpr.fromValue(value);\n    }\n}\n\n/**\n * [[ExprEvaluator]] is used to evaluate {@link Expr} in a given environment.\n *\n * @hidden\n */\nexport class ExprEvaluator implements ExprVisitor<Value, ExprEvaluatorContext> {\n    static defineOperator(op: string, builtin: OperatorDescriptor) {\n        operatorDescriptors.set(op, builtin);\n    }\n\n    static defineOperators(builtins: OperatorDescriptorMap) {\n        Object.getOwnPropertyNames(builtins).forEach(p => {\n            this.defineOperator(p, builtins[p]);\n        });\n    }\n\n    /**\n     * Returns the [[OperatorDescriptor]] for the given operator name.\n     * @hidden\n     */\n    static getOperator(op: string): OperatorDescriptor | undefined {\n        return operatorDescriptors.get(op);\n    }\n\n    visitVarExpr(expr: VarExpr, context: ExprEvaluatorContext): Value {\n        const value = context.env.lookup(expr.name);\n        return value !== undefined ? value : null;\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: ExprEvaluatorContext): Value {\n        return null;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: ExprEvaluatorContext): Value {\n        return expr.value;\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: ExprEvaluatorContext): Value {\n        return context.env.lookup(expr.name) !== undefined;\n    }\n\n    visitMatchExpr(match: MatchExpr, context: ExprEvaluatorContext): Value {\n        const r = context.evaluate(match.value);\n        for (const [label, body] of match.branches) {\n            if (Array.isArray(label) && (label as any[]).includes(r)) {\n                return context.evaluate(body);\n            } else if (label === r) {\n                return context.evaluate(body);\n            }\n        }\n        return context.evaluate(match.fallback);\n    }\n\n    visitCaseExpr(match: CaseExpr, context: ExprEvaluatorContext): Value {\n        if (context.scope === ExprScope.Value) {\n            const firstDynamicCondition = match.branches.findIndex(([condition, _]) =>\n                condition.isDynamic()\n            );\n\n            if (firstDynamicCondition !== -1) {\n                let branches: Array<[Expr, Expr]> | undefined;\n\n                for (let i = 0; i < match.branches.length; ++i) {\n                    const [condition, body] = match.branches[i];\n\n                    const evaluatedCondition = context.evaluate(condition);\n                    const evaluatedBody = context.evaluate(body);\n\n                    if (i < firstDynamicCondition && Boolean(evaluatedCondition)) {\n                        return evaluatedBody;\n                    }\n\n                    if (!Expr.isExpr(evaluatedCondition) && !Boolean(evaluatedCondition)) {\n                        // skip this branch, it constantly evaluates to false.\n                        continue;\n                    }\n\n                    if (branches === undefined) {\n                        branches = [];\n                    }\n\n                    branches?.push([\n                        context.wrapValue(evaluatedCondition),\n                        context.wrapValue(evaluatedBody)\n                    ]);\n\n                    if (!Expr.isExpr(evaluatedCondition) && Boolean(evaluatedCondition)) {\n                        // skip unreachble expressions\n                        return new CaseExpr(branches, LiteralExpr.fromValue(null));\n                    }\n                }\n\n                const fallback = context.evaluate(match.fallback);\n\n                return branches === undefined\n                    ? fallback\n                    : new CaseExpr(branches, context.wrapValue(fallback));\n            }\n        }\n\n        for (const [condition, body] of match.branches) {\n            if (context.evaluate(condition)) {\n                return context.evaluate(body);\n            }\n        }\n\n        return context.evaluate(match.fallback);\n    }\n\n    visitCallExpr(expr: CallExpr, context: ExprEvaluatorContext): Value {\n        const descriptor = expr.descriptor ?? operatorDescriptors.get(expr.op);\n\n        if (descriptor) {\n            expr.descriptor = descriptor;\n\n            let result: Value;\n\n            if (context.scope === ExprScope.Value && expr.isDynamic()) {\n                if (expr.descriptor.partialEvaluate) {\n                    return expr.descriptor.partialEvaluate(context, expr);\n                }\n\n                const args = expr.args.map(arg => {\n                    return context.wrapValue(context.evaluate(arg));\n                });\n\n                if (args.every((arg, i) => arg === expr.args[i])) {\n                    return expr;\n                }\n\n                result = new CallExpr(expr.op, args);\n            } else {\n                result = descriptor.call(context, expr);\n            }\n\n            return result;\n        }\n\n        throw new Error(`undefined operator '${expr.op}'`);\n    }\n\n    visitLookupExpr(expr: LookupExpr, context: ExprEvaluatorContext): Value {\n        // Same behaviour as call expressions.\n        return this.visitCallExpr(expr, context);\n    }\n\n    visitStepExpr(expr: StepExpr, context: ExprEvaluatorContext): Value {\n        if (context.scope === ExprScope.Value) {\n            const input = context.evaluate(expr.input);\n            const defaultValue = context.evaluate(expr.defaultValue);\n            return new StepExpr(\n                context.wrapValue(input),\n                context.wrapValue(defaultValue),\n                expr.stops.map(([key, value]) => {\n                    const v = context.evaluate(value);\n                    return [key, context.wrapValue(v)];\n                })\n            );\n        } else {\n            const input = context.evaluate(expr.input);\n\n            if (typeof input !== \"number\") {\n                throw new Error(`input '${input}' must be a number`);\n            }\n\n            if (input < expr.stops[0][0]) {\n                return context.evaluate(expr.defaultValue);\n            }\n\n            let index = expr.stops.findIndex(s => s[0] > input);\n\n            if (index === -1) {\n                index = expr.stops.length;\n            }\n\n            return context.evaluate(expr.stops[index - 1][1]);\n        }\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: ExprEvaluatorContext): Value {\n        if (context.scope === ExprScope.Value) {\n            const input = context.evaluate(expr.input);\n            return new InterpolateExpr(\n                expr.mode,\n                context.wrapValue(input),\n                expr.stops.map(([key, value]) => {\n                    const v = context.evaluate(value);\n                    return [key, context.wrapValue(v)];\n                })\n            );\n        } else {\n            const param = context.evaluate(expr.input);\n\n            if (typeof param !== \"number\") {\n                throw new Error(`input must be a number`);\n            }\n\n            if (expr.mode[0] === \"cubic\") {\n                return cubicInterpolate(context, expr, param);\n            }\n\n            const keyIndex = expr.stops.findIndex(stop => stop[0] > param);\n\n            if (keyIndex === -1) {\n                // all the keys are smaller than the parameter\n                return context.evaluate(expr.stops[expr.stops.length - 1][1]);\n            } else if (keyIndex === 0) {\n                return context.evaluate(expr.stops[0][1]);\n            }\n\n            const [key, value] = expr.stops[keyIndex];\n            const [prevKey, prevValue] = expr.stops[keyIndex - 1];\n\n            const v0 = promoteValue(context, prevValue);\n\n            let t = 0;\n\n            switch (expr.mode[0]) {\n                case \"discrete\":\n                    return v0;\n\n                case \"linear\":\n                    t = (param - prevKey) / (key - prevKey);\n                    break;\n\n                case \"exponential\": {\n                    const base = expr.mode[1];\n                    t =\n                        base === 1\n                            ? (param - prevKey) / (key - prevKey)\n                            : (Math.pow(base, param - prevKey) - 1) /\n                              (Math.pow(base, key - prevKey) - 1);\n\n                    break;\n                }\n\n                default:\n                    throw new Error(\n                        `interpolation mode ${JSON.stringify(expr.mode)} is not supported`\n                    );\n            }\n\n            const v1 = promoteValue(context, value);\n\n            if (typeof v0 === \"number\" && typeof v1 === \"number\") {\n                return THREE.MathUtils.lerp(v0, v1, t);\n            } else if (v0 instanceof RGBA && v1 instanceof RGBA) {\n                return v0.clone().lerp(v1, t);\n            } else if (v0 instanceof Pixels && v1 instanceof Pixels) {\n                return new Pixels(THREE.MathUtils.lerp(v0.value, v1.value, t));\n            } else if (v0 instanceof THREE.Color && v1 instanceof THREE.Color) {\n                return v0.clone().lerp(v1, t);\n            } else if (v0 instanceof THREE.Vector2 && v1 instanceof THREE.Vector2) {\n                return v0.clone().lerp(v1, t);\n            } else if (v0 instanceof THREE.Vector3 && v1 instanceof THREE.Vector3) {\n                return v0.clone().lerp(v1, t);\n            } else if (v0 instanceof THREE.Vector4 && v1 instanceof THREE.Vector4) {\n                return v0.clone().lerp(v1, t);\n            } else if (Array.isArray(v0) && Array.isArray(v1) && v0.length === v1.length) {\n                return v0.map((x, i) => THREE.MathUtils.lerp(x, (v1 as number[])[i], t));\n            }\n\n            throw new Error(`todo: mix(${JSON.stringify(v0)}, ${JSON.stringify(v1)}, ${t})`);\n        }\n    }\n}\n\nExprEvaluator.defineOperators(CastOperators);\nExprEvaluator.defineOperators(ComparisonOperators);\nExprEvaluator.defineOperators(MathOperators);\nExprEvaluator.defineOperators(StringOperators);\nExprEvaluator.defineOperators(ColorOperators);\nExprEvaluator.defineOperators(TypeOperators);\nExprEvaluator.defineOperators(MiscOperators);\nExprEvaluator.defineOperators(FlowOperators);\nExprEvaluator.defineOperators(ArrayOperators);\nExprEvaluator.defineOperators(ObjectOperators);\nExprEvaluator.defineOperators(FeatureOperators);\nExprEvaluator.defineOperators(MapOperators);\nExprEvaluator.defineOperators(VectorOperators);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env } from \"./Env\";\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    Expr,\n    ExprScope,\n    ExprVisitor,\n    HasAttributeExpr,\n    InterpolateExpr,\n    LiteralExpr,\n    LookupExpr,\n    MatchExpr,\n    MatchLabel,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StepExpr,\n    StringLiteralExpr,\n    VarExpr\n} from \"./Expr\";\n\nexport interface InstantiationContext {\n    /**\n     * The {@link Env} used to lookup for names.\n     */\n    env: Env;\n\n    /**\n     * The names to preserve during the instantiation.\n     */\n    preserve?: Set<string>;\n}\n\nconst emptyEnv = new Env();\n\n/**\n * @hidden\n */\nexport class ExprInstantiator implements ExprVisitor<Expr, InstantiationContext> {\n    visitNullLiteralExpr(expr: NullLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, _context: InstantiationContext): Expr {\n        return expr;\n    }\n\n    visitVarExpr(expr: VarExpr, context: InstantiationContext): Expr {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name);\n        return LiteralExpr.fromValue(value !== undefined ? value : null);\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: InstantiationContext): Expr {\n        if (context.preserve && context.preserve.has(expr.name)) {\n            return expr;\n        }\n        const value = context.env.lookup(expr.name) !== undefined;\n        return LiteralExpr.fromValue(value);\n    }\n\n    private visitCallExprImpl(\n        expr: CallExpr,\n        context: InstantiationContext,\n        constructor: (op: string, args: Expr[]) => CallExpr\n    ): Expr {\n        const args = expr.args.map(arg => arg.accept(this, context));\n        if (args.some((a, i) => a !== expr.args[i])) {\n            return constructor(expr.op, args);\n        }\n        return expr;\n    }\n\n    visitCallExpr(expr: CallExpr, context: InstantiationContext): Expr {\n        return this.visitCallExprImpl(expr, context, (op: string, args: Expr[]) => {\n            return new CallExpr(op, args);\n        });\n    }\n\n    visitLookupExpr(expr: LookupExpr, context: InstantiationContext): Expr {\n        return this.visitCallExprImpl(expr, context, (op: string, args: Expr[]) => {\n            return new LookupExpr(args);\n        });\n    }\n\n    visitMatchExpr(match: MatchExpr, context: InstantiationContext): Expr {\n        const value = match.value.accept(this, context);\n\n        if (value instanceof LiteralExpr) {\n            const r = value.value;\n            for (const [label, body] of match.branches) {\n                if (Array.isArray(label) && (label as any[]).includes(r)) {\n                    return body.accept(this, context);\n                } else if (label === r) {\n                    return body.accept(this, context);\n                }\n            }\n            return match.fallback.accept(this, context);\n        }\n\n        let changed = match.value !== value;\n\n        const branches: Array<[MatchLabel, Expr]> = match.branches.map(([label, branch]) => {\n            const newBranch = branch.accept(this, context);\n            if (newBranch !== branch) {\n                changed = true;\n            }\n            return [label, newBranch];\n        });\n\n        const fallback = match.fallback.accept(this, context);\n\n        if (fallback !== match.fallback) {\n            changed = true;\n        }\n\n        return changed ? new MatchExpr(value, branches, fallback) : match;\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: InstantiationContext): Expr {\n        const branches: Array<[Expr, Expr]> = [];\n\n        let changed = false;\n\n        for (const [condition, branch] of expr.branches) {\n            const newCondition = condition.accept(this, context);\n            const deps = newCondition.dependencies();\n            if (!condition.isDynamic() && deps.properties.size === 0) {\n                if (Boolean(newCondition.evaluate(emptyEnv, ExprScope.Condition))) {\n                    return branch.accept(this, context);\n                }\n            } else {\n                if (newCondition !== condition) {\n                    changed = true;\n                }\n                branches.push([newCondition, branch]);\n            }\n        }\n\n        if (branches.length === 0) {\n            // all the conditions of this CaseExpr evaluated\n            // to false, so the resulting of instantiating this CaseExpr\n            // is the same as instantiating its fallback expression.\n            return expr.fallback.accept(this, context);\n        }\n\n        if (branches.length !== expr.branches.length) {\n            // the number of branches changed, this means that\n            // some of the branches had constant expressions that\n            // evaluate to false. In this case the resulting\n            // `CaseExpr` has less branches.\n            changed = true;\n        }\n\n        // Instantiate the body of all the branches of this CaseExpr\n        // that have dynamic conditions.\n        branches.forEach(branch => {\n            const instantiatedBranch = branch[1].accept(this, context);\n\n            if (instantiatedBranch !== branch[1]) {\n                changed = true;\n            }\n\n            branch[1] = instantiatedBranch;\n        });\n\n        const fallback = expr.fallback.accept(this, context);\n\n        if (fallback !== expr.fallback) {\n            changed = true;\n        }\n\n        if (!changed) {\n            // nothing changed, return the old expression.\n            return expr;\n        }\n\n        return new CaseExpr(branches, fallback);\n    }\n\n    visitStepExpr(expr: StepExpr, context: InstantiationContext): Expr {\n        const input = expr.input.accept(this, context);\n        const defaultValue = expr.defaultValue.accept(this, context);\n        const stops: Array<[number, Expr]> = expr.stops.map(([key, value]) => [\n            key,\n            value.accept(this, context)\n        ]);\n        return new StepExpr(input, defaultValue, stops);\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: InstantiationContext): Expr {\n        const input = expr.input.accept(this, context);\n        const stops: Array<[number, Expr]> = expr.stops.map(([key, value]) => [\n            key,\n            value.accept(this, context)\n        ]);\n        return new InterpolateExpr(expr.mode, input, stops);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    CallExpr,\n    EqualityOp,\n    Expr,\n    HasAttributeExpr,\n    LiteralExpr,\n    NumberLiteralExpr,\n    RelationalOp,\n    StringLiteralExpr,\n    VarExpr\n} from \"./Expr\";\n\n/**\n * Character value\n */\nenum Character {\n    Tab = 9,\n    Lf = 10,\n    Cr = 13,\n    Space = 32,\n    LParen = 40,\n    RParen = 41,\n    Comma = 44,\n    Dot = 46,\n    LBracket = 91,\n    Backslash = 92,\n    RBracket = 93,\n    _0 = 48,\n    _9 = 57,\n    _ = 95,\n    A = 64,\n    Z = 90,\n    a = 97,\n    z = 122,\n    DoubleQuote = 34,\n    SingleQuote = 39,\n    Exclaim = 33,\n    Equal = 61,\n    Caret = 94,\n    Tilde = 126,\n    Dollar = 36,\n    Less = 60,\n    Greater = 62,\n    Bar = 124,\n    Amp = 38\n}\n\n/**\n * Check if a codepoint is a whitespace character.\n */\nfunction isSpace(codepoint: number): boolean {\n    switch (codepoint) {\n        case Character.Tab:\n        case Character.Lf:\n        case Character.Cr:\n        case Character.Space:\n            return true;\n        default:\n            return false;\n    } // switch\n}\n\n/**\n * Check if codepoint is a digit character.\n */\nfunction isNumber(codepoint: number): boolean {\n    return codepoint >= Character._0 && codepoint <= Character._9;\n}\n\n/**\n * Check if codepoint is a letter character.\n */\nfunction isLetter(codepoint: number): boolean {\n    return (\n        (codepoint >= Character.a && codepoint <= Character.z) ||\n        (codepoint >= Character.A && codepoint <= Character.Z)\n    );\n}\n\n/**\n * Check if codepoint is either a digit or a letter character.\n */\nfunction isLetterOrNumber(codepoint: number): boolean {\n    return isLetter(codepoint) || isNumber(codepoint);\n}\n\n/**\n * Check if codepoint is an identification character: underscore, dollar sign, dot or bracket.\n */\nfunction isIdentChar(codepoint: number): boolean {\n    return (\n        isLetterOrNumber(codepoint) ||\n        codepoint === Character._ ||\n        codepoint === Character.Dollar ||\n        codepoint === Character.Dot ||\n        codepoint === Character.LBracket ||\n        codepoint === Character.RBracket\n    );\n}\n\n/**\n * Tokens used in theme grammar.\n */\nenum Token {\n    Eof = 0,\n    Error,\n    Identifier,\n    Number,\n    String,\n    Comma,\n    LParen,\n    RParen,\n    LBracket,\n    RBracket,\n    Exclaim,\n    TildeEqual,\n    CaretEqual,\n    DollarEqual,\n    EqualEqual,\n    ExclaimEqual,\n    Less,\n    Greater,\n    LessEqual,\n    GreaterEqual,\n    BarBar,\n    AmpAmp\n}\n\n/**\n * Maps a token to its string name.\n */\nfunction tokenSpell(token: Token): string {\n    switch (token) {\n        case Token.Eof:\n            return \"eof\";\n        case Token.Error:\n            return \"error\";\n        case Token.Identifier:\n            return \"identifier\";\n        case Token.Number:\n            return \"number\";\n        case Token.String:\n            return \"string\";\n        case Token.Comma:\n            return \",\";\n        case Token.LParen:\n            return \"(\";\n        case Token.RParen:\n            return \")\";\n        case Token.LBracket:\n            return \"[\";\n        case Token.RBracket:\n            return \"]\";\n        case Token.Exclaim:\n            return \"!\";\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        case Token.BarBar:\n            return \"||\";\n        case Token.AmpAmp:\n            return \"&&\";\n        default:\n            throw new Error(`invalid token ${token}`);\n    }\n}\n\n/**\n * Lexer class implementation.\n */\nclass Lexer {\n    private m_token: Token = Token.Error;\n    private m_index = 0;\n    private m_char: number = Character.Lf;\n    private m_text?: string;\n\n    constructor(readonly code: string) {}\n\n    /**\n     * Single lexer token.\n     */\n    token(): Token {\n        return this.m_token;\n    }\n\n    /**\n     * Parsed text.\n     */\n    text(): string {\n        return this.m_text ?? \"\";\n    }\n\n    /**\n     * Go to the next token.\n     */\n    next(): Token {\n        this.m_token = this.yylex();\n        if (this.m_token === Token.Error) {\n            throw new Error(`unexpected character ${this.m_char}`);\n        }\n        return this.m_token;\n    }\n\n    private yyinp(): void {\n        this.m_char = this.code.codePointAt(this.m_index++) ?? 0;\n    }\n\n    private yylex(): Token {\n        this.m_text = undefined;\n        while (isSpace(this.m_char)) {\n            this.yyinp();\n        }\n        if (this.m_char === 0) {\n            return Token.Eof;\n        }\n        const ch = this.m_char;\n        this.yyinp();\n        switch (ch) {\n            case Character.LParen:\n                return Token.LParen;\n            case Character.RParen:\n                return Token.RParen;\n            case Character.LBracket:\n                return Token.LBracket;\n            case Character.RBracket:\n                return Token.RBracket;\n            case Character.Comma:\n                return Token.Comma;\n            case Character.SingleQuote:\n            case Character.DoubleQuote: {\n                const start = this.m_index - 1;\n                while (this.m_char && this.m_char !== ch) {\n                    // ### TODO handle escape sequences\n                    this.yyinp();\n                }\n                if (this.m_char !== ch) {\n                    throw new Error(\"Unfinished string literal\");\n                }\n                this.yyinp();\n                this.m_text = this.code.substring(start, this.m_index - 2);\n                return Token.String;\n            }\n            case Character.Exclaim:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.ExclaimEqual;\n                }\n                return Token.Exclaim;\n            case Character.Caret:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.CaretEqual;\n                }\n                return Token.Error;\n            case Character.Tilde:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.TildeEqual;\n                }\n                return Token.Error;\n            case Character.Equal:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.EqualEqual;\n                }\n                return Token.Error;\n            case Character.Less:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.LessEqual;\n                }\n                return Token.Less;\n            case Character.Greater:\n                if (this.m_char === Character.Equal) {\n                    this.yyinp();\n                    return Token.GreaterEqual;\n                }\n                return Token.Greater;\n            case Character.Bar:\n                if (this.m_char === Character.Bar) {\n                    this.yyinp();\n                    return Token.BarBar;\n                }\n                return Token.Error;\n            case Character.Amp:\n                if (this.m_char === Character.Amp) {\n                    this.yyinp();\n                    return Token.AmpAmp;\n                }\n                return Token.Error;\n            default: {\n                const start = this.m_index - 2;\n                if (\n                    isLetter(ch) ||\n                    ch === Character._ ||\n                    (ch === Character.Dollar && isIdentChar(this.m_char))\n                ) {\n                    while (isIdentChar(this.m_char)) {\n                        this.yyinp();\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Identifier;\n                } else if (isNumber(ch)) {\n                    while (isNumber(this.m_char)) {\n                        this.yyinp();\n                    }\n                    if (this.m_char === Character.Dot) {\n                        this.yyinp();\n                        while (isNumber(this.m_char)) {\n                            this.yyinp();\n                        }\n                    }\n                    this.m_text = this.code.substring(start, this.m_index - 1);\n                    return Token.Number;\n                } else if (ch === Character.Dollar) {\n                    if (this.m_char === Character.Equal) {\n                        this.yyinp();\n                        return Token.DollarEqual;\n                    }\n                    return Token.Error;\n                }\n            }\n        }\n        return Token.Error;\n    }\n}\n\nfunction getEqualityOp(token: Token): EqualityOp | undefined {\n    switch (token) {\n        case Token.TildeEqual:\n            return \"~=\";\n        case Token.CaretEqual:\n            return \"^=\";\n        case Token.DollarEqual:\n            return \"$=\";\n        case Token.EqualEqual:\n            return \"==\";\n        case Token.ExclaimEqual:\n            return \"!=\";\n        default:\n            return undefined;\n    } // switch\n}\n\nfunction getRelationalOp(token: Token): RelationalOp | undefined {\n    switch (token) {\n        case Token.Less:\n            return \"<\";\n        case Token.Greater:\n            return \">\";\n        case Token.LessEqual:\n            return \"<=\";\n        case Token.GreaterEqual:\n            return \">=\";\n        default:\n            return undefined;\n    } // switch\n}\n\nexport class ExprParser {\n    private readonly lex: Lexer;\n\n    constructor(code: string) {\n        this.lex = new Lexer(code);\n        this.lex.next();\n    }\n\n    parse(): Expr | never {\n        return this.parseLogicalOr();\n    }\n\n    private yyexpect(token: Token): void | never {\n        if (this.lex.token() !== token) {\n            throw new Error(\n                `Syntax error: Expected token '${tokenSpell(token)}' but ` +\n                    `found '${tokenSpell(this.lex.token())}'`\n            );\n        }\n        this.lex.next();\n    }\n\n    private parsePrimary(): Expr | never {\n        switch (this.lex.token()) {\n            case Token.Identifier: {\n                const text = this.lex.text();\n                switch (text) {\n                    case \"has\":\n                        this.lex.next(); // skip has keyword\n                        this.yyexpect(Token.LParen);\n                        const hasAttribute = this.lex.text();\n                        this.yyexpect(Token.Identifier);\n                        this.yyexpect(Token.RParen);\n                        return new HasAttributeExpr(hasAttribute);\n                    case \"length\":\n                        this.lex.next(); // skip length keyword\n                        this.yyexpect(Token.LParen);\n                        const value = this.parseLogicalOr();\n                        this.yyexpect(Token.RParen);\n                        return new CallExpr(\"length\", [value]);\n                    default:\n                        const expr = new VarExpr(text);\n                        this.lex.next();\n                        return expr;\n                }\n            }\n\n            case Token.LParen: {\n                this.lex.next();\n                const expr = this.parseLogicalOr();\n                this.yyexpect(Token.RParen);\n                return expr;\n            }\n\n            default:\n                return this.parseLiteral();\n        } // switch\n    }\n\n    private parseLiteral(): NumberLiteralExpr | StringLiteralExpr | never {\n        switch (this.lex.token()) {\n            case Token.Number: {\n                const expr = new NumberLiteralExpr(parseFloat(this.lex.text()));\n                this.lex.next();\n                return expr;\n            }\n            case Token.String: {\n                const expr = new StringLiteralExpr(this.lex.text());\n                this.lex.next();\n                return expr;\n            }\n            default:\n                throw new Error(\"Syntax error\");\n        } // switch\n    }\n\n    private parseUnary(): Expr | never {\n        if (this.lex.token() === Token.Exclaim) {\n            this.lex.next();\n            return new CallExpr(\"!\", [this.parseUnary()]);\n        }\n        return this.parsePrimary();\n    }\n\n    private parseRelational(): Expr | never {\n        let expr = this.parseUnary();\n        while (true) {\n            if (this.lex.token() === Token.Identifier && this.lex.text() === \"in\") {\n                this.lex.next();\n                this.yyexpect(Token.LBracket);\n                const elements = [this.parseLiteral()];\n                while (this.lex.token() === Token.Comma) {\n                    this.lex.next();\n                    elements.push(this.parseLiteral());\n                }\n                this.yyexpect(Token.RBracket);\n                expr = new CallExpr(\"in\", [\n                    expr,\n                    LiteralExpr.fromValue(elements.map(({ value }) => value))\n                ]);\n            } else {\n                const op = getRelationalOp(this.lex.token());\n                if (op === undefined) {\n                    break;\n                }\n                this.lex.next();\n                const right = this.parseUnary();\n                expr = new CallExpr(op, [expr, right]);\n            }\n        }\n        return expr;\n    }\n\n    private parseEquality(): Expr | never {\n        let expr = this.parseRelational();\n        while (true) {\n            let op: string | undefined = getEqualityOp(this.lex.token());\n\n            if (op === undefined) {\n                break;\n            }\n\n            if (op === \"~=\") {\n                op = \"in\";\n            }\n\n            this.lex.next();\n            const right = this.parseRelational();\n            expr = new CallExpr(op, [expr, right]);\n        }\n        return expr;\n    }\n\n    private parseLogicalAnd(): Expr | never {\n        const expr = this.parseEquality();\n\n        if (this.lex.token() !== Token.AmpAmp) {\n            return expr;\n        }\n\n        const expressions: Expr[] = [expr];\n\n        do {\n            this.lex.next();\n            expressions.push(this.parseEquality());\n        } while (this.lex.token() === Token.AmpAmp);\n\n        return new CallExpr(\"all\", expressions);\n    }\n\n    private parseLogicalOr(): Expr | never {\n        const expr = this.parseLogicalAnd();\n\n        if (this.lex.token() !== Token.BarBar) {\n            return expr;\n        }\n\n        const expressions: Expr[] = [expr];\n\n        do {\n            this.lex.next();\n            expressions.push(this.parseLogicalAnd());\n        } while (this.lex.token() === Token.BarBar);\n\n        return new CallExpr(\"any\", expressions);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Value } from \"./Env\";\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    Expr,\n    ExprVisitor,\n    HasAttributeExpr,\n    InterpolateExpr,\n    LookupExpr,\n    MatchExpr,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StepExpr,\n    StringLiteralExpr,\n    VarExpr\n} from \"./Expr\";\n\n/**\n * [[ExprPool]] maintains a set of unique interned {@link Expr} objects.\n *\n * @hidden\n */\nexport class ExprPool implements ExprVisitor<Expr, void> {\n    private readonly m_booleanLiterals = new Map<boolean, BooleanLiteralExpr>();\n    private readonly m_numberLiterals = new Map<number, NumberLiteralExpr>();\n    private readonly m_stringLiterals = new Map<string, StringLiteralExpr>();\n    private readonly m_objectLiterals = new Map<object, ObjectLiteralExpr>();\n    private readonly m_arrayLiterals: ObjectLiteralExpr[] = [];\n    private readonly m_varExprs = new Map<string, VarExpr>();\n    private readonly m_hasAttributeExprs = new Map<string, HasAttributeExpr>();\n    private readonly m_matchExprs: MatchExpr[] = [];\n    private readonly m_caseExprs: CaseExpr[] = [];\n    private readonly m_interpolateExprs: InterpolateExpr[] = [];\n    private readonly m_stepExprs: StepExpr[] = [];\n    private readonly m_callExprs = new Map<string, CallExpr[]>();\n\n    /**\n     * Add `expr` to this [[ExprPool]] and return a unique {@link Expr}\n     * object that is structurally equivalent to `expr`.\n     *\n     * @param expr - The {@link Expr} to add to this [[ExprPool]].\n     * @returns A unique {@link Expr} that is structurally equivalent to `expr`.\n     */\n    add(expr: Expr): Expr {\n        return expr.accept(this, undefined);\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, context: void): Expr {\n        return NullLiteralExpr.instance;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: void): Expr {\n        const e = this.m_booleanLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_booleanLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: void): Expr {\n        const e = this.m_numberLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_numberLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, context: void): Expr {\n        const e = this.m_stringLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n        this.m_stringLiterals.set(expr.value, expr);\n        return expr;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: void): Expr {\n        const e = this.m_objectLiterals.get(expr.value);\n        if (e) {\n            return e;\n        }\n\n        if (Array.isArray(expr.value)) {\n            const array = expr.value as Value[];\n\n            const r = this.m_arrayLiterals.find(literal => {\n                const elements = literal.value as Value[];\n                if (elements.length !== array.length) {\n                    return false;\n                }\n                return array.every((x, i) => x === elements[i]);\n            });\n\n            if (r !== undefined) {\n                return r;\n            }\n\n            this.m_arrayLiterals.push(expr);\n        }\n\n        this.m_objectLiterals.set(expr.value, expr);\n\n        return expr;\n    }\n\n    visitVarExpr(expr: VarExpr, context: void): Expr {\n        const e = this.m_varExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_varExprs.set(expr.name, expr);\n        return expr;\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, context: void): Expr {\n        const e = this.m_hasAttributeExprs.get(expr.name);\n        if (e) {\n            return e;\n        }\n        this.m_hasAttributeExprs.set(expr.name, expr);\n        return expr;\n    }\n\n    visitMatchExpr(expr: MatchExpr, context: void): Expr {\n        const value = expr.value.accept(this, context);\n        const branches: typeof expr.branches = expr.branches.map(([label, body]) => [\n            label,\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n        for (const candidate of this.m_matchExprs) {\n            if (candidate.value !== value) {\n                continue;\n            }\n            if (candidate.fallback !== fallback) {\n                continue;\n            }\n            if (candidate.branches.length !== branches.length) {\n                continue;\n            }\n            let branchesMatching = true;\n            for (let i = 0; i < branches.length; i++) {\n                if (\n                    branches[i][0] !== candidate.branches[i][0] ||\n                    branches[i][1] !== candidate.branches[i][1]\n                ) {\n                    branchesMatching = false;\n                    break;\n                }\n            }\n            if (branchesMatching) {\n                return candidate;\n            }\n        }\n        const r = new MatchExpr(value, branches, fallback);\n        this.m_matchExprs.push(r);\n        return r;\n    }\n\n    visitCaseExpr(expr: CaseExpr, context: void): Expr {\n        const branches: typeof expr.branches = expr.branches.map(([condition, body]) => [\n            condition.accept(this, context),\n            body.accept(this, context)\n        ]);\n        const fallback = expr.fallback.accept(this, context);\n\n        for (const candidate of this.m_caseExprs) {\n            if (candidate.fallback !== fallback) {\n                continue;\n            }\n            if (candidate.branches.length !== branches.length) {\n                continue;\n            }\n            let branchesMatching = true;\n            for (let i = 0; i < branches.length; i++) {\n                if (\n                    branches[i][0] !== candidate.branches[i][0] ||\n                    branches[i][1] !== candidate.branches[i][1]\n                ) {\n                    branchesMatching = false;\n                    break;\n                }\n            }\n            if (branchesMatching) {\n                return candidate;\n            }\n        }\n\n        const r = new CaseExpr(branches, fallback);\n        this.m_caseExprs.push(r);\n        return r;\n    }\n\n    private visitCallExprImpl(\n        expr: CallExpr,\n        context: void,\n        constructor: (op: string, args: Expr[]) => CallExpr\n    ): Expr {\n        // rewrite the actual arguments\n        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));\n        // ensure we have a valid set of interned expressions for the calls\n        if (!this.m_callExprs.has(expr.op)) {\n            this.m_callExprs.set(expr.op, []);\n        }\n        // get the calls for the given operator.\n        const calls = this.m_callExprs.get(expr.op)!;\n        for (const call of calls) {\n            // check the number of arguments\n            if (call.args.length !== expressions.length) {\n                continue;\n            }\n            // find the index of the first mismatch.\n            let index = 0;\n            for (; index < call.args.length; ++index) {\n                if (call.args[index] !== expressions[index]) {\n                    break;\n                }\n            }\n            if (index === call.args.length) {\n                // no mismatch found, return the 'interned' call.\n                return call;\n            }\n        }\n        const e = constructor(expr.op, expressions);\n        e.descriptor = expr.descriptor;\n        calls.push(e);\n        return e;\n    }\n\n    visitCallExpr(expr: CallExpr, context: void): Expr {\n        return this.visitCallExprImpl(expr, context, (op: string, args: Expr[]) => {\n            return new CallExpr(op, args);\n        });\n    }\n\n    visitLookupExpr(expr: LookupExpr, context: void): Expr {\n        return this.visitCallExprImpl(expr, context, (op: string, args: Expr[]) => {\n            return new LookupExpr(args);\n        });\n    }\n\n    visitStepExpr(expr: StepExpr, context: void): Expr {\n        if (this.m_stepExprs.includes(expr)) {\n            return expr;\n        }\n        const input = expr.input.accept(this, context);\n        const defaultValue = expr.defaultValue.accept(this, context);\n        const stops: Array<[number, Expr]> = expr.stops.map(stop => {\n            const key = stop[0];\n            const value = stop[1].accept(this, context);\n            return value === stop[1] ? stop : [key, value];\n        });\n        for (const step of this.m_stepExprs) {\n            if (\n                step.input === input &&\n                step.defaultValue === defaultValue &&\n                stops.length === step.stops.length &&\n                stops.every(\n                    ([key, value], i) => key === step.stops[i][0] && value === step.stops[i][1]\n                )\n            ) {\n                return step;\n            }\n        }\n        const e = new StepExpr(input, defaultValue, stops);\n        this.m_stepExprs.push(e);\n        return e;\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, context: void): Expr {\n        if (this.m_interpolateExprs.includes(expr)) {\n            return expr;\n        }\n        const input = expr.input.accept(this, context);\n        const stops: Array<[number, Expr]> = expr.stops.map(stop => {\n            const key = stop[0];\n            const value = stop[1].accept(this, context);\n            return value === stop[1] ? stop : [key, value];\n        });\n        for (const interp of this.m_interpolateExprs) {\n            if (\n                interp.input === input &&\n                interp.mode[0] === expr.mode[0] &&\n                interp.mode[1] === expr.mode[1] &&\n                stops.length === interp.stops.length &&\n                stops.every(\n                    ([key, value], i) => key === interp.stops[i][0] && value === interp.stops[i][1]\n                )\n            ) {\n                return interp;\n            }\n        }\n        const e = new InterpolateExpr(expr.mode, input, stops);\n        this.m_interpolateExprs.push(e);\n        return e;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Feature details contains `feature.id`, `feature.properties.featureClass` which provides\n * possibility to define style in theme for particular feature.\n */\nexport interface FeatureDetails {\n    featureId?: string;\n    featureClass?: string;\n}\n\n/**\n * Represents \"Point\" GeoJSON geometry object.\n */\nexport interface Point {\n    type: \"Point\";\n    coordinates: number[];\n}\n\n/**\n * Represents \"MultiPoint\" GeoJSON geometry object.\n */\nexport interface MultiPoint {\n    type: \"MultiPoint\";\n    coordinates: number[][];\n}\n\n/**\n * Represents \"LineString\" GeoJSON geometry object.\n */\nexport interface LineString {\n    type: \"LineString\";\n    coordinates: number[][];\n}\n\n/**\n * Represents \"MultiLineString\" GeoJSON geometry object.\n */\nexport interface MultiLineString {\n    type: \"MultiLineString\";\n    coordinates: number[][][];\n}\n\n/**\n * Represents \"Polygon\" GeoJSON geometry object.\n */\nexport interface Polygon {\n    type: \"Polygon\";\n    coordinates: number[][][];\n}\n\n/**\n * Represents \"MultiPolygon\" GeoJSON geometry object.\n */\nexport interface MultiPolygon {\n    type: \"MultiPolygon\";\n    coordinates: number[][][][];\n}\n\n/**\n * Represents \"geometry\" property of \"Feature\" GeoJSON object.\n */\nexport type FeatureGeometry =\n    | Point\n    | MultiPoint\n    | LineString\n    | MultiLineString\n    | Polygon\n    | MultiPolygon;\n\nexport function isFeatureGeometry(object: any): object is FeatureGeometry {\n    const t = object.type;\n    return (\n        t === \"Point\" ||\n        t === \"MultiPoint\" ||\n        t === \"LineString\" ||\n        t === \"MultiLineString\" ||\n        t === \"Polygon\" ||\n        t === \"MultiPolygon\"\n    );\n}\n\n/**\n * Represents \"GeometryCollection\" GeoJSON geometry object.\n */\nexport interface GeometryCollection {\n    type: \"GeometryCollection\";\n    geometries: FeatureGeometry[];\n}\n\n/**\n * Represents \"Feature\" GeoJSON object.\n */\nexport interface Feature {\n    type: \"Feature\";\n    bbox?: number[];\n    id?: string;\n    geometry: FeatureGeometry | GeometryCollection;\n    properties?: any;\n    title?: string;\n}\n\n/**\n * Represents \"FeatureCollection\" GeoJSON object.\n */\nexport interface FeatureCollection {\n    type: \"FeatureCollection\";\n    features: Feature[];\n}\n\n/**\n * Represents a GeoJSON object.\n */\nexport type GeoJson = FeatureGeometry | GeometryCollection | Feature | FeatureCollection;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { JsonExpr } from \"./Expr\";\n\n/**\n * Interpolation mode used when computing a [[InterpolatedProperty]] value for a given zoom level.\n * @internal\n */\nexport enum InterpolationMode {\n    Discrete,\n    Linear,\n    Cubic,\n    Exponential\n}\n\n/**\n * Interpolated property could have its value (some initial value should be provided) changed\n * according to an interpolation type.\n *\n * Here is an example of an interpolated property from a map style:\n * \"lineWidth\": {\n *  \"interpolation\": \"Linear\",\n *  \"zoomLevels\": [13, 14, 15],\n *  \"values\": [ 1.5, 1.2, 0.9]\n * }\n * @internal\n */\nexport interface InterpolatedPropertyDefinition<T> {\n    interpolation?: \"Discrete\" | \"Linear\" | \"Cubic\" | \"Exponential\";\n    zoomLevels: number[];\n    values: T[];\n    exponent?: number;\n}\n\n/**\n * Checks if a property is interpolated.\n * @param p - property to be checked\n * @internal\n */\nexport function isInterpolatedPropertyDefinition<T>(\n    p: any\n): p is InterpolatedPropertyDefinition<T> {\n    if (\n        p &&\n        p.interpolationMode === undefined &&\n        Array.isArray(p.values) &&\n        p.values.length > 0 &&\n        p.values[0] !== undefined &&\n        Array.isArray(p.zoomLevels) &&\n        p.zoomLevels.length > 0 &&\n        p.zoomLevels[0] !== undefined &&\n        p.values.length === p.zoomLevels.length\n    ) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * Converts an [[InterpolatedPropertyDefinition]] to a [[JsonExpr]].\n *\n * @param property - A valid [[InterpolatedPropertyDefinition]]\n */\nexport function interpolatedPropertyDefinitionToJsonExpr(\n    property: InterpolatedPropertyDefinition<any>\n): JsonExpr {\n    if (property.interpolation === undefined || property.interpolation === \"Discrete\") {\n        const step: JsonExpr = [\"step\", [\"zoom\"], property.values[0]];\n        for (let i = 1; i < property.zoomLevels.length; ++i) {\n            step.push(property.zoomLevels[i], property.values[i]);\n        }\n        return step;\n    }\n    const interpolation: JsonExpr = [\"interpolate\"];\n    switch (property.interpolation) {\n        case \"Linear\":\n            interpolation.push([\"linear\"]);\n            break;\n        case \"Cubic\":\n            interpolation.push([\"cubic\"]);\n            break;\n        case \"Exponential\":\n            interpolation.push([\n                \"exponential\",\n                property.exponent !== undefined ? property.exponent : 2\n            ]);\n            break;\n        default:\n            throw new Error(`interpolation mode '${property.interpolation}' is not supported`);\n    } //switch\n    interpolation.push([\"zoom\"]);\n    for (let i = 0; i < property.zoomLevels.length; ++i) {\n        interpolation.push(property.zoomLevels[i], property.values[i]);\n    }\n    return interpolation;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst currEdgeStart = new THREE.Vector2();\nconst currEdgeGoal = new THREE.Vector2();\nconst prevEdgeStart = new THREE.Vector2();\nconst prevEdgeGoal = new THREE.Vector2();\n\n/**\n * Fills an index buffer with the indices for the edges of a polygon contour.\n *\n * @param indexBuffer - Edge index buffer to be filled.\n * @param vertexOffset - Starting offset of the vertices composing the contour.\n * @param vertexStride - Number of elements per contour vertex.\n * @param polygonContour - Vertices that compose the contour.\n * @param polygonContourEdges - Collection of booleans indicating if contour edges should be added.\n */\nexport function addPolygonEdges(\n    indexBuffer: number[],\n    vertexOffset: number,\n    vertexStride: number,\n    polygonContour: number[],\n    polygonContourEdges: boolean[],\n    isExtruded?: boolean,\n    addFootprintEdges?: boolean,\n    wallEdgeSlope?: number\n) {\n    for (let i = 0; i < polygonContourEdges.length; ++i) {\n        if (polygonContourEdges[i]) {\n            if (isExtruded === true) {\n                const vFootprint0 = vertexOffset + i * 2;\n                const vRoof0 = vFootprint0 + 1;\n                const vFootprint1 = vertexOffset + ((i + 1) % polygonContourEdges.length) * 2;\n                const vRoof1 = vFootprint1 + 1;\n\n                if (addFootprintEdges === true) {\n                    indexBuffer.push(vFootprint0, vFootprint1);\n                }\n                indexBuffer.push(vRoof0, vRoof1);\n\n                const prevEdgeIdx = (i === 0 ? polygonContourEdges.length : i) - 1;\n                if (polygonContourEdges[prevEdgeIdx]) {\n                    if (wallEdgeSlope !== undefined) {\n                        const v0x = polygonContour[i * vertexStride];\n                        const v0y = polygonContour[i * vertexStride + 1];\n                        const v1x =\n                            polygonContour[((i + 1) % polygonContourEdges.length) * vertexStride];\n                        const v1y =\n                            polygonContour[\n                                ((i + 1) % polygonContourEdges.length) * vertexStride + 1\n                            ];\n\n                        currEdgeStart.set(v0x, v0y);\n                        currEdgeGoal.set(v1x, v1y);\n                        prevEdgeStart.set(\n                            polygonContour[prevEdgeIdx * vertexStride],\n                            polygonContour[prevEdgeIdx * vertexStride + 1]\n                        );\n                        prevEdgeGoal.set(currEdgeStart.x, currEdgeStart.y);\n\n                        if (\n                            prevEdgeGoal\n                                .sub(prevEdgeStart)\n                                .normalize()\n                                .dot(currEdgeGoal.sub(currEdgeStart).normalize()) <= wallEdgeSlope\n                        ) {\n                            indexBuffer.push(vFootprint0, vRoof0);\n                        }\n                    } else {\n                        indexBuffer.push(vFootprint0, vRoof0);\n                    }\n                }\n            } else {\n                const vFoot0 = vertexOffset + i;\n                const vRoof0 = vertexOffset + ((i + 1) % polygonContourEdges.length);\n                indexBuffer.push(vFoot0, vRoof0);\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst RX = /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/;\n\n/**\n * A class representing Pixels.\n *\n * @hidden\n * @internal\n */\nexport class Pixels {\n    /**\n     * Parses a pixel string literal.\n     *\n     * @param text - The string color literal\n     */\n    static parse(text: string): Pixels | undefined {\n        const match = RX.exec(text);\n        if (match === null) {\n            return undefined;\n        }\n        return new Pixels(Number(match[1]));\n    }\n\n    /**\n     * Constructs a [[Pixels]] literal\n     *\n     * @param value - The number of pixels.\n     */\n    constructor(readonly value: number) {}\n\n    toJSON() {\n        return `${this.value}px`;\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { Env } from \"./Env\";\nimport { Expr, ExprScope, Value } from \"./Expr\";\nimport { Pixels } from \"./Pixels\";\nimport { RGBA } from \"./RGBA\";\nimport { parseStringEncodedNumeral } from \"./StringEncodedNumeral\";\n\nconst logger = LoggerManager.instance.create(\"PropertyValue\");\n\n/**\n * Get the value of the specified property in given `env`.\n *\n * @param property - Property of a technique.\n * @param env - The {@link Env} used to evaluate the property\n * @param cache - An optional expression cache.\n */\nexport function getPropertyValue(\n    property: Value | undefined,\n    env: Env,\n    cache?: Map<Expr, Value>\n): any {\n    if (Expr.isExpr(property)) {\n        try {\n            let r = property.evaluate(env, ExprScope.Dynamic, cache);\n\n            if (typeof r === \"string\") {\n                r = RGBA.parse(r) ?? Pixels.parse(r) ?? r;\n            }\n\n            if (r instanceof RGBA) {\n                return r.getHex();\n            } else if (r instanceof Pixels) {\n                return r.value * (Number(env.lookup(\"$pixelToMeters\")) ?? 1);\n            }\n            return r;\n        } catch (error) {\n            logger.error(\n                \"failed to evaluate expression\",\n                JSON.stringify(property),\n                \"error\",\n                String(error)\n            );\n            return null;\n        }\n    }\n\n    if (property === null || typeof property === \"undefined\") {\n        return null;\n    } else if (typeof property !== \"string\") {\n        // Property in numeric or array, etc. format\n        return property;\n    } else {\n        // Non-interpolated string encoded numeral parsing\n        const pixelToMeters = (env.lookup(\"$pixelToMeters\") as number) || 1;\n        const value = parseStringEncodedNumeral(property, pixelToMeters);\n        return value !== undefined ? value : property;\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { MathUtils } from \"three\";\n\nimport { ColorUtils } from \"./ColorUtils\";\nimport { parseStringEncodedColor } from \"./StringEncodedNumeral\";\n\n/**\n * A class representing RGBA colors.\n *\n * @hidden\n * @internal\n */\nexport class RGBA {\n    /**\n     * Parses a string describing a color.\n     *\n     * @param text - The string color literal\n     */\n    static parse(text: string) {\n        const color = parseStringEncodedColor(text);\n\n        if (color === undefined) {\n            return undefined;\n        }\n\n        return ColorUtils.getRgbaFromHex(color);\n    }\n\n    /**\n     * Constructs a [[RGBA]] color using the given components in the [0..1] range.\n     */\n    constructor(\n        public r: number = 1,\n        public g: number = 1,\n        public b: number = 1,\n        public a: number = 1\n    ) {}\n\n    /**\n     * Clones this [[RGBA]] color.\n     */\n    clone() {\n        return new RGBA(this.r, this.g, this.b, this.a);\n    }\n\n    /**\n     * Returns this color encoded as one single number.\n     */\n    getHex() {\n        return ColorUtils.getHexFromRgba(this.r, this.g, this.b, this.a);\n    }\n\n    /**\n     * Linearly interpolate the components of this color.\n     */\n    lerp(target: RGBA, t: number) {\n        this.r = MathUtils.lerp(this.r, target.r, t);\n        this.g = MathUtils.lerp(this.g, target.g, t);\n        this.b = MathUtils.lerp(this.b, target.b, t);\n        this.a = MathUtils.lerp(this.a, target.a, t);\n        return this;\n    }\n\n    /**\n     * Returns this color encoded as JSON literal.\n     */\n    toJSON() {\n        return `rgba(${(this.r * 255) << 0}, ${(this.g * 255) << 0}, ${(this.b * 255) << 0}, ${\n            this.a\n        })`;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { assert } from \"@here/harp-utils\";\n//@ts-ignore\nimport { parseCSSColor } from \"csscolorparser\";\n\nimport { ColorUtils } from \"./ColorUtils\";\n\n/**\n * Enumeration of supported string encoded numerals.\n * @internal\n */\nexport enum StringEncodedNumeralType {\n    Meters,\n    Pixels,\n    Hex\n}\n\n/**\n * Interface containing information about a [[StringEncodedNumeral]] format, component size and\n * evaluation.\n * @internal\n */\nexport interface StringEncodedNumeralFormat {\n    readonly type: StringEncodedNumeralType;\n    readonly size: number;\n    readonly regExp: RegExp;\n    mask?: number;\n    decoder: (encodedValue: string, target: number[]) => boolean;\n}\nconst StringEncodedMeters: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.Meters,\n    size: 1,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))m$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const match = StringEncodedMeters.regExp.exec(encodedValue);\n        return match ? (target[0] = Number(match[1])) !== undefined : false;\n    }\n};\nconst StringEncodedPixels: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.Pixels,\n    size: 1,\n    mask: 1.0,\n    regExp: /^((?=\\.\\d|\\d)(?:\\d+)?(?:\\.?\\d*))px$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const match = StringEncodedPixels.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        target[0] = Number(match[1]);\n        return true;\n    }\n};\nconst StringEncodedHex: StringEncodedNumeralFormat = {\n    type: StringEncodedNumeralType.Hex,\n    size: 4,\n    regExp: /^\\#((?:[0-9A-Fa-f][0-9A-Fa-f]){4}|[0-9A-Fa-f]{4})$/,\n    decoder: (encodedValue: string, target: number[]) => {\n        const match = StringEncodedHex.regExp.exec(encodedValue);\n        if (match === null) {\n            return false;\n        }\n        const hex = match[1];\n        const size = hex.length;\n        // Only few sizes are possible for given reg-exp.\n        assert(size === 4 || size === 8, `Matched incorrect hex color format`);\n        // Note that we simply ignore alpha channel value.\n        // TODO: To be resolved with HARP-7517\n        if (size === 4) {\n            // #RGB or #RGBA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;\n        } else if (size === 8) {\n            // #RRGGBB or #RRGGBBAA\n            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;\n        }\n        return true;\n    }\n};\n\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.\n * @internal\n */\nexport const StringEncodedMetricFormats: StringEncodedNumeralFormat[] = [\n    StringEncodedMeters,\n    StringEncodedPixels\n];\n\nconst StringEncodedMetricFormatMaxSize = StringEncodedMetricFormats.reduce(\n    (a, b) => Math.max(a, b.size),\n    0\n);\n\n/**\n * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.\n * @internal\n */\nexport const StringEncodedColorFormats: StringEncodedNumeralFormat[] = [StringEncodedHex];\n\nconst StringEncodedColorFormatMaxSize = StringEncodedColorFormats.reduce(\n    (a, b) => Math.max(a, b.size),\n    0\n);\n\n/**\n * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with\n * [[StringEncodedNumeralType]] enum).\n * @internal\n */\nexport const StringEncodedNumeralFormats: StringEncodedNumeralFormat[] = [\n    ...StringEncodedMetricFormats,\n    ...StringEncodedColorFormats\n];\n\n/**\n * @internal\n */\nexport const StringEncodedNumeralFormatMaxSize = Math.max(\n    StringEncodedColorFormatMaxSize,\n    StringEncodedMetricFormatMaxSize\n);\n\nconst tmpBuffer: number[] = new Array(StringEncodedNumeralFormatMaxSize);\n\n/**\n * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].\n *\n * @param numeral - The string representing numeric value.\n * @param pixelToMeters - The ratio used to convert from meters to pixels (default 1.0).\n * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression\n * provided in [[numeral]].\n */\nexport function parseStringEncodedNumeral(\n    numeral: string,\n    pixelToMeters: number = 1.0\n): number | undefined {\n    return parseStringLiteral(numeral, StringEncodedNumeralFormats, pixelToMeters);\n}\n\n/**\n * Parse string encoded color value using all known [[StringEncodedColorFormats]].\n *\n * @param color - The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).\n * @returns The color parsed or __undefined__ if non of the known representations matches\n * the expression provided in [[color]].\n */\nexport function parseStringEncodedColor(color: string): number | undefined {\n    return parseStringLiteral(color, StringEncodedColorFormats);\n}\n\nfunction parseStringLiteral(\n    text: string,\n    formats: StringEncodedNumeralFormat[],\n    pixelToMeters: number = 1.0\n): number | undefined {\n    const matchedFormat = formats.find(format => {\n        return format.decoder(text, tmpBuffer) ? true : false;\n    });\n\n    if (matchedFormat === undefined) {\n        const components: number[] | null = parseCSSColor(text);\n\n        return Array.isArray(components) && !components.some(c => isNaN(c))\n            ? ColorUtils.getHexFromRgba(\n                  components[0] / 255,\n                  components[1] / 255,\n                  components[2] / 255,\n                  components[3]\n              )\n            : undefined;\n    }\n\n    switch (matchedFormat?.type) {\n        case StringEncodedNumeralType.Pixels:\n            return tmpBuffer[0] * pixelToMeters;\n        case StringEncodedNumeralType.Hex:\n            return ColorUtils.getHexFromRgba(\n                tmpBuffer[0],\n                tmpBuffer[1],\n                tmpBuffer[2],\n                tmpBuffer[3]\n            );\n        default:\n            return tmpBuffer[0];\n    }\n}\n","/*\n * Copyright (C) 2019-2022 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport {\n    BooleanLiteralExpr,\n    CallExpr,\n    CaseExpr,\n    Env,\n    Expr,\n    ExprScope,\n    ExprVisitor,\n    HasAttributeExpr,\n    InterpolateExpr,\n    isJsonExpr,\n    JsonExpr,\n    LiteralExpr,\n    LookupExpr,\n    MatchExpr,\n    NullLiteralExpr,\n    NumberLiteralExpr,\n    ObjectLiteralExpr,\n    StepExpr,\n    StringLiteralExpr,\n    Value,\n    VarExpr\n} from \"./Expr\";\nimport { ExprPool } from \"./ExprPool\";\nimport {\n    interpolatedPropertyDefinitionToJsonExpr,\n    isInterpolatedPropertyDefinition\n} from \"./InterpolatedPropertyDefs\";\nimport { DecoderOptions } from \"./ITileDecoder\";\nimport { AttrScope, getTechniqueAttributeDescriptor } from \"./TechniqueDescriptors\";\nimport { IndexedTechnique, setTechniqueRenderOrderOrPriority, Technique } from \"./Techniques\";\nimport { Definitions, Style, StyleSet } from \"./Theme\";\n\nconst logger = LoggerManager.instance.create(\"StyleSetEvaluator\");\n\nconst DEFAULT_TECHNIQUE_ATTR_SCOPE = AttrScope.TechniqueGeometry;\n\n/**\n * Get the attribute scope of the given style property.\n *\n * @remarks\n * Certain Style properties change their dynamic scope behavior\n * based on other properties. For example, the `color` property\n * of `extruded-polygon` change behavior based on the usage\n * of `vertexColors`.\n *\n * @param style A valid Style.\n * @param attrName The name of the attribute of the {@link style}.\n */\nfunction getStyleAttributeScope(style: InternalStyle, attrName: string): AttrScope {\n    if (style.technique === \"extruded-polygon\") {\n        if (attrName === \"color\" && style.vertexColors !== false) {\n            return DEFAULT_TECHNIQUE_ATTR_SCOPE;\n        }\n    }\n\n    return (\n        getTechniqueAttributeDescriptor(style.technique, attrName)?.scope ??\n        DEFAULT_TECHNIQUE_ATTR_SCOPE\n    );\n}\n\ninterface StyleInternalParams {\n    /**\n     * Optimization: Lazy creation and storage of expression in a style object.\n     */\n    _whenExpr?: Expr;\n    _minZoomLevelExpr?: Expr;\n    _maxZoomLevelExpr?: Expr;\n\n    _staticAttributes?: Array<[string, Value]>;\n\n    /**\n     * These attributes are used to instantiate Technique variants.\n     *\n     * @see [[TechiqueDescriptor.techniquePropNames]]\n     */\n    _dynamicTechniqueAttributes?: Array<[string, Expr]>;\n\n    /**\n     * These attributes must be evaluated basing with feature env.\n     *\n     * They are not propagated to rendering scope.\n     *\n     * @see [[TechniqueAttrScope.Feature]]\n     */\n    _dynamicFeatureAttributes?: Array<[string, Expr]>;\n\n    /**\n     * These attributes are forwarded as serialized by decoder to main thread, so they are resolved\n     * directly in render loop.\n     *\n     * Will contain attributes from these lists\n     *  - interpolants from [[TechiqueDescriptor.techniquePropNames]]\n     *  - expressions [[TechniqueDescriptor.dynamicPropNames]] (Future)\n     */\n    _dynamicForwardedAttributes?: Array<[string, Expr]>;\n    _dynamicTechniques?: Map<string, IndexedTechnique>;\n\n    /**\n     * Optimization: Index into table in StyleSetEvaluator.\n     * @hidden\n     */\n    _staticTechnique?: IndexedTechnique;\n\n    /**\n     * Optimization: StyleSet index.\n     * @hidden\n     */\n    _styleSetIndex?: number;\n\n    /**\n     * Optimization: Requested $geometryType.\n     * @hidden\n     */\n    _geometryType?: string;\n\n    /**\n     * `true` if any of the properties of this technique\n     * requires access to the feature's state.\n     */\n    _usesFeatureState?: boolean;\n}\n\ntype InternalStyle = Style & StyleInternalParams;\n\n/**\n * `StyleConditionClassifier` searches for usages of `$layer` in `when` conditions\n * associated with styling rules.\n *\n * @hidden\n */\nclass StyleConditionClassifier implements ExprVisitor<Expr | undefined, Expr | undefined> {\n    private _style!: InternalStyle;\n\n    classify(style: InternalStyle) {\n        if (style._whenExpr) {\n            const savedStyle = this.switchStyle(style);\n            style._whenExpr = style._whenExpr.accept(this, undefined);\n            this._style = savedStyle;\n        }\n    }\n\n    visitNullLiteralExpr(expr: NullLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitNumberLiteralExpr(expr: NumberLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitStringLiteralExpr(expr: StringLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitObjectLiteralExpr(expr: ObjectLiteralExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitVarExpr(expr: VarExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitHasAttributeExpr(expr: HasAttributeExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitMatchExpr(expr: MatchExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitCaseExpr(expr: CaseExpr, enclosingExpr: Expr | undefined): Expr {\n        return expr;\n    }\n\n    visitCallExpr(call: CallExpr, enclosingExpr: Expr | undefined): Expr | undefined {\n        if (call.op === \"all\") {\n            // processing of an `[\"all\", e1, e2, ... eN]` expression. In this case\n            // search for expressions matching comparison of `$layer` and string literals\n            // in the sub expressions.\n            const children = call.args\n                .map(childExpr => childExpr.accept(this, call))\n                .filter(childExpr => childExpr !== undefined) as Expr[];\n\n            return new CallExpr(call.op, children);\n        } else if (enclosingExpr) {\n            // `call` is a direct child expression of an `\"all\"` operator.\n            const matched = this.matchVarStringComparison(call);\n\n            if (matched) {\n                if (this._style.layer === undefined && matched.name === \"$layer\") {\n                    // found a subexpression `[\"==\", [\"get\", \"$layer\"], \"some layer name\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $layer in\n                    // [[StyleInternalParams]].\n\n                    this._style.layer = matched.value;\n\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                } else if (\n                    this._style._geometryType === undefined &&\n                    matched.name === \"$geometryType\"\n                ) {\n                    // found a subexpression `[\"==\", [\"get\", \"$geometryType\"], \"geometry\"]`\n                    // enclosed in an `[\"all\", e1...eN]` expression. Remove it from\n                    // its parent expression and store the value of the expected $geometryType in\n                    // [[StyleInternalParams]].\n\n                    this._style._geometryType = matched.value;\n\n                    // return `undefined` to remove this sub expression from its parent.\n                    return undefined;\n                }\n            }\n        }\n\n        return call;\n    }\n\n    visitLookupExpr(lookup: LookupExpr, enclosingExpr: Expr | undefined): Expr | undefined {\n        return this.visitCallExpr(lookup, enclosingExpr);\n    }\n\n    visitStepExpr(expr: StepExpr, enclosingExpr: Expr | undefined): Expr | undefined {\n        return expr;\n    }\n\n    visitInterpolateExpr(expr: InterpolateExpr, enclosingExpr: Expr | undefined): Expr | undefined {\n        return expr;\n    }\n\n    /**\n     * Tests if the given `call` matches the structure [\"==\", [\"get\", name], value].\n     * If a match is found returns an object containing the `name` and the `value`;\n     *\n     * @param call - The expression to match.\n     */\n    private matchVarStringComparison(call: CallExpr) {\n        if (call.op === \"==\") {\n            const left = call.args[0];\n            const right = call.args[1];\n\n            if (left instanceof VarExpr && right instanceof StringLiteralExpr) {\n                return { name: left.name, value: right.value };\n            }\n\n            if (right instanceof VarExpr && left instanceof StringLiteralExpr) {\n                return { name: right.name, value: left.value };\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Sets the given `style` as current.\n     *\n     * @returns The previous `style`.\n     */\n    private switchStyle(style: InternalStyle) {\n        const saved = this._style;\n        this._style = style;\n        return saved;\n    }\n}\n\nclass OptimizedSubSetKey {\n    key: string;\n    layer: string | undefined;\n    geometryType: string | undefined;\n\n    cachedStyleSet?: InternalStyle[];\n\n    constructor(layer?: string | undefined, geometryType?: string | undefined) {\n        this.key = \"\";\n        this.set(layer, geometryType);\n    }\n\n    set(\n        layer: string | undefined,\n        geometryType: string | undefined,\n        env?: Env\n    ): OptimizedSubSetKey {\n        let keyUpdateNeeded: boolean = false;\n        if (layer === undefined) {\n            const envLayer = env !== undefined ? env.lookup(\"$layer\") : undefined;\n            layer = typeof envLayer === \"string\" ? envLayer : undefined;\n        }\n        if (this.layer !== layer) {\n            this.layer = layer;\n            keyUpdateNeeded = true;\n        }\n\n        if (geometryType === undefined) {\n            const envGeometryType = env !== undefined ? env.lookup(\"$geometryType\") : undefined;\n            geometryType = typeof envGeometryType === \"string\" ? envGeometryType : undefined;\n        }\n        if (this.geometryType !== geometryType) {\n            this.geometryType = geometryType;\n            keyUpdateNeeded = true;\n        }\n\n        if (keyUpdateNeeded) {\n            this.updateKey();\n        }\n        return this;\n    }\n\n    private updateKey() {\n        if (this.layer !== undefined) {\n            if (this.geometryType !== undefined) {\n                this.key = `${this.layer}:${this.geometryType}`;\n            } else {\n                this.key = `${this.layer}:`;\n            }\n        } else {\n            if (this.geometryType !== undefined) {\n                this.key = `:${this.geometryType}`;\n            } else {\n                this.key = \"all\";\n            }\n        }\n        this.cachedStyleSet = undefined;\n    }\n}\n\n/**\n * Options to be passed to the StyleSetEvaluator\n *\n * Basically identical as the DecoderOptions but requires styleSet to be set.\n */\nexport type StyleSetOptions = Omit<DecoderOptions, \"languages\"> & { styleSet: StyleSet };\n\n/**\n * Combine data from datasource and apply the rules from a specified theme to show it on the map.\n */\nexport class StyleSetEvaluator {\n    readonly styleSet: InternalStyle[];\n\n    private readonly m_techniques: IndexedTechnique[] = [];\n    private readonly m_exprPool = new ExprPool();\n    private readonly m_cachedResults = new Map<Expr, Value>();\n    private readonly m_styleConditionClassifier = new StyleConditionClassifier();\n    private readonly m_subStyleSetCache = new Map<string, InternalStyle[]>();\n    private readonly m_definitions?: Definitions;\n    private readonly m_definitionExprCache = new Map<string, Expr>();\n    private readonly m_tmpOptimizedSubSetKey: OptimizedSubSetKey = new OptimizedSubSetKey();\n    private readonly m_emptyEnv = new Env();\n    private m_featureDependencies: string[] = [];\n    private m_layer: string | undefined;\n    private m_geometryType: string | undefined;\n    private m_zoomLevel: number | undefined;\n    private m_previousResult: IndexedTechnique[] | undefined;\n    private m_previousEnv: Env | undefined;\n    private m_nextArrayBufferId = 0;\n\n    constructor(private readonly m_options: StyleSetOptions) {\n        this.m_definitions = this.m_options.definitions;\n        this.styleSet = resolveReferences(this.m_options.styleSet, this.m_definitions);\n        computeDefaultRenderOrder(this.styleSet);\n        this.compileStyleSet();\n    }\n\n    /**\n     * Find all techniques that fit the current objects' environment.\n     * *The techniques in the resulting array may not be modified* since they are being reused for\n     * identical objects.\n     *\n     * @param env - The objects environment, i.e. the attributes that are relevant for its\n     * representation.\n     * @param layer - The optional layer name used to filter techniques.\n     * @param geometryType - The optional geometryType used to filter techniques.\n     */\n    getMatchingTechniques(\n        env: Env,\n        layer?: string | undefined,\n        geometryType?: string | undefined\n    ): IndexedTechnique[] {\n        if (\n            this.m_previousResult &&\n            this.m_previousEnv &&\n            this.m_featureDependencies.every(p => this.m_previousEnv?.lookup(p) === env.lookup(p))\n        ) {\n            return this.m_previousResult;\n        }\n\n        const result: IndexedTechnique[] = [];\n        this.m_cachedResults.clear();\n\n        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;\n        optimizedSubSetKey.set(layer, geometryType, env);\n\n        // get the requested $layer and $geometryType, if any.\n        this.m_layer = optimizedSubSetKey.layer;\n        this.m_geometryType = optimizedSubSetKey.geometryType;\n        this.m_zoomLevel = env.lookup(\"$zoom\") as number | undefined;\n\n        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);\n\n        for (const currStyle of searchedStyleSet) {\n            if (this.processStyle(env, currStyle, result)) {\n                break;\n            }\n        }\n\n        this.m_previousResult = result;\n        this.m_previousEnv = env;\n\n        return result;\n    }\n\n    /**\n     * Check if `styleSet` contains any rule related to `layer`.\n     *\n     * @param layer - name of layer\n     */\n    wantsLayer(layer: string): boolean {\n        return (\n            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0\n        );\n    }\n\n    /**\n     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.\n     *\n     * @param layer - name of layer\n     * @param geometryType - type of layer - `point`, `line` or `polygon`\n     */\n    wantsFeature(layer: string, geometryType?: string): boolean {\n        return (\n            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))\n                .length > 0\n        );\n    }\n\n    /**\n     * Reset array of techniques.\n     *\n     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.\n     */\n    resetTechniques() {\n        for (const techinque of this.m_techniques) {\n            techinque._index = undefined!;\n        }\n        this.m_techniques.length = 0;\n        this.m_previousResult = undefined;\n        this.m_previousEnv = undefined;\n    }\n\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get techniques(): IndexedTechnique[] {\n        return this.m_techniques;\n    }\n\n    /**\n     * Get the (current) array of techniques that have been created during decoding.\n     */\n    get decodedTechniques(): IndexedTechnique[] {\n        return this.m_techniques.map(makeDecodedTechnique);\n    }\n\n    private getOptimizedStyleSet(subSetKey: OptimizedSubSetKey): InternalStyle[] {\n        if (subSetKey.cachedStyleSet !== undefined) {\n            return subSetKey.cachedStyleSet;\n        }\n        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);\n        if (optimizedStyleSet !== undefined) {\n            subSetKey.cachedStyleSet = optimizedStyleSet;\n            return optimizedStyleSet;\n        }\n        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);\n        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);\n        subSetKey.cachedStyleSet = optimizedStyleSet;\n        return optimizedStyleSet;\n    }\n\n    private createPreFilteredStyleSet(subSetKey: OptimizedSubSetKey) {\n        const { layer, geometryType } = subSetKey;\n\n        return this.styleSet.filter(style => {\n            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {\n                return false;\n            }\n            if (\n                geometryType !== undefined &&\n                style._geometryType !== undefined &&\n                style._geometryType !== geometryType\n            ) {\n                return false;\n            }\n            return true;\n        });\n    }\n\n    /**\n     * Compile the `when` conditions found when traversting the styling rules.\n     */\n    private compileStyleSet() {\n        this.m_featureDependencies = [\"$layer\", \"$geometryType\", \"$zoom\"];\n\n        this.styleSet.forEach(style => this.compileStyle(style));\n\n        // Create optimized styleSets for each `layer` & `geometryType` tuple.\n        this.styleSet.forEach(style => {\n            this.getOptimizedStyleSet(\n                this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType)\n            );\n        });\n    }\n\n    /**\n     * Compile the `when` conditions reachable from the given `style`.\n     *\n     * @param style - The current style.\n     */\n    private compileStyle(style: InternalStyle) {\n        this.checkStyleDynamicAttributes(style);\n\n        if (style.when !== undefined) {\n            try {\n                style._whenExpr = Array.isArray(style.when)\n                    ? Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)\n                    : Expr.parse(style.when);\n\n                // search for usages of '$layer' and any other\n                // special symbol that can be used to speed up the evaluation\n                // of the `when` conditions associated to this `style`.\n                this.m_styleConditionClassifier.classify(style);\n\n                if (style._whenExpr !== undefined) {\n                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);\n                }\n\n                const deps = style._whenExpr.dependencies();\n\n                deps?.properties.forEach(prop => {\n                    if (!this.m_featureDependencies.includes(prop)) {\n                        this.m_featureDependencies.push(prop);\n                    }\n                });\n\n                if (isJsonExpr(style.minZoomLevel)) {\n                    style._minZoomLevelExpr = Expr.fromJSON(\n                        style.minZoomLevel,\n                        this.m_definitions\n                    ).intern(this.m_exprPool);\n                }\n\n                if (isJsonExpr(style.maxZoomLevel)) {\n                    style._maxZoomLevelExpr = Expr.fromJSON(\n                        style.maxZoomLevel,\n                        this.m_definitions\n                    ).intern(this.m_exprPool);\n                }\n            } catch (err) {\n                logger.log(\n                    \"failed to evaluate expression\",\n                    JSON.stringify(style.when),\n                    \"error\",\n                    String(err)\n                );\n            }\n        }\n    }\n\n    /**\n     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the\n     * current objects' environment. The attributes of the styles are assembled to create a unique\n     * technique for every object.\n     *\n     * @param env - The objects environment, i.e. the attributes that are relevant for its\n     *            representation.\n     * @param style - Current style (could also be top of stack).\n     * @param result - The array of resulting techniques. There may be more than one technique per\n     *               object, resulting in multiple graphical objects for representation.\n     * @returns `true` if style has been found and processing is finished. `false` if not found, or\n     *          more than one technique should be applied.\n     */\n    private processStyle(env: Env, style: InternalStyle, result: Technique[]): boolean {\n        if (!this.checkZoomLevel(env, style)) {\n            return false;\n        }\n\n        if (\n            this.m_layer !== undefined &&\n            style.layer !== undefined &&\n            style.layer !== this.m_layer\n        ) {\n            return false;\n        }\n        if (\n            this.m_geometryType !== undefined &&\n            style._geometryType !== undefined &&\n            style._geometryType !== this.m_geometryType\n        ) {\n            return false;\n        }\n\n        if (style._whenExpr) {\n            try {\n                if (!style._whenExpr.evaluate(env, ExprScope.Condition, this.m_cachedResults)) {\n                    // Stop processing this styling rule. The `when` condition\n                    // associated with the current `style` evaluates to false so\n                    // no techinque defined by this style should be applied.\n                    return false;\n                }\n            } catch (error) {\n                logger.error(\n                    `failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`\n                );\n                return false;\n            }\n        }\n\n        if (style.technique === undefined) {\n            return false;\n        }\n        // we found a technique!\n        if (style.technique !== \"none\") {\n            result.push(this.getTechniqueForStyleMatch(env, style));\n        }\n        // stop processing if \"final\" is set\n        return style.final === true;\n    }\n\n    private checkZoomLevel(env: Env, style: InternalStyle) {\n        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {\n            return true;\n        }\n\n        const zoomLevel = this.m_zoomLevel;\n        if (zoomLevel === undefined) {\n            return true;\n        }\n\n        if (style.minZoomLevel !== undefined) {\n            let minZoomLevel: Value = style.minZoomLevel;\n\n            if (style._minZoomLevelExpr?.isDynamic() === false) {\n                // Only filter by zoom level if the expression is not dynamic.\n                try {\n                    minZoomLevel = style._minZoomLevelExpr.evaluate(\n                        env,\n                        ExprScope.Condition,\n                        this.m_cachedResults\n                    );\n                } catch (error) {\n                    logger.error(\n                        `failed to evaluate expression '${JSON.stringify(\n                            style._minZoomLevelExpr\n                        )}': ${error}`\n                    );\n                }\n            }\n\n            if (typeof minZoomLevel === \"number\" && zoomLevel < minZoomLevel) {\n                return false;\n            }\n        }\n\n        if (style.maxZoomLevel !== undefined) {\n            let maxZoomLevel: Value = style.maxZoomLevel;\n\n            if (style._maxZoomLevelExpr?.isDynamic() === false) {\n                // Only filter by zoom level if the expression is not dynamic.\n                try {\n                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(\n                        env,\n                        ExprScope.Condition,\n                        this.m_cachedResults\n                    );\n                } catch (error) {\n                    logger.error(\n                        `failed to evaluate expression '${JSON.stringify(\n                            style._maxZoomLevelExpr\n                        )}': ${error}`\n                    );\n                }\n            }\n\n            if (typeof maxZoomLevel === \"number\" && zoomLevel >= maxZoomLevel) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private getTechniqueForStyleMatch(env: Env, style: InternalStyle) {\n        let technique: IndexedTechnique | undefined;\n        if (style._dynamicTechniques !== undefined) {\n            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);\n            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);\n            technique = style._dynamicTechniques!.get(key);\n            if (technique === undefined) {\n                technique = this.createTechnique(style, key, dynamicAttributes);\n                style._dynamicTechniques!.set(key, technique);\n            }\n        } else {\n            technique = style._staticTechnique;\n            if (technique === undefined) {\n                style._staticTechnique = technique = this.createTechnique(\n                    style,\n                    `${style._styleSetIndex}`,\n                    []\n                ) as IndexedTechnique;\n            }\n        }\n\n        if (technique._index === undefined) {\n            technique._index = this.m_techniques.length;\n            this.m_techniques.push(technique);\n        }\n        return technique;\n    }\n\n    private getDynamicTechniqueKey(\n        style: InternalStyle,\n        dynamicAttributes: Array<[string, Value]>\n    ) {\n        const dynamicAttrKey = dynamicAttributes\n            .map(([_attrName, attrValue]) => {\n                if (attrValue === undefined) {\n                    return \"U\";\n                } else if (typeof attrValue === \"object\") {\n                    return JSON.stringify(attrValue, (_, value) => {\n                        if (value instanceof ArrayBuffer) {\n                            // ArrayBuffers cannot be directly stringified. They can be converted\n                            // to typed arrays and then stringified, but it's too slow. Instead,\n                            // assign them unique ids.\n                            let arrayBufferId = (value as any).id;\n                            if (arrayBufferId === undefined) {\n                                arrayBufferId = (value as any).id = this.m_nextArrayBufferId++;\n                            }\n                            return arrayBufferId;\n                        }\n                        return value;\n                    });\n                } else {\n                    return JSON.stringify(attrValue);\n                }\n            })\n            .join(\":\");\n        return `${style._styleSetIndex!}:${dynamicAttrKey}`;\n    }\n\n    private checkStyleDynamicAttributes(style: InternalStyle) {\n        if (style._dynamicTechniqueAttributes !== undefined || style.technique === \"none\") {\n            return;\n        }\n\n        style._dynamicTechniqueAttributes = [];\n        style._dynamicFeatureAttributes = [];\n        style._dynamicForwardedAttributes = [];\n        style._staticAttributes = [];\n\n        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;\n        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;\n        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;\n        const targetStaticAttributes = style._staticAttributes;\n\n        const processAttribute = (attrName: string, attrValue: Value | JsonExpr | undefined) => {\n            if (attrValue === undefined) {\n                return;\n            }\n\n            if (isJsonExpr(attrValue)) {\n                attrValue = Expr.fromJSON(\n                    attrValue,\n                    this.m_definitions,\n                    this.m_definitionExprCache\n                ).intern(this.m_exprPool);\n            } else if (isInterpolatedPropertyDefinition(attrValue)) {\n                // found a property using an object-like interpolation definition.\n                attrValue = Expr.fromJSON(\n                    interpolatedPropertyDefinitionToJsonExpr(attrValue)\n                ).intern(this.m_exprPool);\n            }\n\n            if (Expr.isExpr(attrValue)) {\n                const deps = attrValue.dependencies();\n\n                if (deps.featureState) {\n                    if (attrName !== \"enabled\") {\n                        logger.log(\"feature-state is not supported in this context\");\n                    } else {\n                        style._usesFeatureState = true;\n                    }\n                }\n\n                if (deps.properties.size === 0 && !attrValue.isDynamic()) {\n                    // no data-dependencies detected.\n                    attrValue = attrValue.evaluate(this.m_emptyEnv);\n                }\n            }\n\n            if (Expr.isExpr(attrValue)) {\n                const attrScope = getStyleAttributeScope(style, attrName);\n\n                const deps = attrValue.dependencies();\n\n                deps.properties.forEach(prop => {\n                    if (!this.m_featureDependencies.includes(prop)) {\n                        this.m_featureDependencies.push(prop);\n                    }\n                });\n\n                switch (attrScope) {\n                    case AttrScope.FeatureGeometry:\n                        dynamicFeatureAttributes.push([attrName, attrValue]);\n                        break;\n                    case AttrScope.TechniqueGeometry:\n                        dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        break;\n                    case AttrScope.TechniqueRendering:\n                        if (deps.properties.size === 0) {\n                            dynamicForwardedAttributes.push([attrName, attrValue]);\n                        } else {\n                            dynamicTechniqueAttributes.push([attrName, attrValue]);\n                        }\n                        break;\n                }\n            } else if (attrValue !== undefined && attrValue !== null) {\n                targetStaticAttributes.push([attrName, attrValue]);\n            }\n        };\n\n        const replacement = new Map<string, string>([\n            [\"category\", \"_category\"],\n            [\"secondaryCategory\", \"_secondaryCategory\"]\n        ]);\n\n        for (const p in style) {\n            if (!style.hasOwnProperty(p)) {\n                continue;\n            }\n            if (p.startsWith(\"_\")) {\n                continue;\n            }\n            if ([\"when\", \"technique\", \"layer\", \"attr\", \"description\"].includes(p)) {\n                continue;\n            }\n            const pp = replacement.get(p) ?? p;\n            processAttribute(pp, (style as any)[p]);\n        }\n\n        if (style.attr !== undefined) {\n            for (const attrName in style.attr) {\n                if (!style.attr.hasOwnProperty(attrName)) {\n                    continue;\n                }\n                processAttribute(attrName, (style.attr as any)[attrName]);\n            }\n        }\n\n        if (dynamicTechniqueAttributes.length > 0) {\n            style._dynamicTechniques = new Map();\n        }\n    }\n\n    private evaluateTechniqueProperties(style: InternalStyle, env: Env): Array<[string, Value]> {\n        if (style._dynamicTechniqueAttributes === undefined) {\n            return [];\n        }\n\n        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {\n            try {\n                const evaluatedValue = attrExpr.evaluate(\n                    env,\n                    ExprScope.Value,\n                    this.m_cachedResults\n                );\n                return [attrName, evaluatedValue];\n            } catch (error) {\n                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);\n                return [attrName, null];\n            }\n        });\n    }\n\n    private createTechnique(\n        style: InternalStyle,\n        key: string,\n        dynamicAttrs: Array<[string, Value]>\n    ) {\n        const technique: any = {};\n        technique.name = style.technique;\n        if (style._staticAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._staticAttributes) {\n                if (attrValue !== null) {\n                    technique[attrName] = attrValue;\n                }\n            }\n        }\n        for (const [attrName, attrValue] of dynamicAttrs) {\n            if (attrValue !== null) {\n                technique[attrName] = attrValue;\n            }\n        }\n\n        if (style._dynamicFeatureAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n\n        if (style._dynamicForwardedAttributes !== undefined) {\n            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {\n                technique[attrName] = attrValue;\n            }\n        }\n\n        technique._index = this.m_techniques.length;\n        technique._styleSetIndex = style._styleSetIndex!;\n        if (style.styleSet !== undefined) {\n            technique._styleSet = style.styleSet;\n        }\n        if (style._usesFeatureState !== undefined) {\n            technique._usesFeatureState = style._usesFeatureState;\n        }\n        setTechniqueRenderOrderOrPriority(\n            technique,\n            this.m_options.priorities ?? [],\n            this.m_options.labelPriorities ?? []\n        );\n        this.m_techniques.push(technique as IndexedTechnique);\n        return technique as IndexedTechnique;\n    }\n}\n\nfunction computeDefaultRenderOrder(styleSet: InternalStyle[]) {\n    let techniqueRenderOrder = 0;\n    let styleSetIndex = 0;\n    for (const style of styleSet) {\n        style._styleSetIndex = styleSetIndex++;\n        if (style.technique !== undefined && style.renderOrder === undefined) {\n            style.renderOrder = techniqueRenderOrder++;\n        }\n    }\n}\n\nfunction resolveReferences(styleSet: Style[], definitions: Definitions | undefined) {\n    return styleSet.map(style => resolveStyleReferences(style, definitions));\n}\n\nfunction resolveStyleReferences(style: Style, definitions: Definitions | undefined): InternalStyle {\n    return { ...style };\n}\n\n/**\n * Create transferable representation of dynamic technique.\n *\n * Converts  non-transferable {@link Expr}instances back to JSON form.\n */\nexport function makeDecodedTechnique(technique: IndexedTechnique): IndexedTechnique {\n    const result: Partial<IndexedTechnique> = {};\n    for (const attrName in technique) {\n        if (!technique.hasOwnProperty(attrName)) {\n            continue;\n        }\n\n        let attrValue: any = (technique as any)[attrName];\n\n        if (\n            typeof attrValue === \"object\" &&\n            (attrValue.isVector2 || attrValue.isVector3 || attrValue.isVector4)\n        ) {\n            attrValue = LiteralExpr.fromValue(attrValue);\n        }\n\n        if (Expr.isExpr(attrValue)) {\n            attrValue = attrValue.toJSON();\n        }\n\n        (result as any)[attrName] = attrValue;\n    }\n    return (result as any) as IndexedTechnique;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, Expr, MapEnv, Value } from \"./Expr\";\nimport { getPropertyValue } from \"./PropertyValue\";\n\nexport interface AttrEvaluationContext {\n    /**\n     * Expression evaluation environment containing variable bindings.\n     */\n    env: MapEnv;\n\n    /**\n     * Optional, cache of expression results.\n     *\n     * @see [[Expr.evaluate]]\n     */\n    cachedExprResults?: Map<Expr, Value>;\n}\n\n/**\n * Evaluate feature attr _without_ default value.\n *\n * @returns actual value or `undefined`\n */\nexport function evaluateTechniqueAttr<T = Value>(\n    context: Env | AttrEvaluationContext,\n    attrValue: T | Expr | undefined\n): T | undefined;\n\n/**\n * Evaluate feature attr _with_ default value.\n *\n * @returns actual value or `defaultValue`\n */\nexport function evaluateTechniqueAttr<T extends Value>(\n    context: Env | AttrEvaluationContext,\n    attrValue: T | Expr | undefined,\n    defaultValue: T\n): T;\n\nexport function evaluateTechniqueAttr<T = Value>(\n    context: Env | AttrEvaluationContext,\n    attrValue: Value | undefined,\n    defaultValue?: T\n): T | undefined {\n    if (attrValue === undefined) {\n        return defaultValue;\n    }\n\n    const result = Env.isEnv(context)\n        ? getPropertyValue(attrValue, context)\n        : getPropertyValue(attrValue, context.env, context.cachedExprResults);\n\n    return result ?? defaultValue;\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    BaseTechniqueParams,\n    PointTechniqueParams,\n    PolygonalTechniqueParams\n} from \"./TechniqueParams\";\nimport {\n    CirclesTechnique,\n    ExtrudedPolygonTechnique,\n    FillTechnique,\n    IndexedTechnique,\n    LineMarkerTechnique,\n    LineTechnique,\n    ShaderTechnique,\n    SolidLineTechnique,\n    SquaresTechnique,\n    StandardTechnique,\n    Technique,\n    TextTechnique\n} from \"./Techniques\";\n\nexport enum AttrScope {\n    /**\n     * Attributes that affect generation of feature geometry and thus must be resolved at decoding\n     * time.\n     *\n     * @remarks\n     * They may have huge variancy as they are implemented as vertex attributes or embedded in\n     * generated meshes.\n     *\n     * These attributes are available only in decoding scope.\n     */\n    FeatureGeometry,\n\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     * These attributes affect generated geometry and  thus must be resolved at decoding time.\n     *\n     * @remarks\n     * They shouldn't have big variancy and evaluate to at least dozens of values as each\n     * combination of these attributes consitute new technique and material.\n     *\n     * These attributes are available in decoding and rendering scope.\n     */\n    TechniqueGeometry,\n\n    /**\n     * Attributes that are common to whole group of features drawn with this technique.\n     *\n     * @remarks\n     * Attributes that can be changed in resulting object/material from frame to frame. They are\n     * usually implemented as uniforms.\n     *\n     * These attributes may be available only at rendering scope.\n     */\n    TechniqueRendering\n}\n\n/**\n * Extract  property names from `Technique`-like interface (excluding `name`) as union of string\n * literals.\n *\n * TechniquePropName<Base\n *\n */\ntype TechniquePropNames<T> = T extends { name: any } ? keyof Omit<T, \"name\"> : keyof T;\n\ninterface AttrDescriptor {\n    /**\n     * The evaluation scope of this attribute.\n     */\n    scope?: AttrScope;\n\n    /**\n     * Mark this attribute as automatic.\n     *\n     * @remarks\n     * When set to `true`, the underlying material property\n     * associated with this attribute is automatically kept in sync\n     * with the value of the technique attribute.\n     */\n    automatic?: boolean;\n}\n\ntype TechniqueAttrDescriptors<T> = {\n    [P in TechniquePropNames<T>]?: AttrScope | AttrDescriptor;\n};\n\nexport interface TechniqueDescriptor<T = Technique> {\n    attrTransparencyColor?: string;\n    attrDescriptors: TechniqueAttrDescriptors<T>;\n}\n\ntype OneThatMatches<T, P> = T extends P ? T : never;\ntype TechniqueByName<K extends Technique[\"name\"]> = OneThatMatches<Technique, { name: K }>;\n\ntype TechniqueDescriptorRegistry = {\n    [P in Technique[\"name\"]]?: TechniqueDescriptor<TechniqueByName<P>>;\n};\n\n/**\n * @internal\n */\nfunction mergeTechniqueDescriptor<T>(\n    ...descriptors: Array<Partial<TechniqueDescriptor<T>>>\n): TechniqueDescriptor<T> {\n    const result: TechniqueDescriptor<T> = {\n        attrDescriptors: {}\n    };\n    for (const descriptor of descriptors) {\n        if (descriptor.attrTransparencyColor !== undefined) {\n            result.attrTransparencyColor = descriptor.attrTransparencyColor;\n        }\n        if (descriptor.attrDescriptors !== undefined) {\n            result.attrDescriptors = { ...result.attrDescriptors, ...descriptor.attrDescriptors };\n        }\n    }\n    return result;\n}\n\nconst baseTechniqueParamsDescriptor: TechniqueDescriptor<BaseTechniqueParams> = {\n    // TODO: Choose which techniques should support color with transparency.\n    // For now we chosen all, but it maybe not suitable for text or line marker techniques.\n    attrTransparencyColor: \"color\",\n    attrDescriptors: {\n        constantHeight: AttrScope.FeatureGeometry,\n        enabled: AttrScope.FeatureGeometry,\n        fadeFar: AttrScope.TechniqueRendering,\n        fadeNear: AttrScope.TechniqueRendering,\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        side: { scope: AttrScope.TechniqueRendering, automatic: true }\n    }\n};\n\nconst pointTechniquePropTypes = mergeTechniqueDescriptor<PointTechniqueParams>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrDescriptors: {\n            color: { scope: AttrScope.TechniqueRendering, automatic: true },\n            size: { scope: AttrScope.TechniqueRendering, automatic: true },\n            opacity: { scope: AttrScope.TechniqueRendering, automatic: true }\n        }\n    }\n);\n\nconst squaresTechniquePropTypes = mergeTechniqueDescriptor<SquaresTechnique>(\n    baseTechniqueParamsDescriptor,\n    pointTechniquePropTypes\n);\n\nconst circlesTechniquePropTypes = mergeTechniqueDescriptor<CirclesTechnique>(\n    baseTechniqueParamsDescriptor,\n    pointTechniquePropTypes\n);\n\nconst lineMarkerTechniquePropTypes = mergeTechniqueDescriptor<LineMarkerTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrDescriptors: {\n            text: AttrScope.FeatureGeometry,\n            label: AttrScope.FeatureGeometry,\n            useAbbreviation: AttrScope.FeatureGeometry,\n            useIsoCode: AttrScope.FeatureGeometry,\n            poiName: AttrScope.FeatureGeometry,\n            imageTexture: AttrScope.FeatureGeometry,\n            iconColor: AttrScope.TechniqueRendering,\n            iconBrightness: AttrScope.TechniqueRendering,\n            backgroundColor: AttrScope.TechniqueRendering,\n            backgroundSize: AttrScope.TechniqueRendering,\n            backgroundOpacity: AttrScope.TechniqueRendering,\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            size: AttrScope.TechniqueRendering\n        }\n    }\n);\n\nconst polygonalTechniqueDescriptor: TechniqueDescriptor<PolygonalTechniqueParams> = {\n    attrDescriptors: {\n        polygonOffset: { scope: AttrScope.TechniqueRendering, automatic: true },\n        polygonOffsetFactor: { scope: AttrScope.TechniqueRendering, automatic: true },\n        polygonOffsetUnits: { scope: AttrScope.TechniqueRendering, automatic: true },\n        depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },\n        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n        color: { scope: AttrScope.TechniqueRendering, automatic: true },\n        lineColor: AttrScope.TechniqueRendering,\n        lineFadeFar: AttrScope.TechniqueRendering,\n        lineFadeNear: AttrScope.TechniqueRendering\n    }\n};\n\nconst solidLineTechniqueDescriptor = mergeTechniqueDescriptor<SolidLineTechnique>(\n    baseTechniqueParamsDescriptor,\n    polygonalTechniqueDescriptor,\n    {\n        attrDescriptors: {\n            lineWidth: AttrScope.TechniqueRendering,\n            secondaryWidth: AttrScope.TechniqueRendering,\n            secondaryColor: AttrScope.TechniqueRendering,\n            dashSize: AttrScope.TechniqueRendering,\n            gapSize: AttrScope.TechniqueRendering,\n            outlineColor: { scope: AttrScope.TechniqueRendering, automatic: true },\n            caps: { scope: AttrScope.TechniqueRendering, automatic: true },\n            drawRangeStart: { scope: AttrScope.TechniqueRendering, automatic: true },\n            drawRangeEnd: { scope: AttrScope.TechniqueRendering, automatic: true },\n            dashes: { scope: AttrScope.TechniqueRendering, automatic: true },\n            dashColor: { scope: AttrScope.TechniqueRendering, automatic: true }\n        }\n    }\n);\n\nconst lineTechniqueDescriptor = mergeTechniqueDescriptor<LineTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrDescriptors: {\n            // TODO, check, which are really dynamic !\n            color: { scope: AttrScope.TechniqueRendering, automatic: true },\n            opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n            lineWidth: AttrScope.FeatureGeometry\n        }\n    }\n);\n\nconst fillTechniqueDescriptor = mergeTechniqueDescriptor<FillTechnique>(\n    baseTechniqueParamsDescriptor,\n    polygonalTechniqueDescriptor,\n    {\n        attrDescriptors: {\n            wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },\n            color: { scope: AttrScope.TechniqueRendering, automatic: true },\n            opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n            transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n            lineWidth: AttrScope.TechniqueRendering,\n            map: { scope: AttrScope.TechniqueRendering, automatic: true }\n        }\n    }\n);\n\nconst standardTechniqueDescriptor = mergeTechniqueDescriptor<StandardTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrDescriptors: {\n            color: { scope: AttrScope.TechniqueRendering, automatic: true },\n            vertexColors: { scope: AttrScope.TechniqueRendering, automatic: true },\n            wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },\n            roughness: { scope: AttrScope.TechniqueRendering, automatic: true },\n            metalness: { scope: AttrScope.TechniqueRendering, automatic: true },\n            alphaTest: { scope: AttrScope.TechniqueRendering, automatic: true },\n            depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },\n            transparent: { scope: AttrScope.TechniqueRendering, automatic: true },\n            opacity: { scope: AttrScope.TechniqueRendering, automatic: true },\n            emissive: { scope: AttrScope.TechniqueRendering, automatic: true },\n            emissiveIntensity: { scope: AttrScope.TechniqueRendering, automatic: true },\n            refractionRatio: { scope: AttrScope.TechniqueRendering, automatic: true },\n            normalMapType: { scope: AttrScope.TechniqueRendering, automatic: true },\n            map: { scope: AttrScope.TechniqueRendering, automatic: true },\n            normalMap: { scope: AttrScope.TechniqueRendering, automatic: true },\n            displacementMap: { scope: AttrScope.TechniqueRendering, automatic: true },\n            roughnessMap: { scope: AttrScope.TechniqueRendering, automatic: true },\n            emissiveMap: { scope: AttrScope.TechniqueRendering, automatic: true },\n            bumpMap: { scope: AttrScope.TechniqueRendering, automatic: true },\n            metalnessMap: { scope: AttrScope.TechniqueRendering, automatic: true },\n            alphaMap: { scope: AttrScope.TechniqueRendering, automatic: true }\n        }\n    }\n);\n\nconst extrudedPolygonTechniqueDescriptor = mergeTechniqueDescriptor<ExtrudedPolygonTechnique>(\n    baseTechniqueParamsDescriptor,\n    standardTechniqueDescriptor,\n    {\n        attrDescriptors: {\n            height: AttrScope.FeatureGeometry,\n            floorHeight: AttrScope.FeatureGeometry,\n            color: AttrScope.FeatureGeometry,\n            defaultColor: AttrScope.FeatureGeometry,\n            defaultHeight: AttrScope.FeatureGeometry,\n            boundaryWalls: AttrScope.FeatureGeometry,\n            footprint: AttrScope.FeatureGeometry,\n            maxSlope: AttrScope.FeatureGeometry,\n            animateExtrusion: AttrScope.TechniqueRendering,\n            lineWidth: AttrScope.TechniqueRendering,\n            lineFadeNear: AttrScope.TechniqueRendering,\n            lineFadeFar: AttrScope.TechniqueRendering,\n            lineColor: AttrScope.TechniqueRendering\n        }\n    }\n);\n\nconst textTechniqueDescriptor = mergeTechniqueDescriptor<TextTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrDescriptors: {\n            text: AttrScope.FeatureGeometry,\n            label: AttrScope.FeatureGeometry,\n            useAbbreviation: AttrScope.FeatureGeometry,\n            useIsoCode: AttrScope.FeatureGeometry,\n            backgroundColor: AttrScope.TechniqueRendering,\n            backgroundSize: AttrScope.TechniqueRendering,\n            backgroundOpacity: AttrScope.TechniqueRendering,\n            color: AttrScope.TechniqueRendering,\n            opacity: AttrScope.TechniqueRendering,\n            priority: AttrScope.TechniqueRendering,\n            size: AttrScope.TechniqueRendering\n        }\n    }\n);\n\nconst shaderTechniqueDescriptor = mergeTechniqueDescriptor<ShaderTechnique>(\n    baseTechniqueParamsDescriptor,\n    {\n        attrDescriptors: {\n            params: AttrScope.TechniqueRendering\n        }\n    }\n);\n\nconst techniqueDescriptors: TechniqueDescriptorRegistry = {\n    \"extruded-polygon\": extrudedPolygonTechniqueDescriptor,\n    \"line-marker\": lineMarkerTechniquePropTypes,\n    \"labeled-icon\": lineMarkerTechniquePropTypes,\n    \"solid-line\": solidLineTechniqueDescriptor,\n    \"dashed-line\": solidLineTechniqueDescriptor,\n    terrain: standardTechniqueDescriptor,\n    standard: standardTechniqueDescriptor,\n    squares: squaresTechniquePropTypes,\n    circles: circlesTechniquePropTypes,\n    line: lineTechniqueDescriptor,\n    segments: lineTechniqueDescriptor,\n    fill: fillTechniqueDescriptor,\n    text: textTechniqueDescriptor,\n    shader: shaderTechniqueDescriptor\n};\n\nexport function getTechniqueDescriptor(\n    technique: string | IndexedTechnique | Technique\n): TechniqueDescriptor | undefined {\n    if (typeof technique !== \"string\") {\n        technique = technique.name;\n    }\n    return (techniqueDescriptors as any)[technique];\n}\n\nexport function getTechniqueAttributeDescriptor(\n    technique: string | IndexedTechnique | Technique,\n    attrName: string\n): AttrDescriptor | undefined {\n    const techniqueDescriptor = getTechniqueDescriptor(technique);\n    const attrDescriptors = techniqueDescriptor?.attrDescriptors;\n    const descriptor = attrDescriptors?.[attrName];\n    if (typeof descriptor === undefined) {\n        return undefined;\n    } else if (typeof descriptor === \"object\") {\n        return descriptor;\n    }\n    return { scope: descriptor };\n}\n\nconst automaticAttributeCache: Map<string, string[]> = new Map();\n\nexport function getTechniqueAutomaticAttrs(\n    technique: string | IndexedTechnique | Technique\n): string[] {\n    if (typeof technique !== \"string\") {\n        technique = technique.name;\n    }\n\n    if (automaticAttributeCache.has(technique)) {\n        return automaticAttributeCache.get(technique)!;\n    }\n\n    const descriptors: string[] = [];\n\n    const attrDescriptors = getTechniqueDescriptor(technique)?.attrDescriptors;\n\n    if (attrDescriptors === undefined) {\n        return descriptors;\n    }\n\n    for (const attrName in attrDescriptors) {\n        if (!attrDescriptors.hasOwnProperty(attrName)) {\n            continue;\n        }\n\n        const descr = attrDescriptors[attrName];\n\n        if (descr === undefined || typeof descr === \"number\") {\n            continue;\n        }\n\n        if (descr.automatic === true) {\n            descriptors.push(attrName);\n        }\n    }\n\n    automaticAttributeCache.set(technique, descriptors);\n\n    return descriptors;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { JsonExpr } from \"./Expr\";\nimport { InterpolatedPropertyDefinition } from \"./InterpolatedPropertyDefs\";\n\n/**\n * The style type of the line caps.\n */\nexport type LineCaps = \"Square\" | \"Round\" | \"None\" | \"TriangleOut\" | \"TriangleIn\";\n\n/**\n * The style type of the line dashes.\n */\nexport type LineDashes = \"Square\" | \"Round\" | \"Diamond\";\n\n/**\n * Defines how to interpret the units.\n */\nexport type MetricUnit = \"Meter\" | \"Pixel\";\n\n/**\n * Standard kinds of geometry.\n * @deprecated See {@link BaseTechniqueParams.kind}.\n */\nexport enum StandardGeometryKind {\n    /**\n     * Used in the enabledKinds/disabledKinds filter to match any kind.\n     */\n    All = \"_all_\",\n\n    /**\n     * Background geometry.\n     */\n    Background = \"background\",\n\n    /**\n     * Terrain geometry.\n     */\n    Terrain = \"terrain\",\n\n    /**\n     * Default value for the FillTechnique.\n     */\n    Area = \"area\",\n\n    /**\n     * Default value for all line techniques.\n     */\n    Line = \"line\",\n\n    /**\n     * Default value for the FillTechnique.\n     */\n    Water = \"water\",\n\n    /**\n     * Political borders.\n     */\n    Border = \"border\",\n\n    /**\n     * Basis for all roads.\n     */\n    Road = \"road\",\n\n    /**\n     * Default value for the ExtrudedPolygonTechnique.\n     */\n    Building = \"building\",\n\n    /**\n     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.\n     */\n    Label = \"label\",\n\n    /**\n     * Anything that may show up last.\n     */\n    Detail = \"detail\"\n}\n\n/**\n * The kind of geometry is used to group objects together,\n * allowing the group to be hidden or displayed.\n *\n * @remarks\n * Any string can be used to specify the kind of the technique in a style in the theme file. Is is\n * suggested to specify multiple kinds for specific types of data. For a highway, the following list\n * of kinds is suggested:\n *```json\n *    [\"line\", \"road\", \"road:highway\"]\n *```\n * If it is a tunnel for a highway:\n *```json\n *    [\"line\", \"road\", \"road:highway\", \"tunnel\", \"road:tunnel\", \"road:highway:tunnel\"]\n *```\n * If specified in this way, specific types of data (here: highway roads) can be enabled and/or\n * disabled.\n * @deprecated See {@link BaseTechniqueParams.kind}.\n */\nexport type GeometryKind = string | StandardGeometryKind;\n\n// See https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-redeclare.md#ignoredeclarationmerge\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const GeometryKind = StandardGeometryKind;\n\n/**\n * Decorate property type with possible dynamic variants.\n */\nexport type DynamicProperty<T> = T | JsonExpr | InterpolatedPropertyDefinition<T>;\n\n/**\n * Length literals.\n *\n * @remarks\n * Description of length units inside a style. Supports literal values (interpreted as `m`), `m` and\n * `px`(i.e. `80`, `14px`, `0.6m`, etc.).\n */\nexport type StyleLength = string | number;\n\n/**\n * Color literals.\n *\n * @remarks\n * Description of colors inside a style. Supports hex values as well as CSS hex, rgb and hsl values\n * (i.e. `0xffffff`, `#f00fab`, `#aaa`, `rgb(255, 0 120)`, `hsl(360, 100%, 100%)`, etc.).\n */\nexport type StyleColor = string | number;\n\n/**\n * A set of {@link GeometryKind}s.\n */\nexport class GeometryKindSet extends Set {\n    /**\n     * Return `true` if the Set is a superset of the set 'subset'.\n     */\n    isSuperset(subset: Set<any>): boolean {\n        for (const elem of subset) {\n            if (!this.has(elem)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return `true` if the Set intersects Set 'set'.\n     */\n    hasIntersection(set: any) {\n        for (const elem of set) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'\n     * if set is not a Set.\n     */\n    hasOrIntersects(set: any) {\n        if (set instanceof Set) {\n            return this.hasIntersection(set);\n        }\n        return this.has(set);\n    }\n\n    /**\n     * Return `true` if this set and the array of elements share at least a single element.\n     */\n    hasOrIntersectsArray(subset: any[]) {\n        for (const elem of subset) {\n            if (this.has(elem)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n/**\n * Common attributes or all [[Technique]]s.\n */\nexport interface BaseTechniqueParams {\n    /**\n     * The name used to identify materials created from this technique.\n     */\n    id?: string;\n\n    /**\n     * The render order of the objects created using this technique.\n     *\n     * @remarks\n     * If not specified in style file monotonically increasing\n     * values according to style position in file.\n     */\n    renderOrder?: DynamicProperty<number>;\n\n    /**\n     * The category of this technique.\n     *\n     * @remarks\n     * The category is used in conjunction with {@link Theme.priorities}\n     * to assign render orders to the objects created by this {@link Style}.\n     */\n    category?: DynamicProperty<string>;\n\n    /**\n     * Optional. If `true` or `Pickability.transient`, no IDs will be saved for the geometry\n     * this style creates. Default is `Pickability.onlyVisible`, which allows all pickable and\n     * visible objects to be picked, Pickability.all, will also allow invisible objects to be\n     * picked.\n     * @defaultValue `Pickability.onlyVisible`\n     * The boolean option is for backwardscompatibilty, please use the Pickability.\n     *\n     *\n     * TODO: deprecate and rename to something that makes more sense\n     */\n    transient?: boolean | Pickability;\n\n    /**\n     * Distance to the camera `(0.0 = camera position, 1.0 = farPlane) at which the object start\n     * fading out (opacity decreases).\n     */\n    fadeNear?: DynamicProperty<number>;\n\n    /**\n     * Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the object has zero\n     * opacity and stops fading out. An undefined value disables fading.\n     */\n    fadeFar?: DynamicProperty<number>;\n\n    /**\n     * Specified kind of geometry.\n     *\n     * @remarks\n     * One kind is set as default in the technique, and can be overridden in the style.\n     *\n     * @deprecated Use {@link enabled} with expressions based on `['dynamic-properties']` operator.\n     * See \"object picking\" example.\n     */\n    kind?: GeometryKind | GeometryKindSet;\n\n    /**\n     * Runtime filtering of techniques.\n     *\n     * Use with `['dynamic-properties']` operator for dynamic feature highlight, highlighig etc.\n     *\n     * @see Picking example\n     */\n    enabled?: DynamicProperty<boolean>;\n\n    /**\n     * Set to 'true' if line should appear transparent.\n     *\n     * @remarks\n     * Rendering transparent lines may come with a\n     * slight performance impact.\n     * See https://threejs.org/docs/#api/en/materials/Material.transparent.\n     */\n    transparent?: DynamicProperty<boolean>;\n\n    /**\n     * Defines which side of faces will be rendered - front, back or both.\n     * See https://threejs.org/docs/#api/en/materials/Material.side.\n     */\n    side?: DynamicProperty<number>;\n\n    /**\n     * Minimal zoom level. If the current zoom level is smaller, the technique will not be used.\n     */\n    minZoomLevel?: DynamicProperty<number>;\n\n    /**\n     * Maximum zoom level. If the current zoom level is equal to or greater, the technique will not be used.\n     */\n    maxZoomLevel?: DynamicProperty<number>;\n\n    /**\n     * If `true`, geometry height won't be scaled on projection. Enable it for projections with\n     * variable scale factor (e.g. mercator) to avoid distortions in geometry with great heights and\n     * latitude spans. E.g. a large object with even height would look oblique to the ground plane\n     * on mercator unless this property is set to `true`.\n     *\n     * @defaultValue `true` for geometries stored at level less than `12`.\n     */\n    constantHeight?: DynamicProperty<boolean>;\n}\n\nexport enum TextureCoordinateType {\n    /**\n     * Texture coordinates are in tile space.\n     *\n     * @remarks\n     * SW of the tile will have (0,0) and NE will have (1,1).\n     */\n    TileSpace = \"tile-space\",\n\n    /**\n     * Texture coordinates are in equirectangular space.\n     *\n     * @remarks\n     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).\n     */\n    EquirectangularSpace = \"equirectangular-space\",\n\n    /**\n     * Texture coordinates in feature space.\n     *\n     * @remarks\n     * To compute texture coordinates in feature space,\n     * the feature must have a property named `bbox` with value\n     * the tuple `[west, south, east, north]`.\n     */\n    FeatureSpace = \"feature-space\"\n}\n\n/**\n * Standard technique parameters.\n */\nexport interface StandardTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of the feature in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`,\n     * `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.color.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * A value of `true` creates a wireframe geometry. (May not be supported with all techniques).\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.wireframe.\n     */\n    wireframe?: boolean;\n    /**\n     * If `vertexColors` is `true`, every vertex has color information, which is interpolated\n     * between vertices.\n     * See https://threejs.org/docs/#api/en/materials/Material.vertexColors.\n     */\n    vertexColors?: boolean;\n    /**\n     * How rough the material appears. `0.0` means a smooth mirror reflection. `1.0` means fully\n     * diffuse. Default is `1.0`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.roughness.\n     */\n    roughness?: DynamicProperty<number>;\n    /**\n     * How much the material is like a metal. Nonmetallic materials such as wood or stone use `0.0`,\n     * metallic ones use `1.0`, with nothing (usually) in between. Default is `0.0`. A value between\n     * `0.0` and `1.0` can be used for a rusty metal look. If `metalnessMap` is also provided, both\n     * values are multiplied.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.metalness.\n     */\n    metalness?: DynamicProperty<number>;\n    /**\n     * The material will not be rendered if the opacity is lower than this value.\n     * See https://threejs.org/docs/#api/en/materials/Material.alphaTest.\n     */\n    alphaTest?: DynamicProperty<number>;\n    /**\n     * Skip rendering clobbered pixels.\n     * See https://threejs.org/docs/#api/en/materials/Material.depthTest.\n     */\n    depthTest?: DynamicProperty<boolean>;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     * See https://threejs.org/docs/#api/en/materials/Material.opacity.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Emissive (light) color of the material, essentially a solid color unaffected by other\n     * lighting. Default is black.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.emissive.\n     * @format color-hex\n     */\n    emissive?: DynamicProperty<StyleColor>;\n    /**\n     * Intensity of the emissive light. Modulates the emissive color. Default is `1`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.emissiveIntensity.\n     */\n    emissiveIntensity?: DynamicProperty<number>;\n    /**\n     * The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of\n     * the material. It is used with environment mapping modes `THREE.CubeRefractionMapping` and\n     * `THREE.EquirectangularRefractionMapping`. The refraction ratio should not exceed `1`. Default\n     *  is `0.98`.\n     * See https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.refractionRatio.\n     */\n    refractionRatio?: DynamicProperty<number>;\n\n    /**\n     * Whether and how texture coordinates should be generated. No texture coordinates are\n     * generated if `undefined`.\n     * Should be set if any texture assigned (e.g. `map`, `normalMap`, ...).\n     */\n    textureCoordinateType?: TextureCoordinateType;\n\n    /*\n     * URL or texture buffer that should be used as color map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.map\n     */\n    map?: DynamicProperty<string | TextureBuffer>;\n    mapProperties?: DynamicProperty<TextureProperties>;\n\n    /**\n     * URL or texture buffer that should be used as normal map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.normalMap\n     */\n    normalMap?: DynamicProperty<string | TextureBuffer>;\n    normalMapType?: DynamicProperty<number>;\n    normalMapProperties?: DynamicProperty<TextureProperties>;\n\n    /**\n     * URL or texture buffer that should be used as displacement map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.displacementMap\n     */\n    displacementMap?: DynamicProperty<string | TextureBuffer>;\n    displacementMapProperties?: DynamicProperty<TextureProperties>;\n\n    /**\n     * URL or texture buffer that should be used as roughness map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.roughnessMap\n     */\n    roughnessMap?: DynamicProperty<string | TextureBuffer>;\n    roughnessMapProperties?: DynamicProperty<TextureProperties>;\n\n    /**\n     * URL or texture buffer that should be used as emissive map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.emissiveMap\n     */\n    emissiveMap?: DynamicProperty<string | TextureBuffer>;\n    emissiveMapProperties?: DynamicProperty<TextureProperties>;\n\n    /**\n     * URL or texture buffer that should be used as bump map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.bumpMap\n     */\n    bumpMap?: DynamicProperty<string | TextureBuffer>;\n    bumpMapProperties?: DynamicProperty<TextureProperties>;\n\n    /**\n     * URL or texture buffer that should be used as metalness map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.metalnessMap\n     */\n    metalnessMap?: DynamicProperty<string | TextureBuffer>;\n    metalnessMapProperties?: DynamicProperty<TextureProperties>;\n\n    /**\n     * URL or texture buffer that should be used as alpha map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshStandardMaterial.alphaMap\n     */\n    alphaMap?: DynamicProperty<string | TextureBuffer>;\n    alphaMapProperties?: DynamicProperty<TextureProperties>;\n}\n\n/**\n * Possible parameters of [[PointTechnique]].\n */\nexport interface PointTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of a point in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * URL of a texture image to be loaded.\n     */\n    texture?: string;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Size of point in pixels.\n     */\n    size?: DynamicProperty<number>;\n    /**\n     * Whether to enable picking on these points.\n     */\n    enablePicking?: boolean;\n}\n\n/**\n * Define the stacking option. Enum values for theme file are in \"kebab-case\".\n */\nexport enum PoiStackMode {\n    /**\n     * Show in a stack.\n     */\n    Show = \"show-in-stack\",\n    /**\n     * Do not show in a stack.\n     */\n    Hide = \"hide-in-stack\",\n    /**\n     * Show category parent in the stack.\n     */\n    ShowParent = \"show-parent\"\n}\n\n/**\n * Define the pickability of an object.\n */\nexport enum Pickability {\n    /**\n     * Pickable if visible.\n     */\n    onlyVisible = \"only-visible\",\n    /**\n     * Not Pickable at all.\n     */\n    transient = \"transient\",\n    /**\n     * All objects of this type pickable.\n     */\n    all = \"all\"\n}\n\n/**\n * Converts backwards compatible transient property to pure {@type Pickabilty} object\n *\n * @param transient The transient property from the style\n */\nexport function transientToPickability(transient?: boolean | Pickability): Pickability {\n    let pickability: Pickability = Pickability.onlyVisible;\n    if (transient !== undefined && transient !== null) {\n        pickability =\n            typeof transient === \"string\"\n                ? transient\n                : transient === true\n                ? Pickability.transient\n                : Pickability.onlyVisible;\n    }\n    return pickability;\n}\n\n/**\n * Defines options (tokens) supported for text placements defined via [[placements]] attribute.\n *\n * @remarks\n * Possible values are defined as vertical placement letter and horizontal letter, where\n * one of the axis may be ignored and then assumed centered. Moving clock-wise, we have:\n * `TL` (top-left), `T` (top-center), `TR` (top-right), `R` (center-right), `BR` (bottom-right),\n * `B` (bottom-center), `BL` (bottom-left), `L` (left), `C` (center-center).\n * Alternatively instead of `T`, `B`, `L`, `R` geographic directions may be used accordingly:\n * `NW` (north-west), `N` (north), `NE` (north-east), `E` (east), `SE` (south-east), `S` (south),\n * `SW` (south-west), `W` (west).\n */\nexport enum PlacementToken {\n    TopLeft = \"TL\",\n    Top = \"T\",\n    TopRight = \"TR\",\n    Right = \"R\",\n    BottomRight = \"BR\",\n    Bottom = \"B\",\n    BottomLeft = \"BL\",\n    Left = \"L\",\n    Center = \"C\",\n    NorthWest = \"NW\",\n    North = \"N\",\n    NorthEast = \"NE\",\n    East = \"E\",\n    SouthEast = \"SE\",\n    South = \"S\",\n    SouthWest = \"SW\",\n    West = \"W\"\n}\n\n/**\n * Technique that describes icons with labels. Used in [[PoiTechnique]] and [[LineMarkerTechnique]]\n * (for road shields).\n */\nexport interface MarkerTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Text to be displayed for feature.\n     *\n     * @remarks\n     * Defaults to first defined:\n     *  - feature property `label` if present in technique (deprecated)\n     *  - `[\"get\", \"name:short\"]` is `useAbbreviation` is true\n     *  - `[\"get\", \"iso_code\"]` is `useIsoCode` is true\n     *  - `[\"get\", \"name:$LANGUAGE\"]` for each specified language\n     *  - `[\"get\", \"name\"]`\n     *\n     * See [[ExtendedTileInfo.getFeatureText]]\n     */\n    text?: DynamicProperty<string>;\n\n    /**\n     * Field name of object containing the text to be rendered.\n     *\n     * @deprecated Use `[\"get\", \"FIELD\"]`.\n     */\n    label?: string;\n    /**\n     * If `true`, the abbreviation (field `name:short`) of the elements is used as text.\n     *\n     * @deprecated Use proper expression with [`get`, `name:short`] for this purpose.\n     */\n    useAbbreviation?: boolean;\n    /**\n     * If `true`, the iso code (field 'iso_code') of the elements is used as text.\n     * The `iso_code` field contains the ISO 3166-1 2-letter country code.\n     *\n     * @deprecated Use proper expression with [`get`, `iso_code`] for this purpose.\n     */\n    useIsoCode?: boolean;\n    /**\n     * Priority of marker, defaults to `0`. Markers with highest priority get placed first.\n     */\n    priority?: DynamicProperty<number>;\n    /**\n     * Minimum zoomLevel at which to display the label text. No default.\n     */\n    textMinZoomLevel?: DynamicProperty<number>;\n    /**\n     * Maximum zoomLevel at which to display the label text. No default.\n     */\n    textMaxZoomLevel?: DynamicProperty<number>;\n    /**\n     * Minimum zoomLevel at which to display the label icon. No default.\n     */\n    iconMinZoomLevel?: DynamicProperty<number>;\n    /**\n     * Maximum zoomLevel at which to display the label icon. No default.\n     */\n    iconMaxZoomLevel?: DynamicProperty<number>;\n\n    /**\n     * Icon color.\n     *\n     * @remarks\n     * If specified, combined using multiplication with color value read from icon texture.\n     * Works best for grayscale or monochromatic textures.\n     */\n    iconColor?: StyleColor;\n\n    /**\n     * Icon brightness.\n     *\n     * @remarks\n     * Factor that multiplies a color on top of the icon texture (and `iconColor`) with `0` being\n     * fully black as final output, `1` being the original rgb colors of the texture.\n     *\n     * @defaultValue `1`\n     */\n    iconBrightness?: number;\n\n    /**\n     * Scaling factor of icon. Defaults to 0.5, reducing the size ot 50% in the distance.\n     */\n    distanceScale?: number;\n    /**\n     * If `false`, text may overlap markers.\n     * @defaultValue `false`\n     */\n    textMayOverlap?: boolean;\n    /**\n     * If `false`, the icon may overlap text and other icons of lower priority.\n     *\n     * @remarks\n     * If not defined, the\n     * property value from `textMayOverlap` will be used.\n     * @defaultValue `false`\n     */\n    iconMayOverlap?: boolean;\n    /**\n     * If `false`, text will not reserve screen space, other markers will be able to overlap.\n     * @defaultValue `true`\n     */\n    textReserveSpace?: boolean;\n    /**\n     * If `false`, icon will not reserve screen space, other markers will be able to overlap.\n     *\n     * @remarks\n     * If not defined, the property value from `iconReserveSpace` will be used.\n     * @defaultValue `true`\n     */\n    iconReserveSpace?: boolean;\n    /**\n     * If `false`, text will not be rendered during animations. Defaults to `true`.\n     */\n    renderTextDuringMovements?: boolean;\n    /**\n     * If `true`, the label will always be rendered on top.\n     *\n     * @remarks\n     * If overlapping with other labels with\n     * this flag set, the render order is undefined.\n     * @defaultValue `false`\n     */\n    alwaysOnTop?: boolean;\n    /**\n     * If `true`, icon will appear even if the text part is blocked by other labels.\n     *\n     * @remarks\n     * @defaultValue `false`\n     */\n    textIsOptional?: boolean;\n    /**\n     * Should be displayed on map or not. Defaults to `true`.\n     */\n    showOnMap?: boolean;\n    /**\n     * Specify stack mode. Defaults to `ShowInStack`.\n     */\n    stackMode?: PoiStackMode;\n    /**\n     * Minimal distance between markers in screen pixels.\n     */\n    minDistance?: number;\n    /**\n     * If `true`, text will appear even if the icon is blocked by other labels.\n     *\n     * @defaultValue `false`\n     */\n    iconIsOptional?: boolean;\n    /**\n     * Fading time for labels in seconds.\n     */\n    textFadeTime?: number;\n    /**\n     * Fading time for icons in seconds.\n     */\n    iconFadeTime?: number;\n    /**\n     * Horizontal offset (to the right) in screen pixels.\n     */\n    xOffset?: DynamicProperty<number>;\n    /**\n     * Vertical offset (up) in screen pixels.\n     */\n    yOffset?: DynamicProperty<number>;\n    /**\n     * Horizontal offset (to the right) in screen pixels.\n     */\n    iconXOffset?: DynamicProperty<number>;\n    /**\n     * Vertical offset (up) in screen pixels.\n     */\n    iconYOffset?: DynamicProperty<number>;\n    /**\n     * Scaling factor of icon.\n     */\n    iconScale?: number;\n    /**\n     * Vertical height in pixels, controls vertical scaling. Overrides `iconScale`.\n     */\n    screenHeight?: DynamicProperty<number>;\n    /**\n     * Horizontal height in pixels, controls horizontal scaling. Overrides `iconScale`.\n     */\n    screenWidth?: DynamicProperty<number>;\n    /**\n     * Name of the POI table which should be used for this POI.\n     */\n    poiTable?: string;\n    /**\n     * Fixed name to identify POI options in the POI table.\n     *\n     * @remarks\n     * If `poiName` has a value, this value\n     * supersedes any value read from the field referenced in `poiNameField`.\n     */\n    poiName?: string;\n    /**\n     * Name of the field to evaluate to get the name of the POI options in the POI table.\n     */\n    poiNameField?: string;\n    /**\n     * The name of either the {@link ImageTexture} in {@link Theme.imageTextures} or the user image\n     * cached in {@link @here/harp-mapview#userImageCache} to be rendered as marker.\n     */\n    imageTexture?: DynamicProperty<string>;\n    /**\n     * Field name to extract imageTexture content from, if imageTexture refers to an\n     * [[ImageTexture]] definition.\n     */\n    imageTextureField?: string;\n    /**\n     * Prefix for `imageTexture` if `imageTextureField` is used.\n     */\n    imageTexturePrefix?: string;\n    /**\n     * Postfix for `imageTexture` if `imageTextureField` is used.\n     */\n    imageTexturePostfix?: string;\n    /**\n     * Name of the text style.\n     */\n    style?: string;\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    fontName?: string;\n    /**\n     * Size of the text (pixels).\n     */\n    size?: DynamicProperty<number>;\n    /**\n     * Size of the text background (pixels).\n     */\n    backgroundSize?: DynamicProperty<number>;\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    fontStyle?: \"Regular\" | \"Bold\" | \"Italic\" | \"BoldItalic\";\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    fontVariant?: \"Regular\" | \"AllCaps\" | \"SmallCaps\";\n    /**\n     * Glyph local rotation (radians).\n     */\n    rotation?: number;\n    /**\n     * Text color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * Text background color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`,\n     * `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    backgroundColor?: DynamicProperty<StyleColor>;\n    /**\n     * For transparent text, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Background text opacity value.\n     */\n    backgroundOpacity?: DynamicProperty<number>;\n    /**\n     * Inter-glyph spacing (pixels). Scaled by `size`.\n     */\n    tracking?: DynamicProperty<number>;\n    /**\n     * Inter-line spacing (pixels). Scaled by `size`.\n     */\n    leading?: DynamicProperty<number>;\n    /**\n     * Maximum number of lines for this label.\n     */\n    maxLines?: DynamicProperty<number>;\n    /**\n     * Maximum line width (pixels).\n     */\n    lineWidth?: DynamicProperty<number>;\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    canvasRotation?: DynamicProperty<number>;\n    /**\n     * Line typesetting rotation (radians).\n     */\n    lineRotation?: DynamicProperty<number>;\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    wrappingMode?: DynamicProperty<\"None\" | \"Character\" | \"Word\">;\n    /**\n     * Text position regarding the baseline.\n     *\n     * @note The [[placements]] attribute may override the alignment settings.\n     */\n    hAlignment?: DynamicProperty<\"Left\" | \"Center\" | \"Right\">;\n    /**\n     * Text position inside a line.\n     *\n     * @note The [[placements]] attribute may supersede it.\n     */\n    vAlignment?: DynamicProperty<\"Above\" | \"Center\" | \"Below\">;\n    /**\n     * Text label positions relative to the label central position (anchor point).\n     *\n     * @remarks\n     * This attribute defines a comma separated tokens of possible text placements\n     * relative to label central position (anchor), for example: \"TL, TR, C\".\n     * Keep in mind that horizontal placement defines text position in opposite way to\n     * the alignment, so the text `R` placed (located on the **right side** of label position)\n     * will be the same as `Left` aligned by deduction. On other side vertical placement is quite\n     * similar to vertical alignment so `T` placement corresponds with `Above` alignment.\n     *\n     * @note This attribute may override [[hAlignment]] and [[vAlignment]] if defined.\n     */\n    placements?: string;\n\n    /**\n     * World space offset in meters applied to the icon along the ground plane, i.e. tangent\n     * to the local space up vector.\n     *\n     * @remarks\n     * Valid only for icons which have the\n     * \"offset_direction\" property as an attribute of the data, which specifies an angle in degrees\n     * in which direction the offset should take place, i.e. 0 degrees is north, 90 is east etc.\n     */\n    worldOffset?: DynamicProperty<number>;\n}\n\nexport interface LineTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of a line in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * For transparent lines, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Width of line in pixels. WebGL implementations will normally render all lines with 1 pixel\n     * width, and ignore this value.\n     */\n    lineWidth: DynamicProperty<number>;\n}\n\n/**\n * Declares a geometry as a segment.\n */\nexport interface SegmentsTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Color of segments in a hexadecimal notation, for example: `\"#e4e9ec\"` or `\"#fff\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * For transparent lines, set a value between `0.0` for fully transparent, to `1.0` for fully\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Width of a line in meters.\n     */\n    lineWidth: DynamicProperty<number>;\n}\n\n/**\n * Declares a a geometry as a polygon.\n */\nexport interface PolygonalTechniqueParams {\n    /**\n     * Whether to use polygon offset. Default is false.\n     *\n     * @remarks\n     * This corresponds to the\n     * GL_POLYGON_OFFSET_FILL WebGL feature.\n     *\n     * PolygonOffset is used to raise the geometry towards the geometry (for depth calculation\n     * only). Default is false.\n     *\n     * See here: https://sites.google.com/site/threejstuts/home/polygon_offset\n     *\n     * To activate polygonOffset these values have to be set to pull the line \"forwards\":\n     *\n     * transparent: true\n     *\n     * polygonOffset: true\n     *\n     * polygonOffsetFactor : -1.0, (as an example, see link above)\n     *\n     * polygonOffsetUnits: -1 (as an example, see link above)\n     */\n    polygonOffset?: boolean;\n\n    /**\n     * Sets the polygon offset factor. Default is 0.\n     */\n    polygonOffsetFactor?: DynamicProperty<number>;\n\n    /**\n     * Sets the polygon offset units. Default is 0.\n     */\n    polygonOffsetUnits?: DynamicProperty<number>;\n\n    /**\n     * Skip rendering clobbered pixels.\n     * See https://threejs.org/docs/#api/en/materials/Material.depthTest.\n     * @defaultValue `false`\n     */\n    depthTest?: DynamicProperty<boolean>;\n\n    /**\n     * Sets the polygon outline color.\n     * @format color-hex\n     */\n    lineColor?: DynamicProperty<StyleColor>;\n\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges start\n     * fading out.\n     */\n    lineFadeNear?: DynamicProperty<number>;\n\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges become\n     * transparent. A value of <= 0.0 disables fading.\n     */\n    lineFadeFar?: DynamicProperty<number>;\n\n    /**\n     * Set to `true` if line should appear transparent. Rendering transparent lines may come with a\n     * slight performance impact.\n     */\n    transparent?: DynamicProperty<boolean>;\n\n    /**\n     * For transparent lines, set a value between `0.0` for fully transparent, to `1.0` for fully\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n\n    /**\n     * Fill color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n}\n\n/**\n * Declares a a geometry as a basic extruded line.\n */\nexport interface BasicExtrudedLineTechniqueParams\n    extends BaseTechniqueParams,\n        PolygonalTechniqueParams {\n    /**\n     * A value determining the shading technique.\n     *\n     * @remarks\n     * Valid values are \"Basic\" and \"Standard\". Default is \"basic\".\n     *\n     * `\"basic\"`   : Simple shading, faster to render. Only simple color and opacity are effective.\n     * `\"standard\"`: Elaborate shading, with metalness, and roughness.\n     */\n    shading?: \"basic\";\n    /**\n     * Width of line in meters for different zoom levels.\n     */\n    lineWidth: DynamicProperty<number>;\n    /**\n     * A value of `true` creates a wireframe geometry. (May not be supported with all techniques).\n     */\n    wireframe?: boolean;\n    /**\n     * Style of both end caps. Possible values: `\"None\"`, `\"Circle\"`. A value of undefined maps to\n     * `\"Circle\"`.\n     */\n    caps?: DynamicProperty<\"None\" | \"Circle\">;\n}\n\n/**\n * Declares a a geometry as a standard extruded line.\n */\nexport interface StandardExtrudedLineTechniqueParams\n    extends StandardTechniqueParams,\n        PolygonalTechniqueParams {\n    /**\n     * A value determining the shading technique. Valid values are `\"basic\"` and `\"standard\"`.\n     * Default is `\"basic\"`.\n     *\n     * @remarks\n     * `\"basic\"` : Simple shading, faster to render. Only simple color and opacity are effective.\n     * `\"standard\"` : Elaborate shading, with metalness, and roughness.\n     */\n    shading: \"standard\";\n    /**\n     * Width of a line in meters for different zoom levels.\n     */\n    lineWidth: DynamicProperty<number>;\n    /**\n     * Style of both end caps. Possible values: `\"None\"`, `\"Circle\"`.\n     *\n     * @remarks\n     * A value of undefined maps to\n     * `\"Circle\"`.\n     */\n    caps?: DynamicProperty<\"None\" | \"Circle\">;\n}\n\n/**\n * Declares a a geometry as a solid line.\n */\nexport interface SolidLineTechniqueParams extends BaseTechniqueParams, PolygonalTechniqueParams {\n    /**\n     * Color of a line in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color: DynamicProperty<StyleColor>;\n    /**\n     * Color of a line outline in hexadecimal or CSS-style notation,\n     * for example: `\"#e4e9ec\"`, `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    outlineColor?: DynamicProperty<StyleColor>;\n    /**\n     * @deprecated Specify metrics units as part of the value instead.\n     * Units in which different size properties are specified. Either `Meter` (default) or `Pixel`.\n     */\n    metricUnit?: MetricUnit;\n    /**\n     * Width of a line in `metricUnit` for different zoom levels.\n     */\n    lineWidth: DynamicProperty<StyleLength>;\n    /**\n     * Outline width of a line in `metricUnit`s for different zoom levels.\n     */\n    outlineWidth?: DynamicProperty<StyleLength>;\n    /**\n     * Clip the line outside the tile if `true`.\n     * @defaultValue false\n     */\n    clipping?: DynamicProperty<boolean>;\n    /**\n     * Describes the style of the line caps.\n     * @defaultValue `\"Round\"`.\n     */\n    caps?: DynamicProperty<LineCaps>;\n    /**\n     * Color of secondary line geometry in hexadecimal or CSS-style notation, for example:\n     * `\"#e4e9ec\"`, `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    secondaryColor?: DynamicProperty<StyleColor>;\n    /**\n     * Width of secondary line geometry in `metricUnit`s for different zoom levels.\n     */\n    secondaryWidth?: DynamicProperty<StyleLength>;\n    /**\n     * The render order of the secondary line geometry object created using this technique.\n     */\n    secondaryRenderOrder?: DynamicProperty<number>;\n    /**\n     * Describes the style of the secondary line caps\n     * @defaultValue `\"Round\"`.\n     */\n    secondaryCaps?: DynamicProperty<LineCaps>;\n    /**\n     * Describes the category of the secondary geometry object created using this technique.\n     */\n    secondaryCategory?: DynamicProperty<string>;\n    /**\n     * Describes the starting drawing position for the line (in the range [0...1]).\n     * Default is `0.0`.\n     */\n    drawRangeStart?: number;\n    /**\n     * Describes the ending drawing position for the line (in the range [0...1]).\n     * Default is `1.0`.\n     */\n    drawRangeEnd?: number;\n    /**\n     * Describes the style of the line dashes.\n     * @defaultValue `\"Square\"`.\n     */\n    dashes?: DynamicProperty<LineDashes>;\n    /**\n     * Color of a line dashes in hexadecimal or CSS-style notation,\n     * for example: `\"#e4e9ec\"`, `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    dashColor?: DynamicProperty<StyleColor>;\n    /**\n     * Length of a line in meters for different zoom levels.\n     */\n    dashSize?: DynamicProperty<StyleLength>;\n    /**\n     * Size of a gap between lines in meters for different zoom levels.\n     */\n    gapSize?: DynamicProperty<StyleLength>;\n    /**\n     * Size in world units how far to offset the line perpendicular to its direction.\n     */\n    offset?: DynamicProperty<number>;\n}\n\n/**\n * Technique used to draw filled polygons.\n */\nexport interface FillTechniqueParams extends BaseTechniqueParams, PolygonalTechniqueParams {\n    /**\n     * A value of `true` creates a wireframe geometry. (May not be supported with all techniques).\n     */\n    wireframe?: boolean;\n    /**\n     * Width of the lines. Currently limited to the [0, 1] range.\n     */\n    lineWidth?: DynamicProperty<number>;\n\n    /*\n     * URL or texture buffer that should be used as color map. See:\n     * https://threejs.org/docs/#api/en/materials/MeshBasicMaterial.map\n     */\n    map?: DynamicProperty<string | TextureBuffer>;\n    mapProperties?: DynamicProperty<TextureProperties>;\n\n    /**\n     * Whether and how texture coordinates should be generated. No texture coordinates are\n     * generated if `undefined`.\n     * Should be set if a `map` is assigned.\n     */\n    textureCoordinateType?: TextureCoordinateType;\n}\n\n/**\n * Technique used to draw a geometry as an extruded polygon, for example extruded buildings.\n */\nexport interface ExtrudedPolygonTechniqueParams extends StandardTechniqueParams {\n    /**\n     * Renders the footprint lines if set to 'true'.\n     */\n    footprint?: boolean;\n    /**\n     * Set to a negative value to remove all the vertical lines, and to a value between 0.0 and 1.0\n     * to modulate the amount of vertical lines rendered.\n     */\n    maxSlope?: number;\n    /**\n     * Width of the lines. Currently limited to the [0, 1] range.\n     */\n    lineWidth: DynamicProperty<number>;\n    /**\n     * Fill color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    lineColor?: DynamicProperty<StyleColor>;\n    /**\n     * Mix value between the lineColor(0.0) and the geometry's vertex colors(1.0).\n     */\n    lineColorMix?: number;\n\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges start\n     * fading out.\n     */\n    lineFadeNear?: DynamicProperty<number>;\n    /**\n     * Distance to the camera (0.0 = nearPlane, 1.0 = farPlane) at which the object edges become\n     * transparent. A value of <= 0.0 disables fading.\n     */\n    lineFadeFar?: DynamicProperty<number>;\n\n    /**\n     * Height above ground in world units of extruded polygon.\n     *\n     * Usually, unique per feature, so defaults to `[\"get\", \"height\"]`.\n     */\n    height?: DynamicProperty<number>;\n\n    /**\n     * Height of \"floor\" of extruded polygon in world units of extruded polygon.\n     *\n     * Usually, unique per feature, so defaults to `[\"number\", [\"get\", \"min_height\"], 0]`.\n     */\n    floorHeight?: DynamicProperty<number>;\n\n    /**\n     * In some data sources, for example Tilezen, building extrusion information might be missing.\n     * This attribute allows to define a default height of an extruded polygon in the theme.\n     *\n     * @deprecated use [[height]]\n     */\n    defaultHeight?: number;\n\n    /**\n     * Default color used if feature doesn't provide color attribute\n     * and [[MapEnv]] did not return it too.\n     * @format color-hex\n     */\n    defaultColor?: DynamicProperty<StyleColor>;\n\n    /**\n     * If `true`, wall geometry will is added along the tile boundaries.\n     *\n     * @remarks\n     * this causes artifacts when used with shadows,\n     * so it should be known in advance that shadows won't be enabled.\n     * @defaultValue `false`\n     */\n    boundaryWalls?: boolean;\n\n    /**\n     * Animate the extrusion of the buildings if set to `true`.\n     */\n    animateExtrusion?: DynamicProperty<boolean>;\n\n    /**\n     * Duration of the building's extrusion in milliseconds\n     */\n    animateExtrusionDuration?: number;\n\n    /**\n     * Control rendering of depth prepass before the actual geometry.\n     *\n     * @remarks\n     * Depth prepass is a method to render translucent meshes, hence only the visible front faces of\n     * a mesh are actually rendered, removing artifacts caused by blending with internal faces of\n     * the mesh. This method is used for drawing translucent buildings over map background.\n     *\n     * By default, each [[DataSource]] determines how/if enable the depth pre-pass. A value of\n     * `false` forcefully disables depth prepass.\n     */\n    enableDepthPrePass?: boolean;\n}\n\nexport interface ShaderTechniqueMaterialParameters {\n    [name: string]: any;\n}\n\n/**\n * Special technique for user-defined shaders. See\n * https://threejs.org/docs/#api/harp-materials/ShaderMaterial for details.\n */\nexport interface ShaderTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Parameters for shader. See `THREE.ShaderMaterialParameters`.\n     */\n    params: ShaderTechniqueMaterialParameters;\n\n    /**\n     * Type of primitive for the shader technique.\n     */\n    primitive: \"point\" | \"line\" | \"segments\" | \"mesh\";\n\n    [name: string]: any;\n}\n\n/**\n * Technique used to render a terrain geometry with a texture.\n *\n * @remarks\n * When using this technique, the datasource will produce texture coordinates in\n * local tile space (i.e. [0,0] at south-west and [1,1] at north-east tile corner).\n */\nexport interface TerrainTechniqueParams extends StandardTechniqueParams {\n    /**\n     * Colors to be applied at different heights (as a results of a `displacementMap`).\n     */\n    heightBasedColors?: HeightBasedColors;\n\n    /**\n     * If `heightBasedColors` is defined, this value defines the interpolation method used to\n     * generate the height-based gradient texture (defaults to `Discrete`).\n     * @defaultValue `\"Discrete\"`\n     */\n    heightGradientInterpolation?: \"Discrete\" | \"Linear\" | \"Cubic\";\n\n    /**\n     * If `heightBasedColors` is defined, this value defines the width (in pixels) of the generated\n     * gradient texture.\n     *\n     * @defaultValue `128`\n     */\n    heightGradientWidth?: number;\n}\n\n/**\n * Render geometry as a text.\n */\nexport interface TextTechniqueParams extends BaseTechniqueParams {\n    /**\n     * Text to be displayed for feature.\n     *\n     * @remarks\n     * Defaults to first defined:\n     *  - feature property `label` if present in technique (depreacted);\n     *  - `[\"get\", \"name:short\"]` is `useAbbreviation` is true;\n     *  - `[\"get\", \"iso_code\"]` is `useIsoCode` is true;\n     *  - `[\"get\", \"name:$LANGUAGE\"]` for each specified language;\n     *  - `[\"get\", \"name\"]`.\n     */\n    text?: DynamicProperty<string>;\n\n    /**\n     * Field name of object containing the text to be rendered.\n     *\n     * @deprecated Use `[\"get\", \"FIELD\"]`.\n     */\n    label?: string;\n    /**\n     * If `true`, the abbreviation (field `name:short`) of the elements is used as text.\n     *\n     * @deprecated Use proper expression with [`get`, `name:short`] for this purpose.\n     */\n    useAbbreviation?: boolean;\n    /**\n     * If `true`, the iso code (field 'iso_code') of the elements is used as text.\n     * @remarks\n     * The `iso_code` field contains the ISO 3166-1 2-letter country code.\n     *\n     * @deprecated Use proper expression with [`get`, `iso_code`] for this purpose.\n     */\n    useIsoCode?: boolean;\n    /**\n     * Priority of text, defaults to `0`. Elements with highest priority get placed first.\n     */\n    priority?: DynamicProperty<number>;\n    /**\n     * Scaling factor of the text. Defaults to 0.5, reducing the size ot 50% in the distance.\n     */\n    distanceScale?: number;\n    /**\n     * If `true`, icon is allowed to overlap other labels or icons of lower priority.\n     * @defaultValue `false`\n     */\n    mayOverlap?: boolean;\n    /**\n     * If `true`, element will reserve screen space, other markers of lower priority will not be\n     * able to overlap.\n     * @defaultValue `true`\n     */\n    reserveSpace?: boolean;\n    /**\n     * Fading time for labels in seconds.\n     */\n    textFadeTime?: number;\n    /**\n     * Horizontal offset (to the right) in screen pixels.\n     */\n    xOffset?: number;\n    /**\n     * Vertical offset (up) in screen pixels.\n     */\n    yOffset?: number;\n    /**\n     * Name of the text style.\n     */\n    style?: string;\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    fontName?: string;\n    /**\n     * Size of the text (pixels).\n     */\n    size?: DynamicProperty<number>;\n    /**\n     * Size of the text background (pixels).\n     */\n    backgroundSize?: DynamicProperty<number>;\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    fontStyle?: \"Regular\" | \"Bold\" | \"Italic\" | \"BoldItalic\";\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    fontVariant?: \"Regular\" | \"AllCaps\" | \"SmallCaps\";\n    /**\n     * Glyph local rotation (radians).\n     */\n    rotation?: number;\n    /**\n     * Text color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`, `\"#fff\"`,\n     * `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    color?: DynamicProperty<StyleColor>;\n    /**\n     * Text background color in hexadecimal or CSS-style notation, for example: `\"#e4e9ec\"`,\n     * `\"#fff\"`, `\"rgb(255, 0, 0)\"`, or `\"hsl(35, 11%, 88%)\"`.\n     * @format color-hex\n     */\n    backgroundColor?: DynamicProperty<StyleColor>;\n    /**\n     * For transparent text, set a value between 0.0 for totally transparent, to 1.0 for totally\n     * opaque.\n     */\n    opacity?: DynamicProperty<number>;\n    /**\n     * Background text opacity value.\n     */\n    backgroundOpacity?: DynamicProperty<number>;\n    /**\n     * Inter-glyph spacing (pixels). Scaled by `size`.\n     */\n    tracking?: DynamicProperty<number>;\n    /**\n     * Inter-line spacing (pixels). Scaled by `size`.\n     */\n    leading?: DynamicProperty<number>;\n    /**\n     * Maximum number of lines for this label.\n     */\n    maxLines?: DynamicProperty<number>;\n    /**\n     * Maximum line width (pixels).\n     */\n    lineWidth?: DynamicProperty<number>;\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    canvasRotation?: DynamicProperty<number>;\n    /**\n     * Line typesetting rotation (radians).\n     */\n    lineRotation?: DynamicProperty<number>;\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    wrappingMode?: DynamicProperty<\"None\" | \"Character\" | \"Word\">;\n    /**\n     * Text position regarding the baseline.\n     */\n    hAlignment?: DynamicProperty<\"Left\" | \"Center\" | \"Right\">;\n    /**\n     * Text position inside a line.\n     */\n    vAlignment?: DynamicProperty<\"Above\" | \"Center\" | \"Below\">;\n}\n\n/**\n * Buffer holding a texture.\n */\nexport interface TextureBuffer {\n    /**\n     * Buffer containing the (compressed) image or the raw texture data.\n     */\n    buffer: ArrayBuffer;\n\n    /**\n     * Mime type of the image or 'image/raw' in case of raw texture data.\n     */\n    type: string;\n\n    /**\n     * Properties for creating a three.js DataTexture\n     * (https://threejs.org/docs/#api/en/textures/DataTexture).\n     */\n    dataTextureProperties?: DataTextureProperties;\n}\n\n/**\n * Type guard to check if an object is an instance of `TextureBuffer`.\n */\nexport function isTextureBuffer(object: any): object is TextureBuffer {\n    return object && object.buffer && typeof object.type === \"string\";\n}\n\n/**\n * Properties of a DataTexture (https://threejs.org/docs/#api/en/textures/DataTexture).\n */\nexport interface DataTextureProperties {\n    width: number;\n    height: number;\n\n    format?: PixelFormat;\n    type?: TextureDataType;\n}\n\n/**\n * Properties of a Texture (https://threejs.org/docs/#api/en/textures/Texture).\n */\nexport interface TextureProperties {\n    /**\n     * Texture horizontal wrapping mode.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.wrapS.\n     */\n    wrapS?: WrappingMode;\n\n    /**\n     * Texture vertical wrapping mode.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.wrapT.\n     */\n    wrapT?: WrappingMode;\n\n    /**\n     * Texture magnification filter.\n     */\n    magFilter?: MagFilter;\n\n    /**\n     * Texture minification filter.\n     */\n    minFilter?: MinFilter;\n\n    /**\n     * Flip texture vertically.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.flipY.\n     */\n    flipY?: boolean;\n\n    /**\n     * Texture horizontal repetition rate.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.repeat.\n     */\n    repeatU?: number;\n\n    /**\n     * Texture vertical repetition rate.\n     * See: https://threejs.org/docs/#api/en/textures/Texture.repeat.\n     */\n    repeatV?: number;\n}\n\n/**\n * Interface containing the definition of different colors to be used at different heights with the\n * [[TerrainTechnique]].\n */\nexport interface HeightBasedColors {\n    heightArray: number[];\n    colorArray: string[];\n}\n\nexport type PixelFormat =\n    | \"Alpha\"\n    | \"RGB\"\n    | \"RGBA\"\n    | \"Luminance\"\n    | \"LuminanceAlpha\"\n    | \"RGBE\"\n    | \"Depth\"\n    | \"DepthStencil\"\n    | \"Red\";\n\nexport type TextureDataType =\n    | \"UnsignedByte\"\n    | \"Byte\"\n    | \"Short\"\n    | \"UnsignedShort\"\n    | \"Int\"\n    | \"UnsignedInt\"\n    | \"Float\"\n    | \"HalfFloat\";\n\n/**\n * Available texture wrapping modes.\n */\nexport type WrappingMode = \"clamp\" | \"repeat\" | \"mirror\";\n\n/**\n * Available texture magnification filters.\n */\nexport type MagFilter = \"nearest\" | \"linear\";\n\n/**\n * Available texture minification filters.\n */\nexport type MinFilter =\n    | \"nearest\"\n    | \"nearestMipMapNearest\"\n    | \"nearestMipMapLinear\"\n    | \"linear\"\n    | \"linearMipMapNearest\"\n    | \"linearMipMapLinear\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Expr, JsonExpr } from \"./Expr\";\nimport { InterpolatedPropertyDefinition } from \"./InterpolatedPropertyDefs\";\nimport {\n    BaseTechniqueParams,\n    BasicExtrudedLineTechniqueParams,\n    ExtrudedPolygonTechniqueParams,\n    FillTechniqueParams,\n    isTextureBuffer,\n    LineTechniqueParams,\n    MarkerTechniqueParams,\n    PointTechniqueParams,\n    SegmentsTechniqueParams,\n    ShaderTechniqueParams,\n    SolidLineTechniqueParams,\n    StandardExtrudedLineTechniqueParams,\n    StandardTechniqueParams,\n    TerrainTechniqueParams,\n    TextTechniqueParams,\n    TextureCoordinateType\n} from \"./TechniqueParams\";\nimport { StylePriority } from \"./Theme\";\n\n/**\n * Names of the supported texture properties.\n * @internal\n */\nexport const TEXTURE_PROPERTY_KEYS = [\n    \"map\",\n    \"normalMap\",\n    \"displacementMap\",\n    \"roughnessMap\",\n    \"emissiveMap\",\n    \"alphaMap\",\n    \"metalnessMap\",\n    \"bumpMap\"\n];\n\n// TODO: Can be removed, when all when interpolators are implemented as {@link Expr}s\ntype RemoveInterpolatedPropDef<T> = T | InterpolatedPropertyDefinition<any> extends T\n    ? Exclude<T, InterpolatedPropertyDefinition<any>>\n    : T;\ntype RemoveJsonExpr<T> = T | JsonExpr extends T ? Exclude<T, JsonExpr> : T;\n\n/**\n * Make runtime representation of technique attributes from JSON-compatible typings.\n *\n * Translates\n *  - InterpolatedPropertyDefinition -> InterpolatedProperty\n *  - JsonExpr -> Expr\n */\nexport type MakeTechniqueAttrs<T> = {\n    [P in keyof T]: T[P] | JsonExpr extends T[P]\n        ? RemoveInterpolatedPropDef<RemoveJsonExpr<T[P]>> | Expr\n        : T[P];\n};\n\n/**\n * Possible techniques that can be used to draw a geometry on the map.\n */\nexport type Technique =\n    | SquaresTechnique\n    | CirclesTechnique\n    | PoiTechnique\n    | LineMarkerTechnique\n    | LineTechnique\n    | SegmentsTechnique\n    | SolidLineTechnique\n    | FillTechnique\n    | StandardTechnique\n    | TerrainTechnique\n    | BasicExtrudedLineTechnique\n    | StandardExtrudedLineTechnique\n    | ExtrudedPolygonTechnique\n    | ShaderTechnique\n    | TextTechnique\n    | LabelRejectionLineTechnique;\n\n/**\n * Runtime representation of `SquaresStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `PointTechniqueParams`.\n */\nexport interface SquaresTechnique extends MakeTechniqueAttrs<PointTechniqueParams> {\n    name: \"squares\";\n}\n\n/**\n * Runtime representation of `CirclesStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `PointTechniqueParams`.\n */\nexport interface CirclesTechnique extends MakeTechniqueAttrs<PointTechniqueParams> {\n    name: \"circles\";\n}\n\n/**\n * Runtime representation of `PoiStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `MarkerTechniqueParams`.\n */\nexport interface PoiTechnique extends MakeTechniqueAttrs<MarkerTechniqueParams> {\n    name: \"labeled-icon\";\n}\n\n/**\n * Runtime representation of `LineMarkerStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `MarkerTechniqueParams`.\n */\nexport interface LineMarkerTechnique extends MakeTechniqueAttrs<MarkerTechniqueParams> {\n    name: \"line-marker\";\n}\n\n/**\n * Runtime representation of `SegmentsStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `SegmentsTechniqueParams`.\n */\nexport interface SegmentsTechnique extends MakeTechniqueAttrs<SegmentsTechniqueParams> {\n    name: \"segments\";\n}\n\n/**\n * Runtime representation of `BasicExtrudedLineStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `BasicExtrudedLineTechniqueParams`.\n */\nexport interface BasicExtrudedLineTechnique\n    extends MakeTechniqueAttrs<BasicExtrudedLineTechniqueParams> {\n    name: \"extruded-line\";\n}\n\n/**\n * Runtime representation of `StandardExtrudedLineStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `StandardExtrudedLineTechniqueParams`.\n */\nexport interface StandardExtrudedLineTechnique\n    extends MakeTechniqueAttrs<StandardExtrudedLineTechniqueParams> {\n    name: \"extruded-line\";\n}\n\n/**\n * Runtime representation of `SolidLineStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `SolidLineTechniqueParams`.\n */\nexport interface SolidLineTechnique extends MakeTechniqueAttrs<SolidLineTechniqueParams> {\n    name: \"solid-line\" | \"dashed-line\";\n}\n\n/**\n * Runtime representation of `LineStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `LineTechniqueParams`.\n */\nexport interface LineTechnique extends MakeTechniqueAttrs<LineTechniqueParams> {\n    name: \"line\";\n}\n\n/**\n * Runtime representation of `FillStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `FillTechniqueParams`.\n */\nexport interface FillTechnique extends MakeTechniqueAttrs<FillTechniqueParams> {\n    name: \"fill\";\n}\n\n/**\n * Technique used to render a mesh geometry.\n * For technique parameters see `StandardTechniqueParams`.\n */\nexport interface StandardTechnique extends MakeTechniqueAttrs<StandardTechniqueParams> {\n    name: \"standard\";\n}\n\n/**\n * Runtime representation of `ExtrudedPolygonStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `ExtrudedPolygonTechniqueParams`.\n */\nexport interface ExtrudedPolygonTechnique\n    extends MakeTechniqueAttrs<ExtrudedPolygonTechniqueParams> {\n    name: \"extruded-polygon\";\n}\n\n/**\n * Runtime representation of `TextStyle` as parsed by `StyleSetEvaluator`.\n * For technique parameters see `TextTechniqueParams`.\n */\nexport interface TextTechnique extends MakeTechniqueAttrs<TextTechniqueParams> {\n    name: \"text\";\n}\n\n/**\n * Special technique for user-defined shaders.\n * For technique parameters see `ShaderTechniqueParams`.\n */\nexport interface ShaderTechnique extends MakeTechniqueAttrs<ShaderTechniqueParams> {\n    name: \"shader\";\n}\n\n/**\n * Technique used to render a terrain geometry with textures.\n * For technique parameters see `TerrainTechniqueParams`.\n */\nexport interface TerrainTechnique extends MakeTechniqueAttrs<TerrainTechniqueParams> {\n    name: \"terrain\";\n}\n\n/**\n * Technique to avoid label rendering on top of certain line geometries.\n * For technique parameters see `BaseTechniqueParams`.\n */\nexport interface LabelRejectionLineTechnique extends MakeTechniqueAttrs<BaseTechniqueParams> {\n    name: \"label-rejection-line\";\n}\n\n/**\n * Names of the properties controlling transparency.\n * @internal\n */\nexport const TRANSPARENCY_PROPERTY_KEYS = [\"opacity\", \"transparent\"];\n\n/**\n * Additional params used for optimized usage of `Techniques`.\n */\nexport interface IndexedTechniqueParams {\n    /**\n     * Optimization: Index into table in `StyleSetEvaluator` or in `DecodedTile`.\n     * @hidden\n     */\n    _index: number;\n\n    /**\n     * Optimization: Unique `Technique` index of `Style` from which technique was derived.\n     * @hidden\n     */\n    _styleSetIndex: number;\n\n    /**\n     * The styleSet associated to this `Technique`.\n     * @hidden\n     */\n    _styleSet?: string;\n\n    /**\n     * The category used to assign render orders to objects created using this `Technique`.\n     * @hidden\n     */\n    _category?: string;\n\n    /**\n     * The category used to assign render orders to secondary objects\n     * created using this `Technique`.\n     * @hidden\n     */\n    _secondaryCategory?: string;\n\n    /**\n     * `true` if any of the properties of this technique needs to access\n     * the feature's state.\n     *\n     * @hidden\n     */\n    _usesFeatureState?: boolean;\n\n    /**\n     * Last computed state derived from [[Technique.kind]].\n     */\n    _kindState?: boolean;\n}\n\n/**\n * For efficiency, `StyleSetEvaluator` returns `Techniques` additional params as defined in\n * `IndexedTechniqueParams`.\n */\nexport type IndexedTechnique = Technique & IndexedTechniqueParams;\n\n/**\n * Type guard to check if an object is an instance of `CirclesTechnique`.\n */\nexport function isCirclesTechnique(technique: Technique): technique is CirclesTechnique {\n    return technique.name === \"circles\";\n}\n\n/**\n * Type guard to check if an object is an instance of `SquaresTechnique`.\n */\nexport function isSquaresTechnique(technique: Technique): technique is SquaresTechnique {\n    return technique.name === \"squares\";\n}\n\n/**\n * Type guard to check if an object is an instance of `PoiTechnique`.\n */\nexport function isPoiTechnique(technique: Technique): technique is PoiTechnique {\n    return technique.name === \"labeled-icon\";\n}\n\n/**\n * Type guard to check if an object is an instance of `LineMarkerTechnique`.\n */\nexport function isLineMarkerTechnique(technique: Technique): technique is LineMarkerTechnique {\n    return technique.name === \"line-marker\";\n}\n\n/**\n * Type guard to check if an object is an instance of `LineTechnique`.\n */\nexport function isLineTechnique(technique: Technique): technique is LineTechnique {\n    return technique.name === \"line\";\n}\n\n/**\n * Type guard to check if an object is an instance of `SolidLineTechnique`.\n */\nexport function isSolidLineTechnique(technique: Technique): technique is SolidLineTechnique {\n    return technique.name === \"solid-line\" || technique.name === \"dashed-line\";\n}\n\n/**\n * Type guard to check if an object is an instance of `SolidLineTechnique` and is a kind that\n * has special dashes.\n * @note Lines with special dashes need line caps to render properly.\n */\nexport function isSpecialDashesLineTechnique(\n    technique: Technique\n): technique is SolidLineTechnique {\n    return (\n        (technique.name === \"solid-line\" || technique.name === \"dashed-line\") &&\n        technique.dashes !== undefined &&\n        technique.dashes !== \"Square\"\n    );\n}\n\n/**\n * Type guard to check if an object is an instance of `SegmentsTechnique`.\n */\nexport function isSegmentsTechnique(technique: Technique): technique is SegmentsTechnique {\n    return technique.name === \"segments\";\n}\n\n/**\n * Type guard to check if an object is an instance of `BasicExtrudedLineTechnique`\n * or `StandardExtrudedLineTechnique`.\n */\nexport function isExtrudedLineTechnique(\n    technique: Technique\n): technique is BasicExtrudedLineTechnique | StandardExtrudedLineTechnique {\n    return technique.name === \"extruded-line\";\n}\n\n/**\n * Type guard to check if an object is an instance of `BasicExtrudedLineTechnique`.\n */\nexport function isBasicExtrudedLineTechnique(\n    technique: Technique\n): technique is BasicExtrudedLineTechnique {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"basic\";\n}\n\n/**\n * Type guard to check if an object is an instance of `StandardExtrudedLineTechnique`.\n */\nexport function isStandardExtrudedLineTechnique(\n    technique: Technique\n): technique is StandardExtrudedLineTechnique {\n    return isExtrudedLineTechnique(technique) && technique.shading === \"standard\";\n}\n\n/**\n * Type guard to check if an object is an instance of `FillTechnique`.\n */\nexport function isFillTechnique(technique: Technique): technique is FillTechnique {\n    return technique.name === \"fill\";\n}\n\n/**\n * Type guard to check if an object is an instance of `ExtrudedPolygonTechnique`.\n */\nexport function isExtrudedPolygonTechnique(\n    technique: Technique\n): technique is ExtrudedPolygonTechnique {\n    return technique.name === \"extruded-polygon\";\n}\n\n/**\n * Type guard to check if an object is an instance of `StandardTechnique`.\n */\nexport function isStandardTechnique(technique: Technique): technique is StandardTechnique {\n    return technique.name === \"standard\";\n}\n\n/**\n * Type guard to check if an object is an instance of `TerrainTechnique`.\n */\nexport function isTerrainTechnique(technique: Technique): technique is TerrainTechnique {\n    return technique.name === \"terrain\";\n}\n\n/**\n * Type guard to check if an object is an instance of `TextTechnique`.\n */\nexport function isTextTechnique(technique: Technique): technique is TextTechnique {\n    return technique.name === \"text\";\n}\n\n/**\n * Type guard to check if an object is an instance of `ShaderTechnique`.\n */\nexport function isShaderTechnique(technique: Technique): technique is ShaderTechnique {\n    return technique.name === \"shader\";\n}\n\nexport function isLabelRejectionLineTechnique(\n    technique: Technique\n): technique is LabelRejectionLineTechnique {\n    return technique.name === \"label-rejection-line\";\n}\n\n/**\n * Check if vertex normals should be generated for this technique (if no normals are in the data).\n * @param technique - Technique to check.\n */\nexport function needsVertexNormals(technique: Technique): boolean {\n    return (\n        isExtrudedPolygonTechnique(technique) ||\n        isFillTechnique(technique) ||\n        isStandardTechnique(technique) ||\n        isTerrainTechnique(technique) ||\n        isStandardExtrudedLineTechnique(technique)\n    );\n}\n\n/**\n * Type guard to check if an object is an instance of a technique with textures.\n */\nexport function supportsTextures(\n    technique: Technique\n): technique is FillTechnique | StandardTechnique | ExtrudedPolygonTechnique | TerrainTechnique {\n    return (\n        isFillTechnique(technique) ||\n        isStandardTechnique(technique) ||\n        isExtrudedPolygonTechnique(technique) ||\n        isTerrainTechnique(technique)\n    );\n}\n\n/**\n * Get the texture coordinate type if the technique supports it.\n */\nexport function textureCoordinateType(technique: Technique): TextureCoordinateType | undefined {\n    return supportsTextures(technique) || isShaderTechnique(technique)\n        ? technique.textureCoordinateType\n        : undefined;\n}\n\n/**\n * Add all the buffers of the technique to the transfer list.\n */\nexport function addBuffersToTransferList(technique: Technique, transferList: ArrayBuffer[]) {\n    if (\n        isStandardTechnique(technique) ||\n        isExtrudedPolygonTechnique(technique) ||\n        isTerrainTechnique(technique)\n    ) {\n        for (const texturePropertyKey of TEXTURE_PROPERTY_KEYS) {\n            const textureProperty = (technique as any)[texturePropertyKey];\n            if (isTextureBuffer(textureProperty)) {\n                if (textureProperty.buffer instanceof ArrayBuffer) {\n                    transferList.push(textureProperty.buffer);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Compose full texture name for given image name with technique specified.\n * Some techniques allows to add prefix/postfix to icons names specified, this\n * function uses technique information to create fully qualified texture name.\n * @param imageName - base name of the marker icon.\n * @param technique - the technique describing POI or line marker.\n * @returns fully qualified texture name for loading from atlas (without extension).\n */\nexport function composeTechniqueTextureName(\n    imageName: string,\n    technique: PoiTechnique | LineMarkerTechnique\n): string {\n    let textureName = imageName;\n    if (typeof technique.imageTexturePrefix === \"string\") {\n        textureName = technique.imageTexturePrefix + textureName;\n    }\n    if (typeof technique.imageTexturePostfix === \"string\") {\n        textureName = textureName + technique.imageTexturePostfix;\n    }\n    return textureName;\n}\n\n/**\n * Sets a technique's render order (or priority for screen-space techniques) depending on its\n * category and the priorities specified in a given theme.\n * @param technique- The technique whose render order or priority will be set.\n * @param theme - The theme from which the category priorities will be taken.\n */\nexport function setTechniqueRenderOrderOrPriority(\n    technique: IndexedTechnique,\n    priorities: StylePriority[],\n    labelPriorities: string[]\n) {\n    if (\n        isTextTechnique(technique) ||\n        isPoiTechnique(technique) ||\n        isLineMarkerTechnique(technique)\n    ) {\n        // for screen-space techniques the `category` is used to assign\n        // priorities.\n        if (labelPriorities && typeof technique._category === \"string\") {\n            // override the `priority` when the technique uses `category`.\n            const priority = labelPriorities.indexOf(technique._category);\n            if (priority !== -1) {\n                technique.priority = labelPriorities.length - priority;\n            }\n        }\n    } else if (priorities && technique._styleSet !== undefined) {\n        // Compute the render order based on the style category and styleSet.\n        const computeRenderOrder = (category: string): number | undefined => {\n            const priority = priorities?.findIndex(\n                entry => entry.group === technique._styleSet && entry.category === category\n            );\n\n            return priority !== undefined && priority !== -1 ? (priority + 1) * 10 : undefined;\n        };\n\n        if (typeof technique._category === \"string\") {\n            // override the renderOrder when the technique is using categories.\n            const renderOrder = computeRenderOrder(technique._category);\n\n            if (renderOrder !== undefined) {\n                technique.renderOrder = renderOrder;\n            }\n        }\n\n        if (typeof technique._secondaryCategory === \"string\") {\n            // override the secondaryRenderOrder when the technique is using categories.\n            const secondaryRenderOrder = computeRenderOrder(technique._secondaryCategory);\n\n            if (secondaryRenderOrder !== undefined) {\n                (technique as any).secondaryRenderOrder = secondaryRenderOrder;\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Vector3Like } from \"@here/harp-geoutils/lib/math/Vector3Like\";\n\nimport { JsonExpr, JsonValue } from \"./Expr\";\nimport { InterpolatedPropertyDefinition } from \"./InterpolatedPropertyDefs\";\nimport {\n    BaseTechniqueParams,\n    BasicExtrudedLineTechniqueParams,\n    ExtrudedPolygonTechniqueParams,\n    FillTechniqueParams,\n    LineTechniqueParams,\n    MarkerTechniqueParams,\n    Pickability,\n    PointTechniqueParams,\n    SegmentsTechniqueParams,\n    ShaderTechniqueParams,\n    SolidLineTechniqueParams,\n    StandardExtrudedLineTechniqueParams,\n    StandardTechniqueParams,\n    TerrainTechniqueParams,\n    TextTechniqueParams\n} from \"./TechniqueParams\";\n\n/**\n * Map theme is used to define what features are shown and how the map is styled, for example\n * which lightning is used or whether fog should be displayed.\n */\nexport interface Theme {\n    /**\n     * The URI of the JSON schema describing themes.\n     */\n    $schema?: string;\n\n    /**\n     * The base `Theme`s or `theme` URLs to extend.\n     *\n     * @remarks\n     * If used, base themes are loaded first, and then all the properties from inherited theme\n     * overwrite these defined in base theme.\n     */\n\n    extends?: string | Theme | FlatTheme | Array<string | Theme | FlatTheme>;\n\n    /**\n     * Actual URL the theme has been loaded from.\n     */\n    url?: string;\n\n    /**\n     * Color to be used as a clear background - no map objects.\n     * @format color-hex\n     */\n    clearColor?: string;\n\n    /**\n     * Alpha to be used as a clear background - no map objects.\n     * @format 0-1\n     */\n    clearAlpha?: number;\n\n    /**\n     * Define the default text style for styling labels and texts.\n     */\n    defaultTextStyle?: TextStyleDefinition;\n\n    /**\n     * Define the lightning available on the three.js scene.\n     */\n    lights?: Light[];\n\n    /**\n     * Define the style of the sky presented in the map scene.\n     */\n    sky?: Sky;\n\n    /**\n     * Define the fog used in the map scene.\n     */\n    fog?: Fog;\n\n    /**\n     * The definitions exported by these theme.\n     */\n    definitions?: Definitions;\n\n    /**\n     * Map styles available for datasources used to render the map.\n     */\n    styles?: Styles;\n\n    /**\n     * Define the style to render different types of text used on the map.\n     */\n    textStyles?: TextStyleDefinition[];\n\n    /**\n     * List available fonts to be used while rendering text.\n     */\n    fontCatalogs?: FontCatalogConfig[];\n\n    /**\n     * Optional images to be rendered on the map view.\n     */\n    images?: ImageDefinitions;\n\n    /**\n     * Image textures to be used while rendering geometries on the map view.\n     */\n    imageTextures?: ImageTexture[];\n\n    /**\n     * Optional list of [[ThemePoiTableDef]]s.\n     */\n    poiTables?: PoiTableRef[];\n\n    /**\n     * Optional list of symbolic priorities for the object\n     * created using this {@link Theme}.\n     *\n     * @remarks\n     * The attribute `styleSet` and `category` of the [[Technique]]\n     * are used together with [[Theme.priorities]] to sort\n     * the objects created using this {@link Theme}, for example:\n     *\n     *\n     * ```json\n     * {\n     *      \"priorities\": [\n     *          { \"group\": \"tilezen\", \"category\": \"outline-1\" }\n     *      ],\n     *      \"styles\": [\n     *          {\n     *              \"technique\": \"solid-line\",\n     *              \"styleSet\": \"tilezen\",\n     *              \"category\": \"outline-1\"\n     *          }\n     *      ]\n     * }\n     * ```\n     */\n    priorities?: StylePriority[];\n\n    /**\n     * Optional list of priorities for the screen-space\n     * objects created using this style.\n     *\n     * @remarks\n     * The name of the `category` attribute of the screen-space\n     * technique (e.g. `\"text\"`) must match on the strings\n     * defined by this [[Theme.labelPriorities]], for example:\n     *\n     * ```json\n     * {\n     *      \"labelPriorities\": [\n     *          \"continent-labels\",\n     *          \"country-labels\",\n     *          \"state-labels\"\n     *      ],\n     *      \"styles\": [\n     *          {\n     *              \"technique\": \"text\",\n     *              \"category\": \"state-labels\"\n     *          }\n     *      ]\n     * }\n     * ```\n     */\n    labelPriorities?: string[];\n}\n\n/**\n * A type representing symbolic render orders.\n */\nexport interface StylePriority {\n    /**\n     * The group of this `StylePriority`.\n     */\n    group: string;\n\n    /**\n     * The category of this `StylePriority`.\n     */\n    category?: string;\n}\n\n/**\n * A type representing HARP themes with all the styleset declarations\n * grouped in one `Array`.\n *\n * @internal This type will merge with {@link Theme}.\n */\nexport type FlatTheme = Omit<Theme, \"styles\"> & {\n    /**\n     * The style rules used to render the map.\n     */\n    styles?: StyleSet;\n};\n\n/**\n * Value definition commons.\n */\nexport type Definition = JsonValue | InterpolatedPropertyDefinition<JsonValue>;\n\n/**\n * This is the old, more verbose, format of the definitions, to be deprecated\n * @deprecated\n */\nexport interface VerboseDefinition {\n    /**\n     * The type of the definition.\n     */\n    type?: \"selector\" | \"boolean\" | \"number\" | \"string\" | \"color\";\n\n    /**\n     * The value of the definition.\n     */\n    value: Definition;\n\n    /**\n     * The description of the definition.\n     */\n    description?: string;\n}\n\n/**\n * This is to distinguish between definition types at runtime, to be deprecated with\n * {@link VerboseDefinition}\n * @deprecated\n *\n * @param definition\n * @returns `true` if the Definition is of the deprecated {@link VerboseDefinition} type\n */\nexport function isVerboseDefinition(definition: VerboseDefinition | Definition) {\n    return (definition as VerboseDefinition)?.value !== undefined;\n}\n\n/**\n * This is a utility function to retrive a definitions value until {@link VerboseDefinition} is fully\n * deprecated\n * @deprecated\n *\n * @param definition\n * @returns value of the given definition.\n */\nexport function getDefinitionValue(definition: VerboseDefinition | Definition): Definition {\n    return isVerboseDefinition(definition)\n        ? (definition as VerboseDefinition).value\n        : (definition as Definition);\n}\n\n/*\n * An set of {@link Definition}s.\n */\nexport interface Definitions {\n    [name: string]: Definition | VerboseDefinition;\n}\n\nexport type JsonExprReference = [\"ref\", string];\n\n/**\n * Checks if the given value is a reference to a definition.\n *\n * @param value - The value of a technique property.\n */\nexport function isJsonExprReference(value: any): value is JsonExprReference {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        value[0] === \"ref\" &&\n        typeof value[1] === \"string\"\n    );\n}\n\n/**\n * An array of {@link Style}s that are used together to define how a\n * {@link @here/harp-mapview#DataSource} should be rendered.\n *\n * @remarks\n * `StyleSet`s are applied to sources providing vector tiles via their method\n * `setStyleSet`. This is also handle internally when a whole theme is passed to a\n * {@link @here/harp-mapview#MapView} via {@link @here/harp-mapview#MapViewtheme}.\n */\nexport type StyleSet = Style[];\n\n/**\n * The object that defines what way an item of a {@link @here/harp-mapview#DataSource}\n * should be decoded to assemble a tile.\n *\n * @remarks\n * {@link Style} is describing which features are shown on a map and in what way they are being\n * shown.\n */\nexport type BaseStyle<Technique, Params> = StyleAttributes<Technique, Params> & Partial<Params>;\n\n/**\n * The common attributes of a {@link Style}.\n */\nexport interface StyleAttributes<Technique, Params> {\n    /**\n     * Unique identifier associated with this `Style`.\n     */\n    id?: string;\n\n    /**\n     * Reference to the identifier of an existing `Style` to extend.\n     */\n    extends?: string;\n\n    /**\n     * Condition when this style rule applies.\n     *\n     * @remarks\n     * Condition that is applied to feature properties to check if given {@link Style} this feature\n     * should emit geometry of this style.\n     */\n    when?: string | JsonExpr;\n\n    /**\n     * The layer containing the carto features processed by this style rule.\n     */\n    layer?: string;\n\n    /**\n     * Optional. If `true`, no more matching styles will be evaluated.\n     */\n    final?: boolean;\n\n    /**\n     * Human readable description.\n     */\n    description?: string;\n\n    /**\n     * The style set referenced by this styling rule.\n     */\n    styleSet?: string;\n\n    /**\n     * The category of this style.\n     */\n    category?: string | JsonExpr;\n\n    /**\n     * The name of the technique to use.\n     *\n     * @remarks\n     * Technique name. See the classes extending from this class to determine what possible\n     * techniques are possible, includes `\"line\"`, `\"fill\"`, `\"solid-line\"`, `\"extruded-line\"`,\n     * `\"extruded-polygon\"`, `\"text\"`, `\"none\"`.\n     */\n    technique: Technique;\n\n    /**\n     * Specify `renderOrder` of value.\n     *\n     * @remarks\n     * @default If not specified in style file, `renderOrder` will be assigned with monotonically\n     * increasing values according to style position in file.\n     */\n    renderOrder?: number | JsonExpr;\n\n    /**\n     * Minimal zoom level. If the current zoom level is smaller, the technique will not be used.\n     */\n    minZoomLevel?: number | JsonExpr;\n\n    /**\n     * Maximum zoom level. If the current zoom level is larger, the technique will not be used.\n     */\n    maxZoomLevel?: number | JsonExpr;\n\n    /**\n     * Optional. If `true` or `Pickability.transient`, no IDs will be saved for the geometry\n     * this style creates. Default is `Pickability.onlyVisible`, which allows all pickable and visible\n     * objects to be picked, Pickability.all, will also allow invisible objects to be\n     * picked.\n     * @defaultValue `Pickability.onlyVisible`\n     * The boolean option is for backwardscompatibilty, please use the Pickability.\n     *\n     *\n     * TODO: deprecate and rename to something that makes more sense\n     */\n    transient?: boolean | Pickability;\n\n    /**\n     * Optional: If `true`, the objects with matching `when` statement will be printed to the\n     * console.\n     */\n    debug?: boolean;\n\n    /**\n     * @deprecated Technique parameters are now properties at the Style interface level.\n     */\n    attr?: Partial<Params>;\n}\n\nexport type Style =\n    | SquaresStyle\n    | CirclesStyle\n    | PoiStyle\n    | LineMarkerStyle\n    | LineStyle\n    | SegmentsStyle\n    | SolidLineStyle\n    | LabelRejectionLineStyle\n    | FillStyle\n    | StandardStyle\n    | BasicExtrudedLineStyle\n    | StandardExtrudedLineStyle\n    | ExtrudedPolygonStyle\n    | ShaderStyle\n    | TerrainStyle\n    | TextTechniqueStyle\n    | NoneStyle;\n\n/**\n * A dictionary of {@link StyleSet}s.\n */\nexport interface Styles {\n    [styleSetName: string]: StyleSet;\n}\n\n/**\n * A reference to a style definition.\n *\n * @remarks\n * Use as value `attrs` to reference value from `definitions`.\n *\n * Example of usage:\n * ```json\n * {\n *   \"definitions\": {\n *     \"roadColor\": \"#f00\"\n *   },\n *   \"styles\": { \"tilezen\": [\n *      {\n *       \"when\": \"kind == 'road\",\n *       \"technique\": \"solid-line\",\n *       \"attr\": {\n *         \"lineColor\": { \"$ref\": \"roadColor\" }\n *       }\n *     }\n *   ] }\n * }\n *```\n */\n\n/**\n * The attributes of a technique.\n */\nexport type Attr<T> = { [P in keyof T]?: T[P] | JsonExpr };\n\n/**\n * Render feature as set of squares rendered in screen space.\n *\n * @see {@link PointTechniqueParams}.\n */\nexport type SquaresStyle = BaseStyle<\"squares\", PointTechniqueParams>;\n\n/**\n * Render feature as set of circles rendered in screen space.\n *\n * @see {@link PointTechniqueParams}.\n */\nexport type CirclesStyle = BaseStyle<\"circles\", PointTechniqueParams>;\n\n/**\n * Render feature as POIs (icons and text) rendered in screen space.\n *\n * @see [[MarkerTechniqueParams]].\n */\nexport type PoiStyle = BaseStyle<\"labeled-icon\", MarkerTechniqueParams>;\n\n/**\n * Render feature as line markers, which is a recurring marker along a line (usually road).\n *\n * @see [[MarkerTechniqueParams]].\n */\nexport type LineMarkerStyle = BaseStyle<\"line-marker\", MarkerTechniqueParams>;\n\n/**\n * Render feature as line.\n */\nexport type LineStyle = BaseStyle<\"line\", LineTechniqueParams>;\n\n/**\n * Render feature as segments.\n */\nexport type SegmentsStyle = BaseStyle<\"segments\", SegmentsTechniqueParams>;\n\nexport type SolidLineStyle = BaseStyle<\"solid-line\" | \"dashed-line\", SolidLineTechniqueParams>;\n\nexport type LabelRejectionLineStyle = BaseStyle<\"label-rejection-line\", BaseTechniqueParams>;\n\nexport type FillStyle = BaseStyle<\"fill\", FillTechniqueParams>;\n\nexport type StandardStyle = BaseStyle<\"standard\", StandardTechniqueParams>;\n\nexport type TerrainStyle = BaseStyle<\"terrain\", TerrainTechniqueParams>;\n\nexport type BasicExtrudedLineStyle = BaseStyle<\"extruded-line\", BasicExtrudedLineTechniqueParams>;\n\nexport type StandardExtrudedLineStyle = BaseStyle<\n    \"extruded-line\",\n    StandardExtrudedLineTechniqueParams\n>;\n\n/**\n * Style used to draw a geometry as an extruded polygon, for example extruded buildings.\n */\nexport type ExtrudedPolygonStyle = BaseStyle<\"extruded-polygon\", ExtrudedPolygonTechniqueParams>;\n\nexport type ShaderStyle = BaseStyle<\"shader\", ShaderTechniqueParams>;\n\nexport type TextTechniqueStyle = BaseStyle<\"text\", TextTechniqueParams>;\n\nexport interface NoneStyle\n    extends BaseStyle<\n        \"none\",\n        {\n            [name: string]: any;\n        }\n    > {\n    [name: string]: any;\n}\n\n/**\n * Possible lights used for light the map.\n */\nexport type Light = AmbientLight | DirectionalLight;\n\nexport interface BaseLight {\n    type: string;\n    name: string;\n}\n\n/**\n * Ambient light\n */\nexport interface AmbientLight extends BaseLight {\n    /**\n     * The type of the light.\n     */\n    type: \"ambient\";\n\n    /**\n     * The color of this ambient light.\n     */\n    color: string;\n\n    /**\n     * The intensity of this ambient light.\n     */\n    intensity?: number;\n}\n\n/**\n * Directional light.\n */\nexport interface DirectionalLight extends BaseLight {\n    /**\n     * The type of the light.\n     */\n    type: \"directional\";\n\n    /**\n     * The color of this directional light.\n     */\n    color: string;\n\n    /**\n     * The intensity of this directional light.\n     */\n    intensity: number;\n\n    /**\n     * The direction of this directional light.\n     */\n    direction: Vector3Like;\n\n    /**\n     * Determine if this light casts dynamic shadows.\n     *\n     * @defaultValue false\n     */\n    castShadow?: boolean;\n}\n\n/**\n * Various text styles used with labels and texts.\n */\nexport interface TextStyleDefinition {\n    name?: string;\n    fontCatalogName?: string;\n\n    fontName?: string;\n    size?: number;\n    backgroundSize?: number;\n    fontStyle?: \"Regular\" | \"Bold\" | \"Italic\" | \"BoldItalic\";\n    fontVariant?: \"Regular\" | \"AllCaps\" | \"SmallCaps\";\n    rotation?: number;\n    /**\n     * @format color-hex\n     */\n    color?: string;\n    /**\n     * @format color-hex\n     */\n    backgroundColor?: string;\n    opacity?: number;\n    backgroundOpacity?: number;\n\n    tracking?: number;\n    leading?: number;\n    maxLines?: number;\n    lineWidth?: number;\n    canvasRotation?: number;\n    lineRotation?: number;\n    wrappingMode?: \"None\" | \"Character\" | \"Word\";\n    hAlignment?: \"Left\" | \"Center\" | \"Right\";\n    vAlignment?: \"Above\" | \"Center\" | \"Below\";\n    /**\n     * @format comma separated list of placement tokens, i.e. \"TR, TL, C\"\n     * @see [[PlacementToken]]\n     */\n    placements?: string;\n}\n\n/**\n * Interface that defines a procedural gradient sky.\n */\nexport interface GradientSky {\n    /** Sky type. */\n    type: \"gradient\";\n    /**\n     * Color of the upper part of the gradient.\n     * @format color-hex\n     */\n    topColor: string;\n    /**\n     * Color of bottom part of the gradient.\n     * @format color-hex\n     */\n    bottomColor: string;\n    /**\n     * Color of the ground plane.\n     * @format color-hex\n     */\n    groundColor: string;\n    /** Texture's gradient power. */\n    monomialPower?: number;\n}\n\n/**\n * Interface that defines a cubemap sky.\n */\nexport interface CubemapSky {\n    /** Sky type. */\n    type: \"cubemap\";\n    /** Positive X cube map face. */\n    positiveX: string;\n    /** Negative X cube map face. */\n    negativeX: string;\n    /** Positive Y cube map face. */\n    positiveY: string;\n    /** Negative Y cube map face. */\n    negativeY: string;\n    /** Positive Z cube map face. */\n    positiveZ: string;\n    /** Negative Z cube map face. */\n    negativeZ: string;\n}\n\n/**\n * Interface that defines the options to configure the sky.\n */\nexport type Sky = GradientSky | CubemapSky;\n\n/**\n * Interface that defines the options to configure fog.\n */\nexport interface Fog {\n    /** Fog's color. */\n    color: string;\n    /** Distance ratio to far plane at which the linear fog begins. */\n    startRatio: number;\n}\n\n/**\n * Define an image (e.g. icon).\n */\nexport interface ImageDefinition {\n    /** Url to load content from. */\n    url: string;\n    /** `true` to start loading at init tile, `false` to lazily wait until required. */\n    preload: boolean;\n    /** Url of JSON file containing the texture atlas */\n    atlas?: string;\n}\n\nexport interface ImageDefinitions {\n    /** Name of Image. */\n    [name: string]: ImageDefinition;\n}\n\n/**\n * Can be used to create a texture atlas.\n */\nexport interface ImageTexture {\n    /** Name of ImageTexture. Used to reference texture in the styles. */\n    name: string;\n    /** Name of ImageDefinition to use. */\n    image: string;\n    /** Origin of image, defaults to \"topleft\" */\n    origin?: string;\n    /** Specify sub-region: Defaults to 0. */\n    xOffset?: number;\n    /** Specify sub-region: Defaults to 0. */\n    yOffset?: number;\n    /** Specify sub-region:  Defaults to 0, meaning width is taken from loaded image. */\n    width?: number;\n    /** Specify sub-region:  Defaults to 0, meaning height is taken from loaded image. */\n    height?: number;\n    /** Defaults to false. */\n    flipH?: boolean;\n    /** Defaults to false. */\n    flipV?: boolean;\n    /** Defaults to 1. */\n    opacity?: number;\n}\n\n/**\n * Definition for a [[PoiTable]] reference as part of the {@link Theme} object.\n */\nexport interface PoiTableRef {\n    /** Required name of the [[PoiTable]] for later reference. */\n    name: string;\n    /**\n     * Required URL from where to load [[PoiTable]].\n     *\n     * Should refer to JSON that is matched [[PoiTableDef]] interface.\n     */\n    url: string;\n    /**\n     * If set to `true`, the list of values in the field \"altNames\" will be used as names for this\n     * POI.\n     */\n    useAltNamesForKey: boolean;\n}\n\n/**\n * Interface for the JSON description of the [[PoiTable]]. It is being implemented in [[PoiTable]].\n */\nexport interface PoiTableDef {\n    /** Name of the `PoiTable`. Must be unique. */\n    name?: string;\n    /**\n     * Stores the list of {@link PoiTableEntryDef}s.\n     */\n    poiList?: PoiTableEntryDef[];\n}\n\n/**\n * Interface descrining POI entries.\n */\nexport interface PoiTableEntryDef {\n    /** Default name of the POI as the key for looking it up. */\n    name?: string;\n    /** Alternative names of the POI. */\n    altNames?: string[];\n    /** Visibility of the POI. If `false`, the POI will not be rendered. */\n    visible?: boolean;\n    /** Name of the icon, defined in the the texture atlases. */\n    iconName?: string;\n    /** Stacking mode of the POI. For future use. */\n    stackMode?: string;\n    /**\n     * Priority of the POI to select the visible set in case there are more POIs than can be\n     * handled.\n     */\n    priority?: number;\n    /** Minimum zoom level to render the icon on. */\n    iconMinLevel?: number;\n    /** Maximum zoom level to render the icon on. */\n    iconMaxLevel?: number;\n    /** Minimum zoom level to render the text label on. */\n    textMinLevel?: number;\n    /** Maximum zoom level to render the text label on. */\n    textMaxLevel?: number;\n}\n\n/**\n * Fonts used for all text related rendering.\n */\nexport interface FontCatalogConfig {\n    url: string;\n    name: string;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { isJsonExpr } from \"./Expr\";\nimport { Style, Theme } from \"./Theme\";\n\n/**\n * The ThemeVisitor visits every style in the theme in a depth-first fashion.\n */\nexport class ThemeVisitor {\n    constructor(readonly theme: Theme) {}\n    /**\n     * Applies a function to every style in the theme.\n     *\n     * @param visitFunc - Function to be called with `style` as an argument. Function should return\n     *                  `true` to cancel visitation.\n     * @returns `true` if function has finished prematurely.\n     */\n    visitStyles(visitFunc: (style: Style) => boolean): boolean {\n        const visit = (style: Style): boolean => {\n            if (isJsonExpr(style)) {\n                return false;\n            }\n            if (visitFunc(style)) {\n                return true;\n            }\n            return false;\n        };\n        if (this.theme.styles !== undefined) {\n            for (const styleSetName in this.theme.styles) {\n                if (this.theme.styles[styleSetName] !== undefined) {\n                    for (const style of this.theme.styles[styleSetName]) {\n                        if (visit(style)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BufferAttribute as ThreeBufferAttribute,\n    BufferGeometry as ThreeBufferGeometry,\n    InterleavedBufferAttribute as ThreeInterleavedBufferAttribute\n} from \"three\";\n\nimport {\n    BufferAttribute,\n    BufferElementType,\n    Geometry,\n    GeometryType,\n    InterleavedBufferAttribute\n} from \"./DecodedTile\";\n\n/**\n * Collection of helper methods to convert\n * {@link https://threejs.org/docs/index.html#api/en/core/BufferGeometry|three.js BufferGeometry}\n * to [[Geometry]] that allows creation and transfering of THREE BufferGeometry in webworkers.\n * See also [[CustomDatasourceExample]].\n */\nexport namespace ThreeBufferUtils {\n    export function getBufferElementType(buffer: ArrayBufferView): BufferElementType {\n        if (buffer instanceof Int8Array) {\n            return \"int8\";\n        } else if (buffer instanceof Uint8Array) {\n            return \"uint8\";\n        } else if (buffer instanceof Int16Array) {\n            return \"int16\";\n        } else if (buffer instanceof Uint16Array) {\n            return \"uint16\";\n        } else if (buffer instanceof Int32Array) {\n            return \"int32\";\n        } else if (buffer instanceof Uint32Array) {\n            return \"uint32\";\n        } else if (buffer instanceof Float32Array) {\n            return \"float\";\n        }\n\n        throw new Error(`Unsupported buffer type ${name}`);\n    }\n\n    export function fromThreeBufferAttribute(\n        bufferAttribute: ThreeBufferAttribute\n    ): BufferAttribute {\n        const buffer = (bufferAttribute.array as any) as ArrayBufferView;\n        return {\n            name: bufferAttribute.name,\n            buffer: buffer.buffer,\n            type: getBufferElementType(buffer),\n            itemCount: bufferAttribute.itemSize,\n            normalized: bufferAttribute.normalized\n        };\n    }\n\n    export function fromThreeInterleavedBufferAttribute(\n        bufferAttribute: ThreeInterleavedBufferAttribute\n    ): InterleavedBufferAttribute {\n        throw new Error(\"Not implemented yet\");\n    }\n\n    export function fromThreeBufferGeometry(\n        bufferGeometry: ThreeBufferGeometry,\n        techniqueIndex: number\n    ): Geometry {\n        const vertexAttributes: BufferAttribute[] = [];\n        const attributeNames = Object.getOwnPropertyNames(bufferGeometry.attributes);\n        for (const name of attributeNames) {\n            const attribute = bufferGeometry.attributes[name];\n            // FIXME: Also support InterleavedBufferAttribute\n            const vertexAttribute = fromThreeBufferAttribute(attribute as ThreeBufferAttribute);\n            vertexAttribute.name = name;\n            vertexAttributes.push(vertexAttribute);\n        }\n        const index =\n            bufferGeometry.index !== null\n                ? fromThreeBufferAttribute(bufferGeometry.index)\n                : undefined;\n\n        let count = 0;\n        if (index !== undefined) {\n            count = bufferGeometry.index === null ? 0 : bufferGeometry.index.count;\n        } else {\n            // If there is no index buffer, try to deduce the count from the position attribute.\n            const posAttr = bufferGeometry.attributes.position as ThreeBufferAttribute;\n            if (posAttr === undefined) {\n                throw new Error(\"Missing position attibute to deduce item count\");\n            }\n            count = posAttr.count;\n        }\n\n        return {\n            type: GeometryType.Unspecified,\n            vertexAttributes,\n            index,\n            groups: [{ start: 0, count, technique: techniqueIndex }]\n        };\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Definitions, StylePriority, StyleSet } from \"./Theme\";\nimport { WorkerServiceProtocol } from \"./WorkerServiceProtocol\";\n\n/**\n * Interface for `OptionsMap` which describes a general structure of key-value pairs.\n */\nexport interface OptionsMap {\n    [name: string]: any;\n}\n\n/**\n * Allows to cancel and prioritize requests inside the requestQueue.\n *\n * @remarks\n * Useful to optimize the order of decoding tiles during animations and camera movements.\n *\n * `RequestController` is not extending [[AbortController]], because this is not supported in ES5.\n */\nexport class RequestController implements AbortController {\n    /**\n     * Creates an instance of `RequestController`.\n     *\n     * @param {number} priority\n     * @param {AbortController} abortController Optional [[AbortController]] used internally, since\n     *      [[AbortController]]s should not be subclassed.\n     */\n    constructor(\n        public priority: number = 0,\n        public abortController: AbortController = new AbortController()\n    ) {}\n\n    get signal(): AbortSignal {\n        return this.abortController.signal;\n    }\n\n    /**\n     * Invoking this method will set this object's AbortSignal's aborted flag and\n     * signal to any observers that the associated activity is to be aborted.\n     */\n    abort(): void {\n        this.abortController.abort();\n    }\n}\n\n/**\n * Communication protocol with [[ITileDecoder]].\n */\nexport namespace WorkerDecoderProtocol {\n    /**\n     * Define possible names of messages exchanged with decoder services within `WebWorker`.\n     */\n    export enum DecoderMessageName {\n        Configuration = \"configuration\"\n    }\n\n    /**\n     * Interface for `DecodedTileMessage` which describes metadata for a decoded tile.\n     */\n    export interface DecoderMessage {\n        service: string;\n        type: DecoderMessageName;\n    }\n\n    /**\n     * Interface for a ConfigurationMessage that is sent from the datasource to the decoder. The\n     * message used to configure the [[ITileDecoder]].\n     */\n    export interface ConfigurationMessage extends DecoderMessage {\n        type: DecoderMessageName.Configuration;\n        styleSet?: StyleSet;\n        definitions?: Definitions;\n        priorities?: StylePriority[];\n        labelPriorities?: string[];\n        options?: OptionsMap;\n        languages?: string[];\n    }\n\n    /**\n     * Type guard to check if an object is an instance of `ConfigurationMessage`.\n     */\n    export function isConfigurationMessage(message: any): message is ConfigurationMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === DecoderMessageName.Configuration\n        );\n    }\n\n    /**\n     * Define possible names of requests called on decoder services within `WebWorker`.\n     */\n    export enum Requests {\n        DecodeTileRequest = \"decode-tile-request\",\n        TileInfoRequest = \"tile-info-request\"\n    }\n\n    /**\n     * This object is sent to the decoder asking to decode a specific tile. The expected response\n     * type is a [[DecodedTile]].\n     */\n    export interface DecodeTileRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.DecodeTileRequest;\n        tileKey: number;\n        data: ArrayBufferLike;\n        projection: string;\n    }\n\n    /**\n     * Type guard to check if an object is a decoded tile object sent to a worker.\n     */\n    export function isDecodeTileRequest(message: any): message is DecodeTileRequest {\n        return (\n            message &&\n            typeof message.type === \"string\" &&\n            message.type === Requests.DecodeTileRequest\n        );\n    }\n\n    /**\n     * This object is sent to the decoder asking for a tile info of a specific tile. The expected\n     * response type is a [[DecodedTile]].\n     */\n    export interface TileInfoRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.TileInfoRequest;\n        tileKey: number;\n        data: ArrayBufferLike;\n        projection: string;\n    }\n\n    /**\n     * Type guard to check if an object is an info tile object sent to a worker.\n     */\n    export function isTileInfoRequest(message: any): message is TileInfoRequest {\n        return (\n            message && typeof message.type === \"string\" && message.type === Requests.TileInfoRequest\n        );\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Common communication protocol for [[WorkerService]].\n */\nexport namespace WorkerServiceProtocol {\n    /**\n     * Service id of worker manager ([[WorkerServiceManager]]) used to create/destroy service\n     * instances in workers.\n     */\n    export const WORKER_SERVICE_MANAGER_SERVICE_ID = \"worker-service-manager\";\n\n    /**\n     * Define possible names of messages exchanged with services within `WebWorker`.\n     */\n    export enum ServiceMessageName {\n        Initialized = \"initialized\",\n        Request = \"request\",\n        Response = \"response\"\n    }\n\n    /**\n     * Interface for `ServiceMessage` which describes metadata for a service messages.\n     */\n    export interface ServiceMessage {\n        service: string;\n        type: ServiceMessageName;\n    }\n\n    /**\n     * This message is sent by the worker to the main thread. No data is sent. Receiving this\n     * message confirms that the worker has started successfully.\n     */\n    export interface InitializedMessage extends ServiceMessage {\n        type: ServiceMessageName.Initialized;\n    }\n\n    /**\n     * Type guard to check if an object is a signal message from worker.\n     */\n    export function isInitializedMessage(message: any): message is InitializedMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Initialized\n        );\n    }\n\n    /**\n     * Define possible names of requests called on services within `WebWorker`.\n     */\n    export enum Requests {\n        CreateService = \"create-service\",\n        DestroyService = \"destroy-service\"\n    }\n\n    /**\n     * This is an internal general interface used in communication with workers.\n     * Check [[ConcurrentWorkerSet]]'s invokeRequest function for exemplary usage.\n     */\n    export interface ServiceRequest {\n        type: string;\n    }\n\n    /**\n     * This message is sent by the main thread to [[WorkerServiceManager]] to dynamically create a\n     * new service.\n     *\n     * May throw `UnknownServiceError` if service of given type is not registered in\n     * [[WorkerServiceManager]], see [[isUnknownServiceError]].\n     */\n    export interface CreateServiceRequest extends ServiceRequest {\n        type: Requests.CreateService;\n\n        /**\n         * Type of service to be created.\n         *\n         * @see [[WorkerServiceManager.register]]\n         */\n        targetServiceType: string;\n\n        /**\n         * The newly created service instance will be available under this id.\n         */\n        targetServiceId: string;\n    }\n\n    /**\n     * Test if `error` thrown by [[CreateServiceRequest]] was caused by unknown type of service.\n     */\n    export function isUnknownServiceError(error: Error): boolean {\n        return error.message.includes(\"unknown targetServiceType requested: \");\n    }\n\n    /**\n     * This message is sent by the main thread to [[WorkerServiceManager]] to dynamically destroy a\n     * service.\n     */\n    export interface DestroyServiceRequest extends ServiceRequest {\n        type: Requests.DestroyService;\n\n        /**\n         * Id of service to be destroyed.\n         */\n        targetServiceId: string;\n    }\n\n    /**\n     * Possible service management messages (`CreateService` or `DestroyService`) sent to WebWorker.\n     */\n    export type WorkerServiceManagerRequest = CreateServiceRequest | DestroyServiceRequest;\n\n    /**\n     * This message is a part of the Request-Response scheme implemented to be used in communication\n     * between workers and the decoder.\n     */\n    export interface RequestMessage extends ServiceMessage {\n        type: ServiceMessageName.Request;\n        messageId: number;\n        request: any;\n    }\n\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    export function isRequestMessage(message: any): message is RequestMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Request\n        );\n    }\n\n    /**\n     * This message is a part of the Request-Response scheme implemented to be used in communication\n     * between workers and the decoder.\n     */\n    export interface ResponseMessage extends ServiceMessage {\n        type: ServiceMessageName.Response;\n        messageId: number;\n        errorMessage?: string;\n        errorStack?: string;\n        response?: object;\n    }\n\n    /**\n     * Type guard to check if an object is a request message sent to a worker.\n     */\n    export function isResponseMessage(message: any): message is ResponseMessage {\n        return (\n            message &&\n            typeof message.service === \"string\" &&\n            typeof message.type === \"string\" &&\n            message.type === ServiceMessageName.Response\n        );\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoJson } from \"../lib/GeoJsonDataType\";\nimport { WorkerServiceProtocol } from \"./WorkerServiceProtocol\";\n\n/**\n * Communication protocol with {@link ITiler}.\n */\nexport namespace WorkerTilerProtocol {\n    /**\n     * Define possible names of requests called on tiler services within `WebWorker`.\n     */\n    export enum Requests {\n        RegisterIndex = \"register-index\",\n        UpdateIndex = \"update-index\",\n        TileRequest = \"tile-request\"\n    }\n\n    /**\n     * This object is sent to the tiler to register a new tile index in the worker.\n     */\n    export interface RegisterIndexRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.RegisterIndex;\n        id: string;\n        input: string | GeoJson;\n    }\n\n    /**\n     * Type guard to check if an object is an index registration request sent to a worker.\n     */\n    export function isRegisterIndexRequest(message: any): message is RegisterIndexRequest {\n        return (\n            message && typeof message.type === \"string\" && message.type === Requests.RegisterIndex\n        );\n    }\n\n    /**\n     * This object is sent to the tiler to register a new tile index in the worker.\n     */\n    export interface UpdateIndexRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.UpdateIndex;\n        id: string;\n        input: string | GeoJson;\n    }\n\n    /**\n     * Type guard to check if an object is an update request for the index registration.\n     */\n    export function isUpdateIndexRequest(message: any): message is UpdateIndexRequest {\n        return message && typeof message.type === \"string\" && message.type === Requests.UpdateIndex;\n    }\n\n    /**\n     * This object is sent to the tiler asking to retrieve a specific tile. The expected response\n     * type is an object containing a tiled payload.\n     */\n    export interface TileRequest extends WorkerServiceProtocol.ServiceRequest {\n        type: Requests.TileRequest;\n        index: string;\n        tileKey: number;\n    }\n\n    /**\n     * Type guard to check if an object is a tile request sent to a worker.\n     */\n    export function isTileRequest(message: any): message is TileRequest {\n        return message && typeof message.type === \"string\" && message.type === Requests.TileRequest;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, Expr, JsonArray, NumberLiteralExpr, StringLiteralExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst VALID_ELEMENT_TYPES = [\"boolean\", \"number\", \"string\"];\n\nfunction checkElementTypes(arg: Expr, array: JsonArray) {\n    if (!(arg instanceof StringLiteralExpr) || !VALID_ELEMENT_TYPES.includes(arg.value)) {\n        throw new Error(\n            `expected \"boolean\", \"number\" or \"string\" instead of '${JSON.stringify(arg)}'`\n        );\n    }\n\n    const ty = arg.value;\n\n    array.forEach((element, index) => {\n        if (typeof element !== ty) {\n            throw new Error(`expected array element at index ${index} to have type '${ty}'`);\n        }\n    });\n}\n\nfunction checkArrayLength(arg: Expr, array: JsonArray) {\n    if (!(arg instanceof NumberLiteralExpr)) {\n        throw new Error(`missing expected number of elements`);\n    }\n\n    const length = arg.value;\n\n    if (array.length !== length) {\n        throw new Error(`the array must have ${length} element(s)`);\n    }\n}\n\nfunction checkArray(context: ExprEvaluatorContext, arg: Expr) {\n    const value = context.evaluate(arg);\n    if (!Array.isArray(value)) {\n        throw new Error(`'${value}' is not an array`);\n    }\n    return value;\n}\n\nconst operators = {\n    array: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            switch (call.args.length) {\n                case 0:\n                    throw new Error(\"not enough arguments\");\n                case 1:\n                    return checkArray(context, call.args[0]);\n                case 2: {\n                    const array = checkArray(context, call.args[1]);\n                    checkElementTypes(call.args[0], array);\n                    return array;\n                }\n                case 3: {\n                    const array = checkArray(context, call.args[2]);\n                    checkArrayLength(call.args[1], array);\n                    checkElementTypes(call.args[0], array);\n                    return array;\n                }\n                default:\n                    throw new Error(\"too many arguments\");\n            }\n        }\n    },\n    \"make-array\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            if (call.args.length === 0) {\n                throw new Error(\"not enough arguments\");\n            }\n            return [...call.args.map(arg => context.evaluate(arg))];\n        }\n    },\n    at: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const args = call.args;\n            const index = context.evaluate(args[0]);\n            if (typeof index !== \"number\") {\n                throw new Error(`expected the index of the element to retrieve`);\n            }\n            const value = context.evaluate(args[1]);\n            if (!Array.isArray(value)) {\n                throw new Error(`expected an array`);\n            }\n            return index >= 0 && index < value.length ? value[index] : null;\n        }\n    },\n\n    slice: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            if (call.args.length < 2) {\n                throw new Error(\"not enough arguments\");\n            }\n            const input = context.evaluate(call.args[0]);\n            if (!(typeof input === \"string\" || Array.isArray(input))) {\n                throw new Error(\"input must be a string or an array\");\n            }\n            const start = context.evaluate(call.args[1]);\n            if (typeof start !== \"number\") {\n                throw new Error(\"expected an index\");\n            }\n            let end: number | undefined;\n            if (call.args.length > 2) {\n                end = context.evaluate(call.args[2]) as any;\n                if (typeof end !== \"number\") {\n                    throw new Error(\"expected an index\");\n                }\n            }\n            return input.slice(start, end);\n        }\n    }\n};\n\nexport const ArrayOperators: OperatorDescriptorMap = operators;\nexport type ArrayOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    \"to-boolean\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return Boolean(context.evaluate(call.args[0]));\n        }\n    },\n\n    \"to-string\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return String(context.evaluate(call.args[0]));\n        }\n    },\n\n    \"to-number\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const arg of call.args) {\n                const value = Number(context.evaluate(arg));\n                if (!isNaN(value)) {\n                    return value;\n                }\n            }\n            throw new Error(\"cannot convert the value to a number\");\n        }\n    }\n};\n\nexport const CastOperators: OperatorDescriptorMap = operators;\nexport type CastOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { ColorUtils } from \"../ColorUtils\";\nimport { CallExpr, Value } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\nimport { parseStringEncodedColor } from \"../StringEncodedNumeral\";\n\nconst operators = {\n    alpha: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            let color: Value | undefined = context.evaluate(call.args[0]);\n            if (typeof color === \"string\") {\n                color = parseStringEncodedColor(color);\n            }\n            const alpha = typeof color === \"number\" ? ColorUtils.getAlphaFromHex(color) : 1;\n            return alpha;\n        }\n    },\n    rgba: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            const a = context.evaluate(call.args[3]);\n            if (\n                typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                typeof a === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0 &&\n                a >= 0 &&\n                a <= 1\n            ) {\n                return rgbaToHex(r, g, b, a);\n            }\n            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);\n        }\n    },\n    rgb: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const r = context.evaluate(call.args[0]);\n            const g = context.evaluate(call.args[1]);\n            const b = context.evaluate(call.args[2]);\n            if (\n                typeof r === \"number\" &&\n                typeof g === \"number\" &&\n                typeof b === \"number\" &&\n                r >= 0 &&\n                g >= 0 &&\n                b >= 0\n            ) {\n                return rgbToHex(r, g, b);\n            }\n            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);\n        }\n    },\n    // Hsl operator contains angle modulated to <0, 360> range, percent of\n    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)\n    hsl: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const h = context.evaluate(call.args[0]);\n            const s = context.evaluate(call.args[1]);\n            const l = context.evaluate(call.args[2]);\n            if (\n                typeof h === \"number\" &&\n                typeof s === \"number\" &&\n                typeof l === \"number\" &&\n                h >= 0 &&\n                s >= 0 &&\n                l >= 0\n            ) {\n                return hslToHex(h, s, l);\n            }\n            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);\n        }\n    }\n};\n\nfunction rgbaToHex(r: number, g: number, b: number, a: number): number {\n    // We decode rgba color channels using custom hex format with transparency.\n    return ColorUtils.getHexFromRgba(\n        THREE.MathUtils.clamp(r, 0, 255) / 255,\n        THREE.MathUtils.clamp(g, 0, 255) / 255,\n        THREE.MathUtils.clamp(b, 0, 255) / 255,\n        THREE.MathUtils.clamp(a, 0, 1)\n    );\n}\n\nfunction rgbToHex(r: number, g: number, b: number): number {\n    return ColorUtils.getHexFromRgb(\n        THREE.MathUtils.clamp(r, 0, 255) / 255,\n        THREE.MathUtils.clamp(g, 0, 255) / 255,\n        THREE.MathUtils.clamp(b, 0, 255) / 255\n    );\n}\n\nfunction hslToHex(h: number, s: number, l: number): number {\n    return ColorUtils.getHexFromHsl(\n        THREE.MathUtils.euclideanModulo(h, 360) / 360,\n        THREE.MathUtils.clamp(s, 0, 100) / 100,\n        THREE.MathUtils.clamp(l, 0, 100) / 100\n    );\n}\n\nexport const ColorOperators: OperatorDescriptorMap = operators;\nexport type ColorOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nfunction compare(context: ExprEvaluatorContext, call: CallExpr, strict: boolean = false) {\n    const left = context.evaluate(call.args[0]) as any;\n    const right = context.evaluate(call.args[1]) as any;\n\n    if (\n        !(\n            (typeof left === \"number\" && typeof right === \"number\") ||\n            (typeof left === \"string\" && typeof right === \"string\")\n        )\n    ) {\n        if (strict) {\n            throw new Error(`invalid operands '${left}' and '${right}' for operator '${call.op}'`);\n        }\n    }\n\n    switch (call.op) {\n        case \"<\":\n            return left < right;\n        case \">\":\n            return left > right;\n        case \"<=\":\n            return left <= right;\n        case \">=\":\n            return left >= right;\n        default:\n            throw new Error(`invalid comparison operator '${call.op}'`);\n    }\n}\n\nconst operators = {\n    \"!\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return !context.evaluate(call.args[0]);\n        }\n    },\n\n    \"==\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left === right;\n        }\n    },\n\n    \"!=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            return left !== right;\n        }\n    },\n\n    \"<\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) },\n    \">\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) },\n    \"<=\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) },\n    \">=\": { call: (context: ExprEvaluatorContext, call: CallExpr) => compare(context, call) }\n};\n\nexport const ComparisonOperators: OperatorDescriptorMap = operators;\nexport type ComparisonOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env } from \"../Env\";\nimport { CallExpr, ExprScope } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    \"geometry-type\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const geometryType = context.env.lookup(\"$geometryType\");\n            switch (geometryType) {\n                case \"point\":\n                    return \"Point\";\n                case \"line\":\n                    return \"LineString\";\n                case \"polygon\":\n                    return \"Polygon\";\n                default:\n                    return null;\n            }\n        }\n    },\n    \"feature-state\": {\n        isDynamicOperator: () => true,\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            if (context.scope !== ExprScope.Dynamic) {\n                throw new Error(\"feature-state cannot be used in this context\");\n            }\n            const property = context.evaluate(call.args[0]);\n            if (typeof property !== \"string\") {\n                throw new Error(`expected the name of the property of the feature state`);\n            }\n            const state = context.env.lookup(\"$state\");\n            if (Env.isEnv(state)) {\n                return state.lookup(property) ?? null;\n            } else if (state instanceof Map) {\n                return state.get(property) ?? null;\n            }\n            return null;\n        }\n    },\n    id: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return context.env.lookup(\"$id\") ?? null;\n        }\n    }\n};\n\nexport const FeatureOperators: OperatorDescriptorMap = operators;\nexport type FeatureOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, Expr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nfunction conditionalCast(context: ExprEvaluatorContext, type: string, args: Expr[]) {\n    switch (type) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n            for (const childExpr of args) {\n                const value = context.evaluate(childExpr);\n                if (typeof value === type) {\n                    return value;\n                }\n            }\n            throw new Error(`expected a '${type}'`);\n        default:\n            throw new Error(`invalid type '${type}'`);\n    } // switch\n}\n\nconst operators = {\n    all: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                if (!context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n\n    any: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    },\n\n    none: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                if (context.evaluate(childExpr)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    },\n\n    boolean: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return conditionalCast(context, \"boolean\", call.args);\n        }\n    },\n\n    number: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return conditionalCast(context, \"number\", call.args);\n        }\n    },\n\n    string: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return conditionalCast(context, \"string\", call.args);\n        }\n    }\n};\n\nexport const FlowOperators: OperatorDescriptorMap = operators;\nexport type FlowOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr, ExprScope, Value } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    \"ppi-scale\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]) as number;\n            const scaleFactor = call.args[1] ? (context.evaluate(call.args[1]) as number) : 1;\n            return value * scaleFactor;\n        }\n    },\n    \"world-ppi-scale\": {\n        isDynamicOperator: (): boolean => {\n            return true;\n        },\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const pixels = context.evaluate(call.args[0]) as number;\n            const scaleFactor = call.args[1] ? (context.evaluate(call.args[1]) as number) : 1;\n            const zoom = context.env.lookup(\"$zoom\") as number;\n            const zoomWidth = Math.pow(2, 17) / Math.pow(2, zoom);\n            const v = pixels * zoomWidth * scaleFactor;\n            return v;\n        }\n    },\n    \"world-discrete-ppi-scale\": {\n        isDynamicOperator: (): boolean => {\n            return true;\n        },\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const pixels = context.evaluate(call.args[0]) as number;\n            const scaleFactor = call.args[1] ? (context.evaluate(call.args[1]) as number) : 1;\n            const zoom = context.env.lookup(\"$zoom\") as number;\n            const zoomWidthDiscrete = Math.pow(2, 17) / Math.pow(2, Math.floor(zoom));\n            const v = pixels * zoomWidthDiscrete * scaleFactor;\n            return v;\n        }\n    },\n    ppi: {\n        call: (context: ExprEvaluatorContext) => {\n            const ppi = context.env.lookup(\"$ppi\");\n            if (typeof ppi === \"number\") {\n                return ppi;\n            }\n            return 72;\n        }\n    },\n    zoom: {\n        isDynamicOperator: (): boolean => {\n            return true;\n        },\n        call: (context: ExprEvaluatorContext, call: CallExpr): Value => {\n            if (context.scope === ExprScope.Value) {\n                return call;\n            }\n            return context.env.lookup(\"$zoom\") ?? null;\n        }\n    }\n};\n\nexport const MapOperators: OperatorDescriptorMap = operators;\nexport type MapOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    \"^\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '^'`\n                );\n            }\n            return Math.pow(a, b);\n        }\n    },\n\n    \"-\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            if (call.args.length === 1) {\n                const value = context.evaluate(call.args[0]);\n                if (typeof value !== \"number\") {\n                    throw new Error(`nvalid operand '${typeof value} for operator '-'`);\n                }\n\n                return -value;\n            }\n\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '-'`\n                );\n            }\n            return a - b;\n        }\n    },\n\n    \"/\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '/'`\n                );\n            }\n            return a / b;\n        }\n    },\n\n    \"%\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const a = context.evaluate(call.args[0]);\n            const b = context.evaluate(call.args[1]);\n            if (typeof a !== \"number\" || typeof b !== \"number\") {\n                throw new Error(\n                    `invalid operands '${typeof a}' and '${typeof b}' for operator '%'`\n                );\n            }\n            return a % b;\n        }\n    },\n\n    \"+\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return call.args.reduce((a, b) => Number(a) + Number(context.evaluate(b)), 0);\n        }\n    },\n\n    \"*\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return call.args.reduce((a, b) => Number(a) * Number(context.evaluate(b)), 1);\n        }\n    },\n\n    abs: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'abs'`);\n            }\n            return Math.abs(value);\n        }\n    },\n\n    acos: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'acos'`);\n            }\n            return Math.acos(value);\n        }\n    },\n\n    asin: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'asin'`);\n            }\n            return Math.asin(value);\n        }\n    },\n\n    atan: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'atan'`);\n            }\n            return Math.atan(value);\n        }\n    },\n\n    ceil: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ceil'`);\n            }\n            return Math.ceil(value);\n        }\n    },\n\n    cos: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'cos'`);\n            }\n            return Math.cos(value);\n        }\n    },\n\n    e: {\n        call: () => {\n            return Math.E;\n        }\n    },\n\n    floor: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'floor'`);\n            }\n            return Math.floor(value);\n        }\n    },\n\n    ln: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln'`);\n            }\n            return Math.log(value);\n        }\n    },\n\n    ln2: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'ln2'`);\n            }\n            return Math.log2(value);\n        }\n    },\n\n    log10: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'log10'`);\n            }\n            return Math.log10(value);\n        }\n    },\n\n    max: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return Math.max(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n\n    min: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return Math.min(...call.args.map(v => Number(context.evaluate(v))));\n        }\n    },\n\n    /**\n     * Clamp numeric value to given range, inclusive.\n     *\n     * Synopsis:\n     * ```\n     * [\"clamp\", v: number, min: number, max: number]`\n     * ```\n     */\n    clamp: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const v = context.evaluate(call.args[0]);\n            const min = context.evaluate(call.args[1]);\n            const max = context.evaluate(call.args[2]);\n\n            if (typeof v !== \"number\" || typeof min !== \"number\" || typeof max !== \"number\") {\n                throw new Error(`invalid operands '${v}', ${min}, ${max} for operator 'clamp'`);\n            }\n            return THREE.MathUtils.clamp(v, min, max);\n        }\n    },\n\n    pi: {\n        call: () => {\n            return Math.PI;\n        }\n    },\n\n    round: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'round'`);\n            }\n            return Math.round(value);\n        }\n    },\n\n    sin: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sin'`);\n            }\n            return Math.sin(value);\n        }\n    },\n\n    sqrt: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'sqrt'`);\n            }\n            return Math.sqrt(value);\n        }\n    },\n\n    tan: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (typeof value !== \"number\") {\n                throw new Error(`invalid operand '${value}' for operator 'tan'`);\n            }\n            return Math.tan(value);\n        }\n    }\n};\n\nexport const MathOperators: OperatorDescriptorMap = operators;\nexport type MathOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\n\nimport { CallExpr, LookupExpr, ObjectLiteralExpr, Value } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\ninterface KeyValObj {\n    [key: string]: Value;\n}\ninterface LookupEntry {\n    keys: KeyValObj;\n    attributes: KeyValObj;\n}\n\ntype LookupArray = LookupEntry[];\ntype LookupMap = Map<string, KeyValObj>;\n\nfunction joinKeyValues(keys: string[]): string {\n    return keys.join(\"&\");\n}\n\nfunction stringifyKeyValue(key: string, value: Value): string {\n    return key + \"=\" + JSON.stringify(value);\n}\n\n/**\n * Joins the strings of each given array.\n * @param combinations Array of string arrays that must be joined.\n * @returns The joined strings sorted from longest to shortest (in number of substrings).\n */\nfunction joinCombinations(combinations: string[][]): string[] {\n    // sort from longest (more specific) to shortest (more generic).\n    combinations.sort((lhs, rhs) => rhs.length - lhs.length);\n    const result = combinations.map((keys: string[]) => joinKeyValues(keys));\n    // Add the empty combination which will match a default table entry (an entry without keys) if\n    // it exists.\n    result.push(\"\");\n    return result;\n}\n/**\n * Gets all combinations of all lengths of a list of strings.\n * @param input An array containing all strings.\n * @param index Start index of the strings in `input` that will be considered.\n * @returns An array of all combinations. The strings within each combination are in the inverse\n * order of the input array.\n */\nfunction getAllCombinations(input: string[], index: number = 0): string[][] {\n    if (index >= input.length) {\n        return [];\n    }\n\n    const combinations = getAllCombinations(input, index + 1);\n\n    const initLength = combinations.length;\n    for (let i = 0; i < initLength; i += 1) {\n        combinations.push([...combinations[i], input[index]]);\n    }\n    combinations.push([input[index]]);\n    return combinations;\n}\n\n/**\n * Make all combinations of all lengths with the search keys of the given lookup expression.\n * @param lookupExpr The lookup expression.\n * @param context The context to evaluate expressions.\n * @returns All combinations, sorted from longest(more specific) to shortest (more generic).\n */\nfunction getKeyCombinations(lookupExpr: LookupExpr, context: ExprEvaluatorContext): string[] {\n    const keys = lookupExpr.args.slice(1);\n    const result = [];\n    for (let i = 0; i < keys.length; i += 2) {\n        const value = context.evaluate(keys[i + 1]);\n        // ignore keys whose values evaluate to null.\n        if (value === null) {\n            continue;\n        }\n        const key = context.evaluate(keys[i]) as string;\n        result.push(stringifyKeyValue(key, value));\n    }\n    // Reverse sort, getAllCombinations reverses the order.\n    result.sort().reverse();\n\n    return joinCombinations(getAllCombinations(result));\n}\n\n/**\n * Creates a map from the lookup entries in a given array.\n * @param lookupArray The array to transform.\n * @returns The resulting map.\n */\nfunction createLookupMap(lookupArray: LookupArray): LookupMap {\n    const map = new Map();\n    for (const entry of lookupArray) {\n        if (typeof entry !== \"object\") {\n            throw new Error(`Invalid lookup table entry type (${typeof entry})`);\n        }\n        if (!entry.keys) {\n            throw new Error(`Lookup table entry has no 'keys' property.`);\n        }\n        if (!entry.attributes) {\n            throw new Error(`Lookup table entry has no 'attributes' property.`);\n        }\n        const key = joinKeyValues(\n            Object.getOwnPropertyNames(entry.keys)\n                .sort()\n                .map(key => stringifyKeyValue(key, entry.keys[key]))\n        );\n        map.set(key, entry.attributes);\n    }\n    return map;\n}\n\n/**\n * Searches matches of the given keys in a map.\n * @param keys Keys to search in the map.\n * @param map The lookup map.\n * @returns The first match (in the order in which keys are given) or null if no match found.\n */\nfunction searchLookupMap(keys: string[], map: LookupMap): KeyValObj | null {\n    for (const key of keys) {\n        const matchAttributes = map.get(key);\n        if (matchAttributes) {\n            return matchAttributes;\n        }\n    }\n    return null;\n}\n\nconst operators = {\n    length: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            if (Array.isArray(value) || typeof value === \"string\") {\n                return value.length;\n            }\n            throw new Error(`invalid operand '${value}' for operator 'length'`);\n        }\n    },\n    coalesce: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            for (const childExpr of call.args) {\n                const value = context.evaluate(childExpr);\n                if (value !== null) {\n                    return value;\n                }\n            }\n            return null;\n        }\n    },\n    lookup: {\n        call: (context: ExprEvaluatorContext, lookup: LookupExpr) => {\n            // Argument types are checked on parsing, see LookupExpr.parseArray().\n            assert(lookup.args.length > 0, \"missing lookup table\");\n\n            const keyCombinations = getKeyCombinations(lookup, context);\n            let table = context.evaluate(lookup.args[0]) as LookupArray | LookupMap;\n            assert(Array.isArray(table) || table instanceof Map, \"wrong lookup table type\");\n\n            if (Array.isArray(table)) {\n                // Transform the lookup table into a map to speedup lookup, since the same table\n                // might be used by multiple lookup expressions.\n                table = createLookupMap(table);\n                const lookupMapExpr = new ObjectLiteralExpr(table);\n                // Replace the lookup table argument with the map. Next calls to the same expression\n                // (e.g. re-evaluations due to data dependencies) will use the map.\n                lookup.args[0] = lookupMapExpr;\n            }\n\n            return searchLookupMap(keyCombinations, table);\n        }\n    }\n};\n\nexport const MiscOperators: OperatorDescriptorMap = operators;\nexport type MiscOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env } from \"../Env\";\nimport { CallExpr, Expr, ExprScope } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nenum LookupMode {\n    get,\n    has\n}\n\nfunction lookupMember(context: ExprEvaluatorContext, args: Expr[], lookupMode: LookupMode) {\n    const memberName = context.evaluate(args[0]);\n\n    if (typeof memberName !== \"string\") {\n        throw new Error(`expected the name of an attribute`);\n    }\n\n    const object = context.evaluate(args[1]) as any;\n\n    if (object && typeof object === \"object\") {\n        if (Env.isEnv(object)) {\n            const value = object.lookup(memberName) ?? null;\n            return lookupMode === LookupMode.get ? value : value !== null;\n        }\n        if (hasOwnProperty.call(object, memberName)) {\n            return lookupMode === LookupMode.get ? object[memberName] : true;\n        }\n    }\n\n    return lookupMode === LookupMode.get ? null : false;\n}\n\nconst operators = {\n    in: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const value = context.evaluate(call.args[0]);\n            const object = context.evaluate(call.args[1]);\n            if (typeof value === \"string\" && typeof object === \"string\") {\n                return object.includes(value);\n            } else if (Array.isArray(object)) {\n                return object.includes(value);\n            }\n            return false;\n        }\n    },\n\n    get: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) =>\n            lookupMember(context, call.args, LookupMode.get)\n    },\n\n    has: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) =>\n            lookupMember(context, call.args, LookupMode.has)\n    },\n\n    \"dynamic-properties\": {\n        isDynamicOperator: () => true,\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            if (context.scope === ExprScope.Dynamic) {\n                return context.env;\n            }\n            return call;\n        }\n    }\n};\n\nexport const ObjectOperators: OperatorDescriptorMap = operators;\nexport type ObjectOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    concat: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return \"\".concat(...call.args.map(a => String(context.evaluate(a))));\n        }\n    },\n\n    downcase: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return String(context.evaluate(call.args[0])).toLocaleLowerCase();\n        }\n    },\n\n    upcase: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return String(context.evaluate(call.args[0])).toLocaleUpperCase();\n        }\n    },\n\n    \"~=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.includes(right);\n            }\n            return false;\n        }\n    },\n\n    \"^=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.startsWith(right);\n            }\n            return false;\n        }\n    },\n\n    \"$=\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            const left = context.evaluate(call.args[0]);\n            const right = context.evaluate(call.args[1]);\n            if (typeof left === \"string\" && typeof right === \"string\") {\n                return left.endsWith(right);\n            }\n            return false;\n        }\n    }\n};\n\nexport const StringOperators: OperatorDescriptorMap = operators;\nexport type StringOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CallExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\nconst operators = {\n    typeof: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => {\n            return typeof context.evaluate(call.args[0]);\n        }\n    }\n};\n\nexport const TypeOperators: OperatorDescriptorMap = operators;\nexport type TypeOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { Value } from \"../Env\";\nimport { CallExpr, NumberLiteralExpr } from \"../Expr\";\nimport { ExprEvaluatorContext, OperatorDescriptorMap } from \"../ExprEvaluator\";\n\ntype MakeVectorCallExpr = CallExpr & {\n    _value?: THREE.Vector2 | THREE.Vector3 | THREE.Vector4;\n};\n\nfunction isVector(\n    context: ExprEvaluatorContext,\n    call: CallExpr,\n    type: \"vector2\" | \"vector3\" | \"vector4\"\n): Value {\n    let ctor: new () => object;\n    switch (type) {\n        case \"vector2\":\n            ctor = THREE.Vector2;\n            break;\n        case \"vector3\":\n            ctor = THREE.Vector3;\n            break;\n        case \"vector4\":\n            ctor = THREE.Vector4;\n            break;\n    }\n    for (const childExpr of call.args) {\n        const value = context.evaluate(childExpr);\n        if (value instanceof ctor) {\n            return value;\n        }\n    }\n    throw new Error(`expected a \"${type}\"`);\n}\n\nfunction toVector(\n    context: ExprEvaluatorContext,\n    call: CallExpr,\n    type: \"vector2\" | \"vector3\" | \"vector4\"\n): Value {\n    let VectorCtor: any;\n    let components: number;\n\n    switch (type) {\n        case \"vector2\":\n            VectorCtor = THREE.Vector2;\n            components = 2;\n            break;\n        case \"vector3\":\n            VectorCtor = THREE.Vector3;\n            components = 3;\n            break;\n        case \"vector4\":\n            VectorCtor = THREE.Vector4;\n            components = 4;\n            break;\n    }\n\n    for (const childExpr of call.args) {\n        const value = context.evaluate(childExpr);\n        if (value instanceof VectorCtor) {\n            return value;\n        } else if (\n            Array.isArray(value) &&\n            value.length === components &&\n            value.every(v => typeof v === \"number\")\n        ) {\n            return new VectorCtor().fromArray(value);\n        }\n    }\n    throw new Error(`expected a \"${type}\"`);\n}\n\nconst operators = {\n    \"make-vector\": {\n        call: (context: ExprEvaluatorContext, call: MakeVectorCallExpr) => {\n            if (call._value !== undefined) {\n                return call._value;\n            }\n\n            if (call.args.length < 2) {\n                throw new Error(\"not enough arguments\");\n            } else if (call.args.length > 4) {\n                throw new Error(\"too many arguments\");\n            }\n\n            const components = call.args.map(arg => context.evaluate(arg)) as number[];\n\n            components.forEach((element, index) => {\n                if (typeof element !== \"number\") {\n                    throw new Error(\n                        `expected vector component at index ${index} to have type \"number\"`\n                    );\n                }\n            });\n\n            let result: THREE.Vector2 | THREE.Vector3 | THREE.Vector4 | undefined;\n\n            switch (components.length) {\n                case 2:\n                    result = new THREE.Vector2().fromArray(components);\n                    break;\n                case 3:\n                    result = new THREE.Vector3().fromArray(components);\n                    break;\n                case 4:\n                    result = new THREE.Vector4().fromArray(components);\n                    break;\n                default:\n                    throw new Error(\"too many arguments\");\n            }\n\n            if (call.args.every(arg => arg instanceof NumberLiteralExpr)) {\n                call._value = result;\n            }\n\n            return result;\n        }\n    },\n    vector2: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => isVector(context, call, \"vector2\")\n    },\n    vector3: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => isVector(context, call, \"vector3\")\n    },\n    vector4: {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => isVector(context, call, \"vector4\")\n    },\n    \"to-vector2\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => toVector(context, call, \"vector2\")\n    },\n    \"to-vector3\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => toVector(context, call, \"vector3\")\n    },\n    \"to-vector4\": {\n        call: (context: ExprEvaluatorContext, call: CallExpr) => toVector(context, call, \"vector4\")\n    }\n};\n\nexport const VectorOperators: OperatorDescriptorMap = operators;\nexport type VectorOperatorNames = keyof typeof operators;\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Overlay useful for debugging map data.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/DebugTileDataSource\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GeoCoordinates, ProjectionType, TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport { DataSource, TextElement, Tile } from \"@here/harp-mapview\";\nimport {\n    FontUnit,\n    HorizontalAlignment,\n    TextLayoutStyle,\n    TextRenderStyle,\n    VerticalAlignment\n} from \"@here/harp-text-canvas\";\nimport * as THREE from \"three\";\n\nconst debugMaterial = new THREE.LineBasicMaterial({\n    color: 0xff0000,\n    linewidth: 1,\n    depthTest: false\n});\n\n// Set maximum priority.\nconst PRIORITY_ALWAYS = Number.MAX_SAFE_INTEGER;\n\n// Size/scale of text showing the tiles key\nconst TEXT_SCALE = 0.8;\n\nexport class DebugTile extends Tile {\n    private readonly geometry = new THREE.BufferGeometry();\n    private readonly m_labelPositions = new THREE.BufferAttribute(new Float32Array(3), 3);\n\n    private readonly m_textRenderStyle: TextRenderStyle;\n    private readonly m_textLayoutStyle: TextLayoutStyle;\n\n    constructor(dataSource: DataSource, tileKey: TileKey, gridColor = \"#ff0000\") {\n        super(dataSource, tileKey);\n\n        const tilingScheme = dataSource.getTilingScheme();\n        const worldBox = tilingScheme.boundingBoxGenerator.getWorldBox(tileKey);\n        const projection = tilingScheme.projection;\n        const geoCoordinates: GeoCoordinates[] = [\n            projection.unprojectPoint(new THREE.Vector3(worldBox.min.x, worldBox.min.y, 0)),\n            projection.unprojectPoint(new THREE.Vector3(worldBox.max.x, worldBox.min.y, 0)),\n            projection.unprojectPoint(new THREE.Vector3(worldBox.max.x, worldBox.max.y, 0)),\n            projection.unprojectPoint(new THREE.Vector3(worldBox.min.x, worldBox.max.y, 0))\n        ];\n\n        const middlePoint = new THREE.Vector3();\n\n        const vertices: number[] = [];\n        geoCoordinates.forEach(geoPoint => {\n            const pt = new THREE.Vector3();\n            this.projection.projectPoint(geoPoint, pt);\n            pt.sub(this.center);\n            vertices.push(...pt.toArray());\n            middlePoint.add(pt);\n        });\n        this.geometry.setAttribute(\n            \"position\",\n            new THREE.BufferAttribute(new Float32Array(vertices), 3)\n        );\n\n        middlePoint.divideScalar(geoCoordinates.length);\n\n        const lineObject = new THREE.Line(this.geometry, debugMaterial);\n        lineObject.renderOrder = PRIORITY_ALWAYS;\n        this.objects.push(lineObject);\n\n        this.m_labelPositions.setXYZ(0, 0, 0, 0);\n\n        const textPosition = new THREE.Vector3();\n\n        if (this.projection.type === ProjectionType.Planar) {\n            // place the text position at north/west for planar projections.\n            textPosition.set(\n                this.geometry.getAttribute(\"position\").getX(3),\n                this.geometry.getAttribute(\"position\").getY(3),\n                this.geometry.getAttribute(\"position\").getZ(3)\n            );\n            textPosition.multiplyScalar(0.95);\n\n            this.m_textLayoutStyle = new TextLayoutStyle({\n                verticalAlignment: VerticalAlignment.Below,\n                horizontalAlignment: HorizontalAlignment.Left\n            });\n        } else {\n            textPosition.copy(middlePoint);\n\n            this.m_textLayoutStyle = new TextLayoutStyle({\n                verticalAlignment: VerticalAlignment.Center,\n                horizontalAlignment: HorizontalAlignment.Center\n            });\n        }\n\n        this.m_textRenderStyle = new TextRenderStyle({\n            fontSize: {\n                unit: FontUnit.Pixel,\n                size: 16,\n                backgroundSize: 0\n            },\n            color: new THREE.Color(gridColor)\n        });\n\n        const text = `${tileKey.mortonCode()} (${tileKey.row}, ${tileKey.column}, ${\n            tileKey.level\n        })`;\n\n        textPosition.add(this.center);\n        const textElement = new TextElement(\n            text,\n            textPosition,\n            this.m_textRenderStyle,\n            this.m_textLayoutStyle,\n            PRIORITY_ALWAYS,\n            TEXT_SCALE\n        );\n        textElement.mayOverlap = true;\n        textElement.reserveSpace = false;\n        textElement.alwaysOnTop = true;\n        textElement.ignoreDistance = true;\n\n        this.addTextElement(textElement);\n    }\n}\n\nexport class DebugTileDataSource extends DataSource {\n    constructor(\n        private readonly m_tilingScheme: TilingScheme,\n        name = \"debug\",\n        public maxDbgZoomLevel: number = 20\n    ) {\n        super({ name, minDataLevel: 1, maxDataLevel: 20, storageLevelOffset: -1 });\n\n        this.cacheable = true;\n        this.enablePicking = false;\n    }\n\n    /** @override */\n    getTilingScheme(): TilingScheme {\n        return this.m_tilingScheme;\n    }\n\n    /** @override */\n    getTile(tileKey: TileKey): DebugTile {\n        const tile = new DebugTile(this, tileKey);\n        return tile;\n    }\n\n    /** @override */\n    canGetTile(zoomLevel: number, tileKey: TileKey): boolean {\n        if (tileKey.level > this.maxDbgZoomLevel) {\n            return false;\n        }\n        return super.canGetTile(zoomLevel, tileKey);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Provides support for rendering custom carto features.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/Features\";\nexport * from \"./lib/FeaturesDataSource\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    FeatureGeometry,\n    LineString,\n    MultiLineString,\n    MultiPoint,\n    MultiPolygon,\n    Point,\n    Polygon\n} from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\n\n/**\n * Base class to create features.\n */\nexport abstract class MapViewFeature {\n    /**\n     * The type of the feature. The extended class should initialize this value. It defaults to\n     * \"Point\" in order to avoid allowing `null` or `undefined`.\n     */\n    type: FeatureGeometry[\"type\"] = \"Point\";\n\n    /**\n     * A string identifying this feature.\n     */\n    uuid: string = THREE.MathUtils.generateUUID();\n\n    /**\n     * Builds a new `MapViewFeature`.\n     *\n     * @param coordinates - The GeoJson geometry.\n     * @param style - The style to render the geometry.\n     */\n    constructor(public coordinates: FeatureGeometry[\"coordinates\"], public properties?: {}) {}\n}\n\nexport class MapViewLineFeature extends MapViewFeature {\n    /** @override */\n    type: LineString[\"type\"] = \"LineString\";\n    constructor(public coordinates: LineString[\"coordinates\"], public properties?: {}) {\n        super(coordinates, properties);\n    }\n}\n\nexport class MapViewMultiLineFeature extends MapViewFeature {\n    /** @override */\n    type: MultiLineString[\"type\"] = \"MultiLineString\";\n    constructor(public coordinates: MultiLineString[\"coordinates\"], public properties?: {}) {\n        super(coordinates, properties);\n    }\n}\n\nexport class MapViewPolygonFeature extends MapViewFeature {\n    /** @override */\n    type: Polygon[\"type\"] = \"Polygon\";\n    constructor(public coordinates: Polygon[\"coordinates\"], public properties?: {}) {\n        super(coordinates, properties);\n    }\n}\n\nexport class MapViewMultiPolygonFeature extends MapViewFeature {\n    /** @override */\n    type: MultiPolygon[\"type\"] = \"MultiPolygon\";\n    constructor(public coordinates: MultiPolygon[\"coordinates\"], public properties?: {}) {\n        super(coordinates, properties);\n    }\n}\n\nexport class MapViewPointFeature extends MapViewFeature {\n    /** @override */\n    type: Point[\"type\"] = \"Point\";\n    constructor(public coordinates: Point[\"coordinates\"], public properties?: {}) {\n        super(coordinates, properties);\n    }\n}\n\nexport class MapViewMultiPointFeature extends MapViewFeature {\n    /** @override */\n    type: MultiPoint[\"type\"] = \"MultiPoint\";\n    constructor(public coordinates: MultiPoint[\"coordinates\"], public properties?: {}) {\n        super(coordinates, properties);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    Feature,\n    FeatureCollection,\n    FeatureGeometry,\n    GeometryCollection\n} from \"@here/harp-datasource-protocol\";\nimport { GeoBox, GeoCoordinates } from \"@here/harp-geoutils\";\nimport { MapView } from \"@here/harp-mapview\";\nimport { LoggerManager } from \"@here/harp-utils\";\nimport {\n    GeoJsonDataProvider,\n    GeoJsonDataProviderOptions,\n    VectorTileDataSource,\n    VectorTileDataSourceParameters\n} from \"@here/harp-vectortile-datasource\";\n\nimport { MapViewFeature } from \"./Features\";\n\nconst logger = LoggerManager.instance.create(\"FeaturesDataSource\");\n\nconst NAME = \"user-features-datasource\";\nconst DEFAULT_GEOJSON: FeatureCollection = {\n    type: \"FeatureCollection\",\n    features: []\n};\n\n/**\n * Options for [[FeaturesDataSource]].\n */\nexport interface FeatureDataSourceOptions\n    extends VectorTileDataSourceParameters,\n        GeoJsonDataProviderOptions {\n    /**\n     * Initial set of features for new instance of [[FeaturesDataSource]].\n     *\n     * Shortcut for calling [[FeaturesDataSource.add]] after construction.\n     */\n    features?: MapViewFeature[];\n\n    /**\n     * Initial GeoJSON load for new instance of [[FeaturesDataSource]].\n     *\n     * Shortcut for calling [[FeaturesDataSource.setFromGeojson]] after construction.\n     */\n    geojson?: FeatureCollection | GeometryCollection | Feature;\n}\n\n/**\n * [[DataSource]] implementation to use for the addition of custom features.\n */\nexport class FeaturesDataSource extends VectorTileDataSource {\n    private m_isAttached = false;\n    private m_featureCollection: FeatureCollection = this.emptyGeojson();\n\n    /**\n     * Builds a `FeaturesDataSource`.\n     *\n     * @param options - specify custom options using [[FeatureDataSourceOptions]] interface.\n     */\n    constructor(options?: FeatureDataSourceOptions) {\n        super({\n            ...options,\n            dataProvider: new GeoJsonDataProvider(NAME, DEFAULT_GEOJSON, options),\n            addGroundPlane: false\n        });\n        if (options !== undefined) {\n            if (options.features !== undefined) {\n                this.add(...options.features);\n            }\n            if (options.geojson !== undefined) {\n                this.setFromGeojson(options.geojson);\n            }\n        }\n    }\n\n    /**\n     * This method allows to directly add a GeoJSON without using [[MapViewFeature]] instances. It\n     * also overwrites existing features in this data source. To add a GeoJSON without overwriting\n     * the data source, one should loop through it to create [[MapViewFeature]] and add them with\n     * the `add` method.\n     *\n     * @param geojson - A javascript object matching the GeoJSON specification.\n     */\n    setFromGeojson(geojson: FeatureCollection | GeometryCollection | Feature) {\n        if (geojson.type === \"FeatureCollection\") {\n            this.m_featureCollection = geojson;\n        } else if (geojson.type === \"Feature\") {\n            this.m_featureCollection = this.emptyGeojson();\n            this.m_featureCollection.features.push(geojson);\n        } else if (geojson.type === \"GeometryCollection\") {\n            this.m_featureCollection = this.emptyGeojson();\n            for (const geometry of geojson.geometries) {\n                this.m_featureCollection.features.push({\n                    type: \"Feature\",\n                    geometry\n                });\n            }\n        } else {\n            throw new TypeError(\"The provided object is not a valid GeoJSON object.\");\n        }\n        this.update();\n        return this;\n    }\n\n    /**\n     * Adds a custom feature in the datasource.\n     *\n     * @param features - The features to add in the datasource.\n     */\n    add(...features: MapViewFeature[]): this {\n        for (const feature of features) {\n            this.addFeature(feature);\n        }\n        this.update();\n        return this;\n    }\n\n    /**\n     * Removes a custom feature in the datasource.\n     *\n     * @param features - The features to add in the datasource.\n     */\n    remove(...features: MapViewFeature[]): this {\n        for (const feature of features) {\n            this.removeFeature(feature);\n        }\n        this.update();\n        return this;\n    }\n\n    /**\n     * Removes all the custom features in this `FeaturesDataSource`.\n     */\n    clear() {\n        this.m_featureCollection = this.emptyGeojson();\n        this.update();\n    }\n\n    /** @override */\n    async connect(): Promise<void> {\n        await super.connect();\n        if (this.m_featureCollection.features.length > 0) {\n            await this.update();\n        }\n    }\n\n    /**\n     * Override [[DataSource.attach]] to know if we're really connected to [[MapView]].\n     * @param mapView -\n     * @override\n     */\n    attach(mapView: MapView): void {\n        super.attach(mapView);\n        this.m_isAttached = true;\n    }\n\n    /**\n     * Override [[DataSource.detach]] to know if we're really connected to [[MapView]].\n     * @param mapView -\n     * @override\n     */\n    detach(mapView: MapView): void {\n        super.detach(mapView);\n        this.m_isAttached = false;\n    }\n\n    /**\n     * Get [[GeoBox]] containing all the points in datasource.\n     *\n     * Returns undefined if there were no features added to this DS.\n     */\n    getGeoBox(): GeoBox | undefined {\n        let result: GeoBox | undefined;\n        const addPoint = (geoJsonCoords: number[]) => {\n            // NOTE: GeoJson coordinates are in [longitude, latitude] order!\n            const coords = new GeoCoordinates(geoJsonCoords[1], geoJsonCoords[0]);\n            if (result === undefined) {\n                result = new GeoBox(coords, coords.clone());\n            } else {\n                result.growToContain(coords);\n            }\n        };\n        for (const feature of this.m_featureCollection.features) {\n            switch (feature.geometry.type) {\n                case \"Point\":\n                    addPoint(feature.geometry.coordinates);\n                    break;\n                case \"MultiPoint\":\n                case \"LineString\":\n                    feature.geometry.coordinates.forEach(addPoint);\n                    break;\n                case \"MultiLineString\":\n                case \"Polygon\":\n                    feature.geometry.coordinates.forEach(segment => segment.forEach(addPoint));\n                    break;\n                case \"MultiPolygon\":\n                    feature.geometry.coordinates.forEach(polygon =>\n                        polygon.forEach(segment => segment.forEach(addPoint))\n                    );\n                    break;\n            }\n        }\n        return result;\n    }\n\n    private addFeature(feature: MapViewFeature) {\n        // Check if the feature is not already in there.\n        const hasFeature = this.m_featureCollection.features.some(\n            _feature => _feature.properties.__mapViewUuid === feature.uuid\n        );\n        if (hasFeature) {\n            return;\n        }\n\n        // Create a GeoJson feature from the feature coordinates and push it.\n        const geometry: FeatureGeometry = {\n            type: feature.type,\n            coordinates: feature.coordinates\n        } as any;\n        const geojsonFeature: Feature = {\n            type: \"Feature\",\n            geometry,\n            properties: {\n                ...feature.properties,\n                __mapViewUuid: feature.uuid\n            }\n        };\n        this.m_featureCollection.features.push(geojsonFeature);\n    }\n\n    private removeFeature(feature: MapViewFeature) {\n        // Remove geojson feature from the root FeatureCollection.\n        const index = this.m_featureCollection.features.findIndex(\n            _feature => _feature.properties.__mapViewUuid === feature.uuid\n        );\n\n        if (index === -1) {\n            return;\n        }\n        this.m_featureCollection.features.splice(index, 1);\n    }\n\n    private async update() {\n        const dataProvider = this.dataProvider() as GeoJsonDataProvider;\n        if (!this.m_isAttached || !dataProvider.ready()) {\n            return;\n        }\n\n        try {\n            await dataProvider.updateInput(this.m_featureCollection);\n            if (this.m_isAttached) {\n                this.mapView.markTilesDirty(this);\n            }\n        } catch (error) {\n            // We use `update` in sync API, so there's no-one to react to errors so log them.\n            logger.error(`[${this.name}]: failed to update tile index`, error);\n        }\n    }\n\n    private emptyGeojson(): FeatureCollection {\n        return {\n            features: [],\n            type: \"FeatureCollection\"\n        };\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Provides support for GeoJSON datasource.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/GeoJsonDataSource\";\nexport * from \"./lib/GeoJsonDataProvider\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport { GeoJsonDataProvider, GeoJsonDataProviderOptions } from \"@here/harp-vectortile-datasource\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    OmvWithCustomDataProvider,\n    OmvWithRestClientParams,\n    VectorTileDataSource\n} from \"@here/harp-vectortile-datasource\";\n\n/**\n * `GeoJsonDataSource` is used for the visualization of geometric objects provided in the GeoJSON\n * format. To be able to render GeoJSON data, a `GeoJsonDataSource` instance must be added to the\n * {@link @here/harp-mapview#MapView} instance.\n *\n * @example\n * ```typescript\n *    const geoJsonDataProvider = new GeoJsonDataProvider(\n *        \"italy\",\n *        new URL(\"resources/italy.json\", window.location.href)\n *    );\n *    const geoJsonDataSource = new GeoJsonDataSource({\n *        dataProvider: geoJsonDataProvider,\n *        styleSetName: \"geojson\"\n *    });\n *    mapView.addDataSource(geoJsonDataSource);\n *   ```\n */\nexport class GeoJsonDataSource extends VectorTileDataSource {\n    /**\n     * Default constructor.\n     *\n     * @param params - Data source configuration's parameters.\n     */\n    constructor(params: OmvWithRestClientParams | OmvWithCustomDataProvider) {\n        super({ styleSetName: \"geojson\", ...params });\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Box3Like, GeoBox, Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport { Vector3 } from \"three\";\n\nimport { SubdivisionModifier } from \"./SubdivisionModifier\";\n\nconst VERTEX_POSITION_CACHE = [new Vector3(), new Vector3()];\n\nexport enum SubdivisionMode {\n    /**\n     * Subdivide all edges\n     */\n    All,\n    /**\n     * Only subdivide horizontal and vertical edges\n     */\n    NoDiagonals\n}\n\n/**\n * The [[EdgeLengthGeometrySubdivisionModifier]] subdivides triangle mesh depending on\n * length of edges.\n */\nexport class EdgeLengthGeometrySubdivisionModifier extends SubdivisionModifier {\n    private readonly m_projectedBox: Box3Like;\n    private readonly m_maxLength: number;\n    private readonly m_maxLengthX: number;\n    private readonly m_maxLengthY: number;\n\n    /**\n     * Constructs a new [[EdgeLengthGeometrySubdivisionModifier]].\n     *\n     * @param subdivision - The subdivision factor\n     * @param geoBox - The geo bounding box of a tile\n     * @param subdivisionMode - Configures what edges to divide\n     * @param projection - The projection that defines the world space of this geometry.\n     */\n    constructor(\n        readonly subdivision: number,\n        readonly geoBox: GeoBox,\n        readonly subdivisionMode: SubdivisionMode = SubdivisionMode.All,\n        readonly projection: Projection\n    ) {\n        super();\n\n        assert(\n            projection.type === ProjectionType.Planar,\n            \"EdgeLengthGeometrySubdivisionModifier only supports planar projections\"\n        );\n\n        const northEast = projection.projectPoint(geoBox.northEast, VERTEX_POSITION_CACHE[0]);\n        const southWest = projection.projectPoint(geoBox.southWest, VERTEX_POSITION_CACHE[1]);\n        this.m_projectedBox = {\n            min: {\n                x: Math.min(northEast.x, southWest.x),\n                y: Math.min(northEast.y, southWest.y),\n                z: Math.min(northEast.z, southWest.z)\n            },\n            max: {\n                x: Math.max(northEast.x, southWest.x),\n                y: Math.max(northEast.y, southWest.y),\n                z: Math.max(northEast.z, southWest.z)\n            }\n        };\n        this.m_maxLengthX = (this.m_projectedBox.max.x - this.m_projectedBox.min.x) / subdivision;\n        this.m_maxLengthY = (this.m_projectedBox.max.y - this.m_projectedBox.min.y) / subdivision;\n\n        // Increase max length slightly to account for precision errors\n        if (this.subdivisionMode === SubdivisionMode.All) {\n            this.m_maxLengthX *= 1.1;\n            this.m_maxLengthY *= 1.1;\n        }\n        this.m_maxLength = Math.sqrt(\n            this.m_maxLengthX * this.m_maxLengthX + this.m_maxLengthY * this.m_maxLengthY\n        );\n    }\n\n    /**\n     * Return upper bound for length of diagonal edges\n     */\n    get maxLength() {\n        return this.m_maxLength;\n    }\n\n    /**\n     * Return upper bound for edge length in x direction\n     */\n    get maxLengthX() {\n        return this.m_maxLengthX;\n    }\n\n    /**\n     * Return upper bound for edge length in y direction\n     */\n    get maxLengthY() {\n        return this.m_maxLengthY;\n    }\n\n    /** @override */\n    protected shouldSplitTriangle(a: Vector3, b: Vector3, c: Vector3): number | undefined {\n        const shouldSplitAB = this.shouldSplitEdge(a, b);\n        const shouldSplitBC = this.shouldSplitEdge(b, c);\n        const shouldSplitCA = this.shouldSplitEdge(c, a);\n        const shouldSplit = shouldSplitAB || shouldSplitBC || shouldSplitCA;\n\n        if (!shouldSplit) {\n            return;\n        }\n\n        const ab = a.distanceTo(b);\n        const bc = b.distanceTo(c);\n        const ca = c.distanceTo(a);\n        const maxDistance = Math.max(\n            shouldSplitAB ? ab : 0,\n            shouldSplitBC ? bc : 0,\n            shouldSplitCA ? ca : 0\n        );\n        if (ab === maxDistance) {\n            return 0;\n        } else if (bc === maxDistance) {\n            return 1;\n        } else if (ca === maxDistance) {\n            return 2;\n        }\n\n        throw new Error(\"Could not split triangle.\");\n    }\n\n    private shouldSplitEdge(a: Vector3, b: Vector3): boolean {\n        switch (this.subdivisionMode) {\n            case SubdivisionMode.All:\n                return (\n                    (a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||\n                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY) ||\n                    a.distanceTo(b) > this.m_maxLength\n                );\n            case SubdivisionMode.NoDiagonals:\n                return (\n                    (a.y === b.y && Math.abs(a.x - b.x) > this.m_maxLengthX) ||\n                    (a.x === b.x && Math.abs(a.y - b.y) > this.m_maxLengthY)\n                );\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Projection, sphereProjection } from \"@here/harp-geoutils\";\nimport { Vector3 } from \"three\";\n\nimport { SubdivisionModifier } from \"./SubdivisionModifier\";\n\nconst VERTEX_POSITION_CACHE = [new Vector3(), new Vector3(), new Vector3()];\n\n/**\n * The [[SphericalGeometrySubdivisionModifier]] subdivides triangle mesh geometries positioned\n * on the surface of a sphere centered at `(0, 0, 0)`.\n */\nexport class SphericalGeometrySubdivisionModifier extends SubdivisionModifier {\n    /**\n     * Constructs a new [[SphericalGeometrySubdivisionModifier]].\n     *\n     * @param angle - The maximum angle in radians between two vertices and the origin.\n     * @param projection - The projection that defines the world space of this geometry.\n     */\n    constructor(readonly angle: number, readonly projection: Projection = sphereProjection) {\n        super();\n    }\n\n    /** @override */\n    protected shouldSplitTriangle(a: Vector3, b: Vector3, c: Vector3): number | undefined {\n        const aa = sphereProjection.reprojectPoint(this.projection, a, VERTEX_POSITION_CACHE[0]);\n        const bb = sphereProjection.reprojectPoint(this.projection, b, VERTEX_POSITION_CACHE[1]);\n        const cc = sphereProjection.reprojectPoint(this.projection, c, VERTEX_POSITION_CACHE[2]);\n\n        const alpha = aa.angleTo(bb);\n        const beta = bb.angleTo(cc);\n        const gamma = cc.angleTo(aa);\n\n        // find the maximum angle\n        const m = Math.max(alpha, Math.max(beta, gamma));\n\n        // split the triangle if needed.\n        if (m < this.angle) {\n            return undefined;\n        }\n\n        if (m === alpha) {\n            return 0;\n        } else if (m === beta) {\n            return 1;\n        } else if (m === gamma) {\n            return 2;\n        }\n\n        throw new Error(\"failed to split triangle\");\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { BufferAttribute, BufferGeometry, Vector3 } from \"three\";\n\nconst tmpVectorA = new Vector3();\nconst tmpVectorB = new Vector3();\nconst tmpVectorC = new Vector3();\n\n/**\n * The [[SubdivisionModifier]] subdivides triangle mesh geometries.\n */\nexport abstract class SubdivisionModifier {\n    /**\n     * Constructs a new [[SubdivisionModifier]].\n     */\n    constructor() {\n        // nothing to do\n    }\n\n    /**\n     * Subdivides the faces of the given [[THREE.BufferGeometry]].\n     *\n     * This method modifies (in-place) the vertices and the faces of the geometry.\n     * Please note that only the vertex position and their UV coordinates are subdivided.\n     * Normals, vertex colors and other attributes are left unmodified.\n     *\n     * @param geometry - The [[THREE.BufferGeometry]] to subdivide.\n     */\n    modify(geometry: BufferGeometry): BufferGeometry {\n        const positionAttr = geometry.getAttribute(\"position\") as BufferAttribute;\n        const position = Array.from(positionAttr.array);\n\n        const uvAttr = geometry.getAttribute(\"uv\") as BufferAttribute;\n        const uv = uvAttr !== undefined ? Array.from(uvAttr.array) : undefined;\n\n        const edgeAttr = geometry.getAttribute(\"edge\") as BufferAttribute;\n        const edge = edgeAttr !== undefined ? Array.from(edgeAttr.array) : undefined;\n\n        const wallAttr = geometry.getAttribute(\"wall\") as BufferAttribute;\n        const wall = wallAttr !== undefined ? Array.from(wallAttr.array) : undefined;\n\n        const indexAttr = geometry.getIndex() as BufferAttribute;\n        const indices = Array.from(indexAttr.array);\n\n        // A cache containing the indices of the vertices added\n        // when subdiving the faces of the geometry.\n        const cache = new Map<string, number>();\n\n        /**\n         * Returns the index of the vertex positioned in the middle of the given vertices.\n         */\n        function middleVertex(i: number, j: number): number {\n            // Build a unique `key` for the pair of indices `(i, j)`.\n            const key = `${Math.min(i, j)}_${Math.max(i, j)}`;\n\n            const h = cache.get(key);\n\n            if (h !== undefined) {\n                // Nothing to do, a vertex in the middle of (i, j) was already created.\n                return h;\n            }\n\n            // The position of the new vertex.\n            tmpVectorA.set(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);\n            tmpVectorB.set(position[j * 3], position[j * 3 + 1], position[j * 3 + 2]);\n            tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n\n            // The index of the new vertex.\n            const index = position.length / 3;\n            position.push(...tmpVectorC.toArray());\n            // Cache the position of the new vertex.\n            cache.set(key, index);\n\n            // The uvs of the new vertex.\n            if (uv !== undefined) {\n                tmpVectorA.set(uv[i * 2], uv[i * 2 + 1], 0);\n                tmpVectorB.set(uv[j * 2], uv[j * 2 + 1], 0);\n                tmpVectorC.lerpVectors(tmpVectorA, tmpVectorB, 0.5);\n                uv.push(tmpVectorC.x, tmpVectorC.y);\n            }\n\n            // The edge and wall attributes of the new vertex.\n            // If a new vertex has been introduced between i and j, connect the elements\n            // accordingly.\n            if (edge !== undefined) {\n                if (edge[i] === j) {\n                    edge.push(j);\n                    edge[i] = index;\n                } else if (edge[j] === i) {\n                    edge.push(i);\n                    edge[j] = index;\n                } else {\n                    edge.push(-1);\n                }\n            }\n            if (wall !== undefined) {\n                if (wall[i] === j) {\n                    wall.push(j);\n                    wall[i] = index;\n                } else if (wall[j] === i) {\n                    wall.push(i);\n                    wall[j] = index;\n                } else {\n                    wall.push(-1);\n                }\n            }\n\n            return index;\n        }\n\n        const newIndices = [];\n        while (indices.length >= 3) {\n            const v0 = indices.shift()!;\n            const v1 = indices.shift()!;\n            const v2 = indices.shift()!;\n\n            tmpVectorA.set(position[v0 * 3], position[v0 * 3 + 1], position[v0 * 3 + 2]);\n            tmpVectorB.set(position[v1 * 3], position[v1 * 3 + 1], position[v1 * 3 + 2]);\n            tmpVectorC.set(position[v2 * 3], position[v2 * 3 + 1], position[v2 * 3 + 2]);\n\n            const edgeToSplit = this.shouldSplitTriangle(tmpVectorA, tmpVectorB, tmpVectorC);\n\n            switch (edgeToSplit) {\n                case 0: {\n                    const v3 = middleVertex(v0, v1);\n                    indices.push(v0, v3, v2, v3, v1, v2);\n                    break;\n                }\n\n                case 1: {\n                    const v3 = middleVertex(v1, v2);\n                    indices.push(v0, v1, v3, v0, v3, v2);\n                    break;\n                }\n\n                case 2: {\n                    const v3 = middleVertex(v2, v0);\n                    indices.push(v0, v1, v3, v3, v1, v2);\n                    break;\n                }\n\n                case undefined: {\n                    newIndices.push(v0, v1, v2);\n                    break;\n                }\n\n                default:\n                    throw new Error(\"failed to subdivide the given geometry\");\n            }\n        }\n\n        positionAttr.array =\n            positionAttr.array instanceof Float32Array\n                ? new Float32Array(position)\n                : new Float64Array(position);\n        positionAttr.count = position.length / positionAttr.itemSize;\n        positionAttr.needsUpdate = true;\n\n        geometry.setIndex(newIndices);\n\n        if (uv !== undefined) {\n            uvAttr.array = new Float32Array(uv);\n            uvAttr.count = uv.length / uvAttr.itemSize;\n            uvAttr.needsUpdate = true;\n        }\n\n        if (edge !== undefined) {\n            edgeAttr.array = new Float32Array(edge);\n            edgeAttr.count = edge.length / edgeAttr.itemSize;\n            edgeAttr.needsUpdate = true;\n        }\n\n        return geometry;\n    }\n\n    /**\n     * Returns if the given triangle should be subdivide.\n     *\n     * Implementations of this function should return the index of\n     * the edge of the triangle to split (0, 1, or 2) or undefined if\n     * the triangle doesn't need to be subdivided.\n     *\n     * @param a - The position of the first vertex of the triangle.\n     * @param b - The position of the second vertex of the triangle.\n     * @param c - The position of the third vertex of the triangle.\n     */\n    protected abstract shouldSplitTriangle(a: Vector3, b: Vector3, c: Vector3): number | undefined;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { GeoBoxExtentLike } from \"./GeoBoxExtentLike\";\nimport { GeoCoordinates, MAX_LONGITUDE } from \"./GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"./GeoCoordinatesLike\";\n\n/**\n * `GeoBox` is used to represent a bounding box in geo coordinates.\n */\nexport class GeoBox implements GeoBoxExtentLike {\n    /**\n     * Returns a `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest - The south west position in geo coordinates.\n     * @param northEast - The north east position in geo coordinates.\n     */\n    static fromCoordinates(southWest: GeoCoordinates, northEast: GeoCoordinates): GeoBox {\n        return new GeoBox(southWest, northEast);\n    }\n\n    /**\n     * Returns a `GeoBox` with the given center and dimensions.\n     *\n     * @param center - The center position of geo box.\n     * @param extent - Box latitude and logitude span\n     */\n    static fromCenterAndExtents(center: GeoCoordinates, extent: GeoBoxExtentLike): GeoBox {\n        return new GeoBox(\n            new GeoCoordinates(\n                center.latitude - extent.latitudeSpan / 2,\n                center.longitude - extent.longitudeSpan / 2\n            ),\n            new GeoCoordinates(\n                center.latitude + extent.latitudeSpan / 2,\n                center.longitude + extent.longitudeSpan / 2\n            )\n        );\n    }\n\n    /**\n     * Constructs a new `GeoBox` with the given geo coordinates.\n     *\n     * @param southWest - The south west position in geo coordinates.\n     * @param northEast - The north east position in geo coordinates.\n     */\n    constructor(readonly southWest: GeoCoordinates, readonly northEast: GeoCoordinates) {\n        if (this.west > this.east) {\n            this.northEast.longitude += 360;\n        }\n    }\n\n    /**\n     * Returns the minimum altitude or `undefined`.\n     */\n    get minAltitude(): number | undefined {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.min(this.southWest.altitude, this.northEast.altitude);\n    }\n\n    /**\n     * Returns the maximum altitude or `undefined`.\n     */\n    get maxAltitude(): number | undefined {\n        if (this.southWest.altitude === undefined || this.northEast.altitude === undefined) {\n            return undefined;\n        }\n        return Math.max(this.southWest.altitude, this.northEast.altitude);\n    }\n\n    /**\n     * Returns the south latitude in degrees of this `GeoBox`.\n     */\n    get south(): number {\n        return this.southWest.latitude;\n    }\n\n    /**\n     * Returns the north altitude in degrees of this `GeoBox`.\n     */\n    get north(): number {\n        return this.northEast.latitude;\n    }\n\n    /**\n     * Returns the west longitude in degrees of this `GeoBox`.\n     */\n    get west(): number {\n        return this.southWest.longitude;\n    }\n\n    /**\n     * Returns the east longitude in degrees of this `GeoBox`.\n     */\n    get east(): number {\n        return this.northEast.longitude;\n    }\n\n    /**\n     * Returns the center of this `GeoBox`.\n     */\n    get center(): GeoCoordinates {\n        const latitude = (this.south + this.north) * 0.5;\n        const { west, east } = this;\n        const { minAltitude, altitudeSpan } = this;\n\n        let altitude: number | undefined;\n\n        if (minAltitude !== undefined && altitudeSpan !== undefined) {\n            altitude = minAltitude + altitudeSpan * 0.5;\n        }\n\n        if (west <= east) {\n            return new GeoCoordinates(latitude, (west + east) * 0.5, altitude);\n        }\n\n        let longitude = (360 + east + west) * 0.5;\n\n        if (longitude > 360) {\n            longitude -= 360;\n        }\n\n        return new GeoCoordinates(latitude, longitude, altitude);\n    }\n\n    /**\n     * Returns the latitude span in radians.\n     */\n    get latitudeSpanInRadians(): number {\n        return THREE.MathUtils.degToRad(this.latitudeSpan);\n    }\n\n    /**\n     * Returns the longitude span in radians.\n     */\n    get longitudeSpanInRadians(): number {\n        return THREE.MathUtils.degToRad(this.longitudeSpan);\n    }\n\n    /**\n     * Returns the latitude span in degrees.\n     */\n    get latitudeSpan(): number {\n        return this.north - this.south;\n    }\n\n    get altitudeSpan(): number | undefined {\n        if (this.maxAltitude === undefined || this.minAltitude === undefined) {\n            return undefined;\n        }\n        return this.maxAltitude - this.minAltitude;\n    }\n\n    /**\n     * Returns the longitude span in degrees.\n     */\n    get longitudeSpan(): number {\n        let width = this.northEast.longitude - this.southWest.longitude;\n\n        if (width < 0) {\n            width += 360;\n        }\n\n        return width;\n    }\n\n    /**\n     * Returns the latitude span in degrees.\n     * @deprecated Use [[latitudeSpan]] instead.\n     */\n    get latitudeSpanInDegrees(): number {\n        return this.latitudeSpan;\n    }\n\n    /**\n     * Returns the longitude span in degrees.\n     * @deprecated Use [[longitudeSpan]] instead.\n     */\n    get longitudeSpanInDegrees(): number {\n        return this.longitudeSpan;\n    }\n\n    /**\n     * Returns `true` if the given geo coordinates are contained in this `GeoBox`.\n     *\n     * @param point - The geo coordinates.\n     */\n    contains(point: GeoCoordinates): boolean {\n        if (\n            point.altitude === undefined ||\n            this.minAltitude === undefined ||\n            this.maxAltitude === undefined\n        ) {\n            return this.containsHelper(point);\n        }\n\n        const isFlat = this.minAltitude === this.maxAltitude;\n        const isSameAltitude = this.minAltitude === point.altitude;\n        const isWithinAltitudeRange =\n            this.minAltitude <= point.altitude && this.maxAltitude > point.altitude;\n\n        // If box is flat, we should check the altitude and containment,\n        // otherwise we should check also altitude difference where we consider\n        // point to be inside if alt is from [m_minAltitude, m_maxAltitude) range!\n        if (isFlat ? isSameAltitude : isWithinAltitudeRange) {\n            return this.containsHelper(point);\n        }\n\n        return false;\n    }\n\n    /**\n     * Clones this `GeoBox` instance.\n     */\n    clone(): GeoBox {\n        return new GeoBox(this.southWest.clone(), this.northEast.clone());\n    }\n\n    /**\n     * Update the bounding box by considering a given point.\n     *\n     * @param point - The point that may expand the bounding box.\n     */\n    growToContain(point: GeoCoordinatesLike) {\n        this.southWest.latitude = Math.min(this.southWest.latitude, point.latitude);\n        this.southWest.longitude = Math.min(this.southWest.longitude, point.longitude);\n        this.southWest.altitude =\n            this.southWest.altitude !== undefined && point.altitude !== undefined\n                ? Math.min(this.southWest.altitude, point.altitude)\n                : this.southWest.altitude !== undefined\n                ? this.southWest.altitude\n                : point.altitude !== undefined\n                ? point.altitude\n                : undefined;\n\n        this.northEast.latitude = Math.max(this.northEast.latitude, point.latitude);\n        this.northEast.longitude = Math.max(this.northEast.longitude, point.longitude);\n        this.northEast.altitude =\n            this.northEast.altitude !== undefined && point.altitude !== undefined\n                ? Math.max(this.northEast.altitude, point.altitude)\n                : this.northEast.altitude !== undefined\n                ? this.northEast.altitude\n                : point.altitude !== undefined\n                ? point.altitude\n                : undefined;\n    }\n\n    private containsHelper(point: GeoCoordinates): boolean {\n        if (point.latitude < this.southWest.latitude || point.latitude >= this.northEast.latitude) {\n            return false;\n        }\n\n        const { west, east } = this;\n\n        let longitude = point.longitude;\n        if (east > MAX_LONGITUDE) {\n            while (longitude < west) {\n                longitude = longitude + 360;\n            }\n        }\n\n        if (longitude > east) {\n            while (longitude > west + 360) {\n                longitude = longitude - 360;\n            }\n        }\n\n        return longitude >= west && longitude < east;\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents an object that carry {@link GeoBox} extents like interface.\n */\nexport interface GeoBoxExtentLike {\n    /**\n     * Latitude span in degrees.\n     */\n    readonly latitudeSpan: number;\n\n    /**\n     * Longitude span in degrees\n     */\n    readonly longitudeSpan: number;\n}\n\n/**\n * Type guard to assert that `object` conforms to {@link GeoBoxExtentLike} interface.\n */\nexport function isGeoBoxExtentLike(obj: any): obj is GeoBoxExtentLike {\n    return (\n        obj &&\n        typeof obj === \"object\" &&\n        typeof obj.latitudeSpan === \"number\" &&\n        typeof obj.longitudeSpan === \"number\"\n    );\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"./GeoCoordinatesLike\";\nimport { GeoPointLike, isGeoPointLike } from \"./GeoPointLike\";\nimport { isLatLngLike, LatLngLike } from \"./LatLngLike\";\n\n/**\n * Represents an object in different geo coordinate formats\n */\nexport type GeoCoordLike = GeoPointLike | GeoCoordinatesLike | LatLngLike;\n\nexport function geoCoordLikeToGeoCoordinatesLike(coord: GeoCoordLike): GeoCoordinatesLike {\n    return isGeoCoordinatesLike(coord)\n        ? coord\n        : isLatLngLike(coord)\n        ? { latitude: coord.lat, longitude: coord.lng }\n        : { latitude: coord[1], longitude: coord[0] };\n}\n\nexport function geoCoordLikeToGeoPointLike(coord: GeoCoordLike): GeoPointLike {\n    return isGeoPointLike(coord)\n        ? coord\n        : isLatLngLike(coord)\n        ? [coord.lng, coord.lat]\n        : [coord.longitude, coord.latitude];\n}\n\nexport function isGeoCoordLike(object: any): boolean {\n    return isGeoCoordinatesLike(object) || isLatLngLike(object) || !isGeoPointLike(object);\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"./GeoCoordinatesLike\";\nimport { GeoCoordLike } from \"./GeoCoordLike\";\nimport { GeoPointLike, isGeoPointLike } from \"./GeoPointLike\";\nimport { isLatLngLike, LatLngLike } from \"./LatLngLike\";\n\nexport const MAX_LATITUDE = 90;\nexport const MIN_LATITUDE = -90;\nexport const MAX_LONGITUDE = 180;\nexport const MIN_LONGITUDE = -180;\n\nconst tmpV0 = new THREE.Vector3();\nconst tmpV1 = new THREE.Vector3();\n\n/**\n * Compute the modulo.\n *\n * @internal\n */\nfunction mod(dividend: number, divisor: number): number {\n    const modulo = dividend % divisor;\n    const modulo_sign = modulo < 0;\n    const divisor_sign = divisor < 0;\n    return modulo_sign === divisor_sign ? modulo : modulo + divisor;\n}\n\n/**\n * `GeoCoordinates` is used to represent geo positions.\n */\nexport class GeoCoordinates implements GeoCoordinatesLike {\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in degrees.\n     * @param longitude - Longitude in degrees.\n     * @param altitude - Altitude in meters.\n     */\n    static fromDegrees(latitude: number, longitude: number, altitude?: number): GeoCoordinates {\n        return new GeoCoordinates(latitude, longitude, altitude);\n    }\n\n    /**\n     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in radians.\n     * @param longitude - Longitude in radians.\n     * @param altitude - Altitude in meters.\n     */\n    static fromRadians(latitude: number, longitude: number, altitude?: number): GeoCoordinates {\n        return new GeoCoordinates(\n            THREE.MathUtils.radToDeg(latitude),\n            THREE.MathUtils.radToDeg(longitude),\n            altitude\n        );\n    }\n\n    /**\n     * Creates a {@link GeoCoordinates} from a {@link LatLngLike} literal.\n     * ```typescript\n     * const center = { lat: 53.3, lng: 13.4 };\n     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);\n     * ```\n     * @param latLng - A {@link LatLngLike} object literal.\n     */\n    static fromLatLng(latLng: LatLngLike) {\n        return new GeoCoordinates(latLng.lat, latLng.lng);\n    }\n\n    /**\n     * Creates a {@link GeoCoordinates} from a [[GeoPointLike]] tuple.\n     *\n     * Example:\n     * ```typescript\n     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);\n     *\n     * let geoCoords: number[] = ...;\n     *\n     * if (isGeoPointLike(geoCoords)) {\n     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);\n     * }\n     * ```\n     * @param geoPoint - An [[Array]] of at least two elements following the order\n     * longitude, latitude, altitude.\n     */\n    static fromGeoPoint(geoPoint: GeoPointLike): GeoCoordinates {\n        return new GeoCoordinates(geoPoint[1], geoPoint[0], geoPoint[2]);\n    }\n\n    /**\n     * Creates a {@link GeoCoordinates} from different types of geo coordinate objects.\n     *\n     * Example:\n     * ```typescript\n     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);\n     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });\n     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));\n     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });\n     * ```\n     *\n     * @param geoPoint - Either [[GeoPointLike]], {@link GeoCoordinatesLike}\n     * or {@link LatLngLike} object literal.\n     */\n    static fromObject(geoPoint: GeoCoordLike): GeoCoordinates {\n        if (isGeoPointLike(geoPoint)) {\n            return GeoCoordinates.fromGeoPoint(geoPoint);\n        } else if (isGeoCoordinatesLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(\n                geoPoint.latitude,\n                geoPoint.longitude,\n                geoPoint.altitude\n            );\n        } else if (isLatLngLike(geoPoint)) {\n            return GeoCoordinates.fromDegrees(geoPoint.lat, geoPoint.lng);\n        }\n\n        throw new Error(\"Invalid input coordinate format.\");\n    }\n\n    /**\n     * Returns a `GeoCoordinates` resulting from the linear interpolation of other two.\n     * @param geoCoords0 - One of the `GeoCoordinates` used for interpolation.\n     * @param geoCoords1 - The other `GeoCoordinates` used for interpolation.\n     * @param factor - Interpolation factor. If `0` result will be equal to `geoCoords0`, if `1`\n     * it'll be equal to `geoCoords1`.\n     * @param wrap - If `true`, interpolation will be done across the antimeridian, otherwise it's\n     * done across the Greenwich meridian. Supported only if longitude span is less than 360 deg.\n     * @default false\n     * @param normalize - If `true`, interpolation result will be normalized. @default false\n     */\n    static lerp(\n        geoCoords0: GeoCoordinates,\n        geoCoords1: GeoCoordinates,\n        factor: number,\n        wrap: boolean = false,\n        normalize: boolean = false\n    ): GeoCoordinates {\n        if (wrap) {\n            if (geoCoords0.lng < geoCoords1.lng) {\n                const geoCoordsEnd = geoCoords0.clone();\n                geoCoordsEnd.longitude += 360;\n                return this.lerp(geoCoords1, geoCoordsEnd, 1 - factor);\n            } else {\n                const geoCoordsEnd = geoCoords1.clone();\n                geoCoordsEnd.longitude += 360;\n                return this.lerp(geoCoords0, geoCoordsEnd, factor);\n            }\n        }\n\n        const v0 = tmpV0.set(geoCoords0.lat, geoCoords0.lng, geoCoords0.altitude ?? 0);\n        const v1 = tmpV1.set(geoCoords1.lat, geoCoords1.lng, geoCoords1.altitude ?? 0);\n        v0.lerp(v1, factor);\n        const result = new GeoCoordinates(v0.x, v0.y, v0.z);\n\n        return normalize ? result.normalized() : result;\n    }\n\n    /**\n     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.\n     *\n     * @param latitude - Latitude in degrees.\n     * @param longitude - Longitude in degrees.\n     * @param altitude - Altitude in meters.\n     */\n    constructor(public latitude: number, public longitude: number, public altitude?: number) {}\n\n    /**\n     * Returns the latitude in radians.\n     */\n    get latitudeInRadians(): number {\n        return THREE.MathUtils.degToRad(this.latitude);\n    }\n\n    /**\n     * Returns the longitude in radians.\n     */\n    get longitudeInRadians(): number {\n        return THREE.MathUtils.degToRad(this.longitude);\n    }\n\n    /**\n     * Returns the latitude in degrees.\n     * @deprecated Use the [[latitude]] property instead.\n     */\n    get latitudeInDegrees(): number {\n        return this.latitude;\n    } // compat api\n\n    /**\n     * Returns the longitude in degrees.\n     * @deprecated Use the [[longitude]] property instead.\n     */\n    get longitudeInDegrees(): number {\n        return this.longitude;\n    } // compat api\n\n    /**\n     * The latitude in the degrees.\n     */\n    get lat() {\n        return this.latitude;\n    }\n\n    /**\n     * The longitude in the degrees.\n     */\n    get lng() {\n        return this.longitude;\n    }\n\n    /**\n     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.\n     */\n    isValid(): boolean {\n        return !isNaN(this.latitude) && !isNaN(this.longitude);\n    }\n\n    /**\n     * Returns the normalized `GeoCoordinates`.\n     */\n    normalized(): GeoCoordinates {\n        let { latitude, longitude } = this;\n        if (isNaN(latitude) || isNaN(longitude)) {\n            return this;\n        }\n        if (longitude < -180 || longitude > 180) {\n            longitude = mod(longitude + 180, 360) - 180;\n        }\n        latitude = THREE.MathUtils.clamp(latitude, -90, 90);\n        return new GeoCoordinates(latitude, longitude, this.altitude);\n    }\n\n    /**\n     * Returns `true` if this `GeoCoordinates` is equal to the other.\n     *\n     * @param other - GeoCoordinatesLike to compare to.\n     */\n    equals(other: GeoCoordinatesLike): boolean {\n        return (\n            this.latitude === other.latitude &&\n            this.longitude === other.longitude &&\n            this.altitude === other.altitude\n        );\n    }\n\n    /**\n     * Copy values from the other.\n     *\n     * @param other - GeoCoordinatesLike to copy all values from.\n     */\n    copy(other: GeoCoordinatesLike): GeoCoordinates {\n        this.latitude = other.latitude;\n        this.longitude = other.longitude;\n        this.altitude = other.altitude;\n        return this;\n    }\n\n    /**\n     * Clones this `GeoCoordinates`.\n     */\n    clone(): GeoCoordinates {\n        return new GeoCoordinates(this.latitude, this.longitude, this.altitude);\n    }\n\n    /**\n     * Returns this {@link GeoCoordinates} as {@link LatLngLike} literal.\n     */\n    toLatLng(): LatLngLike {\n        return { lat: this.latitude, lng: this.longitude };\n    }\n\n    /**\n     * Converts this {@link GeoCoordinates} to a [[GeoPointLike]].\n     */\n    toGeoPoint(): GeoPointLike {\n        return this.altitude !== undefined\n            ? [this.longitude, this.latitude, this.altitude]\n            : [this.longitude, this.latitude];\n    }\n\n    /**\n     * Returns the minimum longitude span from this `GeoCoordinates` to another.\n     *\n     * @param other - The other GeoCoordinatesLike defining the longitude span.\n     */\n    minLongitudeSpanTo(other: GeoCoordinatesLike): number {\n        const minLongitude = Math.min(this.longitude, other.longitude);\n        const maxLongitude = Math.max(this.longitude, other.longitude);\n\n        return Math.min(maxLongitude - minLongitude, 360 + minLongitude - maxLongitude);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents an object with `GeoCoordinates` like interface.\n */\nexport interface GeoCoordinatesLike {\n    /** The latitude in degrees. */\n    latitude: number;\n\n    /** The longitude in degrees. */\n    longitude: number;\n\n    /** The optional altitude in meters. */\n    altitude?: number;\n}\n\n/**\n * Type guard to assert that `object` conforms to {@link GeoCoordinatesLike} data interface.\n */\nexport function isGeoCoordinatesLike(object: any): object is GeoCoordinatesLike {\n    return (\n        object &&\n        typeof object.latitude === \"number\" &&\n        typeof object.longitude === \"number\" &&\n        (typeof object.altitude === \"number\" || typeof object.altitude === \"undefined\")\n    );\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * An [[Array]] following the order longitude, latitude, altitude.\n */\nexport type GeoPointLike = [number, number, number?];\n\n/**\n * Type guard to assert that `object` conforms to [[GeoPointLike]] interface.\n */\nexport function isGeoPointLike(geoPoint: any): geoPoint is GeoPointLike {\n    if (Array.isArray(geoPoint)) {\n        const [longitude, latitude, altitude] = geoPoint;\n        return (\n            typeof longitude === \"number\" &&\n            typeof latitude === \"number\" &&\n            (altitude === undefined || typeof altitude === \"number\")\n        );\n    }\n    return false;\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Vector2 } from \"three\";\n\nimport { GeoBox } from \"./GeoBox\";\nimport { GeoCoordinates, MAX_LATITUDE, MIN_LATITUDE } from \"./GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"./GeoCoordinatesLike\";\nimport { GeoCoordLike, geoCoordLikeToGeoCoordinatesLike } from \"./GeoCoordLike\";\nimport { GeoPolygonLike } from \"./GeoPolygonLike\";\n\nfunction computeLonSpanAcrossGreewich(lonA: number, lonB: number) {\n    return Math.max(lonA, lonB) - Math.min(lonA, lonB);\n}\n\nfunction isLeftToRightAntimeridianCrossing(lonStart: number, lonEnd: number) {\n    return lonStart > 0 && lonEnd < 0 && computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180;\n}\n\nfunction isRightToLeftAntimeridianCrossing(lonStart: number, lonEnd: number) {\n    return isLeftToRightAntimeridianCrossing(lonEnd, lonStart);\n}\n\nexport function isAntimeridianCrossing(lonStart: number, lonEnd: number) {\n    return (\n        Math.sign(lonStart) === -Math.sign(lonEnd) &&\n        computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180\n    );\n}\n\ntype MinThreeItemsArray<T> = [T, T, T, ...T[]];\n\nexport type GeoPolygonCoordinates = MinThreeItemsArray<\n    GeoCoordinatesLike | GeoCoordinates | GeoCoordLike\n>;\n\n/**\n * A GeoPolygon in 2D Space (altitudes will be ignored).\n * Coordinates are expected in counter-clockwise order, for convex polygons a sorting is\n * available.\n * Clockwise ordered or selfintersecting Polygons might lead to no or unexpected results.\n *\n * @beta @internal\n */\nexport class GeoPolygon implements GeoPolygonLike {\n    private readonly m_coordinates: MinThreeItemsArray<GeoCoordinatesLike>;\n\n    /**\n     * Creates a GeoPolygon instance\n     *\n     * @param coordinates An array of GeoCoordinates acting as the Vertices of the Polygon.\n     * @param needsSort  If `true` it will sort the coordinates in ccw order, this will only\n     *  result correctly for convex polygons @default false\n     * @param needsWrapping  If `true` it will wrap around coordinates crossing the antemeridian.\n     * Only supported for polygons with sides that don't span more than 180 degrees longitude.\n     * @default false\n     */\n    constructor(\n        coordinates: GeoPolygonCoordinates,\n        needsSort: boolean = false,\n        needsWrapping: boolean = false\n    ) {\n        this.m_coordinates = coordinates.map(coord => {\n            return geoCoordLikeToGeoCoordinatesLike(coord);\n        }) as MinThreeItemsArray<GeoCoordinatesLike>;\n        if (needsSort) {\n            this.sortCCW();\n        }\n        if (needsWrapping) {\n            this.wrapCoordinatesAround();\n        }\n    }\n\n    get coordinates(): MinThreeItemsArray<GeoCoordinatesLike> {\n        return this.m_coordinates;\n    }\n\n    /**\n     * Gets a BoundingBox for the Polygon\n     *\n     * Might have unexpected results for twisted or concave Polygons\n     */\n    getGeoBoundingBox(): GeoBox {\n        const centroid = this.getCentroid();\n        if (centroid === undefined) {\n            //return a BBox without extend if the centroid could not be generated\n            return GeoBox.fromCoordinates(\n                this.coordinates[0] as GeoCoordinates,\n                this.coordinates[0] as GeoCoordinates\n            );\n        }\n        const { east, west } = this.getEastAndWest(centroid);\n        const { north, south } = this.getNorthAndSouth();\n        return GeoBox.fromCoordinates(\n            new GeoCoordinates(south, west),\n            new GeoCoordinates(north, east)\n        );\n    }\n\n    /**\n     * Gets the Centroid for the Polygon\n     *\n     * Might be undefined or with unexpected results for twisted or concave Polygons.\n     */\n    getCentroid(): GeoCoordinates | undefined {\n        const area = this.getArea();\n        if (area === 0) {\n            return undefined;\n        }\n        let latitude = 0;\n        let longitude = 0;\n        let f;\n\n        let previousIndex = this.m_coordinates.length - 1;\n\n        this.m_coordinates.forEach((coordinate, index) => {\n            const previousCoordinate = this.m_coordinates[previousIndex];\n            f =\n                coordinate.latitude * previousCoordinate.longitude -\n                previousCoordinate.latitude * coordinate.longitude;\n            latitude += (coordinate.latitude + previousCoordinate.latitude) * f;\n            longitude += (coordinate.longitude + previousCoordinate.longitude) * f;\n            previousIndex = index;\n        });\n\n        f = area * 6;\n\n        return new GeoCoordinates(\n            latitude / f,\n            area < 0 /* antimeridian crossing */ ? -180 + longitude / f : longitude / f\n        );\n    }\n\n    private sortCCW() {\n        const polyCenter = this.getPolyAverageCenter();\n        if (!polyCenter) {\n            return;\n        }\n\n        //sorts by angle from x-axis\n        this.m_coordinates.sort((a: GeoCoordinatesLike, b: GeoCoordinatesLike) => {\n            const veca = new Vector2(\n                a.latitude - polyCenter.latitude,\n                a.longitude - polyCenter.longitude\n            ).normalize();\n            const vecb = new Vector2(\n                b.latitude - polyCenter.latitude,\n                b.longitude - polyCenter.longitude\n            ).normalize();\n\n            return vecb.angle() - veca.angle();\n        });\n    }\n\n    private wrapCoordinatesAround() {\n        const firstAntimerCrossIndex = this.m_coordinates.findIndex(\n            (val: GeoCoordinatesLike, index: number) => {\n                const prevLonIndex = index === 0 ? this.m_coordinates.length - 1 : index - 1;\n                const prevLon = this.m_coordinates[prevLonIndex].longitude;\n                const lon = val.longitude;\n\n                return isLeftToRightAntimeridianCrossing(prevLon, lon);\n            }\n        );\n        if (firstAntimerCrossIndex < 0) {\n            return;\n        }\n\n        let wrapAround = true;\n        for (let i = 0; i < this.m_coordinates.length; i++) {\n            const index = (firstAntimerCrossIndex + i) % this.m_coordinates.length;\n            const currentLon = this.m_coordinates[index].longitude;\n            const nextLon = this.m_coordinates[(index + 1) % this.m_coordinates.length].longitude;\n\n            if (wrapAround) {\n                this.m_coordinates[index].longitude += 360;\n            }\n\n            if (isRightToLeftAntimeridianCrossing(currentLon, nextLon)) {\n                wrapAround = false;\n            } else if (isLeftToRightAntimeridianCrossing(currentLon, nextLon)) {\n                wrapAround = true;\n            }\n        }\n    }\n\n    private getPolyAverageCenter(): GeoCoordinates | undefined {\n        const polySum = this.m_coordinates.reduce((prev, curr) => {\n            return new GeoCoordinates(\n                prev.latitude + curr.latitude,\n                prev.longitude + curr.longitude\n            );\n        });\n        //create an average center point\n        return new GeoCoordinates(\n            polySum.latitude / this.m_coordinates.length,\n            polySum.longitude / this.m_coordinates.length\n        );\n    }\n\n    private getArea(): number {\n        let area = 0;\n        let previousIndex = this.m_coordinates.length - 1;\n\n        this.m_coordinates.forEach((coordinate, index) => {\n            const previousCoordinate = this.m_coordinates[previousIndex];\n            area += coordinate.latitude * previousCoordinate.longitude;\n            area -= coordinate.longitude * previousCoordinate.latitude;\n            previousIndex = index;\n        });\n\n        return (area /= 2);\n    }\n\n    private getEastAndWest(center: GeoCoordinates): { east: number; west: number } {\n        let west = center.longitude;\n        let east = center.longitude;\n        let previousIndex = this.m_coordinates.length - 1;\n        this.m_coordinates.forEach((coordinate, index) => {\n            const previousCoordinate = this.m_coordinates[previousIndex];\n            previousIndex = index;\n            const veca = new Vector2(\n                coordinate.latitude - center.latitude,\n                coordinate.longitude - center.longitude\n            ).normalize();\n\n            const vecb = new Vector2(\n                previousCoordinate.latitude - center.latitude,\n                previousCoordinate.longitude - center.longitude\n            ).normalize();\n\n            let ccw = Math.sign(vecb.angle() - veca.angle()) === 1;\n            // overwrite in case of angle over axis\n            if (vecb.y >= 0 && veca.y < 0) {\n                ccw = true;\n            }\n\n            const long = coordinate.longitude;\n            if (long < center.longitude) {\n                if (ccw) {\n                    west = Math.min(west, long);\n                } else {\n                    east = Math.min(east, long);\n                }\n            } else {\n                if (ccw) {\n                    east = Math.max(east, long);\n                } else {\n                    west = Math.max(west, long);\n                }\n            }\n        });\n        return { east, west };\n    }\n\n    private getNorthAndSouth(): { north: number; south: number } {\n        let north = MIN_LATITUDE;\n        let south = MAX_LATITUDE;\n        this.m_coordinates.forEach((coordinate, index) => {\n            north = Math.max(north, coordinate.latitude);\n            south = Math.min(south, coordinate.latitude);\n        });\n        return { north, south };\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GeoCoordLike, isGeoCoordLike } from \"./GeoCoordLike\";\n\n/**\n * Represents an object with `GeoPolygon` like interface.\n *\n * This is defined as an Array of GeoCoordinates sorted in ccw order.\n *\n * @beta, @internal\n */\nexport interface GeoPolygonLike {\n    /**\n     * Array of ccw sorted GeoCoordLike\n     */\n    coordinates: GeoCoordLike[];\n}\n\n/**\n * Type guard to assert that `object` conforms to {@link GeoPolygonLike} data interface.\n *\n * @beta, @internal\n */\nexport function isGeoPolygonLike(object: any): object is GeoPolygonLike {\n    if (!object || (!Array.isArray(object.coordinates) && object.coordinates.length > 2)) {\n        return false;\n    }\n    let isValid: boolean = true;\n    //TODO: this might take a while, not sure this should be that extensive\n    object.coordinates.forEach((coord: any) => {\n        if (!isGeoCoordLike(object)) {\n            isValid = false;\n        }\n    });\n    return isValid;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents an object with `LatLng` like interface.\n */\nexport interface LatLngLike {\n    /** The latitude in degrees. */\n    lat: number;\n\n    /** The longitude in degrees. */\n    lng: number;\n}\n\n/**\n * Type guard to assert that `object` conforms to {@link LatLngLike} interface.\n */\nexport function isLatLngLike(object: any): object is LatLngLike {\n    return object && typeof object.lat === \"number\" && typeof object.lng === \"number\";\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"./Vector3Like\";\n\n/**\n * An interface representing bounding box in world coordinates.\n */\nexport interface Box3Like {\n    /**\n     * The minimum position in world coordinates of this bounding box.\n     */\n    readonly min: Vector3Like;\n\n    /**\n     * The maximum position in world coordinates of this bounding box.\n     */\n    readonly max: Vector3Like;\n}\n\n/**\n * Returns true if the given object implements the {@link Box3Like} interface.\n *\n * @param object - A valid object.\n */\nexport function isBox3Like(object: {}): object is Box3Like {\n    const box3 = object as Partial<Box3Like>;\n    return box3.min !== undefined && box3.max !== undefined;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { Box3Like } from \"./Box3Like\";\nimport { Vector3Like } from \"./Vector3Like\";\n\nexport namespace MathUtils {\n    /**\n     * Creates a new empty bounding box.\n     *\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/Box3 | THREE.Box3} instead.\n     */\n    export function newEmptyBox3(): Box3Like {\n        return {\n            min: { x: Infinity, y: Infinity, z: Infinity },\n            max: { x: -Infinity, y: -Infinity, z: -Infinity }\n        };\n    }\n\n    /**\n     * Creates a new [Vector3Like] instance.\n     *\n     * @param x - The x component.\n     * @param y - The y component.\n     * @param z - The z component.\n     */\n    export function newVector3(x: number, y: number, z: number): Vector3Like;\n\n    /**\n     * Creates a new [Vector3Like] instance.\n     *\n     * @param x - The x component.\n     * @param y - The y component.\n     * @param z - The z component.\n     * @param v - The resulting [Vector3Like] instance.\n     */\n    export function newVector3<Vector extends Vector3Like>(\n        x: number,\n        y: number,\n        z: number,\n        v: Vector\n    ): Vector;\n\n    /**\n     * Set the components of the given [Vector3Like] instance.\n     *\n     * @param x - The x component.\n     * @param y - The y component.\n     * @param z - The z component.\n     * @param v - The [Vector3Like]\n     */\n    export function newVector3(x: number, y: number, z: number, v?: Vector3Like): Vector3Like {\n        if (v === undefined) {\n            return { x, y, z };\n        }\n        v.x = x;\n        v.y = y;\n        v.z = z;\n        return v;\n    }\n\n    /**\n     * Copies the vector across.\n     *\n     * @param from - The vector to copy from.\n     * @param to - The resulting [Vector3Like] instance, with the contents copied from from\n     */\n    export function copyVector3<Vector extends Vector3Like>(from: Vector3Like, to: Vector): Vector {\n        to.x = from.x;\n        to.y = from.y;\n        to.z = from.z;\n        return to;\n    }\n\n    /**\n     * Converts an angle measured in degrees to an equivalent value in radians.\n     *\n     * @param degrees - Value in degrees.\n     * @returns Value in radians.\n     * @deprecated use THREE.MathUtils.degToRad instead\n     */\n    export const degToRad = THREE.MathUtils.degToRad;\n\n    /**\n     * Converts an angle measured in radians to an equivalent value in degrees.\n     *\n     * @param degrees - Value in radians.\n     * @returns Value in degrees.\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.radToDeg\n     *                | THREE.MathUtils.radToDeg}.\n     */\n    export const radToDeg = THREE.MathUtils.radToDeg;\n\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value - The value to be clamped.\n     * @param min - Minimum value.\n     * @param max - Maximum value.\n     * @returns Clamped value.\n     * @deprecated Use {@link https://threejs.org/docs/#api/en/math/MathUtils.clamp\n     *                | THREE.MathUtils.clamp}.\n     */\n    export const clamp = THREE.MathUtils.clamp;\n\n    /**\n     * Normalize angle in degrees to range `[0, 360)`.\n     *\n     * @param a - Angle in degrees.\n     * @returns Angle in degrees in range `[0, 360)`.\n     */\n    export function normalizeAngleDeg(a: number): number {\n        a = a % 360;\n        if (a < 0) {\n            a = a + 360;\n        }\n        return a;\n    }\n\n    /**\n     * Normalize latitude angle in degrees to range `[-180, 180]`.\n     *\n     * @param a - Latitude angle in degrees.\n     * @returns Latitude angle in degrees in range `[-180, 180]`.\n     */\n    export function normalizeLongitudeDeg(a: number): number {\n        a = normalizeAngleDeg(a);\n        if (a > 180) {\n            a = a - 360;\n        }\n        return a;\n    }\n\n    /**\n     * Return the minimal delta between angles `a` and `b` given in degrees.\n     *\n     * Equivalent to `a - b` in coordinate space with exception vector direction can be reversed\n     * that if `abs(a-b) > 180` because trip is shorter in 'other' direction.\n     *\n     * Useful when interpolating between `b` and `a` in angle space.\n     *\n     * @param a - Start angle in degrees.\n     * @param b - End angle in degrees.\n     * @returns Angle that that satisfies condition `a - b - d = 0` in angle space.\n     */\n    export function angleDistanceDeg(a: number, b: number): number {\n        a = normalizeAngleDeg(a);\n        b = normalizeAngleDeg(b);\n\n        const d = a - b;\n        if (d > 180) {\n            return d - 360;\n        } else if (d <= -180) {\n            return d + 360;\n        } else {\n            return d;\n        }\n    }\n\n    /**\n     * Interpolate linearly between two angles given in degrees.\n     *\n     * @param p0 - Angle from in degrees\n     * @param p1 - Angle to in degrees\n     * @param t - Interpolation factor (alpha), in range `0-1`.\n     */\n    export function interpolateAnglesDeg(p0: number, p1: number, t: number): number {\n        // hand crafted version,\n        // see stack for maybe better versions:\n        //    https://stackoverflow.com/questions/2708476/rotation-interpolation\n\n        const d = angleDistanceDeg(p1, p0);\n        const r = (p0 + d * t) % 360;\n        return r;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Frustum, Matrix4, Plane, Ray, Vector3 } from \"three\";\n\nimport { OrientedBox3Like } from \"./OrientedBox3Like\";\n\nfunction intersectsSlab(\n    rayDir: Vector3,\n    p: Vector3,\n    axis: Vector3,\n    extent: number,\n    t: { min: number; max: number }\n): boolean {\n    const epsilon = 1e-20;\n    const e = axis.dot(p);\n    const f = axis.dot(rayDir);\n    if (Math.abs(f) < epsilon) {\n        // ray parallel to near/far slab lines.\n        return Math.abs(e) <= extent;\n    }\n\n    // ray intersects near/far slab lines.\n    const finv = 1 / f;\n    const t1 = (e + extent) * finv;\n    const t2 = (e - extent) * finv;\n    if (t1 > t2) {\n        // t1 is far intersect, t2 is near.\n        if (t2 > t.min) {\n            t.min = t2;\n        }\n        if (t1 < t.max) {\n            t.max = t1;\n        }\n    } else {\n        // t1 is near intersect, t2 is far.\n        if (t1 > t.min) {\n            t.min = t1;\n        }\n        if (t2 < t.max) {\n            t.max = t2;\n        }\n    }\n    return t.min <= t.max && t.max >= 0;\n}\n\nconst tmpVec = new Vector3();\nconst tmpT = { min: -Infinity, max: Infinity };\n\nexport class OrientedBox3 implements OrientedBox3Like {\n    /**\n     * The position of the center of this `OrientedBox3`.\n     */\n    readonly position = new Vector3();\n\n    /**\n     * The x-axis of this `OrientedBox3`.\n     */\n    readonly xAxis = new Vector3(1, 0, 0);\n\n    /**\n     * The y-axis of this `OrientedBox3`.\n     */\n    readonly yAxis = new Vector3(0, 1, 0);\n\n    /**\n     * The z-axis of this `OrientedBox3`.\n     */\n    readonly zAxis = new Vector3(0, 0, 1);\n\n    /**\n     * The extents of this `OrientedBox3`.\n     */\n    readonly extents = new Vector3();\n\n    /**\n     * Creates a new `OrientedBox3`.\n     */\n    constructor();\n\n    /**\n     * Creates a new `OrientedBox3` with the given position, orientation and extents.\n     *\n     * @param position - The position of the center of the `OrientedBox3`.\n     * @param rotationMatrix - The rotation of the `OrientedBox3`.\n     * @param extents - The extents of the `OrientedBox3`.\n     */\n    constructor(position: Vector3, rotationMatrix: Matrix4, extents: Vector3);\n\n    /**\n     * Creates a new `OrientedBox3`.\n     *\n     * @hideconstructor\n     */\n    constructor(position?: Vector3, rotationMatrix?: Matrix4, extents?: Vector3) {\n        if (position !== undefined) {\n            this.position.copy(position);\n        }\n\n        if (rotationMatrix !== undefined) {\n            rotationMatrix.extractBasis(this.xAxis, this.yAxis, this.zAxis);\n        }\n\n        if (extents !== undefined) {\n            this.extents.copy(extents);\n        }\n    }\n\n    /**\n     * Create a copy of this [[OrientedBoundingBox]].\n     */\n    clone(): OrientedBox3 {\n        const newBox = new OrientedBox3();\n        newBox.copy(this);\n        return newBox;\n    }\n\n    /**\n     * Copies the values of `other` to this {@link OrientedBox3}.\n     * @param other - The other {@link OrientedBox3} to copy.\n     */\n    copy(other: OrientedBox3) {\n        this.position.copy(other.position);\n        this.xAxis.copy(other.xAxis);\n        this.yAxis.copy(other.yAxis);\n        this.zAxis.copy(other.zAxis);\n        this.extents.copy(other.extents);\n    }\n\n    /**\n     * Gets the center position of this {@link OrientedBox3}.\n     *\n     * @param center - The returned center position.\n     */\n    getCenter(center = new Vector3()): Vector3 {\n        return center.copy(this.position);\n    }\n\n    /**\n     * Gets the size of this {@link OrientedBox3}.\n     *\n     * @param size - The returned size.\n     */\n    getSize(size = new Vector3()): Vector3 {\n        return size.copy(this.extents).multiplyScalar(2);\n    }\n\n    /**\n     * Gets the orientation matrix of this `OrientedBox3`.\n     * @param matrix - The output orientation matrix.\n     */\n    getRotationMatrix(matrix: Matrix4 = new Matrix4()): Matrix4 {\n        return matrix.makeBasis(this.xAxis, this.yAxis, this.zAxis);\n    }\n\n    /**\n     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.\n     *\n     * @param frustumOrPlanes - Frustum or array of planes.\n     */\n    intersects(frustumOrPlanes: Plane[] | Frustum): boolean {\n        const planes: Plane[] = Array.isArray(frustumOrPlanes)\n            ? frustumOrPlanes\n            : frustumOrPlanes.planes;\n\n        for (const plane of planes) {\n            const r =\n                Math.abs(plane.normal.dot(this.xAxis) * this.extents.x) +\n                Math.abs(plane.normal.dot(this.yAxis) * this.extents.y) +\n                Math.abs(plane.normal.dot(this.zAxis) * this.extents.z);\n\n            const d = plane.distanceToPoint(this.position);\n\n            if (d + r < 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks intersection with the given ray.\n     *\n     * @param ray - The ray to test.\n     * @returns distance from ray origin to intersection point if it exist, undefined otherwise.\n     */\n    intersectsRay(ray: Ray): number | undefined {\n        // Slabs intersection algorithm.\n        tmpT.min = -Infinity;\n        tmpT.max = Infinity;\n        tmpVec.copy(this.position).sub(ray.origin);\n        if (!intersectsSlab(ray.direction, tmpVec, this.xAxis, this.extents.x, tmpT)) {\n            return undefined;\n        }\n        if (!intersectsSlab(ray.direction, tmpVec, this.yAxis, this.extents.y, tmpT)) {\n            return undefined;\n        }\n        if (!intersectsSlab(ray.direction, tmpVec, this.zAxis, this.extents.z, tmpT)) {\n            return undefined;\n        }\n\n        return tmpT.min > 0 ? tmpT.min : tmpT.max;\n    }\n\n    /**\n     * Returns true if this {@link OrientedBox3} contains the given point.\n     *\n     * @param point - A valid point.\n     */\n    contains(point: Vector3): boolean {\n        const dx = point.x - this.position.x;\n        const dy = point.y - this.position.y;\n        const dz = point.z - this.position.z;\n        const x = Math.abs(dx * this.xAxis.x + dy * this.xAxis.y + dz * this.xAxis.z);\n        const y = Math.abs(dx * this.yAxis.x + dy * this.yAxis.y + dz * this.yAxis.z);\n        const z = Math.abs(dx * this.zAxis.x + dy * this.zAxis.y + dz * this.zAxis.z);\n        if (x > this.extents.x || y > this.extents.y || z > this.extents.z) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the distance from this {@link OrientedBox3} and the given `point`.\n     *\n     * @param point - A point.\n     */\n    distanceToPoint(point: Vector3): number {\n        return Math.sqrt(this.distanceToPointSquared(point));\n    }\n\n    /**\n     * Returns the squared distance from this {@link OrientedBox3} and the given `point`.\n     *\n     * @param point - A point.\n     */\n    distanceToPointSquared(point: Vector3): number {\n        const d = new Vector3();\n        d.subVectors(point, this.position);\n\n        const lengths = [d.dot(this.xAxis), d.dot(this.yAxis), d.dot(this.zAxis)];\n\n        let result = 0;\n\n        for (let i = 0; i < 3; ++i) {\n            const length = lengths[i];\n            const extent = this.extents.getComponent(i);\n            if (length < -extent) {\n                const dd = extent + length;\n                result += dd * dd;\n            } else if (length > extent) {\n                const dd = length - extent;\n                result += dd * dd;\n            }\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TransformLike } from \"./TransformLike\";\nimport { Vector3Like } from \"./Vector3Like\";\n\n/**\n * The interface {@link OrientedBox3Like} is used to represent oriented bounding box.\n */\nexport interface OrientedBox3Like extends TransformLike {\n    /**\n     * The extents of this bounding box.\n     */\n    readonly extents: Vector3Like;\n}\n\n/**\n * Returns true if the given object implements the interface {@link OrientedBox3Like}.\n *\n * @param object - The object.\n */\nexport function isOrientedBox3Like(object: {}): object is OrientedBox3Like {\n    const obb = object as Partial<OrientedBox3Like>;\n    return (\n        obb.position !== undefined &&\n        obb.xAxis !== undefined &&\n        obb.yAxis !== undefined &&\n        obb.zAxis !== undefined &&\n        obb.extents !== undefined\n    );\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"./Vector3Like\";\n\n/**\n * The interface {@link TransformLike} is used to represent transforms with\n * only translation and rotation.\n */\nexport interface TransformLike {\n    /**\n     * The position of this transform.\n     */\n    readonly position: Vector3Like;\n\n    /**\n     * The x-axis of this transform.\n     */\n    readonly xAxis: Vector3Like;\n\n    /**\n     * The y-axis of this transform.\n     */\n    readonly yAxis: Vector3Like;\n\n    /**\n     * The z-axis of this transform.\n     */\n    readonly zAxis: Vector3Like;\n}\n\n/**\n * Returns true if the given object implements the interface {@link TransformLike}.\n *\n * @param object - The object.\n */\nexport function isTransformLike(object: {}): object is TransformLike {\n    const transform = object as Partial<TransformLike>;\n    return (\n        transform.position !== undefined &&\n        transform.xAxis !== undefined &&\n        transform.yAxis !== undefined &&\n        transform.zAxis !== undefined\n    );\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Interface representing a Vector2.\n */\nexport interface Vector2Like {\n    /**\n     * The X position.\n     */\n    x: number;\n\n    /**\n     * The Y position.\n     */\n    y: number;\n}\n\nexport function isVector2Like(v: any): v is Vector2Like {\n    return v && typeof v.x === \"number\" && typeof v.y === \"number\";\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Interface representing a Vector3.\n */\nexport interface Vector3Like {\n    /**\n     * The X position.\n     */\n    x: number;\n\n    /**\n     * The Y position.\n     */\n    y: number;\n\n    /**\n     * The Z position.\n     */\n    z: number;\n}\n\nexport function isVector3Like(v: any): v is Vector3Like {\n    return v && typeof v.x === \"number\" && typeof v.y === \"number\" && typeof v.z === \"number\";\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport class EarthConstants {\n    /** The equatorial circumference in meters. */\n    static EQUATORIAL_CIRCUMFERENCE: number = 40075016.6855784861531768177614;\n\n    /** The equatorial radius in meters. */\n    static EQUATORIAL_RADIUS: number = 6378137.0;\n\n    /** The lowest point on earth (Dead Sea) in meters. */\n    static MIN_ELEVATION: number = -433.0;\n\n    /** The highest point on earth (Mt. Everest) in meters. */\n    static MAX_ELEVATION: number = 8848.0;\n\n    /** The highest artificial structure (building) on earth, Burj Khalifa tower in Dubai */\n    static MAX_BUILDING_HEIGHT: number = 828;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nclass EquirectangularProjection extends Projection {\n    static geoToWorldScale: number = 1.0 / (2.0 * Math.PI);\n    static worldToGeoScale: number = (2.0 * Math.PI) / 1.0;\n\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    /** @override */\n    getScaleFactor(_worldPoint: Vector3Like): number {\n        return 1;\n    }\n\n    /** @override */\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        result.min.x = 0.0;\n        result.min.y = 0.0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale / 2;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        if (result === undefined) {\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n        result.x =\n            (THREE.MathUtils.degToRad(geoPoint.longitude) + Math.PI) *\n            EquirectangularProjection.geoToWorldScale *\n            this.unitScale;\n        result.y =\n            (THREE.MathUtils.degToRad(geoPoint.latitude) + Math.PI * 0.5) *\n            EquirectangularProjection.geoToWorldScale *\n            this.unitScale;\n        result.z = geoPoint.altitude ?? 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const geoPoint = GeoCoordinates.fromRadians(\n            (worldPoint.y * EquirectangularProjection.worldToGeoScale) / this.unitScale -\n                Math.PI * 0.5,\n            (worldPoint.x * EquirectangularProjection.worldToGeoScale) / this.unitScale - Math.PI,\n            worldPoint.z\n        );\n        return geoPoint;\n    }\n\n    /** @override */\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const worldCenter = this.projectPoint(\n            new GeoCoordinates(geoBox.center.latitude, geoBox.center.longitude, 0)\n        );\n        const { latitudeSpanInRadians, longitudeSpanInRadians, altitudeSpan } = geoBox;\n        const sizeX = longitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        const sizeY = latitudeSpanInRadians * EquirectangularProjection.geoToWorldScale;\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        if (isBox3Like(result)) {\n            result.min.x = worldCenter.x - sizeX * 0.5 * this.unitScale;\n            result.min.y = worldCenter.y - sizeY * 0.5 * this.unitScale;\n            result.max.x = worldCenter.x + sizeX * 0.5 * this.unitScale;\n            result.max.y = worldCenter.y + sizeY * 0.5 * this.unitScale;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            } else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = sizeX * 0.5 * this.unitScale;\n            result.extents.y = sizeY * 0.5 * this.unitScale;\n            result.extents.z = Math.max(Number.EPSILON, (altitudeSpan ?? 0) * 0.5);\n        }\n        return result;\n    }\n\n    /** @override */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\n\n/**\n * Equirectangular {@link Projection} used to convert geo coordinates to unit coordinates and vice\n * versa.\n */\nexport const normalizedEquirectangularProjection: Projection = new EquirectangularProjection(1);\n\n/**\n * Equirectangular {@link Projection} used to convert geo coordinates to world coordinates and vice\n * versa.\n */\nexport const equirectangularProjection: Projection = new EquirectangularProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nclass IdentityProjection extends Projection {\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    /** @override */\n    getScaleFactor(_worldPoint: Vector3Like): number {\n        return 1;\n    }\n\n    /** @override */\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        result.min.x = -Math.PI;\n        result.min.y = -Math.PI * 0.5;\n        result.min.z = minAltitude;\n        result.max.x = Math.PI;\n        result.max.y = Math.PI * 0.5;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n        result.x = THREE.MathUtils.degToRad(geoPoint.longitude);\n        result.y = THREE.MathUtils.degToRad(geoPoint.latitude);\n        result.z = geoPoint.altitude ?? 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const geoPoint = GeoCoordinates.fromRadians(worldPoint.y, worldPoint.x, worldPoint.z);\n        return geoPoint;\n    }\n\n    /** @override */\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        const min = this.projectPoint(\n            new GeoCoordinates(geoBox.south, geoBox.west, geoBox.minAltitude)\n        );\n        const max = this.projectPoint(\n            new GeoCoordinates(geoBox.north, geoBox.east, geoBox.maxAltitude)\n        );\n        if (isBox3Like(result)) {\n            result.min.x = min.x;\n            result.min.y = min.y;\n            result.min.z = min.z;\n            result.max.x = max.x;\n            result.max.y = max.y;\n            result.max.z = max.z;\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (min.x + max.x) * 0.5;\n            result.position.y = (min.y + max.y) * 0.5;\n            result.position.z = (min.z + max.z) * 0.5;\n            result.extents.x = (max.x - min.x) * 0.5;\n            result.extents.y = (max.y - min.y) * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (max.z - min.z) * 0.5);\n        }\n        return result;\n    }\n\n    /** @override */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        return GeoBox.fromCoordinates(minGeo, maxGeo);\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n}\n\n/**\n * Identity {@link Projection} used to convert geo coordinates to unit coordinates and vice versa.\n */\nexport const identityProjection: Projection = new IdentityProjection(1);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { TransformLike } from \"../math/TransformLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\nclass MercatorProjection extends Projection {\n    protected static clamp(val: number, min: number, max: number): number {\n        return Math.min(Math.max(min, val), max);\n    }\n\n    protected static latitudeClamp(latitude: number): number {\n        return MercatorProjection.clamp(\n            latitude,\n            -MercatorConstants.MAXIMUM_LATITUDE,\n            MercatorConstants.MAXIMUM_LATITUDE\n        );\n    }\n\n    private static latitudeProject(latitude: number): number {\n        return Math.log(Math.tan(Math.PI * 0.25 + latitude * 0.5)) / Math.PI;\n    }\n\n    private static latitudeClampProject(latitude: number): number {\n        return MercatorProjection.latitudeProject(MercatorProjection.latitudeClamp(latitude));\n    }\n\n    private static unprojectLatitude(y: number): number {\n        return 2.0 * Math.atan(Math.exp(Math.PI * y)) - Math.PI * 0.5;\n    }\n\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    /** @override */\n    getScaleFactor(worldPoint: Vector3Like): number {\n        return Math.cosh(2 * Math.PI * (worldPoint.y / this.unitScale - 0.5));\n    }\n\n    /** @override */\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPointLike: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        let geoPoint: GeoCoordinates;\n\n        if (geoPointLike instanceof GeoCoordinates) {\n            geoPoint = geoPointLike;\n        } else {\n            geoPoint = new GeoCoordinates(\n                geoPointLike.latitude,\n                geoPointLike.longitude,\n                geoPointLike.altitude\n            );\n        }\n\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        result.y =\n            (MercatorProjection.latitudeClampProject(geoPoint.latitudeInRadians) * 0.5 + 0.5) *\n            this.unitScale;\n        result.z = geoPoint.altitude ?? 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const geoPoint = GeoCoordinates.fromRadians(\n            MercatorProjection.unprojectLatitude((worldPoint.y / this.unitScale - 0.5) * 2.0),\n            (worldPoint.x / this.unitScale) * 2 * Math.PI - Math.PI,\n            worldPoint.z\n        );\n        return geoPoint;\n    }\n\n    /** @override */\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const worldCenter = this.projectPoint(geoBox.center);\n        const worldNorth =\n            (MercatorProjection.latitudeClampProject(geoBox.northEast.latitudeInRadians) * 0.5 +\n                0.5) *\n            this.unitScale;\n        const worldSouth =\n            (MercatorProjection.latitudeClampProject(geoBox.southWest.latitudeInRadians) * 0.5 +\n                0.5) *\n            this.unitScale;\n        const worldYCenter = (worldNorth + worldSouth) * 0.5;\n\n        worldCenter.y = worldYCenter;\n\n        const latitudeSpan = worldNorth - worldSouth;\n        const longitudeSpan = (geoBox.longitudeSpan / 360) * this.unitScale;\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        if (isBox3Like(result)) {\n            result.min.x = worldCenter.x - longitudeSpan * 0.5;\n            result.min.y = worldCenter.y - latitudeSpan * 0.5;\n            result.max.x = worldCenter.x + longitudeSpan * 0.5;\n            result.max.y = worldCenter.y + latitudeSpan * 0.5;\n            const altitudeSpan = geoBox.altitudeSpan;\n            if (altitudeSpan !== undefined) {\n                result.min.z = worldCenter.z - altitudeSpan * 0.5;\n                result.max.z = worldCenter.z + altitudeSpan * 0.5;\n            } else {\n                result.min.z = 0;\n                result.max.z = 0;\n            }\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = worldCenter.x;\n            result.position.y = worldCenter.y;\n            result.position.z = worldCenter.z;\n            result.extents.x = longitudeSpan * 0.5;\n            result.extents.y = latitudeSpan * 0.5;\n            result.extents.z = Math.max(Number.EPSILON, (geoBox.altitudeSpan ?? 0) * 0.5);\n        } else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n\n    /** @override */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = 1;\n        }\n        return normal;\n    }\n\n    /** @override */\n    reprojectPoint(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result?: Vector3Like\n    ): Vector3Like {\n        // this implementation of [[reprojectPoint]] supports both\n        // [[WebMercatorProjection]] and [[MercatorProjection]]. The only\n        // difference betweeen these two variants of WEB Mercator\n        // is in the orientation of the Y axis, so we just flip Y coordinates\n        // when reprojecting between them.\n        if (\n            sourceProjection !== this &&\n            (sourceProjection === webMercatorProjection || sourceProjection === mercatorProjection)\n        ) {\n            if (result === undefined) {\n                result = {} as Vector3Like;\n            }\n\n            result.x = worldPos.x;\n            result.y = this.unitScale - worldPos.y;\n            result.z = worldPos.z;\n\n            return result;\n        }\n\n        return super.reprojectPoint(sourceProjection, worldPos, result!);\n    }\n}\n\nclass WebMercatorProjection extends MercatorProjection {\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPointLike: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        let geoPoint: GeoCoordinates;\n\n        if (geoPointLike instanceof GeoCoordinates) {\n            geoPoint = geoPointLike;\n        } else {\n            geoPoint = new GeoCoordinates(\n                geoPointLike.latitude,\n                geoPointLike.longitude,\n                geoPointLike.altitude\n            );\n        }\n\n        /*\n         * The following tslint:disable is due to the fact that the [[WorldCoordinates]]\n         * might be a concrete class which is not available at runtime.\n         * Consider the following example:\n         *\n         *  const x: THREE.Vector3 = new THREE.Vector3(0,0,0);\n         *  const result = EquirectangularProjection.projectPoint<THREE.Vector3>(x);\n         *\n         * Note: type of `result` is Vector3Like and not as expected: THREE.Vector3!\n         */\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n\n        result.x = ((geoPoint.longitude + 180) / 360) * this.unitScale;\n        const sy = Math.sin(MercatorProjection.latitudeClamp(geoPoint.latitudeInRadians));\n        result.y = (0.5 - Math.log((1 + sy) / (1 - sy)) / (4 * Math.PI)) * this.unitScale;\n        result.z = geoPoint.altitude ?? 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const x = worldPoint.x / this.unitScale - 0.5;\n        const y = 0.5 - worldPoint.y / this.unitScale;\n\n        const longitude = 360 * x;\n        const latitude = 90 - (360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI;\n\n        return new GeoCoordinates(latitude, longitude, worldPoint.z);\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const r = super.projectBox(geoBox, result);\n        if (isBox3Like(r)) {\n            // Invert the y axis for web mercator, this means that max => min & min => max\n            const maxY = r.max.y;\n            r.max.y = this.unitScale - r.min.y;\n            r.min.y = this.unitScale - maxY;\n        } else if (isOrientedBox3Like(r)) {\n            MathUtils.newVector3(1, 0, 0, r.xAxis);\n            MathUtils.newVector3(0, -1, 0, r.yAxis);\n            MathUtils.newVector3(0, 0, -1, r.zAxis);\n            r.position.y = this.unitScale - r.position.y;\n        }\n        return r;\n    }\n\n    /** @override */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const minGeo = this.unprojectPoint(worldBox.min);\n        const maxGeo = this.unprojectPoint(worldBox.max);\n        const geoBox = new GeoBox(\n            new GeoCoordinates(maxGeo.latitude, minGeo.longitude, minGeo.altitude),\n            new GeoCoordinates(minGeo.latitude, maxGeo.longitude, maxGeo.altitude)\n        );\n        return geoBox;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n\n    /** @override */\n    localTangentSpace(\n        point: GeoCoordinatesLike | Vector3Like,\n        result: TransformLike\n    ): TransformLike {\n        if (isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n        } else {\n            MathUtils.copyVector3(point, result.position);\n        }\n        MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils.newVector3(0, -1, 0, result.yAxis);\n        MathUtils.newVector3(0, 0, -1, result.zAxis);\n        return result;\n    }\n}\n\nexport class MercatorConstants {\n    // Math.atan(Math.sinh(Math.PI))\n    static readonly MAXIMUM_LATITUDE: number = 1.4844222297453323;\n}\n\n/**\n * Mercator {@link Projection} used to convert geo coordinates to world coordinates and vice versa.\n */\nexport const mercatorProjection: Projection = new MercatorProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n\n/**\n * Web Mercator {@link Projection} used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexport const webMercatorProjection: Projection = new WebMercatorProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { TransformLike } from \"../math/TransformLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\n\n/**\n * The type of projection.\n */\nexport enum ProjectionType {\n    /**\n     * A type of [Projection] with zero curvature.\n     */\n    Planar,\n\n    /**\n     * A spherical [Projection].\n     */\n    Spherical\n}\n\n/**\n * `Projection` is used to convert positions from geo coordinates to world coordinates and vice\n * versa.\n */\nexport abstract class Projection {\n    /**\n     * The type of this [Projection].\n     */\n    abstract get type(): ProjectionType;\n\n    /**\n     * Constructs the Projection\n     *\n     * @param unitScale - How to transform the projected coordinates to world units.\n     */\n    constructor(readonly unitScale: number) {\n        //Prevent empty constructor error.\n    }\n\n    /**\n     * Returns the world extents in world coordinates.\n     *\n     * @param minElevation - The minimum elevation in meters.\n     * @param maxElevation - The maximum elevation in meters.\n     * @param result - The optional object that will be used to create the resulting bounding box.\n     */\n    abstract worldExtent<Bounds extends Box3Like>(\n        minElevation: number,\n        maxElevation: number,\n        result?: Bounds\n    ): Bounds;\n\n    /**\n     * Projects a point from geo coordinates (latitude, longitude, altitude) to world coordinates\n     * (x,y,z).\n     *\n     * Example:\n     * ```typescript\n     * const worldPos = new THREE.Vector3();\n     * projection.projectPoint(geoPos, worldPos);\n     * ```\n     *\n     * @param geoPoint - The position in geo coordinates.\n     * @param result - The optional object used to store the resulting world position, result must\n     * implement {@link Vector3Like}.\n     */\n    abstract projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates;\n\n    /**\n     * Gets the {@link TransformLike} of the local tangent space at the given point.\n     *\n     * @param point - The geo / world coordinates.\n     * @param result - The {@link TransformLike}.\n     */\n    localTangentSpace(\n        point: GeoCoordinatesLike | Vector3Like,\n        result: TransformLike\n    ): TransformLike {\n        if (isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n        } else {\n            MathUtils.copyVector3(point, result.position);\n        }\n        MathUtils.newVector3(1, 0, 0, result.xAxis);\n        MathUtils.newVector3(0, 1, 0, result.yAxis);\n        MathUtils.newVector3(0, 0, 1, result.zAxis);\n        return result;\n    }\n\n    /**\n     * Returns the geo coordinates (latitude, longitude, altitude) from the given world position\n     * (x,y,z).\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = projection.unprojectPoint(worldPos);\n     * console.log(geoPos.latitude, geoPos.longitude, geoPos.altitude);\n     * ```\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract unprojectPoint(worldPoint: Vector3Like): GeoCoordinates;\n\n    /**\n     * Returns the altitude at the given world position (x,y,z) in meters.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract unprojectAltitude(worldPoint: Vector3Like): number;\n\n    /**\n     * Projects bounds in geo coordinates to a bounding box in world coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const bounds = projection.projectBox(geoBox);\n     * console.log(bounds.min, bounds.max);\n     * ```\n     *\n     * @param geoBox - The bounding box in geo coordinates.\n     */\n    abstract projectBox(geoBox: GeoBox): Box3Like;\n\n    /**\n     * Projects bounds in geo coordinates to a bounding box in world coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const bounds = projection.projectBox(geoBox, new THREE.Box3());\n     * console.log(bounds.min, bounds.max);\n     * ```\n     *\n     * @param geoBox - The bounding box in geo coordinates.\n     * @param result - The resulting {@link OrientedBox3Like}.\n     */\n    abstract projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result: WorldBoundingBox\n    ): WorldBoundingBox;\n\n    /**\n     * Converts a bounding box in world coordinates to a bounding box in geo coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = projection.unprojectPoint(worldPos);\n     * console.log(geoPos.latitude, geoPos.longitude, geoPos.altitude);\n     * ```\n     *\n     * @param worldBox - The bounding box in world coordinates.\n     */\n    abstract unprojectBox(worldBox: Box3Like): GeoBox;\n\n    /**\n     * Returns the scaling factor that must be used to convert the units used by `worldPoint` to\n     * meters.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract getScaleFactor(worldPoint: Vector3Like): number;\n\n    /**\n     * Returns the surface normal at the given world position.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract surfaceNormal(worldPoint: Vector3Like): Vector3Like;\n\n    /**\n     * Returns the surface normal at the given world position.\n     *\n     * @param worldPoint - The position in world coordinates.\n     * @returns The resulting normal vector.\n     */\n    abstract surfaceNormal<Normal extends Vector3Like>(\n        worldPoint: Vector3Like,\n        result: Normal\n    ): Normal;\n\n    /**\n     * Returns the signed distance between the given coordinates and\n     * the closest point on the surface.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract groundDistance(worldPoint: Vector3Like): number;\n\n    /**\n     * Scales the given world coordinates to the surface.\n     *\n     * @param worldPoint - The position in world coordinates.\n     */\n    abstract scalePointToSurface(worldPoint: Vector3Like): Vector3Like;\n\n    /**\n     * Reproject a world position from the given source {@link Projection}.\n     *\n     * @param sourceProjection - The source projection.\n     * @param worldPos - A valid world position for the given source projection.\n     * @returns The world position reprojected using this {@link Projection}.\n     */\n    reprojectPoint(sourceProjection: Projection, worldPos: Vector3Like): Vector3Like;\n\n    /**\n     * Reproject a world position from the given source {@link Projection}.\n     *\n     * @param sourceProjection - The source projection.\n     * @param worldPos - A valid position in the world space defined by the source projection.\n     * @param result - The resulting position reprojected using this {@link Projection}.\n     */\n    reprojectPoint<WorldCoordinates extends Vector3Like>(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result: WorldCoordinates\n    ): WorldCoordinates;\n\n    /**\n     * Reproject a world position from the given source {@link Projection}.\n     * Implementations should be aware of worldPos and result may be one object\n     *\n     * @param sourceProjection - The source projection.\n     * @param worldPos - A valid position in the world space defined by the source projection.\n     * @param result - The resulting position reprojected using this {@link Projection}.\n     * @hidden\n     */\n    reprojectPoint(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result?: Vector3Like\n    ): Vector3Like {\n        if (sourceProjection === this) {\n            if (result === undefined) {\n                return { x: worldPos.x, y: worldPos.y, z: worldPos.z };\n            }\n            result.x = worldPos.x;\n            result.y = worldPos.y;\n            result.z = worldPos.z;\n            return result;\n        }\n        return this.projectPoint(sourceProjection.unprojectPoint(worldPos), result);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike, isGeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { TransformLike } from \"../math/TransformLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { mercatorProjection, webMercatorProjection } from \"./MercatorProjection\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\n/**\n * Transforms the given vector using the provided basis.\n */\nfunction apply(\n    xAxis: Vector3Like,\n    yAxis: Vector3Like,\n    zAxis: Vector3Like,\n    v: Vector3Like\n): Vector3Like {\n    const x = xAxis.x * v.x + yAxis.x * v.y + zAxis.x * v.z;\n    const y = xAxis.y * v.x + yAxis.y * v.y + zAxis.y * v.z;\n    const z = xAxis.z * v.x + yAxis.z * v.y + zAxis.z * v.z;\n    v.x = x;\n    v.y = y;\n    v.z = z;\n    return v;\n}\n\n/**\n * Returns the quadrants for the given longitude. The quadrant is defined as:\n *  - quadrant(+Math.PI * -1.0) = 0\n *  - quadrant(+Math.PI * -0.5) = 1\n *  - quadrant(+Math.PI *  0.0) = 2\n *  - quadrant(+Math.PI *  0.5) = 3\n *  - quadrant(+Math.PI *  1.0) = 4\n *\n * @param longitude - The longitude in radians.\n */\nfunction getLongitudeQuadrant(longitude: number) {\n    const oneOverPI = 1 / Math.PI;\n    const quadrantIndex = Math.floor(2 * (longitude * oneOverPI + 1));\n    return THREE.MathUtils.clamp(quadrantIndex, 0, 4);\n}\n\nfunction lengthOfVector3(worldPoint: Vector3Like): number {\n    const d = Math.sqrt(\n        worldPoint.x * worldPoint.x + worldPoint.y * worldPoint.y + worldPoint.z * worldPoint.z\n    );\n    return d;\n}\n\n/**\n * Creates a Box3 enclosing the geobox.\n *\n * @param geoBox - Ghe given geobox\n * @param worldBox - The resulting axis aligned bounding box.\n */\nfunction makeBox3<Bounds extends Box3Like>(\n    geoBox: GeoBox,\n    worldBox: Bounds,\n    unitScale: number\n): Bounds {\n    const halfEquatorialRadius = (unitScale + (geoBox.maxAltitude ?? 0)) * 0.5;\n\n    const minLongitude = THREE.MathUtils.degToRad(geoBox.west);\n    const maxLongitude = THREE.MathUtils.degToRad(geoBox.east);\n\n    const minLongitudeQuadrant = getLongitudeQuadrant(minLongitude);\n    const maxLongitudeQuadrant = getLongitudeQuadrant(maxLongitude);\n\n    let xMin = Math.cos(minLongitude);\n    let xMax = xMin;\n    let yMin = Math.sin(minLongitude);\n    let yMax = yMin;\n\n    for (\n        let quadrantIndex = minLongitudeQuadrant + 1;\n        quadrantIndex <= maxLongitudeQuadrant;\n        quadrantIndex++\n    ) {\n        const x = ((quadrantIndex + 1) & 1) * ((quadrantIndex & 2) - 1);\n        xMin = Math.min(x, xMin);\n        xMax = Math.max(x, xMax);\n\n        const y = (quadrantIndex & 1) * ((quadrantIndex & 2) - 1);\n        yMin = Math.min(y, yMin);\n        yMax = Math.max(y, yMax);\n    }\n\n    const cosMaxLongitude = Math.cos(maxLongitude);\n    xMin = Math.min(cosMaxLongitude, xMin);\n    xMax = Math.max(cosMaxLongitude, xMax);\n\n    const sinMaxLongitude = Math.sin(maxLongitude);\n    yMin = Math.min(sinMaxLongitude, yMin);\n    yMax = Math.max(sinMaxLongitude, yMax);\n\n    const xCenter = (xMax + xMin) * halfEquatorialRadius;\n    const xExtent = (xMax - xMin) * halfEquatorialRadius;\n\n    const yCenter = (yMax + yMin) * halfEquatorialRadius;\n    const yExtent = (yMax - yMin) * halfEquatorialRadius;\n\n    // Calculate Z boundaries.\n    const minLatitude = THREE.MathUtils.degToRad(geoBox.south);\n    const maxLatutide = THREE.MathUtils.degToRad(geoBox.north);\n\n    const zMax = Math.sin(maxLatutide);\n    const zMin = Math.sin(minLatitude);\n\n    const zCenter = (zMax + zMin) * halfEquatorialRadius;\n    const zExtent = (zMax - zMin) * halfEquatorialRadius;\n\n    worldBox.min.x = xCenter - xExtent;\n    worldBox.min.y = yCenter - yExtent;\n    worldBox.min.z = zCenter - zExtent;\n    worldBox.max.x = xCenter + xExtent;\n    worldBox.max.y = yCenter + yExtent;\n    worldBox.max.z = zCenter + zExtent;\n\n    return worldBox;\n}\n\n/**\n * Computes the spherical projection of the given geo coordinates.\n *\n * @param geoPoint - The geo coordinates.\n * @param worldpoint - The resulting world coordinates.\n */\nfunction project<WorldCoordinates extends Vector3Like>(\n    geoPoint: GeoCoordinatesLike,\n    worldpoint: WorldCoordinates,\n    unitScale: number\n): typeof worldpoint {\n    const radius = unitScale + (geoPoint.altitude ?? 0);\n    const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);\n    const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);\n    const cosLatitude = Math.cos(latitude);\n    worldpoint.x = radius * cosLatitude * Math.cos(longitude);\n    worldpoint.y = radius * cosLatitude * Math.sin(longitude);\n    worldpoint.z = radius * Math.sin(latitude);\n    return worldpoint;\n}\n\nclass SphereProjection extends Projection {\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Spherical;\n\n    /** @override */\n    worldExtent<Bounds extends Box3Like>(\n        _minElevation: number,\n        maxElevation: number,\n        result: Bounds = (new THREE.Box3() as Box3Like) as Bounds\n    ): Bounds {\n        const radius = this.unitScale + maxElevation;\n        result.min.x = -radius;\n        result.min.y = -radius;\n        result.min.z = -radius;\n        result.max.x = radius;\n        result.max.y = radius;\n        result.max.z = radius;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result: WorldCoordinates = MathUtils.newVector3(0, 0, 0) as WorldCoordinates\n    ): WorldCoordinates {\n        return project(geoPoint, result, this.unitScale);\n    }\n\n    /** @override */\n    unprojectPoint(point: Vector3Like): GeoCoordinates {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y;\n        const parallelRadius = Math.sqrt(parallelRadiusSq);\n        const v = point.z / parallelRadius;\n\n        if (isNaN(v)) {\n            return GeoCoordinates.fromRadians(0, 0, -this.unitScale);\n        }\n\n        const radius = Math.sqrt(parallelRadiusSq + point.z * point.z);\n\n        return GeoCoordinates.fromRadians(\n            Math.atan(v),\n            Math.atan2(point.y, point.x),\n            radius - this.unitScale\n        );\n    }\n\n    /** @override */\n    unprojectAltitude(point: Vector3Like): number {\n        const parallelRadiusSq = point.x * point.x + point.y * point.y + point.z * point.z;\n        return Math.sqrt(parallelRadiusSq) - EarthConstants.EQUATORIAL_RADIUS;\n    }\n\n    /** @override */\n    projectBox<Bounds extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result: Bounds = (new THREE.Box3() as Box3Like) as Bounds\n    ): Bounds {\n        if (isBox3Like(result)) {\n            return makeBox3(geoBox, result, this.unitScale);\n        } else if (isOrientedBox3Like(result)) {\n            if (geoBox.longitudeSpan >= 90) {\n                const bounds = makeBox3(geoBox, new THREE.Box3() as Box3Like, this.unitScale);\n                MathUtils.newVector3(1, 0, 0, result.xAxis);\n                MathUtils.newVector3(0, 1, 0, result.yAxis);\n                MathUtils.newVector3(0, 0, 1, result.zAxis);\n                result.position.x = (bounds.max.x + bounds.min.x) * 0.5;\n                result.position.y = (bounds.max.y + bounds.min.y) * 0.5;\n                result.position.z = (bounds.max.z + bounds.min.z) * 0.5;\n                result.extents.x = (bounds.max.x - bounds.min.x) * 0.5;\n                result.extents.y = (bounds.max.y - bounds.min.y) * 0.5;\n                result.extents.z = (bounds.max.z - bounds.min.z) * 0.5;\n                return result;\n            }\n\n            const { south, west, north, east, center: mid } = geoBox;\n            const midX = mid.longitude;\n            const midY = mid.latitude;\n            const cosSouth = Math.cos(THREE.MathUtils.degToRad(south));\n            const sinSouth = Math.sin(THREE.MathUtils.degToRad(south));\n            const cosWest = Math.cos(THREE.MathUtils.degToRad(west));\n            const sinWest = Math.sin(THREE.MathUtils.degToRad(west));\n            const cosNorth = Math.cos(THREE.MathUtils.degToRad(north));\n            const sinNorth = Math.sin(THREE.MathUtils.degToRad(north));\n            const cosEast = Math.cos(THREE.MathUtils.degToRad(east));\n            const sinEast = Math.sin(THREE.MathUtils.degToRad(east));\n            const cosMidX = Math.cos(THREE.MathUtils.degToRad(midX));\n            const sinMidX = Math.sin(THREE.MathUtils.degToRad(midX));\n            const cosMidY = Math.cos(THREE.MathUtils.degToRad(midY));\n            const sinMidY = Math.sin(THREE.MathUtils.degToRad(midY));\n\n            // Build the orientation of the OBB using the normal vector and its partial derivates.\n\n            // the sperical coordinates of the mid point of the geobox.\n            MathUtils.newVector3(cosMidX * cosMidY, sinMidX * cosMidY, sinMidY, result.zAxis);\n\n            // the partial derivates of the normal vector.\n            MathUtils.newVector3(-sinMidX, cosMidX, 0, result.xAxis);\n            MathUtils.newVector3(-cosMidX * sinMidY, -sinMidX * sinMidY, cosMidY, result.yAxis);\n\n            let width: number;\n            let minY: number;\n            let maxY: number;\n\n            if (south >= 0) {\n                // abs(dot(southWest - southEast, xAxis))\n                width = Math.abs(\n                    cosSouth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest))\n                );\n\n                // dot(south, yAxis)\n                minY = cosMidY * sinSouth - sinMidY * cosSouth;\n\n                // dot(northEast, zAxis)\n                maxY =\n                    cosMidY * sinNorth -\n                    sinMidY * cosNorth * (cosMidX * cosEast + sinMidX * sinEast);\n            } else {\n                if (north <= 0) {\n                    // abs(dot(northWest - northEast, xAxis))\n                    width = Math.abs(\n                        cosNorth * (cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest))\n                    );\n\n                    // dot(north, yAxis)\n                    maxY = cosMidY * sinNorth - sinMidY * cosNorth;\n                } else {\n                    // abs(dot(west - east, xAxis))\n                    width = Math.abs(cosMidX * (sinWest - sinEast) + sinMidX * (cosEast - cosWest));\n\n                    // dot(northEast, yAxis)\n                    maxY =\n                        cosMidY * sinNorth -\n                        sinMidY * cosNorth * (sinMidX * sinEast + cosMidX * cosEast);\n                }\n\n                // dot(southEast, yAxis)\n                minY =\n                    cosMidY * sinSouth -\n                    sinMidY * cosSouth * (cosMidX * cosEast + sinMidX * sinEast);\n            }\n\n            const rMax = (this.unitScale + (geoBox.maxAltitude ?? 0)) * 0.5;\n            const rMin = (this.unitScale + (geoBox.minAltitude ?? 0)) * 0.5;\n\n            // min(dot(southEast, zAxis), dot(northEast, zAxis))\n\n            const d = cosMidY * (cosMidX * cosEast + sinMidX * sinEast);\n\n            const minZ = Math.min(\n                cosNorth * d + sinNorth * sinMidY,\n                cosSouth * d + sinSouth * sinMidY\n            );\n\n            MathUtils.newVector3(\n                width * rMax,\n                (maxY - minY) * rMax,\n                rMax - minZ * rMin,\n                result.extents\n            );\n\n            MathUtils.newVector3(0, (minY + maxY) * rMax, rMax + rMax, result.position);\n\n            apply(result.xAxis, result.yAxis, result.zAxis, result.position);\n\n            result.position.x = result.position.x - result.zAxis.x * result.extents.z;\n            result.position.y = result.position.y - result.zAxis.y * result.extents.z;\n            result.position.z = result.position.z - result.zAxis.z * result.extents.z;\n\n            return result;\n        }\n\n        throw new Error(\"Invalid bounding box\");\n    }\n\n    /** @override */\n    unprojectBox(_worldBox: Box3Like): GeoBox {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /** @override */\n    getScaleFactor(_worldPoint: Vector3Like): number {\n        return 1;\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return lengthOfVector3(worldPoint) - this.unitScale;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        const scale = this.unitScale / (lengthOfVector3(worldPoint) || 1);\n        worldPoint.x *= scale;\n        worldPoint.y *= scale;\n        worldPoint.z *= scale;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: 0 };\n        }\n        const scale = 1 / (lengthOfVector3(worldPoint) || 1);\n        normal.x = worldPoint.x * scale;\n        normal.y = worldPoint.y * scale;\n        normal.z = worldPoint.z * scale;\n        return normal;\n    }\n\n    /** @override */\n    reprojectPoint(\n        sourceProjection: Projection,\n        worldPos: Vector3Like,\n        result?: Vector3Like\n    ): Vector3Like {\n        if (sourceProjection === mercatorProjection || sourceProjection === webMercatorProjection) {\n            const { x, y, z } = worldPos;\n            const r = this.unitScale;\n            const mx = x / r - Math.PI;\n            const my = y / r - Math.PI;\n            const w = Math.exp(my);\n            const d = w * w;\n            const gx = (2 * w) / (d + 1);\n            const gy = (d - 1) / (d + 1);\n            const scale = r + z;\n\n            if (result === undefined) {\n                result = {} as Vector3Like;\n            }\n\n            result.x = Math.cos(mx) * gx * scale;\n            result.y = Math.sin(mx) * gx * scale;\n            result.z = gy * scale;\n\n            if (sourceProjection === webMercatorProjection) {\n                result.z = -result.z;\n            }\n\n            return result;\n        }\n\n        return super.reprojectPoint(sourceProjection, worldPos, result!);\n    }\n\n    /** @override */\n    localTangentSpace(\n        point: GeoCoordinatesLike | Vector3Like,\n        result: TransformLike\n    ): TransformLike {\n        let geoPoint: GeoCoordinatesLike;\n        if (isGeoCoordinatesLike(point)) {\n            this.projectPoint(point, result.position);\n            geoPoint = point;\n        } else {\n            MathUtils.copyVector3(point, result.position);\n            geoPoint = this.unprojectPoint(point);\n        }\n\n        const latitude = THREE.MathUtils.degToRad(geoPoint.latitude);\n        const longitude = THREE.MathUtils.degToRad(geoPoint.longitude);\n\n        const cosLongitude = Math.cos(longitude);\n        const sinLongitude = Math.sin(longitude);\n        const cosLatitude = Math.cos(latitude);\n        const sinLatitude = Math.sin(latitude);\n\n        MathUtils.newVector3(\n            cosLongitude * cosLatitude,\n            sinLongitude * cosLatitude,\n            sinLatitude,\n            result.zAxis\n        );\n\n        MathUtils.newVector3(-sinLongitude, cosLongitude, 0, result.xAxis);\n\n        MathUtils.newVector3(\n            -cosLongitude * sinLatitude,\n            -sinLongitude * sinLatitude,\n            cosLatitude,\n            result.yAxis\n        );\n        return result;\n    }\n}\n\nexport const sphereProjection: Projection = new SphereProjection(EarthConstants.EQUATORIAL_RADIUS);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like, isBox3Like } from \"../math/Box3Like\";\nimport { MathUtils } from \"../math/MathUtils\";\nimport { isOrientedBox3Like, OrientedBox3Like } from \"../math/OrientedBox3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { EarthConstants } from \"./EarthConstants\";\nimport { Projection, ProjectionType } from \"./Projection\";\n\n/**\n *\n * https://en.wikipedia.org/wiki/Transverse_Mercator_projection\n * http://mathworld.wolfram.com/MercatorProjection.html\n *\n */\nclass TransverseMercatorProjection extends Projection {\n    /**\n     * Like in regular Mercator projection, there are two points on sphere\n     * with radius about 5 degrees, that is out of projected space.\n     *\n     *\n     * in regular Mercator these points are:\n     *     (90, any), (-90, any)\n     *\n     * and in transverse Mercator:\n     *     (0, 90), (0, -90)\n     *\n     * So, in transverse we need to compute distnce to poles, and clamp if\n     * radius is exceeded\n     */\n    static clampGeoPoint(geoPoint: GeoCoordinatesLike, _unitScale: number) {\n        const lat = geoPoint.latitude;\n        const lon = geoPoint.longitude;\n\n        const r = TransverseMercatorUtils.POLE_RADIUS;\n        const rsq = TransverseMercatorUtils.POLE_RADIUS_SQ;\n\n        const nearestQuarter = Math.round(lon / 90);\n        const deltaLon = nearestQuarter * 90 - lon;\n        if (nearestQuarter % 2 === 0 || Math.abs(deltaLon) > r) {\n            return geoPoint;\n        }\n\n        const deltaLat = lat - 0;\n        const distanceToPoleSq = deltaLon * deltaLon + deltaLat * deltaLat;\n        if (distanceToPoleSq < rsq) {\n            const distanceToPole = Math.sqrt(distanceToPoleSq);\n            const scale = (r - distanceToPole) / distanceToPole;\n            // const quarter = ((nearestQuarter % 4) + 4) % 4;\n            // const dir = quarter === 1 ? -1 : quarter === 3 ? 1 : 0;\n            const dir = 1;\n            const offsetLon = deltaLon === 0 && deltaLat === 0 ? r * dir : deltaLon;\n            return new GeoCoordinates(lat + deltaLat * scale, lon + offsetLon * scale);\n        }\n\n        return geoPoint;\n    }\n\n    /** @override */\n    readonly type: ProjectionType = ProjectionType.Planar;\n\n    private readonly m_phi0: number = 0;\n    private readonly m_lambda0: number = 0;\n\n    constructor(readonly unitScale: number) {\n        super(unitScale);\n    }\n\n    /** @override */\n    getScaleFactor(worldPoint: Vector3Like): number {\n        return Math.cosh((worldPoint.x / this.unitScale - 0.5) * 2 * Math.PI);\n    }\n\n    /** @override */\n    worldExtent<WorldBoundingBox extends Box3Like>(\n        minAltitude: number,\n        maxAltitude: number,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        result.min.x = 0;\n        result.min.y = 0;\n        result.min.z = minAltitude;\n        result.max.x = this.unitScale;\n        result.max.y = this.unitScale;\n        result.max.z = maxAltitude;\n        return result;\n    }\n\n    /** @override */\n    projectPoint<WorldCoordinates extends Vector3Like>(\n        geoPoint: GeoCoordinatesLike,\n        result?: WorldCoordinates\n    ): WorldCoordinates {\n        if (!result) {\n            result = { x: 0, y: 0, z: 0 } as WorldCoordinates;\n        }\n\n        const clamped = TransverseMercatorProjection.clampGeoPoint(geoPoint, this.unitScale);\n        const normalLon = clamped.longitude / 360 + 0.5;\n        const offset = normalLon === 1 ? 0 : Math.floor(normalLon);\n        const phi = THREE.MathUtils.degToRad(clamped.latitude);\n        const lambda = THREE.MathUtils.degToRad(clamped.longitude - offset * 360) - this.m_lambda0;\n\n        const B = Math.cos(phi) * Math.sin(lambda);\n        // result.x = 1/2 * Math.log((1 + B) / (1 - B));\n        result.x = Math.atanh(B);\n        result.y = Math.atan2(Math.tan(phi), Math.cos(lambda)) - this.m_phi0;\n\n        const outScale = 0.5 / Math.PI;\n        result.x =\n            this.unitScale * (THREE.MathUtils.clamp(result.x * outScale + 0.5, 0, 1) + offset);\n        result.y = this.unitScale * THREE.MathUtils.clamp(result.y * outScale + 0.5, 0, 1);\n\n        result.z = geoPoint.altitude ?? 0;\n        return result;\n    }\n\n    /** @override */\n    unprojectPoint(worldPoint: Vector3Like): GeoCoordinates {\n        const tau = Math.PI * 2;\n        const nx = worldPoint.x / this.unitScale;\n        const ny = worldPoint.y / this.unitScale;\n        const offset = nx === 1 ? 0 : Math.floor(nx);\n        const x = tau * (nx - 0.5 - offset);\n        const y = tau * (ny - 0.5);\n        const z = worldPoint.z || 0;\n\n        const D = y + this.m_phi0;\n\n        const phi = Math.asin(Math.sin(D) / Math.cosh(x));\n        const lambda = this.m_lambda0 + Math.atan2(Math.sinh(x), Math.cos(D)) + offset * tau;\n\n        const geoPoint = GeoCoordinates.fromRadians(phi, lambda, z);\n        return geoPoint;\n    }\n\n    /** @override */\n    projectBox<WorldBoundingBox extends Box3Like | OrientedBox3Like>(\n        geoBox: GeoBox,\n        result?: WorldBoundingBox\n    ): WorldBoundingBox {\n        const { north, south, east, west } = geoBox;\n\n        const pointsToCheck = [\n            geoBox.center,\n            geoBox.northEast,\n            geoBox.southWest,\n            new GeoCoordinates(south, east),\n            new GeoCoordinates(north, west)\n        ];\n\n        const E = TransverseMercatorUtils.POLE_EDGE_DEG;\n\n        const containsWestCut = west < -90 && east > -90;\n        const containsEastCut = west < 90 && east > 90;\n        const containsCenterX = west < 0 && east > 0;\n        const containsCenterY = west < E && east > -E && north > 0 && south < 0;\n\n        if (containsWestCut) {\n            pointsToCheck.push(new GeoCoordinates(north, -90));\n            pointsToCheck.push(new GeoCoordinates(south, -90));\n        }\n\n        if (containsEastCut) {\n            pointsToCheck.push(new GeoCoordinates(north, 90));\n            pointsToCheck.push(new GeoCoordinates(south, 90));\n        }\n\n        if (containsCenterX) {\n            pointsToCheck.push(new GeoCoordinates(north, 0));\n            pointsToCheck.push(new GeoCoordinates(south, 0));\n        }\n\n        if (containsCenterY) {\n            pointsToCheck.push(new GeoCoordinates(0, west));\n            pointsToCheck.push(new GeoCoordinates(0, east));\n        }\n\n        TransverseMercatorUtils.alignLatitude(pointsToCheck, pointsToCheck[0]);\n\n        const projected = pointsToCheck.map(p => this.projectPoint(p));\n        const vx = projected.map(p => p.x);\n        const vy = projected.map(p => p.y);\n        const vz = projected.map(p => p.z);\n\n        const minX = Math.min(...vx);\n        const minY = Math.min(...vy);\n        const minZ = Math.min(...vz);\n        const maxX = Math.max(...vx);\n        const maxY = Math.max(...vy);\n        const maxZ = Math.max(...vz);\n\n        if (!result) {\n            result = (new THREE.Box3() as Box3Like) as WorldBoundingBox;\n        }\n        if (isBox3Like(result)) {\n            result.min.x = minX;\n            result.min.y = minY;\n            result.min.z = minZ;\n            result.max.x = maxX;\n            result.max.y = maxY;\n            result.max.z = maxZ;\n        } else if (isOrientedBox3Like(result)) {\n            MathUtils.newVector3(1, 0, 0, result.xAxis);\n            MathUtils.newVector3(0, 1, 0, result.yAxis);\n            MathUtils.newVector3(0, 0, 1, result.zAxis);\n            result.position.x = (minX + maxX) / 2;\n            result.position.y = (minY + maxY) / 2;\n            result.position.z = (minZ + maxZ) / 2;\n            result.extents.x = (maxX - minX) / 2;\n            result.extents.y = (maxY - minY) / 2;\n            result.extents.z = (maxZ - minZ) / 2;\n        } else {\n            throw new Error(\"invalid bounding box\");\n        }\n        return result;\n    }\n\n    /**\n     * There are 8 sub-regions on entire projection space\n     * where both longitude and latitude preserve direction.\n     * If bounding box hits more than one region, it should be splitted\n     * into sub-boxes by regions, (un)projected and then united again.\n     *\n     *\n     * directions in form [latitude / longitude]:\n     *    1 |\n     *       dr / dl | dl / ul \n     * 0.75 ----------|----------\n     *       ur / dr | ul / ur \n     * 0.5  ----------|----------\n     *       ul / ur | ur / dr \n     * 0.25 ----------|----------\n     *       dl / ul | dr / dl \n     *      |\n     *     0         0.5        1\n     *     @override\n     */\n    unprojectBox(worldBox: Box3Like): GeoBox {\n        const s = this.unitScale;\n\n        const min = worldBox.min;\n        const max = worldBox.max;\n        const pointsToCheck = [\n            { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2, z: 0 },\n            min,\n            max,\n            { x: min.x, y: max.y, z: 0 },\n            { x: max.x, y: min.y, z: 0 }\n        ];\n\n        const center = 0.5 * s;\n        const lowerQ = 0.25 * s;\n        const upperQ = 0.75 * s;\n\n        const containsCenterX = min.x < center && max.x > center;\n        const containsCenterY = min.y < center && max.y > center;\n        const containsLowerQY = min.y < lowerQ && max.y > lowerQ;\n        const containsUpperQY = min.y < upperQ && max.y > upperQ;\n\n        if (containsCenterY) {\n            pointsToCheck.push({ x: min.x, y: center, z: 0 });\n            pointsToCheck.push({ x: max.x, y: center, z: 0 });\n\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: center, z: 0 });\n            }\n        }\n        if (containsLowerQY) {\n            pointsToCheck.push({ x: min.x, y: lowerQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: lowerQ, z: 0 });\n\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: lowerQ, z: 0 });\n            }\n        }\n        if (containsUpperQY) {\n            pointsToCheck.push({ x: min.x, y: upperQ, z: 0 });\n            pointsToCheck.push({ x: max.x, y: upperQ, z: 0 });\n\n            if (containsCenterX) {\n                pointsToCheck.push({ x: center, y: upperQ, z: 0 });\n            }\n        }\n\n        const geoPoints = pointsToCheck.map(p => this.unprojectPoint(p));\n        TransverseMercatorUtils.alignLongitude(geoPoints, geoPoints[0]);\n\n        const latitudes = geoPoints.map(g => g.latitude);\n        const longitudes = geoPoints.filter(g => Math.abs(g.latitude) < 90).map(g => g.longitude);\n        const altitudes = geoPoints.map(g => g.altitude ?? 0);\n\n        const minGeo = new GeoCoordinates(\n            Math.min(...latitudes),\n            Math.min(...longitudes),\n            Math.min(...altitudes)\n        );\n\n        const maxGeo = new GeoCoordinates(\n            Math.max(...latitudes),\n            Math.max(...longitudes),\n            Math.max(...altitudes)\n        );\n\n        const geoBox = GeoBox.fromCoordinates(minGeo, maxGeo);\n        return geoBox;\n    }\n\n    /** @override */\n    unprojectAltitude(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    groundDistance(worldPoint: Vector3Like): number {\n        return worldPoint.z;\n    }\n\n    /** @override */\n    scalePointToSurface(worldPoint: Vector3Like): Vector3Like {\n        worldPoint.z = 0;\n        return worldPoint;\n    }\n\n    /** @override */\n    surfaceNormal(_worldPoint: Vector3Like, normal?: Vector3Like) {\n        if (normal === undefined) {\n            normal = { x: 0, y: 0, z: -1 };\n        } else {\n            normal.x = 0;\n            normal.y = 0;\n            normal.z = -1;\n        }\n        return normal;\n    }\n}\n\nexport class TransverseMercatorUtils {\n    static POLE_EDGE: number = 1.4844222297453323;\n    static POLE_EDGE_DEG: number = THREE.MathUtils.radToDeg(TransverseMercatorUtils.POLE_EDGE);\n    static POLE_RADIUS: number = 90 - TransverseMercatorUtils.POLE_EDGE_DEG;\n    static POLE_RADIUS_SQ: number = Math.pow(TransverseMercatorUtils.POLE_RADIUS, 2);\n\n    /**\n     * There are two regions on projected space that have same geo coordinates,\n     * it's the entire lines   { x: [0..1], y: 0 } and { x: [0..1], y: 1 }\n     * they both have geo coordinates of   (0, [-90..+90])\n     * and should be aligned somehow to fall into first or second region\n     * to make proper bounding boxes, tile bounds, etc.\n     */\n    static alignLatitude(points: GeoCoordinatesLike[], referencePoint: GeoCoordinatesLike): void {\n        const EPSILON = 1e-9;\n\n        for (const point of points) {\n            if (point.latitude === 0) {\n                point.latitude = referencePoint.latitude * EPSILON;\n            }\n        }\n    }\n\n    /**\n     * There are two regions on projected plane,\n     * { x: 0.5, y: [0..0.25] }    and    { x: 0.5, y: [0.75..1] }\n     * that represent longitude edge where -180 and +180 met.\n     * Points falling in this regions should be aligned to get proper boxes etc.\n     */\n    static alignLongitude(points: GeoCoordinatesLike[], referencePoint: GeoCoordinatesLike): void {\n        const bad = referencePoint.longitude < 0 ? 180 : -180;\n        const good = referencePoint.longitude < 0 ? -180 : 180;\n\n        for (const point of points) {\n            if (point.longitude === bad) {\n                point.longitude = good;\n            }\n        }\n    }\n}\n\n/**\n * Transverse Mercator {@link Projection} used to convert geo coordinates to world coordinates\n * and vice versa.\n */\nexport const transverseMercatorProjection: Projection = new TransverseMercatorProjection(\n    EarthConstants.EQUATORIAL_CIRCUMFERENCE\n);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { Box3Like } from \"../math/Box3Like\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { Projection } from \"../projection/Projection\";\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\nimport { TileKey } from \"./TileKey\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * `FlatTileBoundingBoxGenerator` generates bounding boxes in world and geo coordinates for a given\n * TilingScheme.\n */\nexport class FlatTileBoundingBoxGenerator {\n    private readonly m_tilingScheme: TilingScheme;\n    private readonly m_worldDimensions: Vector3Like;\n    private readonly m_worldBox: Box3Like;\n    /**\n     * Creates a new `FlatTileBoundingBoxGenerator` that can generate bounding boxes for the given\n     * TilingScheme.\n     *\n     * @param tilingScheme - The {@link TilingScheme} used to compute bounding boxes.\n     * @param minElevation - The minimum elevation in meters.\n     * @param maxElevation - The maximum elevation in meters.\n     */\n    constructor(\n        readonly tilingScheme: TilingScheme,\n        readonly minElevation: number = 0,\n        readonly maxElevation: number = 0\n    ) {\n        this.m_tilingScheme = tilingScheme;\n        this.m_worldBox = tilingScheme.projection.worldExtent(minElevation, maxElevation);\n        const { min, max } = this.m_worldBox;\n        this.m_worldDimensions = { x: max.x - min.x, y: max.y - min.y, z: max.z - min.z };\n    }\n\n    /**\n     * Returns the {@link Projection} of the {@link TilingScheme}.\n     */\n    get projection(): Projection {\n        return this.m_tilingScheme.projection;\n    }\n\n    /**\n     * Returns the {@link SubdivisionScheme} of the {@link TilingScheme}.\n     */\n    get subdivisionScheme(): SubdivisionScheme {\n        return this.m_tilingScheme.subdivisionScheme;\n    }\n\n    /**\n     * Returns the bounding box in world coordinates of the given {@link TileKey}.\n     *\n     * Example:\n     * ```typescript\n     * const worldBounds = new THREE.Box3();\n     * generator.getWorldBox(geoBox, worldBounds);\n     * console.log(worldBounds.getCenter());\n     * ```\n     *\n     * @param tileKey - The TileKey.\n     * @param result - The optional object used to store the resulting bounding box in world\n     * coordinates.\n     */\n    getWorldBox(tileKey: TileKey, result?: Box3Like): Box3Like {\n        const level = tileKey.level;\n        const levelDimensionX = this.subdivisionScheme.getLevelDimensionX(level);\n        const levelDimensionY = this.subdivisionScheme.getLevelDimensionY(level);\n        const sizeX = this.m_worldDimensions.x / levelDimensionX;\n        const sizeY = this.m_worldDimensions.y / levelDimensionY;\n        const originX = this.m_worldBox.min.x + sizeX * tileKey.column;\n        const originY = this.m_worldBox.min.y + sizeY * tileKey.row;\n\n        if (!result) {\n            result = new THREE.Box3();\n        }\n\n        result.min.x = originX;\n        result.min.y = originY;\n        result.min.z = this.m_worldBox.min.z;\n        result.max.x = originX + sizeX;\n        result.max.y = originY + sizeY;\n        result.max.z = this.m_worldBox.max.z;\n        return result;\n    }\n\n    /**\n     * Returns the bounding box in geo coordinates for the given {@link TileKey}.\n     *\n     * Example:\n     * ```typescript\n     * const geoBox = generator.getGeoBox(worldBounds);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tileKey - The {@link TileKey}.\n     */\n    getGeoBox(tileKey: TileKey): GeoBox {\n        const worldBox = this.getWorldBox(tileKey);\n        return this.projection.unprojectBox(worldBox);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\n\nclass HalfQuadTreeSubdivisionScheme implements SubdivisionScheme {\n    getSubdivisionX(): number {\n        return 2;\n    }\n\n    getSubdivisionY(level: number): number {\n        return level === 0 ? 1 : 2;\n    }\n\n    getLevelDimensionX(level: number): number {\n        return 1 << level;\n    }\n\n    getLevelDimensionY(level: number): number {\n        return level !== 0 ? 1 << (level - 1) : 1;\n    }\n}\n\n/**\n * A {@link SubdivisionScheme} used to represent half quadtrees.\n * This particular subdivision scheme is\n * used by the HERE tiling scheme.\n */\nexport const halfQuadTreeSubdivisionScheme: SubdivisionScheme = new HalfQuadTreeSubdivisionScheme();\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { normalizedEquirectangularProjection } from \"../projection/EquirectangularProjection\";\nimport { halfQuadTreeSubdivisionScheme } from \"./HalfQuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * {@link TilingScheme} used by most of the data published by HERE.\n *\n * The `hereTilingScheme` features a half quadtree subdivision scheme and an equirectangular\n * projection.\n */\nexport const hereTilingScheme = new TilingScheme(\n    halfQuadTreeSubdivisionScheme,\n    normalizedEquirectangularProjection\n);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { mercatorProjection } from \"../projection/MercatorProjection\";\nimport { quadTreeSubdivisionScheme } from \"./QuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * The {@link TilingScheme} used by the HERE web tiles.\n *\n * The `mercatorTilingScheme` features a quadtree subdivision scheme and a Mercator projection.\n */\nexport const mercatorTilingScheme = new TilingScheme(quadTreeSubdivisionScheme, mercatorProjection);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { transverseMercatorProjection } from \"../projection/TransverseMercatorProjection\";\nimport { quadTreeSubdivisionScheme } from \"./QuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * A {@link TilingScheme} featuring quadtree subdivision scheme and\n * transverse Mercator projection.\n */\nexport const polarTilingScheme = new TilingScheme(\n    quadTreeSubdivisionScheme,\n    transverseMercatorProjection\n);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { TileKey } from \"./TileKey\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * A class used to represent a quadtree.\n */\nexport class QuadTree {\n    /**\n     * Constructs a new `QuadTree` for the given {@link TilingScheme}.\n     *\n     * Example:\n     * ```typescript\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * const geoBox = quadTree.getGeoBox(tileKey);\n     * console.log(geoBox.center);\n     * ```\n     *\n     * @param tilingScheme - The TilingScheme used by this `QuadTree`.\n     */\n    constructor(readonly tilingScheme: TilingScheme) {}\n\n    /**\n     * Visits this `QuadTree` and invoke the given accept method\n     * with the current {@link TileKey} and\n     * its bounding box in geo coordinates.\n     *\n     * Example:\n     * ```typescript\n     * const geoPos = new GeoCoordinates(latitude, longitude);\n     * const quadTree = new QuadTree(hereTilingScheme);\n     * quadTree.visit((tileKey, geoBox) => {\n     *     if (geoBox.contains(geoPos)) {\n     *         console.log(\"tile\", tileKey, \"contains\", geoPos);\n     *         return tileKey.level < 14; // stop visiting the quadtree if the level is >= 14.\n     *     }\n     *     return false; // stop visiting the quadtree,\n     *                   // the tile's geoBox doesn't contain the given coordinates.\n     * });\n     * ```\n     *\n     * @param accept - A function that takes a {@link TileKey}\n     * and its bounding box in geo coordinates\n     * and returns `true` if the visit of the `QuadTree`\n     * should continue; otherwise `false`.\n     */\n    visit(accept: (tileKey: TileKey, geoBox: GeoBox) => boolean) {\n        this.visitTileKey(TileKey.fromRowColumnLevel(0, 0, 0), accept);\n    }\n\n    /**\n     * Visits the subtree starting from the given tile.\n     *\n     * @param tileKey - The root of the subtree that should be visited.\n     * @param accept - A function that takes a {@link TileKey}\n     *                 and its bounding box in geo coordinates\n     *                 and returns `true` if the visit of the\n     *                 `QuadTree` should continue; otherwise `false`.\n     */\n    visitTileKey(tileKey: TileKey, accept: (tileKey: TileKey, geoBox: GeoBox) => boolean) {\n        const geoBox = this.tilingScheme.getGeoBox(tileKey);\n\n        if (!accept(tileKey, geoBox)) {\n            return;\n        }\n\n        for (const subTileKey of this.tilingScheme.getSubTileKeys(tileKey)) {\n            this.visitTileKey(subTileKey, accept);\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\n\nclass QuadTreeSubdivisionScheme implements SubdivisionScheme {\n    getSubdivisionX(): number {\n        return 2;\n    }\n\n    getSubdivisionY(): number {\n        return 2;\n    }\n\n    getLevelDimensionX(level: number): number {\n        return 1 << level;\n    }\n\n    getLevelDimensionY(level: number): number {\n        return 1 << level;\n    }\n}\n\n/**\n * {@link SubdivisionScheme} representing a quadtree.\n */\nexport const quadTreeSubdivisionScheme: SubdivisionScheme = new QuadTreeSubdivisionScheme();\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"./TileKey\";\n\nexport class SubTiles implements Iterable<TileKey> {\n    constructor(public tileKey: TileKey, public sizeX: number, public sizeY: number) {}\n\n    [Symbol.iterator](): Iterator<TileKey> {\n        return this.sizeX === 2 && this.sizeY === 2\n            ? SubTiles.ZCurveIterator(this.tileKey)\n            : SubTiles.RowColumnIterator(this.tileKey, this.sizeX, this.sizeY);\n    }\n}\n\nexport namespace SubTiles {\n    export function* RowColumnIterator(\n        parentKey: TileKey,\n        sizeX: number,\n        sizeY: number\n    ): Iterator<TileKey> {\n        for (let y = 0; y < sizeY; y++) {\n            for (let x = 0; x < sizeX; x++) {\n                yield TileKey.fromRowColumnLevel(\n                    parentKey.row * sizeY + y,\n                    parentKey.column * sizeX + x,\n                    parentKey.level + 1\n                );\n            }\n        }\n    }\n\n    export function* ZCurveIterator(parentKey: TileKey): Iterator<TileKey> {\n        for (let i = 0; i < 4; i++) {\n            yield TileKey.fromRowColumnLevel(\n                (parentKey.row << 1) | (i >> 1),\n                (parentKey.column << 1) | (i & 1),\n                parentKey.level + 1\n            );\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** @hidden */\nconst powerOfTwo = [\n    0x1,\n    0x2,\n    0x4,\n    0x8,\n    0x10,\n    0x20,\n    0x40,\n    0x80,\n    0x100,\n    0x200,\n    0x400,\n    0x800,\n    0x1000,\n    0x2000,\n    0x4000,\n    0x8000,\n    0x10000,\n    0x20000,\n    0x40000,\n    0x80000,\n    0x100000,\n    0x200000,\n    0x400000,\n    0x800000,\n    0x1000000,\n    0x2000000,\n    0x4000000,\n    0x8000000,\n    0x10000000,\n    0x20000000,\n    0x40000000,\n    0x80000000,\n    0x100000000,\n    0x200000000,\n    0x400000000,\n    0x800000000,\n    0x1000000000,\n    0x2000000000,\n    0x4000000000,\n    0x8000000000,\n    0x10000000000,\n    0x20000000000,\n    0x40000000000,\n    0x80000000000,\n    0x100000000000,\n    0x200000000000,\n    0x400000000000,\n    0x800000000000,\n    0x1000000000000,\n    0x2000000000000,\n    0x4000000000000,\n    0x8000000000000,\n    0x10000000000000 // Math.pow(2, 52), highest bit that can be set correctly.\n];\n\n/**\n * The `TileKey` instances are used to address a tile in a quadtree.\n *\n * A tile key is defined by a row, a column, and a level. The tree has a root at level 0, with one\n * single tile. On every level, each tile is divided into four children (therefore the name\n * quadtree).\n *\n * Within each [[level]], any particular tile is addressed with [[row]] and [[column]]. The number\n * of rows and columns in each level is 2 to the power of the level. This means: On level 0, only\n * one tile exists, [[columnsAtLevel]]() and [[rowsAtLevel]]() are both 1. On level 1, 4 tiles\n * exist, in 2 rows and 2 columns. On level 2 we have 16 tiles, in 4 rows and 4 columns. And so on.\n *\n * A tile key is usually created using [[fromRowColumnLevel]]() method.\n *\n * `TileKey` instances are immutable, all members return new instances of `TileKey` and do not\n * modify the original object.\n *\n * Utility functions like [[parent]](), [[changedLevelBy]](), and [[changedLevelTo]]() allow for\n * easy vertical navigation of the tree. The number of available rows and columns in the tile's\n * level is given with [[rowCount]]() and [[columnCount]]().\n *\n * Tile keys can be created from and converted into various alternative formats:\n *\n *  - [[toQuadKey]]() / [[fromQuadKey]]() - string representation 4-based\n *  - [[toHereTile]]() / [[fromHereTile]]() - string representation 10-based\n *  - [[mortonCode]]() / [[fromMortonCode]]() - number representation\n *\n * Note - as JavaScript's number type can hold 53 bits in its mantissa, only levels up to 26 can be\n * represented in the number representation returned by [[mortonCode]]().\n */\nexport class TileKey {\n    /**\n     * Creates a tile key.\n     *\n     * @param row - The requested row. Must be less than 2 to the power of level.\n     * @param column - The requested column. Must be less than 2 to the power of level.\n     * @param level - The requested level.\n     */\n    static fromRowColumnLevel(row: number, column: number, level: number): TileKey {\n        return new TileKey(row, column, level);\n    }\n\n    /**\n     * Creates a tile key from a quad string.\n     *\n     * The quad string can be created with [[toQuadKey]].\n     *\n     * @param quadkey - The quadkey to convert.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromQuadKey(quadkey: string): TileKey {\n        const level = quadkey.length;\n        let row = 0;\n        let column = 0;\n        for (let i = 0; i < quadkey.length; ++i) {\n            const mask = 1 << i;\n            const d = parseInt(quadkey.charAt(level - i - 1), 10);\n            if (d & 0x1) {\n                column |= mask;\n            }\n            if (d & 0x2) {\n                row |= mask;\n            }\n        }\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n\n    /**\n     * Creates a tile key from a numeric Morton code representation.\n     *\n     * You can convert a tile key into a numeric Morton code with [[mortonCode]].\n     *\n     * @param quadKey64 - The Morton code to be converted.\n     * @returns A new instance of {@link TileKey}.\n     */\n    static fromMortonCode(quadKey64: number): TileKey {\n        let level = 0;\n        let row = 0;\n        let column = 0;\n        let quadKey = quadKey64;\n        while (quadKey > 1) {\n            const mask: number = 1 << level;\n\n            if (quadKey & 0x1) {\n                column |= mask;\n            }\n            if (quadKey & 0x2) {\n                row |= mask;\n            }\n\n            level++;\n            quadKey = (quadKey - (quadKey & 0x3)) / 4;\n        }\n        const result = TileKey.fromRowColumnLevel(row, column, level);\n        result.m_mortonCode = quadKey64;\n        return result;\n    }\n\n    /**\n     * Creates a tile key from a heretile code string.\n     *\n     * The string can be created with [[toHereTile]].\n     *\n     * @param quadkey64 - The string representation of the HERE tile key.\n     * @returns A new instance of `TileKey`.\n     */\n    static fromHereTile(quadkey64: string): TileKey {\n        const result = TileKey.fromMortonCode(parseInt(quadkey64, 10));\n        result.m_hereTile = quadkey64;\n        return result;\n    }\n\n    /**\n     * Returns the number of available columns at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level - The level for which to return the number of columns.\n     * @returns The available columns at the given level.\n     */\n    static columnsAtLevel(level: number): number {\n        return Math.pow(2, level);\n    }\n\n    /**\n     * Returns the number of available rows at a given level.\n     *\n     * This is 2 to the power of the level.\n     *\n     * @param level - The level for which to return the number of rows.\n     * @returns The available rows at the given level.\n     */\n    static rowsAtLevel(level: number): number {\n        return Math.pow(2, level);\n    }\n\n    /**\n     * Returns the closest matching `TileKey` in a cartesian coordinate system.\n     *\n     * @param level - The level for the tile key.\n     * @param coordX - The X coordinate.\n     * @param coordY - The Y coordinate.\n     * @param totalWidth - The maximum X coordinate.\n     * @param totalHeight - The maximum Y coordinate.\n     * @returns A new tile key at the given level that includes the given coordinates.\n     */\n    static atCoords(\n        level: number,\n        coordX: number,\n        coordY: number,\n        totalWidth: number,\n        totalHeight: number\n    ): TileKey {\n        return TileKey.fromRowColumnLevel(\n            Math.floor(coordY / (totalHeight / TileKey.rowsAtLevel(level))),\n            Math.floor(coordX / (totalWidth / TileKey.columnsAtLevel(level))),\n            level\n        );\n    }\n\n    /**\n     * Computes the Morton code of the parent tile key of the given Morton code.\n     *\n     * Note: The parent key of the root key is the root key itself.\n     *\n     * @param mortonCode - A Morton code, for example, obtained from [[mortonCode]].\n     * @returns The Morton code of the parent tile.\n     */\n    static parentMortonCode(mortonCode: number): number {\n        return Math.floor(mortonCode / 4);\n    }\n\n    private m_mortonCode?: number;\n    private m_hereTile?: string;\n\n    /**\n     * Constructs a new immutable instance of a `TileKey`.\n     *\n     * For the better readability, {@link TileKey.fromRowColumnLevel} should be preferred.\n     *\n     * Note - row and column must not be greater than the maximum rows/columns for the given level.\n     *\n     * @param row - Represents the row in the quadtree.\n     * @param column - Represents the column in the quadtree.\n     * @param level - Represents the level in the quadtree.\n     */\n    constructor(readonly row: number, readonly column: number, readonly level: number) {}\n\n    /**\n     * Returns a tile key representing the parent of the tile addressed by this tile key.\n     *\n     * Throws an exception is this tile is already the root.\n     */\n    parent(): TileKey {\n        if (this.level === 0) {\n            throw new Error(\"Cannot get the parent of the root tile key\");\n        }\n        return TileKey.fromRowColumnLevel(this.row >>> 1, this.column >>> 1, this.level - 1);\n    }\n\n    /**\n     * Returns a new tile key at a level that differs from this tile's level by delta.\n     *\n     * Equivalent to `changedLevelTo(level() + delta)`.\n     *\n     * Note - root key is returned if `delta` is smaller than the level of this tile key.\n     *\n     * @param delta - The numeric difference between the current level and the requested level.\n     */\n    changedLevelBy(delta: number): TileKey {\n        const level = Math.max(0, this.level + delta);\n        let row = this.row;\n        let column = this.column;\n\n        if (delta >= 0) {\n            row <<= delta;\n            column <<= delta;\n        } else {\n            row >>>= -delta;\n            column >>>= -delta;\n        }\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n\n    /**\n     * Returns a new tile key at the requested level.\n     *\n     * If the requested level is smaller than the tile's level, then the key of an ancestor of this\n     * tile is returned. If the requested level is larger than the tile's level, then the key of\n     * first child or grandchild of this tile is returned, for example, the child with the lowest\n     * row and column number. If the requested level equals this tile's level, then the tile key\n     * itself is returned. If the requested level is negative, the root tile key is returned.\n     *\n     * @param level - The requested level.\n     */\n    changedLevelTo(level: number): TileKey {\n        return this.changedLevelBy(level - this.level);\n    }\n\n    /**\n     * Converts the tile key to a numeric code representation.\n     *\n     * You can create a tile key from a numeric Morton code with [[fromMortonCode]].\n     *\n     * Note - only levels <= 26 are supported.\n     */\n    mortonCode(): number {\n        if (this.m_mortonCode === undefined) {\n            let column = this.column;\n            let row = this.row;\n\n            let result = powerOfTwo[this.level << 1];\n            for (let i = 0; i < this.level; ++i) {\n                if (column & 0x1) {\n                    result += powerOfTwo[2 * i];\n                }\n                if (row & 0x1) {\n                    result += powerOfTwo[2 * i + 1];\n                }\n                column >>>= 1;\n                row >>>= 1;\n            }\n\n            this.m_mortonCode = result;\n        }\n        return this.m_mortonCode;\n    }\n\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * The string is a quadkey Morton code representation as a string.\n     *\n     * You can convert back from a quadkey string with [[fromHereTile]].\n     */\n    toHereTile(): string {\n        if (this.m_hereTile === undefined) {\n            this.m_hereTile = this.mortonCode().toString();\n        }\n        return this.m_hereTile;\n    }\n\n    /**\n     * Converts the tile key into a string for using in REST API calls.\n     *\n     * If the tile is the root tile, the quadkey is '-'. Otherwise the string is a number to the\n     * base of 4, but without the leading 1, with the following properties:\n     *  1. the number of digits equals the level.\n     *  2. removing the last digit gives the parent tile's quadkey string, i.e. appending 0,1,2,3\n     *     to a quadkey string gives the tiles's children.\n     *\n     * You can convert back from a quadkey string with [[fromQuadKey]].\n     */\n    toQuadKey(): string {\n        let result: string = \"\";\n\n        for (let i = this.level; i > 0; --i) {\n            const mask = 1 << (i - 1);\n\n            const col = (this.column & mask) !== 0;\n            const row = (this.row & mask) !== 0;\n\n            if (col && row) {\n                result += \"3\";\n            } else if (row) {\n                result += \"2\";\n            } else if (col) {\n                result += \"1\";\n            } else {\n                result += \"0\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Equality operator.\n     *\n     * @param qnr - The tile key to compare to.\n     * @returns `true` if this tile key has identical row, column and level, `false` otherwise.\n     */\n    equals(qnr: TileKey): boolean {\n        return this.row === qnr.row && this.column === qnr.column && this.level === qnr.level;\n    }\n\n    /**\n     * Returns the absolute quadkey that is constructed from its sub quadkey.\n     *\n     * @param sub - The sub key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubKey(sub: string): TileKey {\n        const subQuad = TileKey.fromQuadKey(sub.length === 0 ? \"-\" : sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(\n            child.row + subQuad.row,\n            child.column + subQuad.column,\n            child.level\n        );\n    }\n\n    /**\n     * Returns the absolute quadkey that is constructed from its sub HERE tile key.\n     *\n     * @param sub - The sub HERE key.\n     * @returns The absolute tile key in the quadtree.\n     */\n    addedSubHereTile(sub: string): TileKey {\n        const subQuad = TileKey.fromHereTile(sub);\n        const child = this.changedLevelBy(subQuad.level);\n        return TileKey.fromRowColumnLevel(\n            child.row + subQuad.row,\n            child.column + subQuad.column,\n            child.level\n        );\n    }\n\n    /**\n     * Returns a sub quadkey that is relative to its parent.\n     *\n     * This function can be used to generate sub keys that are relative to a parent that is delta\n     * levels up in the quadtree.\n     *\n     * This function can be used to create shortened keys for quads on lower levels if the parent is\n     * known.\n     *\n     * Note - the sub quadkeys fit in a 16-bit unsigned integer if the `delta` is smaller than 8. If\n     * `delta` is smaller than 16, the sub quadkey fits into an unsigned 32-bit integer.\n     *\n     * Deltas larger than 16 are not supported.\n     *\n     * @param delta - The number of levels relative to its parent quadkey. Must be greater or equal\n     * to 0 and smaller than 16.\n     * @returns The quadkey relative to its parent that is `delta` levels up the tree.\n     */\n    getSubHereTile(delta: number): string {\n        const key = this.mortonCode();\n        const msb = 1 << (delta * 2);\n        const mask = msb - 1;\n        const result = (key & mask) | msb;\n        return result.toString();\n    }\n\n    /**\n     * Returns the number of available rows in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    rowCount(): number {\n        return TileKey.rowsAtLevel(this.level);\n    }\n\n    /**\n     * Returns the number of available columns in the tile's [[level]].\n     *\n     * This is 2 to the power of the level.\n     */\n    columnCount(): number {\n        return TileKey.columnsAtLevel(this.level);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinates } from \"../coordinates/GeoCoordinates\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Vector3Like } from \"../math/Vector3Like\";\nimport { TileKey } from \"./TileKey\";\nimport { TilingScheme } from \"./TilingScheme\";\n\nexport const powerOfTwo = (() => {\n    let val = 0.5;\n    return new Array(53).fill(0).map(() => (val *= 2));\n})();\n\nexport namespace TileKeyUtils {\n    export function geoCoordinatesToTileKey(\n        tilingScheme: TilingScheme,\n        geoPoint: GeoCoordinatesLike,\n        level: number\n    ): TileKey | null {\n        const projection = tilingScheme.projection;\n        const worldPoint = projection.projectPoint(geoPoint);\n\n        return worldCoordinatesToTileKey(tilingScheme, worldPoint, level);\n    }\n\n    export function worldCoordinatesToTileKey(\n        tilingScheme: TilingScheme,\n        worldPoint: Vector3Like,\n        level: number\n    ): TileKey | null {\n        const projection = tilingScheme.projection;\n        const subdivisionScheme = tilingScheme.subdivisionScheme;\n\n        const cx = subdivisionScheme.getLevelDimensionX(level);\n        const cy = subdivisionScheme.getLevelDimensionY(level);\n\n        const { min, max } = projection.worldExtent(0, 0);\n        const worldSizeX = max.x - min.x;\n        const worldSizeY = max.y - min.y;\n\n        if (worldPoint.x < min.x || worldPoint.x > max.x) {\n            return null;\n        }\n\n        if (worldPoint.y < min.y || worldPoint.y > max.y) {\n            return null;\n        }\n\n        const column = Math.min(cx - 1, Math.floor((cx * (worldPoint.x - min.x)) / worldSizeX));\n        const row = Math.min(cy - 1, Math.floor((cy * (worldPoint.y - min.y)) / worldSizeY));\n\n        return TileKey.fromRowColumnLevel(row, column, level);\n    }\n\n    export function geoRectangleToTileKeys(\n        tilingScheme: TilingScheme,\n        geoBox: GeoBox,\n        level: number\n    ): TileKey[] {\n        const wrap = (value: number, lower: number, upper: number) => {\n            if (value < lower) {\n                return upper - ((lower - value) % (upper - lower));\n            }\n\n            return lower + ((value - lower) % (upper - lower));\n        };\n\n        const clamp = (x: number, minVal: number, maxVal: number) => {\n            return Math.min(Math.max(x, minVal), maxVal);\n        };\n\n        // Clamp at the poles and wrap around the international date line.\n        const southWestLongitude = wrap(geoBox.southWest.longitudeInRadians, -Math.PI, Math.PI);\n        const southWestLatitude = clamp(\n            geoBox.southWest.latitudeInRadians,\n            -(Math.PI * 0.5),\n            Math.PI * 0.5\n        );\n        const northEastLongitude = wrap(geoBox.northEast.longitudeInRadians, -Math.PI, Math.PI);\n        const northEastLatitude = clamp(\n            geoBox.northEast.latitudeInRadians,\n            -(Math.PI * 0.5),\n            Math.PI * 0.5\n        );\n        const minTileKey = TileKeyUtils.geoCoordinatesToTileKey(\n            tilingScheme,\n            GeoCoordinates.fromRadians(southWestLatitude, southWestLongitude),\n            level\n        );\n        const maxTileKey = TileKeyUtils.geoCoordinatesToTileKey(\n            tilingScheme,\n            GeoCoordinates.fromRadians(northEastLatitude, northEastLongitude),\n            level\n        );\n        const columnCount = tilingScheme.subdivisionScheme.getLevelDimensionX(level);\n\n        if (!minTileKey || !maxTileKey) {\n            throw new Error(\"Invalid coordinates\");\n        }\n\n        const minColumn = minTileKey.column;\n        let maxColumn = maxTileKey.column;\n\n        // wrap around case\n        if (southWestLongitude > northEastLongitude) {\n            if (maxColumn !== minColumn) {\n                maxColumn += columnCount;\n            } else {\n                // do not duplicate\n                maxColumn += columnCount - 1;\n            }\n        }\n\n        const minRow = Math.min(minTileKey.row, maxTileKey.row);\n        const maxRow = Math.max(minTileKey.row, maxTileKey.row);\n\n        const keys = new Array<TileKey>();\n\n        for (let row = minRow; row <= maxRow; ++row) {\n            for (let column = minColumn; column <= maxColumn; ++column) {\n                keys.push(TileKey.fromRowColumnLevel(row, column % columnCount, level));\n            }\n        }\n\n        return keys;\n    }\n\n    /**\n     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the\n     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because\n     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the\n     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24\n     * levels. Given the current support up to level 19 this should be fine.\n     *\n     * @param tileKey - The unique {@link @here/harp-geoutils#TileKey}\n     *                  from which to compute the unique key.\n     * @param offset - How much the given {@link @here/harp-geoutils#TileKey} is offset\n     * @param bitshift - How much space we have to store the offset. The default of 4 means we have\n     *      enough space to store 16 unique tiles in a single view.\n     */\n    export function getKeyForTileKeyAndOffset(\n        tileKey: TileKey,\n        offset: number,\n        bitshift: number = 4\n    ) {\n        const shiftedOffset = getShiftedOffset(offset, bitshift);\n        return tileKey.mortonCode() + shiftedOffset;\n    }\n\n    /**\n     * Extracts the offset and morton key from the given key (must be created by:\n     * [[getKeyForTileKeyAndOffset]])\n     *\n     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and\n     * would truncate the numbers, hence using powers of two.\n     *\n     * @param key - Key to extract offset and morton key.\n     * @param bitshift - How many bits to shift by, must be the same as was used when creating the\n     * key.\n     */\n    export function extractOffsetAndMortonKeyFromKey(key: number, bitshift: number = 4) {\n        let offset = 0;\n        let mortonCode = key;\n        let i = 0;\n        // Compute the offset\n        for (; i < bitshift; i++) {\n            // Note, we use 52, because 2^53-1 is the biggest value, the highest value\n            // that can be set is the bit in the 52th position.\n            const num = powerOfTwo[52 - i];\n            if (mortonCode >= num) {\n                mortonCode -= num;\n                offset += powerOfTwo[bitshift - 1 - i];\n            }\n        }\n        // We subtract half of the total amount, this undoes what is computed in getShiftedOffset\n        offset -= powerOfTwo[bitshift - 1];\n        return { offset, mortonCode };\n    }\n\n    /**\n     * Returns the key of the parent. Key must have been computed using the function\n     * [[getKeyForTileKeyAndOffset]].\n     *\n     * @param calculatedKey - Key to decompose\n     * @param bitshift - Bit shift used to create the key\n     */\n    export function getParentKeyFromKey(calculatedKey: number, bitshift: number = 4) {\n        const { offset, mortonCode } = extractOffsetAndMortonKeyFromKey(calculatedKey, bitshift);\n        const parentTileKey = TileKey.fromMortonCode(TileKey.parentMortonCode(mortonCode));\n        return getKeyForTileKeyAndOffset(parentTileKey, offset, bitshift);\n    }\n\n    /**\n     * Packs the supplied offset into the high bits, where the highbits are between 2^52 and\n     * 2^(52-bitshift).\n     *\n     * Offsets are wrapped around, to fit in the offsetBits. In practice, this doesn't really\n     * matter, this is primarily used to find a unique id, if there is an offset 10, which is\n     * wrapped to 2, it doesn't matter, because the offset of 10 is still stored in the tile.\n     * What can be a problem though is that the cache gets filled up and isn't emptied.\n     *\n     * Note, because bit shifting in JavaScript works on 32 bit integers, we use powers of 2 to set\n     * the high bits instead.\n     *\n     * @param offset - Offset to pack into the high bits.\n     * @param offsetBits - How many bits to use to pack the offset.\n     */\n    function getShiftedOffset(offset: number, offsetBits: number = 4) {\n        let result = 0;\n        const totalOffsetsToStore = powerOfTwo[offsetBits];\n        //Offsets are stored by adding half 2 ^ (bitshift - 1), i.e.half of the max amount stored,\n        //and then wrapped based on this value.For example, given a bitshift of 3, and an offset -\n        //3, it would have 4 added(half of 2 ^ 3), and be stored as 1, 3 would have 4 added and be\n        //stored as 7, 4 would be added with 4 and be stored as 0 (it wraps around).\n        offset += totalOffsetsToStore / 2;\n        while (offset < 0) {\n            offset += totalOffsetsToStore;\n        }\n        while (offset >= totalOffsetsToStore) {\n            offset -= totalOffsetsToStore;\n        }\n        // Offset is now a number between >= 0 and < totalOffsetsToStore\n        for (let i = 0; i < offsetBits && offset > 0; i++) {\n            // 53 is used because 2^53-1 is the biggest number that Javascript can represent as an\n            // integer safely.\n            if (offset & 0x1) {\n                result += powerOfTwo[53 - offsetBits + i];\n            }\n            offset >>>= 1;\n        }\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\nimport { SubTiles } from \"./SubTiles\";\nimport { TileKey } from \"./TileKey\";\n\nexport class TileTreeTraverse {\n    private readonly m_subdivisionScheme: SubdivisionScheme;\n\n    constructor(subdivisionScheme: SubdivisionScheme) {\n        this.m_subdivisionScheme = subdivisionScheme;\n    }\n\n    subTiles(tileKey: TileKey): Iterable<TileKey> {\n        const divX = this.m_subdivisionScheme.getSubdivisionX(tileKey.level);\n        const divY = this.m_subdivisionScheme.getSubdivisionY(tileKey.level);\n\n        return new SubTiles(tileKey, divX, divY);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"../coordinates/GeoBox\";\nimport { GeoCoordinatesLike } from \"../coordinates/GeoCoordinatesLike\";\nimport { Box3Like } from \"../math/Box3Like\";\nimport { Projection } from \"../projection/Projection\";\nimport { FlatTileBoundingBoxGenerator } from \"./FlatTileBoundingBoxGenerator\";\nimport { SubdivisionScheme } from \"./SubdivisionScheme\";\nimport { TileKey } from \"./TileKey\";\nimport { TileKeyUtils } from \"./TileKeyUtils\";\nimport { TileTreeTraverse } from \"./TileTreeTraverse\";\n\n/**\n * The `TilingScheme` represents how the data is tiled.\n */\nexport class TilingScheme {\n    readonly boundingBoxGenerator: FlatTileBoundingBoxGenerator;\n    readonly tileTreeTraverse: TileTreeTraverse;\n\n    /**\n     * Constructs a new `TilingScheme` with the given subdivision scheme and projection.\n     *\n     * @param subdivisionScheme - The subdivision scheme used by this `TilingScheme`.\n     * @param projection - The projection used by this `TilingScheme`.\n     */\n    constructor(readonly subdivisionScheme: SubdivisionScheme, readonly projection: Projection) {\n        this.boundingBoxGenerator = new FlatTileBoundingBoxGenerator(this);\n        this.tileTreeTraverse = new TileTreeTraverse(subdivisionScheme);\n    }\n\n    /**\n     * Returns the sub tile keys of the given tile.\n     *\n     * @param tileKey - The {@link TileKey}.\n     * @returns The list of the sub tile keys.\n     */\n    getSubTileKeys(tileKey: TileKey): Iterable<TileKey> {\n        return this.tileTreeTraverse.subTiles(tileKey);\n    }\n\n    /**\n     * Gets the {@link TileKey} from the given geo position and level.\n     *\n     * @param geoPoint - The position in geo coordinates.\n     * @param level - The level of the resulting `TileKey`.\n     */\n    getTileKey(geoPoint: GeoCoordinatesLike, level: number): TileKey | null {\n        return TileKeyUtils.geoCoordinatesToTileKey(this, geoPoint, level);\n    }\n\n    /**\n     * Gets the list of {@link TileKey}s contained in the given {@link GeoBox}.\n     *\n     * @param geoBox - The bounding box in geo coordinates.\n     * @param level - The level of the resulting `TileKey`.\n     */\n    getTileKeys(geoBox: GeoBox, level: number): TileKey[] {\n        return TileKeyUtils.geoRectangleToTileKeys(this, geoBox, level);\n    }\n\n    /**\n     * Returns the bounding box in geo coordinates for the given {@link TileKey}.\n     *\n     * @param tileKey - The `TileKey`.\n     */\n    getGeoBox(tileKey: TileKey): GeoBox {\n        return this.boundingBoxGenerator.getGeoBox(tileKey);\n    }\n\n    /**\n     * Returns the bounding box in world coordinates.\n     *\n     * @param tileKey - The `TileKey`.\n     * @param result - The optional object that will contain the resulting bounding box.\n     */\n    getWorldBox(tileKey: TileKey, result?: Box3Like): Box3Like {\n        return this.boundingBoxGenerator.getWorldBox(tileKey, result);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { webMercatorProjection } from \"../projection/MercatorProjection\";\nimport { quadTreeSubdivisionScheme } from \"./QuadTreeSubdivisionScheme\";\nimport { TilingScheme } from \"./TilingScheme\";\n\n/**\n * A {@link TilingScheme} featuring quadtree subdivision scheme and web Mercator projection.\n */\nexport const webMercatorTilingScheme = new TilingScheme(\n    quadTreeSubdivisionScheme,\n    webMercatorProjection\n);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/Lines\";\nexport * from \"./lib/TriangulateLines\";\nexport * from \"./lib/HighPrecisionLines\";\nexport * from \"./lib/HighPrecisionUtils\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { HighPrecisionLineMaterial } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { HighPrecisionUtils } from \"./HighPrecisionUtils\";\n\n/**\n * Declare interface for `HighPrecisionObject` which describes additional functionality to render\n * high-precision vertices.\n */\nexport interface HighPrecisionObject extends THREE.Object3D {\n    /**\n     * Allow direct access to [[BufferGeometry]] without cast.\n     */\n    bufferGeometry: THREE.BufferGeometry;\n\n    /**\n     * Allow direct access to [[ShaderMaterial]] without cast.\n     */\n    shaderMaterial: THREE.ShaderMaterial;\n\n    /**\n     * Inversed World Matrix.\n     */\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Sets up attributes for position (one attribute for major 32 bits position \"halve\", and one\n     * attribute for lower 32 bits).\n     */\n    setPositions(positions: number[] | THREE.Vector3[]): void;\n\n    /**\n     * Prepare the objects \"`onBeforeRender()`\" callback to generate proper high-precision camera\n     * position.\n     */\n    setupForRendering(): void;\n}\n\n/**\n * Class used to render high-precision wireframe lines.\n */\nexport class HighPrecisionWireFrameLine extends THREE.Line implements HighPrecisionObject {\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Creates a `HighPrecisionWireFrameLine` object.\n     *\n     * @param geometry - [[BufferGeometry]] used to render this object.\n     * @param material - [[HighPrecisionLineMaterial]] used to render this object.\n     * @param positions - Array of 2D/3D positions.\n     */\n    constructor(\n        geometry: THREE.BufferGeometry,\n        material: HighPrecisionLineMaterial,\n        positions?: number[] | THREE.Vector3[]\n    ) {\n        super(geometry, material);\n        this.matrixWorldInverse = new THREE.Matrix4();\n\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n\n    get bufferGeometry(): THREE.BufferGeometry {\n        return this.geometry as THREE.BufferGeometry;\n    }\n\n    get shaderMaterial(): THREE.ShaderMaterial {\n        return this.material as THREE.ShaderMaterial;\n    }\n\n    setPositions(positions: number[] | THREE.Vector3[]): void {\n        HighPrecisionUtils.setPositions(this, positions);\n    }\n\n    setupForRendering(): void {\n        this.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n\n    updateMatrixWorld(force: boolean) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n\n        super.updateMatrixWorld(force);\n\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.copy(this.matrixWorld).invert();\n        }\n    }\n}\n\n/**\n * Class used to render high-precision lines.\n */\nexport class HighPrecisionLine extends THREE.Mesh implements HighPrecisionObject {\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Creates a `HighPrecisionLine` object.\n     *\n     * @param geometry - [[BufferGeometry]] used to render this object.\n     * @param material - [[HighPrecisionLineMaterial]] used to render this object.\n     * @param positions - Array of 2D/3D positions.\n     */\n    constructor(\n        geometry: THREE.BufferGeometry,\n        material: HighPrecisionLineMaterial,\n        positions?: number[] | THREE.Vector3[]\n    ) {\n        super(geometry, material);\n\n        this.matrixWorldInverse = new THREE.Matrix4();\n\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n\n    get bufferGeometry(): THREE.BufferGeometry {\n        return this.geometry as THREE.BufferGeometry;\n    }\n\n    get shaderMaterial(): THREE.ShaderMaterial {\n        return this.material as THREE.ShaderMaterial;\n    }\n\n    setPositions(positions: number[] | THREE.Vector3[]): void {\n        HighPrecisionUtils.setPositions(this, positions);\n    }\n\n    setupForRendering(): void {\n        this.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n\n    updateMatrixWorld(force: boolean) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n\n        super.updateMatrixWorld(force);\n\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.copy(this.matrixWorld).invert();\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { HighPrecisionPointMaterial } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { HighPrecisionObject } from \"./HighPrecisionLines\";\nimport { HighPrecisionUtils } from \"./HighPrecisionUtils\";\n\n/**\n * Class used to render high-precision points.\n */\nexport class HighPrecisionPoints extends THREE.Points implements HighPrecisionObject {\n    matrixWorldInverse: THREE.Matrix4;\n\n    /**\n     * Number of dimensions this `HighPrecisionObject` is specified in (2D/3D).\n     */\n    dimensionality?: number;\n\n    /**\n     * Creates a `HighPrecisionPoints` object.\n     *\n     * @param geometry - [[BufferGeometry]] used to render this object.\n     * @param material - [[HighPrecisionLineMaterial]] used to render this object.\n     *     instances.\n     * @param positions - Array of 2D/3D positions.\n     * @param color - Color of the rendered point.\n     * @param opacity - Opacity of the rendered point.\n     */\n    constructor(\n        geometry?: THREE.BufferGeometry,\n        material?: HighPrecisionPointMaterial,\n        positions?: number[] | THREE.Vector3[],\n        color?: THREE.Color,\n        opacity?: number\n    ) {\n        if (material === undefined) {\n            material = new HighPrecisionPointMaterial({\n                color: color ? color : HighPrecisionPointMaterial.DEFAULT_COLOR,\n                opacity: opacity !== undefined ? opacity : 1\n            });\n        }\n\n        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);\n\n        this.matrixWorldInverse = new THREE.Matrix4();\n\n        if (positions) {\n            this.setPositions(positions);\n        }\n    }\n\n    get bufferGeometry(): THREE.BufferGeometry {\n        return this.geometry as THREE.BufferGeometry;\n    }\n\n    /**\n     * Clears the [[BufferGeometry]] used to render this point.\n     */\n    clearGeometry(): THREE.BufferGeometry {\n        return (this.geometry = new THREE.BufferGeometry());\n    }\n\n    get shaderMaterial(): THREE.ShaderMaterial {\n        return this.material as THREE.ShaderMaterial;\n    }\n\n    setPositions(positions: number[] | THREE.Vector3[]): void {\n        HighPrecisionUtils.setPositions(this, positions);\n    }\n\n    setupForRendering(): void {\n        if (\n            (this.material as any).isHighPrecisionPointsMaterial &&\n            this.dimensionality !== undefined\n        ) {\n            (this.material as any).setDimensionality(this.dimensionality);\n        }\n        this.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);\n        };\n    }\n\n    updateMatrixWorld(force: boolean) {\n        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;\n\n        super.updateMatrixWorld(force);\n\n        if (doUpdateMatrixWorldInverse) {\n            this.matrixWorldInverse.copy(this.matrixWorld).invert();\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    HighPrecisionLineMaterial,\n    HighPrecisionLineMaterialParameters,\n    HighPrecisionPointMaterial,\n    isHighPrecisionPointMaterial\n} from \"@here/harp-materials\";\nimport {\n    BufferAttribute,\n    BufferGeometry,\n    Camera,\n    Float32BufferAttribute,\n    InterleavedBuffer,\n    InterleavedBufferAttribute,\n    Matrix4,\n    PointsMaterialParameters,\n    ShaderMaterial,\n    Vector3\n} from \"three\";\n\nimport * as HPL from \"./HighPrecisionLines\";\nimport * as HPP from \"./HighPrecisionPoints\";\nimport { triangulateLine } from \"./TriangulateLines\";\n\nexport namespace HighPrecisionUtils {\n    /**\n     * Extract the `float` parts of all vector members, Making this a `Vector3` of `float`.\n     * precision.\n     *\n     * @param v -\n     */\n    export function doubleToFloatVec(v: Vector3): Vector3 {\n        return new Vector3(Math.fround(v.x), Math.fround(v.y), Math.fround(v.z));\n    }\n\n    /**\n     * Convert a `Vector3` to `float` (in place!) Returns the minor float vector, which is the\n     * difference of the double elements and their float counterparts.\n     *\n     * @param v - Vector3 to convert to float IN-PLACE!\n     */\n    export function makeFloatVec(v: Vector3): Vector3 {\n        const majorX = Math.fround(v.x);\n        const majorY = Math.fround(v.y);\n        const majorZ = Math.fround(v.z);\n\n        const minorVec = new Vector3(v.x - majorX, v.y - majorY, v.z - majorZ);\n\n        v.x = Math.fround(majorX);\n        v.y = Math.fround(majorY);\n        v.z = Math.fround(majorZ);\n\n        return minorVec;\n    }\n\n    /**\n     * Describes addtional postion data needed to render high-precision vertices. Created by\n     * [[createHighPrecisionCameraPos]].\n     */\n    export interface HighPrecisionCameraInfo {\n        /**\n         * View Projection matrix of this high-precision camera.\n         */\n        viewProjection: Matrix4;\n\n        /**\n         * Low-order bits of the high-precision camera's position.\n         */\n        eyePosLo: Vector3;\n\n        /**\n         * High-order bits of the high-precision camera's position.\n         */\n        eyePosHi: Vector3;\n    }\n\n    /**\n     * Describes different properties used when creating a [[HighPrecisionLine]] or\n     * a [[HighPrecisionWireFrameLine]].\n     */\n    export interface HighPrecisionLineParams extends HighPrecisionLineMaterialParameters {\n        /**\n         * Width of the rendered line (specified in world units).\n         */\n        lineWidth?: number;\n\n        /**\n         * Add rounded caps to the extremes of the line if set to `true`.\n         */\n        addCircles?: boolean;\n\n        /**\n         * Renders a wireframe line if set to `true`.\n         */\n        wireFrame?: boolean;\n    }\n\n    /**\n     * Calculate high-precision camera position used in vertex shader of high-precision materials.\n     *\n     * @param camera - Camera used to get the high-precision position.\n     * @param objectInverseWorldMatrix - Inverse World Matrix of the rendered\n     *                                   [[HighPrecisionObject]].\n     */\n    export function createHighPrecisionCameraPos(\n        camera: Camera,\n        objectInverseWorldMatrix: Matrix4\n    ): HighPrecisionCameraInfo {\n        const _projScreenMatrix = new Matrix4().copy(camera.projectionMatrix);\n        const mvp = _projScreenMatrix.multiply(camera.matrixWorldInverse);\n        const eyePos = new Vector3(0, 0, 0).applyMatrix4(objectInverseWorldMatrix);\n\n        // split the double float vector into hi and lo parts\n        const eyePosFloat = doubleToFloatVec(eyePos);\n\n        const eyePosLo = doubleToFloatVec(eyePos.sub(eyePosFloat));\n\n        return {\n            viewProjection: mvp,\n            eyePosHi: eyePosFloat,\n            eyePosLo\n        };\n    }\n\n    /**\n     * Updates the high-precision uniform data of a material used to render a\n     * [[HighPrecisionObject]].\n     *\n     * @param object - [[HighPrecisionObject]] used for rendering.\n     * @param camera - Camera used to get the high-precision position.\n     * @param shaderMaterial - Material which uniforms will be updated.\n     */\n    export function updateHpUniforms(\n        object: HPL.HighPrecisionObject,\n        camera: Camera,\n        shaderMaterial: ShaderMaterial\n    ): void {\n        const highPrecisionCameraInfo = createHighPrecisionCameraPos(\n            camera,\n            object.matrixWorldInverse\n        );\n        const mvp = highPrecisionCameraInfo.viewProjection;\n\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (\n                shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_mvp &&\n                shaderMaterial.uniforms.u_eyepos &&\n                shaderMaterial.uniforms.u_eyepos_lowpart\n            ) {\n                shaderMaterial.uniforms.u_mvp.value = new Float32Array(mvp.elements);\n                shaderMaterial.uniforms.u_eyepos.value = new Float32Array(\n                    highPrecisionCameraInfo.eyePosHi.toArray()\n                );\n                shaderMaterial.uniforms.u_eyepos_lowpart.value = new Float32Array(\n                    highPrecisionCameraInfo.eyePosLo.toArray()\n                );\n            } else {\n                throw Error(\"High pecision material has missing uniforms\");\n            }\n        } else {\n            throw Error(\"High pecision line has no high precision material\");\n        }\n    }\n\n    /**\n     * Assembles the necessary attribute buffers needed to render [[HighPrecisionObject]].\n     *\n     * @param positions - Array of positions.\n     */\n    export function createAttributes(\n        positions: ArrayLike<number> | ArrayLike<Vector3>\n    ): {\n        positionHigh: BufferAttribute;\n        positionLow: BufferAttribute;\n    } {\n        if (positions.length > 0) {\n            const v = positions[0];\n\n            if (v === undefined || v === null) {\n                throw Error(\"Empty element in positions\");\n            }\n\n            const positionVec = new Array<number>();\n            const positionVecLow = new Array<number>();\n\n            const addHPValue = (...values: number[]) => {\n                for (const value of values) {\n                    const major = Math.fround(value);\n                    positionVecLow.push(value - major);\n                    positionVec.push(major);\n                }\n            };\n\n            const addHPVector = (vec: Vector3) => {\n                addHPValue(vec.x, vec.y, vec.z);\n            };\n\n            const vAny = v as any;\n            if (vAny.z !== undefined) {\n                (positions as Vector3[]).forEach(vec => {\n                    addHPVector(vec);\n                });\n            } else {\n                if (positionVec.length % 3 !== 0) {\n                    throw Error(\"Positions must be 3D, not 2D\");\n                }\n                (positions as number[]).forEach((n: number): void => {\n                    addHPValue(n);\n                });\n            }\n\n            return {\n                positionHigh: new Float32BufferAttribute(positionVec, 3),\n                positionLow: new Float32BufferAttribute(positionVecLow, 3)\n            };\n        } else {\n            return {\n                positionHigh: new Float32BufferAttribute([], 3),\n                positionLow: new Float32BufferAttribute([], 3)\n            };\n        }\n    }\n\n    /**\n     * Assembles an interleaved buffer containing the position attribute data for a\n     * [[HighPrecisionObject]].\n     *\n     * @param positions - Array of positions.\n     * @param stride - Stride of the elements in the `positions` array.\n     * @param positionOffset - Offset into the `positions` array.\n     */\n    export function addInterleavedAttributes3(\n        positions: ArrayLike<number>,\n        stride: number,\n        positionOffset = 0\n    ): ArrayLike<number> {\n        const newPositions = new Array<number>();\n\n        const end = positions.length;\n\n        for (let i = 0; i < end; i += stride) {\n            for (let j = 0; j < positionOffset; j++) {\n                newPositions.push(positions[i + j]);\n            }\n\n            const x = positions[i + positionOffset];\n            const y = positions[i + positionOffset + 1];\n            const z = positions[i + positionOffset + 2];\n            const majorX = Math.fround(x);\n            const minorX = x - majorX;\n            const majorY = Math.fround(y);\n            const minorY = y - majorY;\n            const majorZ = Math.fround(z);\n            const minorZ = z - majorZ;\n\n            // insert values in interleaved buffer\n            newPositions.push(majorX, majorY, majorZ, minorX, minorY, minorZ);\n\n            for (let j = positionOffset + 3; j < stride; j++) {\n                newPositions.push(positions[i + j]);\n            }\n        }\n\n        return newPositions;\n    }\n\n    /**\n     * Adds the high-precision position attribute data to a [[HighPrecisionObject]].\n     *\n     * @param object - [[HighPrecisionObject]] which position attribute will be set.\n     * @param positions - Array of positions.\n     */\n    export function setPositions(\n        object: HPL.HighPrecisionObject,\n        positions: ArrayLike<number> | ArrayLike<Vector3>\n    ): number {\n        const attributes = createAttributes(positions);\n\n        object.bufferGeometry.setAttribute(\"position\", attributes.positionHigh);\n        object.bufferGeometry.setAttribute(\"positionLow\", attributes.positionLow);\n\n        return attributes.positionHigh.itemSize;\n    }\n\n    /**\n     * Convert positions from `Array<Vector3>` to `Array<number>`.\n     *\n     * @param positions - Array of positions.\n     */\n    export function convertPositions(\n        positions: ArrayLike<number> | ArrayLike<Vector3>\n    ): { positions: number[] } {\n        if (positions.length <= 0) {\n            return { positions: [] };\n        }\n\n        const v = positions[0];\n\n        if (v === undefined || v === null) {\n            throw Error(\"Empty element in positions\");\n        }\n\n        const vAny = v as any;\n        if (vAny.y === undefined && vAny.z === undefined) {\n            return { positions: positions as number[] };\n        }\n\n        const returnPositions = new Array<number>();\n        (positions as Vector3[]).forEach(vec => {\n            returnPositions.push(vec.x, vec.y, vec.z);\n        });\n\n        return { positions: returnPositions };\n    }\n\n    /**\n     * Creates a [[HighPrecisionLine]] or [[HighPrecisionWireFrameLine]] object.\n     *\n     * @param linePositions - Array of 2D/3D positions.\n     * @param params - Parameters used to configure the created [[HighPrecisionObject]].\n     */\n    export function createLine(\n        linePositions: ArrayLike<number>,\n        params: HighPrecisionLineParams\n    ): HPL.HighPrecisionLine | HPL.HighPrecisionWireFrameLine {\n        const lineWidth = params.lineWidth !== undefined ? params.lineWidth : 5;\n        const addCircles = params.addCircles !== undefined ? params.addCircles : false;\n        const wireFrame = params.wireFrame !== undefined ? params.wireFrame : false;\n\n        const positions: number[] = [];\n        const indices: number[] = [];\n\n        triangulateLine(linePositions, lineWidth, positions, indices, addCircles);\n\n        const hpLineGeometry = new BufferGeometry();\n        const hpPositions = addInterleavedAttributes3(positions, 3);\n        const buffer = new InterleavedBuffer(new Float32Array(hpPositions), 6);\n\n        const positionAttribute = new InterleavedBufferAttribute(buffer, 3, 0, false);\n        const positionLowAttribute = new InterleavedBufferAttribute(buffer, 3, 3, false);\n\n        hpLineGeometry.setAttribute(\"position\", positionAttribute);\n        hpLineGeometry.setAttribute(\"positionLow\", positionLowAttribute);\n        hpLineGeometry.setIndex(new BufferAttribute(new Uint32Array(indices), 1));\n\n        const hpSolidMaterial = new HighPrecisionLineMaterial(params);\n\n        const lineObject = wireFrame\n            ? new HPL.HighPrecisionWireFrameLine(hpLineGeometry, hpSolidMaterial)\n            : new HPL.HighPrecisionLine(hpLineGeometry, hpSolidMaterial);\n\n        lineObject.setupForRendering();\n\n        return lineObject;\n    }\n\n    /**\n     * Creates a group of [[HighPrecisionPoints]].\n     *\n     * @param pointPositions - Array of 2D/3D positions.\n     * @param materialParameters - Parameters used to configure the material used to render the\n     * created [[HighPrecisionPoints]].\n     */\n    export function createPoints(\n        pointPositions: ArrayLike<number>,\n        materialParameters?: PointsMaterialParameters | HighPrecisionPointMaterial\n    ): HPP.HighPrecisionPoints {\n        const indices: number[] = [];\n\n        for (let i = 0; i < pointPositions.length; i++) {\n            indices.push(indices.length / 3);\n        }\n\n        const hpPointsGeometry = new BufferGeometry();\n\n        const hpPointsMaterial = isHighPrecisionPointMaterial(materialParameters)\n            ? materialParameters\n            : new HighPrecisionPointMaterial(materialParameters);\n\n        const pointsObject = new HPP.HighPrecisionPoints(hpPointsGeometry, hpPointsMaterial);\n\n        setPositions(pointsObject, pointPositions);\n\n        pointsObject.setupForRendering();\n\n        return pointsObject;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Projection } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\n// Preallocate temp variables used during line generation.\nconst tmpV = new THREE.Vector3();\nconst tmpNormal = new THREE.Vector3();\nconst tmpTangent0 = new THREE.Vector3();\nconst tmpTangent1 = new THREE.Vector3();\nconst tmpBitangent = new THREE.Vector3();\nconst SEGMENT_OFFSET = 0.1;\n\n/**\n * Describes vertex attribute parameters of interleaved buffer.\n */\ninterface VertexAttributeDescriptor {\n    name: string;\n    itemSize: number;\n    offset: number;\n}\n\ninterface VertexDescriptor {\n    attributes: VertexAttributeDescriptor[];\n    stride: number;\n}\n\n/**\n * Declares all the vertex attributes used for rendering a line using the [[SolidLineMaterial]].\n */\n\n/** Base line vertex attributes. */\nconst LINE_VERTEX_ATTRIBUTES: VertexDescriptor = {\n    attributes: [\n        // The \"extrusionCoord\" is a vec4 which represents:\n        // xy: Extrusion coordinates\n        // sign(xy): Extrusion direction\n        // z: Line length\n        { name: \"extrusionCoord\", itemSize: 3, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 3 },\n        { name: \"tangent\", itemSize: 3, offset: 6 },\n        // HARP-17373: Original uniform name 'bitangent' due to shader compilation errors with Metal\n        // in Safari 15 on MacOS Monterrey and iPadOS 15.\n        { name: \"biTangent\", itemSize: 4, offset: 9 }\n    ],\n    stride: 13\n};\n\n/** Optional normal and uv coordinates. */\nconst NORMAL_UV_VERTEX_ATTRIBUTES: VertexDescriptor = {\n    attributes: [\n        { name: \"uv\", itemSize: 2, offset: LINE_VERTEX_ATTRIBUTES.stride },\n        { name: \"normal\", itemSize: 3, offset: LINE_VERTEX_ATTRIBUTES.stride + 2 }\n    ],\n    stride: 5\n};\n\n/** Base line vertex attributes plus normals and uv coordinates. */\nconst LINE_VERTEX_ATTRIBUTES_NUV: VertexDescriptor = {\n    attributes: [...LINE_VERTEX_ATTRIBUTES.attributes, ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes],\n    stride: LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n\n/**\n * Declares all the vertex attributes used for rendering a line using the\n * [[HighPrecisionLineMaterial]].\n */\nconst HP_LINE_VERTEX_ATTRIBUTES: VertexDescriptor = {\n    attributes: [\n        { name: \"extrusionCoord\", itemSize: 2, offset: 0 },\n        { name: \"position\", itemSize: 3, offset: 2 },\n        { name: \"positionLow\", itemSize: 3, offset: 5 },\n        { name: \"tangent\", itemSize: 3, offset: 8 },\n        // HARP-17373: Original uniform name 'bitangent' due to shader compilation errors with Metal\n        // in Safari 15 on MacOS Monterrey and iPadOS 15.\n        { name: \"biTangent\", itemSize: 4, offset: 11 }\n    ],\n    stride: 15\n};\n\n/** High precision line vertex attributes plus normals and uv coordinates. */\nconst HP_LINE_VERTEX_ATTRIBUTES_NUV: VertexDescriptor = {\n    attributes: [\n        ...HP_LINE_VERTEX_ATTRIBUTES.attributes,\n        ...NORMAL_UV_VERTEX_ATTRIBUTES.attributes\n    ],\n    stride: HP_LINE_VERTEX_ATTRIBUTES.stride + NORMAL_UV_VERTEX_ATTRIBUTES.stride\n};\n\n/**\n * Class that holds the vertex and index attributes for a [[Lines]] object.\n */\nexport class LineGeometry {\n    vertices: number[] = [];\n    vertexColors: number[] = [];\n    indices: number[] = [];\n}\n\nfunction getVertexDescriptor(hasNormalsAndUvs: boolean, highPrecision: boolean): VertexDescriptor {\n    if (highPrecision) {\n        return hasNormalsAndUvs ? HP_LINE_VERTEX_ATTRIBUTES_NUV : HP_LINE_VERTEX_ATTRIBUTES;\n    } else {\n        return hasNormalsAndUvs ? LINE_VERTEX_ATTRIBUTES_NUV : LINE_VERTEX_ATTRIBUTES;\n    }\n}\n\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param center - Center of the polyline.\n * @param polyline - Array of `numbers` describing a polyline.\n * @param offsets - Array of `numbers` representing line segment offsets.\n * @param uvs - Array of `numbers` representing texture coordinates.\n * @param colors - Array of `numbers` describing a polyline's colors.\n * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.\n * @param highPrecision - If `true` will create high-precision vertex information.\n */\nexport function createLineGeometry(\n    center: THREE.Vector3,\n    polyline: ArrayLike<number>,\n    projection: Projection,\n    offsets?: ArrayLike<number>,\n    uvs?: ArrayLike<number>,\n    colors?: ArrayLike<number>,\n    geometry = new LineGeometry(),\n    highPrecision: boolean = false\n): LineGeometry {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n\n    const stride = getVertexDescriptor(uvs !== undefined, highPrecision).stride;\n\n    const pointCount = polyline.length / 3;\n    const segments = new Array<number>(pointCount);\n    const tangents = new Array<number>(polyline.length - 3);\n    const baseVertex = geometry.vertices.length / stride;\n\n    const hasSegmentOffsets = offsets !== undefined && offsets.length > 0;\n    const hasTexCoords = uvs !== undefined && uvs.length > 0;\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n\n    assert(!hasSegmentOffsets || offsets!.length === pointCount);\n    assert(!hasTexCoords || uvs!.length / 2 === pointCount);\n    assert(!vertexColors || colors!.length === polyline.length);\n\n    // Compute segments and tangents.\n    let sum = SEGMENT_OFFSET;\n    segments[0] = sum;\n    for (let i = 0; i < pointCount - 1; ++i) {\n        let sqrLength = 0;\n        for (let j = 0; j < 3; ++j) {\n            const d = polyline[(i + 1) * 3 + j] - polyline[i * 3 + j];\n            tangents[i * 3 + j] = d;\n            sqrLength += d * d;\n        }\n        const len = Math.sqrt(sqrLength);\n        sum = sum + len;\n        segments[i + 1] = sum;\n    }\n\n    const lineCoverage = hasSegmentOffsets\n        ? Math.abs(offsets![offsets!.length - 1] - offsets![0])\n        : 1.0;\n    const lineLength = segments[segments.length - 1] / lineCoverage;\n\n    // Override the segments if offsets are explicitly provided.\n    if (hasSegmentOffsets) {\n        for (let i = 0; i < pointCount; ++i) {\n            segments[i] = offsets![i] * lineLength + SEGMENT_OFFSET;\n        }\n    }\n\n    // Check if we're working with a closed line.\n    let isClosed = true;\n    for (let j = 0; j < 3; ++j) {\n        isClosed = isClosed && polyline[j] === polyline[polyline.length - 3 + j];\n    }\n\n    const tmpVertices: number[] = [];\n\n    const addVertexPair = (\n        i: number,\n        T1: number,\n        T2: number,\n        segment: number,\n        extrusionCoord: number\n    ) => {\n        tmpVertices.length = 0;\n\n        // Store the segment and extrusionCoord attributes.\n        geometry.vertices.push(segment, extrusionCoord * -1, lineLength);\n        tmpVertices.push(segment, extrusionCoord * 1, lineLength);\n\n        // Store the position attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            if (!highPrecision) {\n                geometry.vertices.push(polyline[i * 3 + j]);\n                tmpVertices.push(polyline[i * 3 + j]);\n            } else {\n                const highComp = Math.fround(polyline[i * 3 + j]);\n                const lowComp = polyline[i * 3 + j] - highComp;\n                geometry.vertices.push(highComp, lowComp);\n                tmpVertices.push(highComp, lowComp);\n            }\n            tmpNormal.setComponent(j, polyline[i * 3 + j]);\n        }\n\n        // Store the bitangent attribute (component-dependant).\n        for (let j = 0; j < 3; ++j) {\n            tmpTangent0.setComponent(j, tangents[T1 + j]);\n            tmpTangent1.setComponent(j, tangents[T2 + j]);\n        }\n        tmpTangent0.normalize();\n        geometry.vertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpVertices.push(tmpTangent0.x, tmpTangent0.y, tmpTangent0.z);\n        tmpNormal.add(center); // tmpNormal contains world position\n        projection.surfaceNormal(tmpNormal, tmpNormal);\n        const angle = computeBitangent(\n            tmpNormal,\n            tmpTangent0,\n            tmpTangent1.normalize(),\n            tmpBitangent\n        );\n        geometry.vertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n        tmpVertices.push(tmpBitangent.x, tmpBitangent.y, tmpBitangent.z, angle);\n\n        if (hasTexCoords) {\n            // uvs\n            geometry.vertices.push(uvs![i * 2], uvs![i * 2 + 1]);\n            tmpVertices.push(uvs![i * 2], uvs![i * 2 + 1]);\n            // normals\n            geometry.vertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n            tmpVertices.push(tmpNormal.x, tmpNormal.y, tmpNormal.z);\n        }\n\n        geometry.vertices.push(...tmpVertices);\n\n        // Add vertex colors (if supplied).\n        if (vertexColors) {\n            geometry.vertexColors.push(colors![i * 3], colors![i * 3 + 1], colors![i * 3 + 2]);\n            geometry.vertexColors.push(colors![i * 3], colors![i * 3 + 1], colors![i * 3 + 2]);\n        }\n    };\n\n    for (let i = 0; i < pointCount; ++i) {\n        // Retrieve the per-point tangents.\n        const T1 = isClosed && i === 0 ? tangents.length - 3 : Math.max(0, i - 1) * 3;\n        const T2 = isClosed && i === pointCount - 1 ? 0 : Math.min(i * 3, tangents.length - 3);\n\n        // Process v0 and v1.\n        if (i > 0) {\n            addVertexPair(i, T1, T2, segments[i - 1], segments[i]);\n        }\n\n        // Process v2 and v3.\n        if (i + 1 < pointCount) {\n            addVertexPair(\n                i,\n                T1,\n                T2,\n                segments[Math.min(i, segments.length - 1)] * -1,\n                segments[Math.min(i + 1, segments.length - 1)]\n            );\n        }\n    }\n\n    // Store the triangle indices in the final index buffer.\n    for (let i = 0; i < pointCount - 1; ++i) {\n        const base = baseVertex + i * 4;\n        geometry.indices.push(base, base + 1, base + 2, base + 2, base + 1, base + 3);\n    }\n\n    return geometry;\n}\n\n/**\n * Creates a [[LineGeometry]] object out of a polyline.\n *\n * @param polyline - Array of `numbers` describing a polyline.\n * @param colors - Array of `numbers` describing a polyline's colors.\n * @param geometry - [[LineGeometry]] object used to store the vertex and index attributes.\n */\nexport function createSimpleLineGeometry(\n    polyline: ArrayLike<number>,\n    colors?: ArrayLike<number>,\n    geometry = new LineGeometry()\n): LineGeometry {\n    if (polyline.length === 0) {\n        return geometry;\n    }\n\n    const pointCount = polyline.length / 3;\n    let index = geometry.vertices.length / 3;\n\n    const vertexColors = colors !== undefined && colors.length && polyline.length;\n\n    for (let i = 0; i < pointCount; ++i, index++) {\n        if (i > 0) {\n            geometry.indices.push(index);\n        }\n        if (i < pointCount - 1) {\n            geometry.indices.push(index);\n        }\n        for (let j = 0; j < 3; ++j) {\n            geometry.vertices.push(polyline[i * 3 + j]);\n            if (vertexColors) {\n                geometry.vertexColors.push(colors![i * 3 + j]);\n            }\n        }\n    }\n\n    return geometry;\n}\n\n/**\n * Class used to render groups (or batches) of width-variable lines (in the same tile).\n */\nexport class LineGroup {\n    /**\n     * Adds all the attribute data needed to a [[BufferGeometry]] object for rendering `Lines`.\n     *\n     * @param vertices - Array of vertex attributes.\n     * @param colors - Array of vertex colors.\n     * @param indices - Array of vertex indices.\n     * @param geometry - [[BufferGeometry]] object which will store all the `Lines` attribute data.\n     * @param hasNormalsAnUvs - Whether vertices have normal and uv coordinates as attributes.\n     * @param highPrecision - If `true` will create high-precision vertex information.\n     * @param isSimple - `true` to create simple (nonsolid, nonextruded) lines. Defaults to `false`.\n     */\n    static createGeometry(\n        vertices: ArrayLike<number>,\n        colors: ArrayLike<number>,\n        indices: ArrayLike<number>,\n        geometry: THREE.BufferGeometry,\n        hasNormalsAndUvs: boolean = false,\n        highPrecision = false,\n        isSimple = false\n    ): THREE.BufferGeometry {\n        if (isSimple) {\n            geometry.setAttribute(\n                \"position\",\n                new THREE.BufferAttribute(new Float32Array(vertices), 3)\n            );\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\n                    \"color\",\n                    new THREE.BufferAttribute(new Float32Array(colors), 3)\n                );\n            }\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n            return geometry;\n        } else {\n            const vertexDescriptor = getVertexDescriptor(hasNormalsAndUvs, highPrecision);\n\n            const buffer = new THREE.InterleavedBuffer(\n                new Float32Array(vertices),\n                vertexDescriptor.stride\n            );\n            vertexDescriptor.attributes.forEach(descr => {\n                const attribute = new THREE.InterleavedBufferAttribute(\n                    buffer,\n                    descr.itemSize,\n                    descr.offset,\n                    false\n                );\n                geometry.setAttribute(descr.name, attribute);\n            });\n            if (colors.length === vertices.length) {\n                geometry.setAttribute(\n                    \"color\",\n                    new THREE.BufferAttribute(new Float32Array(colors), 3)\n                );\n            }\n\n            geometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n\n            return geometry;\n        }\n    }\n\n    private readonly m_geometry: LineGeometry;\n\n    constructor(\n        readonly hasNormalsAndUvs: boolean = false,\n        readonly highPrecision: boolean = false,\n        readonly isSimple: boolean = false\n    ) {\n        this.m_geometry = new LineGeometry();\n    }\n\n    /**\n     * Clears the list of line strips.\n     */\n    clear() {\n        this.m_geometry.vertices = [];\n        this.m_geometry.vertexColors = [];\n        this.m_geometry.indices = [];\n    }\n\n    /**\n     * Add the given points to this line group.\n     *\n     * @param center - World center of the provided points.\n     * @param points - Sequence of (x,y,z) coordinates.\n     * @param offsets - Sequence of line segment offsets.\n     * @param uvs - Sequence of (u,v) texture coordinates.\n     * @param colors - Sequence of (r,g,b) color components.\n     */\n    add(\n        center: THREE.Vector3,\n        points: ArrayLike<number>,\n        projection: Projection,\n        offsets?: ArrayLike<number>,\n        uvs?: ArrayLike<number>,\n        colors?: ArrayLike<number>\n    ): this {\n        if (!this.isSimple) {\n            assert(!this.hasNormalsAndUvs || uvs !== undefined);\n            createLineGeometry(\n                center,\n                points,\n                projection,\n                offsets,\n                uvs,\n                colors,\n                this.m_geometry,\n                this.highPrecision\n            );\n        } else {\n            createSimpleLineGeometry(points, colors, this.m_geometry);\n        }\n        return this;\n    }\n\n    /**\n     * Returns the list of vertices.\n     */\n    get vertices(): number[] {\n        return this.m_geometry.vertices;\n    }\n\n    /**\n     * Returns the list of vertex colors.\n     */\n    get vertexColors(): number[] {\n        return this.m_geometry.vertexColors;\n    }\n\n    /**\n     * Returns the list of indices.\n     */\n    get indices(): number[] {\n        return this.m_geometry.indices;\n    }\n\n    /**\n     * Returns the list of [[VertexAttributeDescriptor]]s.\n     */\n    get vertexAttributes(): VertexAttributeDescriptor[] {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).attributes;\n    }\n\n    /**\n     * Returns the vertex attribute stride.\n     */\n    get stride(): number {\n        return getVertexDescriptor(this.hasNormalsAndUvs, this.highPrecision).stride;\n    }\n\n    /**\n     * Creates a three.js geometry.\n     */\n    createGeometry(geometry?: THREE.BufferGeometry): THREE.BufferGeometry {\n        if (geometry === undefined) {\n            geometry = new THREE.BufferGeometry();\n        }\n        return LineGroup.createGeometry(\n            this.m_geometry.vertices,\n            this.m_geometry.vertexColors,\n            this.m_geometry.indices,\n            geometry,\n            this.hasNormalsAndUvs,\n            this.highPrecision\n        );\n    }\n}\n\nfunction computeBitangent(\n    n: THREE.Vector3,\n    t0: THREE.Vector3,\n    t1: THREE.Vector3,\n    bt: THREE.Vector3\n): number {\n    let angle = 0;\n    if (!t0.equals(t1)) {\n        angle = Math.acos(t0.dot(t1)) * Math.sign(n.dot(tmpV.copy(t0).cross(t1)));\n        if (Number.isNaN(angle)) {\n            angle = 0;\n        }\n    }\n    bt.copy(t0).add(t1).normalize().cross(n).normalize();\n    return angle;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nconst UNIT_Z = new THREE.Vector3(0, 0, 1);\nconst POINTS = [0, 1, 2, 1, 3, 2];\nconst BEVEL_POINTS = [0, 1, 3, 3, 1, 2, 0, 3, 4, 5, 4, 3];\n\nconst SECTORS_IN_CIRCLE = 8;\nconst STEP = Math.PI / SECTORS_IN_CIRCLE;\n\n/**\n * Adds a half-circle geometry to original line\n *\n * @param x - The line end X (used as circle center X)\n * @param y - The line end Y (used as circle center Y)\n * @param lineAngle - The cap incline angle\n * @param radius - The cap (circle) radius\n * @param vertices - The input vertex buffer (cap vertices are added there)\n * @param indices - The input index buffer (cap indices are is added there)\n */\nfunction addCircle(\n    x: number,\n    y: number,\n    lineAngle: number,\n    radius: number,\n    vertices: number[],\n    indices: number[]\n) {\n    const baseVertex = vertices.length / 3;\n\n    // Add cap center to vertices directly (it doesn't need rotation)\n    vertices.push(x, y, 0);\n\n    for (let i = 0; i < SECTORS_IN_CIRCLE + 1; ++i) {\n        const angle = STEP * i + Math.PI / 2 + lineAngle; // Start angle is -90deg\n        vertices.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle), 0);\n\n        indices.push(\n            baseVertex,\n            baseVertex + i + 1,\n            baseVertex + ((i + 1) % (SECTORS_IN_CIRCLE + 1)) + 1\n        );\n    }\n}\n\n/**\n * Returns the number of points in circle used for caps.\n *\n * @param lineWidth - Width of line.\n */\nexport function numCirclePoints(lineWidth: number): number {\n    return SECTORS_IN_CIRCLE + 1;\n}\n\n/**\n * Create a triangle mesh from the given polyline.\n *\n * @param points - Sequence of (x,y,z) coordinates.\n * @param width - The width of the extruded line.\n * @param vertices - The output vertex buffer.\n * @param indices - The output index buffer.\n * @param startWithCircle - `true` if the line should start will a circle.\n * @param endWithCircle - `true` if the line should end with a circle.\n */\nexport function triangulateLine(\n    points: ArrayLike<number>,\n    width: number,\n    vertices: number[],\n    indices: number[],\n    startWithCircle = true,\n    endWithCircle = startWithCircle\n) {\n    if (points.length < 3) {\n        return;\n    }\n\n    // This vector is used for computing cap angle\n    const angleVec = new THREE.Vector2();\n\n    if (startWithCircle) {\n        // Define lineAngle as (direction - origin) vector angle to X axis\n        const lineAngle =\n            points.length !== 3\n                ? angleVec.set(points[3] - points[0], points[4] - points[1]).angle()\n                : 0;\n\n        addCircle(points[0], points[1], lineAngle, width, vertices, indices);\n    }\n\n    const baseVertex = vertices.length / 3;\n\n    // bt = Bitangent (i.e. extrusion vector)\n    const prevBt = new THREE.Vector3();\n    const p = new THREE.Vector3(); // current point\n    const n = new THREE.Vector3(); // next point\n    const bt = new THREE.Vector3();\n    const averageBt = new THREE.Vector3();\n    const p0 = new THREE.Vector3();\n    const p1 = new THREE.Vector3();\n    const p2 = new THREE.Vector3();\n    const p3 = new THREE.Vector3();\n\n    const N = points.length / 3;\n\n    let vertexOffset = 0;\n    for (let i = 0; i < N; ++i) {\n        let useBevel = false;\n        p.set(points[i * 3], points[i * 3 + 1], points[i * 3 + 2]);\n\n        if (i + 1 < N) {\n            n.set(points[(i + 1) * 3], points[(i + 1) * 3 + 1], points[(i + 1) * 3 + 2]);\n\n            bt.copy(n).sub(p).normalize().cross(UNIT_Z);\n\n            averageBt.copy(bt);\n\n            if (i > 0) {\n                averageBt.add(prevBt).multiplyScalar(1.0 - 0.5 * bt.dot(prevBt));\n\n                useBevel = prevBt.angleTo(bt) > Math.PI / 2;\n\n                if (useBevel) {\n                    const inclineWidth = width / Math.cos(bt.angleTo(prevBt) / 2);\n\n                    p0.copy(bt).add(prevBt).normalize().multiplyScalar(-inclineWidth).add(p);\n\n                    p1.copy(prevBt).multiplyScalar(width).add(p);\n\n                    // p2 is used for \"miter\" connections\n                    p2.copy(bt).add(prevBt).normalize().multiplyScalar(inclineWidth).add(p);\n\n                    p3.copy(bt).multiplyScalar(width).add(p);\n                }\n            }\n\n            if (useBevel) {\n                vertices.push(\n                    p0.x,\n                    p0.y,\n                    p0.z,\n                    p1.x,\n                    p1.y,\n                    p1.z,\n                    p2.x,\n                    p2.y,\n                    p2.z,\n                    p3.x,\n                    p3.y,\n                    p3.z\n                );\n            } else {\n                p0.copy(averageBt).multiplyScalar(-width).add(p);\n\n                p1.copy(averageBt).multiplyScalar(width).add(p);\n\n                vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n            }\n\n            prevBt.copy(bt);\n        } else {\n            p0.copy(prevBt).multiplyScalar(-width).add(p);\n\n            p1.copy(prevBt).multiplyScalar(width).add(p);\n\n            vertices.push(p0.x, p0.y, p0.z, p1.x, p1.y, p1.z);\n        }\n\n        if (i !== N - 1) {\n            (useBevel ? BEVEL_POINTS : POINTS).forEach(o =>\n                indices.push(baseVertex + vertexOffset + o)\n            );\n            vertexOffset += useBevel ? 4 : 2;\n        }\n    }\n\n    if (endWithCircle) {\n        const lineAngle =\n            points.length !== 2\n                ? angleVec\n                      .set(\n                          points[(N - 3) * 3] - points[(N - 2) * 3],\n                          points[(N - 3) * 3 + 1] - points[(N - 2) * 3 + 1]\n                      )\n                      .angle()\n                : Math.PI;\n\n        addCircle(\n            points[(N - 2) * 3],\n            points[(N - 2) * 3 + 1],\n            lineAngle,\n            width,\n            vertices,\n            indices\n        );\n    }\n}\n\n/**\n * Reconstruct the original points of a line from the vertices of the triangulated line.\n *\n * @param inBuffer - Buffer with vertices.\n * @param startOffset - Start index, will differ from `0` if the line has caps.\n * @returns Buffer containing the original points of the triangulated line.\n */\nexport function reconstructLine(inBuffer: Float32Array, startOffset: number): Float32Array {\n    const outBuffer = new Float32Array(inBuffer.length / 2);\n\n    for (let i = startOffset * 3, i2 = i * 2; i < outBuffer.length; i += 3, i2 += 6) {\n        outBuffer[i] = inBuffer[i2] + (inBuffer[i2 + 3] - inBuffer[i2]) * 0.5;\n        outBuffer[i + 1] = inBuffer[i2 + 1] + (inBuffer[i2 + 3 + 1] - inBuffer[i2 + 1]) * 0.5;\n        outBuffer[i + 2] = inBuffer[i2 + 2] + (inBuffer[i2 + 3 + 2] - inBuffer[i2 + 2]) * 0.5;\n    }\n    return outBuffer;\n}\n\n/**\n * Extract the line width from a triangulated line.\n *\n * @param inBuffer - Array of vertex elements of a triangulated line.\n * @param startIndex - Start index, will differ from `0` if the line has caps.\n */\nexport function reconstructLineWidth(inBuffer: Float32Array, startIndex: number): number {\n    const xd = inBuffer[startIndex * 2 + 3] - inBuffer[startIndex * 2];\n    const yd = inBuffer[startIndex * 2 + 3 + 1] - inBuffer[startIndex * 2 + 1];\n    const zd = inBuffer[startIndex * 2 + 3 + 2] - inBuffer[startIndex * 2 + 2];\n\n    return Math.sqrt(xd * xd + yd * yd + zd * zd) * 0.5;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * LRU cache.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/LRUCache\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\n\n/** @hidden */\nexport class Entry<Key, Value> {\n    constructor(\n        public key: Key,\n        public value: Value,\n        public size: number,\n        public newer: Entry<Key, Value> | null,\n        public older: Entry<Key, Value> | null\n    ) {}\n}\n\n/**\n * Fixed size cache that evicts its entries in least-recently-used order when it overflows.\n * Modeled after standard JavaScript `Map` otherwise.\n */\nexport class LRUCache<Key, Value> {\n    /**\n     * Optional callback that is called on every item that is evicted from the cache.\n     *\n     * **Note**: This callback is not called when an item is explicitly deleted from the map via\n     * [[delete]] or [[clear]].\n     */\n    evictionCallback?: (key: Key, value: Value) => void;\n\n    /**\n     * Optional callback that is called on every item that should be evicted from the cache to\n     * determine if it can be removed, or should be locked in the cache.\n     *\n     * It returns `true` if the item can be removed from cache, `false` otherwise. Locking items in\n     * the cache should be a temporary measure, since if the cache is filled with non-evictable\n     * items only, it may grow beyond its capacity.\n     *\n     * **Note**: This callback is not called when an item is explicitly deleted from the map via\n     * [[delete]] or [[clear]].\n     */\n    canEvict?: (key: Key, value: Value) => boolean;\n    private m_capacity: number;\n    private m_size = 0;\n\n    /**\n     * The internal map object that keeps the key-value pairs and their order.\n     */\n    private readonly m_map = new Map<Key, Entry<Key, Value>>();\n\n    /**\n     * The newest entry, i.e. the most recently used item.\n     */\n    private m_newest: Entry<Key, Value> | null = null;\n\n    /**\n     * The oldest entry, i.e. the least recently used item.\n     */\n    private m_oldest: Entry<Key, Value> | null = null;\n\n    /**\n     * A function determining the size per element.\n     */\n    private m_sizeFunction: (v: Value) => number;\n\n    /**\n     * Creates a new instance of `LRUCache`.\n     *\n     * The optional [[sizeFunction]] can be used to fine tune the memory consumption of all cached\n     * elements, thus [[cacheCapacity]] means then memory used (in MBs). Otherwise, if\n     * [[sizeFunction]] is not specified, the [[cacheCapacity]] accounts for the maximum\n     * number of elements stored.\n     *\n     * @param cacheCapacity - Number used to configure the maximum cache size, may express\n     * number of entries or memory consumed in megabytes depending on [[sizeFunction]].\n     * @param sizeFunction - A function determining the size per element.\n     */\n    constructor(cacheCapacity: number, sizeFunction: (v: Value) => number = () => 1) {\n        this.m_capacity = cacheCapacity;\n        this.m_sizeFunction = sizeFunction;\n    }\n\n    /**\n     * Iterates over all items from the most recently used item to the least recently used one.\n     *\n     * **Note**: Results are undefined if the entire cache is modified during iteration. You may\n     * although modify the current element in [[callbackfn]] function.\n     *\n     * @param callbackfn - The callback to call for each item.\n     * @param thisArg - Optional this argument for the callback.\n     */\n    forEach(\n        callbackfn: (value: Value, key: Key, map: LRUCache<Key, Value>) => void,\n        thisArg?: any\n    ): void {\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const older = entry.older;\n            callbackfn.call(thisArg, entry.value, entry.key, this);\n            entry = older;\n        }\n    }\n\n    /**\n     * The size of the cache, i.e. the sum of all the sizes of all the objects in the cache.\n     *\n     * @returns The size of the cache.\n     */\n    get size(): number {\n        return this.m_size;\n    }\n\n    /**\n     * Returns the maximum capacity of the cache, i.e. the maximum number of elements this cache\n     * can contain or the total amount of memory that may be consumed by cache if element size\n     * function was specified in cache c-tor.\n     *\n     * @returns The capacity of the cache.\n     */\n    get capacity(): number {\n        return this.m_capacity;\n    }\n\n    /**\n     * @deprecated - DO NOT USE. Will be removed in future versions.\n     *\n     * Returns the internal map object that keeps the key-value pairs and their order.\n     *\n     * @returns The internal map object.\n     */\n    get map(): Map<Key, Entry<Key, Value>> {\n        // ### TODO - remove me. Cache must not expose its internal object,\n        // modifications to it are fatal for the internal state machine.\n        return this.m_map;\n    }\n\n    /**\n     * Returns the newest entry in the cache.\n     *\n     * @returns Newest entry in the cache.\n     */\n    get newest(): Entry<Key, Value> | null {\n        return this.m_newest;\n    }\n\n    /**\n     * Returns the oldest entry in the cache.\n     *\n     * Note: Does not promote the oldest item as most recently used item.\n     *\n     * @returns Oldest entry in the cache.\n     */\n    get oldest(): Entry<Key, Value> | null {\n        return this.m_oldest;\n    }\n\n    /**\n     * Resets the capacity of this cache. If `newCapacity` is smaller than the current cache size,\n     * all items will be evicted until the cache shrinks to `newCapacity`.\n     *\n     * @param newCapacity - The new capacity of this cache.\n     */\n    setCapacity(newCapacity: number): void {\n        this.m_capacity = newCapacity;\n        this.evict();\n    }\n\n    /**\n     * Resets the cache capacity and function used to measure the element size.\n     *\n     * @param newCapacity - The new capacity masured in units returned from [[sizeMeasure]] funtion.\n     * @param sizeMeasure - Function that defines the size of element, if you want to measure\n     * number of elements only always return 1 from this function (default), you may also\n     * specify own function that measures entries by memory consumed, nubmer of sub-elements, etc.\n     */\n    setCapacityAndMeasure(newCapacity: number, sizeMeasure: (v: Value) => number = () => 1) {\n        this.m_capacity = newCapacity;\n        this.m_sizeFunction = sizeMeasure;\n        this.shrinkToCapacity();\n    }\n\n    /**\n     * Updates the size of all elements in this cache. If their aggregated size is larger than the\n     * capacity, items will be evicted until the cache shrinks to fit the capacity.\n     */\n    shrinkToCapacity(): void {\n        let size = 0;\n        const sizeFunction = this.m_sizeFunction;\n\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entrySize = sizeFunction(entry.value);\n            entry.size = entrySize;\n            size += entrySize;\n            entry = entry.older;\n        }\n\n        this.m_size = size;\n        this.evict();\n    }\n\n    /**\n     * Inserts or updates a key/value pair in the cache.\n     *\n     * If the key already existed in the cache, it will be updated and promoted to the most recently\n     * used item.\n     *\n     * If the key didn't exist in the cache, it will be inserted as most recently used item. An\n     * eviction of the least recently used item takes place if the cache exceeded its capacity.\n     *\n     * @param key - The key for the key-value pair to insert or update.\n     * @param value - The value for the key-value pair to insert or update.\n     */\n    set(key: Key, value: Value) {\n        const valueSize = this.m_sizeFunction(value);\n        let entry = this.m_map.get(key);\n        if (entry !== undefined) {\n            this.m_size = this.m_size - entry.size + valueSize;\n            entry.value = value;\n            entry.size = valueSize;\n            this.promoteEntry(entry);\n            this.evict();\n        } else {\n            if (valueSize > this.m_capacity) {\n                return; // single item too big to cache\n            }\n\n            entry = new Entry<Key, Value>(key, value, valueSize, null, null);\n            if (this.m_map.size === 0) {\n                this.m_newest = this.m_oldest = entry;\n            } else {\n                assert(this.m_newest !== null);\n                const newest: Entry<Key, Value> = this.m_newest!;\n                entry.older = this.m_newest;\n                newest.newer = entry;\n                this.m_newest = entry;\n            }\n            this.m_map.set(key, entry);\n            this.m_size += valueSize;\n            this.evict();\n        }\n    }\n\n    /**\n     * Looks up key in the cache and returns the associated value.\n     *\n     * @param key - The key to look up.\n     * @returns The associated value, or `undefined` if the key-value pair is not in the cache.\n     */\n    get(key: Key): Value | undefined {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return undefined;\n        }\n\n        this.promoteEntry(entry);\n        return entry.value;\n    }\n\n    /**\n     * Test if a key/value pair is in the cache.\n     *\n     * @param key - The key to look up.\n     * @returns `true` if the key-value pair is in the cache, `false` otherwise.\n     */\n    has(key: Key): boolean {\n        return this.m_map.has(key);\n    }\n\n    /**\n     * Clears the cache and removes all stored key-value pairs.\n     *\n     * Does not call the eviction callback. Use [[evictAll]] to clear the cache and call the\n     * eviction callback.\n     */\n    clear(): void {\n        this.m_newest = this.m_oldest = null;\n        this.m_size = 0;\n        this.m_map.clear();\n    }\n\n    /**\n     * Evicts all items from the cache, calling the eviction callback on each item.\n     *\n     * Use [[clear]] to remove all items without calling the eviction callback.\n     */\n    evictAll(): void {\n        const cb = this.evictionCallback;\n        if (cb !== undefined) {\n            this.forEach((value, key) => cb(key, value));\n        }\n        this.clear();\n    }\n\n    /**\n     * Evict selected elements from the cache using [[selector]] function.\n     *\n     * @param selector - The function for selecting elements for eviction.\n     * @param thisArg - Optional _this_ object reference.\n     */\n    evictSelected(selector: (value: Value, key: Key) => boolean, thisArg?: any) {\n        const cb = this.evictionCallback;\n        let entry = this.m_newest;\n        while (entry !== null) {\n            const entryOlder = entry.older;\n            if (selector.call(thisArg, entry.value, entry.key)) {\n                if (cb !== undefined) {\n                    cb(entry.key, entry.value);\n                }\n                this.deleteEntry(entry);\n                this.m_map.delete(entry.key);\n            }\n            entry = entryOlder;\n        }\n    }\n\n    /**\n     * Explicitly removes a key-value pair from the cache.\n     *\n     * **Note**: This is an explicit removal, thus, the eviction callback will not be called.\n     *\n     * @param key - The key of the key-value pair to delete.\n     * @returns `true` if the key-value pair existed and was deleted, `false` otherwise.\n     */\n    delete(key: Key): boolean {\n        const entry = this.m_map.get(key);\n        if (entry === undefined) {\n            return false;\n        }\n        this.deleteEntry(entry);\n        return this.m_map.delete(key);\n    }\n\n    protected evict() {\n        while (this.m_oldest !== null && this.m_size > this.m_capacity) {\n            const evicted = this.evictOldest();\n            if (evicted === undefined) {\n                return;\n            }\n        }\n    }\n\n    protected evictOldest(): Entry<Key, Value> | undefined {\n        assert(this.m_oldest !== null);\n        const oldest = this.m_oldest!;\n        assert(oldest.older === null);\n        let itemToRemove = oldest;\n\n        if (this.canEvict !== undefined) {\n            while (!this.canEvict(itemToRemove.key, itemToRemove.value)) {\n                if (itemToRemove.newer === null) {\n                    return undefined;\n                }\n                itemToRemove = itemToRemove.newer;\n            }\n        }\n\n        if (itemToRemove === oldest) {\n            this.m_oldest = itemToRemove.newer;\n            if (itemToRemove.newer !== null) {\n                assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = null;\n            }\n        } else {\n            if (itemToRemove.newer !== null) {\n                assert(itemToRemove.newer.older === itemToRemove);\n                itemToRemove.newer.older = itemToRemove.older;\n                if (itemToRemove.older !== null) {\n                    itemToRemove.older.newer = itemToRemove.newer;\n                }\n            } else {\n                return undefined;\n            }\n        }\n\n        const isOk = this.m_map.delete(itemToRemove.key);\n        assert(isOk === true);\n        if (isOk && this.evictionCallback !== undefined) {\n            this.evictionCallback(itemToRemove.key, itemToRemove.value);\n        }\n        this.m_size -= itemToRemove.size;\n        return itemToRemove;\n    }\n\n    private deleteEntry(entry: Entry<Key, Value>): void {\n        if (entry === this.m_newest) {\n            this.m_newest = entry.older;\n        } else if (entry.newer) {\n            entry.newer.older = entry.older;\n        } else {\n            assert(false);\n        }\n\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        } else if (entry.older) {\n            entry.older.newer = entry.newer;\n        } else {\n            assert(false);\n        }\n\n        this.m_size -= entry.size;\n    }\n\n    private promoteEntry(entry: Entry<Key, Value>): void {\n        if (entry === this.m_newest) {\n            return;\n        } // already newest, nothing to do\n\n        // re-link newer and older items\n        if (entry.newer) {\n            assert(entry.newer.older === entry);\n            entry.newer.older = entry.older;\n        }\n        if (entry.older) {\n            assert(entry.older.newer === entry);\n            entry.older.newer = entry.newer;\n        }\n        if (entry === this.m_oldest) {\n            this.m_oldest = entry.newer;\n        }\n        // re-link ourselves\n        entry.newer = null;\n        entry.older = this.m_newest;\n\n        // finally, set ourselves as the newest entry\n        assert(this.m_newest !== null);\n        const newest = this.m_newest!;\n        assert(newest.newer === null);\n        newest.newer = entry;\n        this.m_newest = entry;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as geoUtils from \"@here/harp-geoutils\";\nimport {\n    CameraUtils,\n    EventDispatcher,\n    MapView,\n    MapViewEventNames,\n    MapViewUtils\n} from \"@here/harp-mapview\";\nimport * as THREE from \"three\";\n\nimport * as utils from \"./Utils\";\n\nenum State {\n    NONE,\n    PAN,\n    ROTATE,\n    ORBIT,\n    TOUCH\n}\n\nexport enum TiltState {\n    Tilted,\n    Down\n}\n\ninterface TouchState {\n    currentTouchPoint: THREE.Vector2;\n    lastTouchPoint: THREE.Vector2;\n    currentWorldPosition: THREE.Vector3;\n    initialWorldPosition: THREE.Vector3;\n}\n\n/**\n * Map interaction events' names.\n */\nexport enum EventNames {\n    Update = \"update\",\n    BeginInteraction = \"begin-interaction\",\n    EndInteraction = \"end-interaction\"\n}\n\n// cast needed to workaround wrong three.js typings.\nconst MAPCONTROL_EVENT: THREE.Event = { type: EventNames.Update } as any;\nconst MAPCONTROL_EVENT_BEGIN_INTERACTION: THREE.Event = {\n    type: EventNames.BeginInteraction\n} as any;\nconst MAPCONTROL_EVENT_END_INTERACTION: THREE.Event = {\n    type: EventNames.EndInteraction\n} as any;\n\n/**\n * The number of user's inputs to consider for panning inertia, to reduce erratic inputs.\n */\nconst USER_INPUTS_TO_CONSIDER = 5;\n\n/**\n * The default maximum for the camera tilt. This value avoids seeing the horizon.\n */\nconst DEFAULT_MAX_TILT_ANGLE = THREE.MathUtils.degToRad(89);\n\n/**\n * Epsilon value to rule out when a number can be considered 0.\n */\nconst EPSILON = 0.01;\n\n/**\n * Maximum duration between start and end touch events to define a finger tap.\n */\nconst MAX_TAP_DURATION = 120;\n\n/**\n * This map control provides basic map-related building blocks to interact with the map. It also\n * provides a default way of handling user input. Currently we support basic mouse interaction and\n * touch input interaction.\n *\n * Mouse interaction:\n *  - Left mouse button + move = Panning the map.\n *  - Right mouse button + move = Orbits the camera around the focus point.\n *  - Middle mouse button + move = Rotating the view. Up down movement changes the pitch. Left/right\n *    movement changes the yaw.\n *  - Mouse wheel = Zooms up and down by one zoom level, zooms on target.\n *\n * Touch interaction:\n *  - One finger = Panning the map.\n *  - Two fingers = Scale, rotate and panning the map.\n *  - Three fingers = Orbiting the map. Up down movements influences the current orbit altitude.\n *    Left/right changes the azimuth.\n */\nexport class MapControls extends EventDispatcher {\n    /**\n     * Creates MapControls object and attaches it specified [[MapView]].\n     *\n     * @param mapView - [[MapView]] object to which MapControls should be attached to.\n     * @param disposeWithMapView - If `true`, an event with MapView is registered to dispose of\n     * `MapControls` if MapView itself is disposed.\n     */\n    static create(mapView: MapView, disposeWithMapView = true) {\n        return new MapControls(mapView, disposeWithMapView);\n    }\n\n    /**\n     * This factor will be applied to the delta of the current mouse pointer position and the last\n     * mouse pointer position: The result then will be used as an offset for the rotation then.\n     * Default value is `0.1`.\n     */\n    rotationMouseDeltaFactor = 0.1;\n\n    /**\n     * This factor will be applied to the delta of the current mouse pointer position and the last\n     * mouse pointer position: The result then will be used as an offset to orbit the camera.\n     * Default value is `0.1`.\n     */\n    orbitingMouseDeltaFactor = 0.1 * THREE.MathUtils.DEG2RAD;\n\n    /**\n     * This factor will be applied to the delta of the current touch pointer position and the last\n     * touch pointer position: The result then will be used as an offset to orbit the camera.\n     * Default value is `0.1`.\n     */\n    orbitingTouchDeltaFactor = 0.1 * THREE.MathUtils.DEG2RAD;\n\n    /**\n     * Set to `true` to enable input handling through this map control, `false` to disable input\n     * handling. Even when disabling input handling, you can manually use the public functions to\n     * change the view to the current map.\n     */\n    enabled = true;\n\n    /**\n     * Set to `true` to enable zooming through these controls, `false` otherwise.\n     */\n    zoomEnabled = true;\n\n    /**\n     * Set to `true` to enable panning through these controls, `false` otherwise.\n     */\n    panEnabled = true;\n\n    /**\n     * Set to `true` to enable tilting through these controls, `false` otherwise.\n     */\n    tiltEnabled = true;\n\n    /**\n     * Set to `true` to enable rotation through this map control, `false` to disable rotation.\n     */\n    rotateEnabled = true;\n\n    /**\n     * Set to `true` to enable an inertia dampening on zooming and panning. `false` cancels inertia.\n     */\n    inertiaEnabled = true;\n\n    /**\n     * Inertia damping duration for the zoom, in seconds.\n     */\n    zoomInertiaDampingDuration = 0.6;\n\n    /**\n     * Inertia damping duration for the panning, in seconds.\n     */\n    panInertiaDampingDuration = 1.0;\n\n    /**\n     * Duration in seconds of the camera animation when the tilt button is clicked. Independent of\n     * inertia.\n     */\n    tiltToggleDuration = 0.5;\n\n    /**\n     * Camera tilt to the target when tilting from the `toggleTilt` public method.\n     */\n    tiltAngle = Math.PI / 4;\n\n    /**\n     * Duration of the animation to reset the camera to looking north, in seconds. Independent of\n     * inertia.\n     */\n    northResetAnimationDuration = 1.5;\n\n    /**\n     * Determines the zoom level delta for single mouse wheel movement. So after each mouse wheel\n     * movement the current zoom level will be added or subtracted by this value.\n     *\n     * The default values are:\n     * - `0.2` when `inertiaEnabled` is `false` - this means that every 5th mouse wheel movement\n     * you will cross a zoom level.\n     * - `0.8`, otherwise.\n     */\n    get zoomLevelDeltaOnMouseWheel(): number {\n        return this.m_zoomLevelDeltaOnMouseWheel !== undefined\n            ? this.m_zoomLevelDeltaOnMouseWheel\n            : this.inertiaEnabled\n            ? 0.8\n            : 0.2;\n    }\n\n    /**\n     * Set the zoom level delta for a single mouse wheel movement.\n     *\n     * **Note**: To reverse the zoom direction, you can provide a negative value.\n     */\n    set zoomLevelDeltaOnMouseWheel(delta: number) {\n        this.m_zoomLevelDeltaOnMouseWheel = delta;\n    }\n\n    /**\n     * @private\n     */\n    private m_zoomLevelDeltaOnMouseWheel?: number;\n\n    /**\n     * Zoom level delta when using the UI controls.\n     */\n    zoomLevelDeltaOnControl = 1.0;\n\n    /**\n     * Determines the minimum zoom level we can zoom to.\n     */\n    minZoomLevel = 0;\n\n    /**\n     * Determines the maximum zoom level we can zoom to.\n     */\n    maxZoomLevel = 20;\n\n    /**\n     * Determines the minimum camera height in meter.\n     */\n    minCameraHeight = 3;\n\n    /**\n     * Zoom level delta to apply when double clicking or double tapping. `0` disables the feature.\n     */\n    zoomLevelDeltaOnDoubleClick = 1.0;\n\n    /**\n     * Double click uses the OS delay through the double click event. Tapping is implemented locally\n     * here in `MapControls` with this duration setting the maximum delay to define a double tap.\n     * The value is in seconds. `300ms` is picked as the default value as jQuery does.\n     */\n    doubleTapTime = 0.3;\n\n    /**\n     * Three.js camera that this controller affects.\n     */\n    readonly camera: THREE.Camera;\n\n    /**\n     * Map's HTML DOM element.\n     */\n    readonly domElement: HTMLCanvasElement;\n\n    private readonly m_currentViewDirection = new THREE.Vector3();\n\n    private readonly m_lastMousePosition = new THREE.Vector2(0, 0);\n    private readonly m_initialMousePosition = new THREE.Vector2(0, 0);\n    private readonly m_mouseDelta = new THREE.Vector2(0, 0);\n\n    private m_needsRenderLastFrame: boolean = true;\n\n    // Internal variables for animating panning (planar + spherical panning).\n    private m_panIsAnimated: boolean = false;\n    private readonly m_panDistanceFrameDelta: THREE.Vector3 = new THREE.Vector3();\n    private m_panAnimationTime: number = 0;\n    private m_panAnimationStartTime: number = 0;\n    private m_lastAveragedPanDistanceOrAngle: number = 0;\n    private m_currentInertialPanningSpeed: number = 0;\n    private readonly m_lastPanVector: THREE.Vector3 = new THREE.Vector3();\n    private readonly m_rotateGlobeQuaternion: THREE.Quaternion = new THREE.Quaternion();\n    private readonly m_lastRotateGlobeAxis: THREE.Vector3 = new THREE.Vector3();\n    private m_lastRotateGlobeAngle: number = 0;\n    private readonly m_lastRotateGlobeFromVector: THREE.Vector3 = new THREE.Vector3();\n    private m_recentPanDistancesOrAngles: [number, number, number, number, number] = [\n        0,\n        0,\n        0,\n        0,\n        0\n    ];\n\n    private m_currentPanDistanceOrAngleIndex: number = 0;\n\n    // Internal variables for animating zoom.\n    private m_zoomIsAnimated: boolean = false;\n    private m_zoomDeltaRequested: number = 0;\n    private readonly m_zoomTargetNormalizedCoordinates: THREE.Vector2 = new THREE.Vector2();\n    private m_zoomAnimationTime: number = 0;\n    private m_zoomAnimationStartTime: number = 0;\n    private m_startZoom: number = 0;\n    private m_targetedZoom?: number;\n    private m_currentZoom?: number;\n\n    // Internal variables for animating tilt.\n    private m_tiltIsAnimated: boolean = false;\n    private m_tiltRequested?: number = undefined;\n    private m_tiltAnimationTime: number = 0;\n    private m_tiltAnimationStartTime: number = 0;\n    private m_startTilt: number = 0;\n    private m_targetedTilt?: number;\n    private m_currentTilt?: number;\n\n    private m_tiltState?: TiltState;\n    private m_state: State = State.NONE;\n\n    private readonly m_tmpVector2: THREE.Vector2 = new THREE.Vector2();\n    private readonly m_tmpVector3: THREE.Vector3 = new THREE.Vector3();\n\n    // Internal variables for animating double tap.\n    private m_tapStartTime: number = 0;\n    private m_lastSingleTapTime: number = 0;\n    private m_fingerMoved: boolean = false;\n    private m_isDoubleTap: boolean = false;\n\n    // Internal variables for animating the movement resetting the north.\n    private m_resetNorthStartTime: number = 0;\n    private m_resetNorthIsAnimated: boolean = false;\n    private m_resetNorthAnimationDuration: number = 0;\n    private m_currentAzimuth: number = 0;\n    private m_lastAzimuth: number = 0;\n    private m_startAzimuth: number = 0;\n\n    /**\n     * Determines the maximum angle the camera can tilt to. It is defined in radians.\n     */\n    private m_maxTiltAngle = DEFAULT_MAX_TILT_ANGLE;\n\n    private m_cleanupMouseEventListeners?: () => void;\n\n    private m_touchState: {\n        touches: TouchState[];\n        currentRotation: number;\n        initialRotation: number;\n    } = {\n        touches: [],\n        currentRotation: 0,\n        initialRotation: 0\n    };\n\n    /**\n     * Constructs a new `MapControls` object.\n     *\n     * @param mapView - [[MapView]] this controller modifies.\n     * @param disposeWithMapView - If `true`, an event with MapView is registered to dispose of\n     * `MapControls` if MapView itself is disposed.\n     */\n    constructor(readonly mapView: MapView, disposeWithMapView = true) {\n        super();\n\n        this.camera = mapView.camera;\n        this.domElement = mapView.renderer.domElement;\n        this.maxZoomLevel = mapView.maxZoomLevel;\n        this.minZoomLevel = mapView.minZoomLevel;\n        this.minCameraHeight = mapView.minCameraHeight;\n        this.bindInputEvents(this.domElement);\n        this.handleZoom = this.handleZoom.bind(this);\n        this.handlePan = this.handlePan.bind(this);\n        this.tilt = this.tilt.bind(this);\n        this.resetNorth = this.resetNorth.bind(this);\n        this.assignZoomAfterTouchZoomRender = this.assignZoomAfterTouchZoomRender.bind(this);\n\n        if (disposeWithMapView) {\n            // Catch the disposal of `MapView`.\n            mapView.addEventListener(MapViewEventNames.Dispose, () => {\n                this.dispose();\n            });\n        }\n    }\n\n    /**\n     * Destroy this `MapControls` instance.\n     *\n     * Unregisters all global event handlers used. This is method should be called when you stop\n     * using `MapControls`.\n     * @override\n     */\n    dispose = () => {\n        // replaced with real code in bindInputEvents\n    };\n\n    /**\n     * Current viewing angles yaw/pitch/roll in degrees.\n     */\n    get attitude(): MapViewUtils.Attitude {\n        const attitude = MapViewUtils.extractAttitude(this.mapView, this.camera);\n        return {\n            yaw: THREE.MathUtils.radToDeg(attitude.yaw),\n            pitch: THREE.MathUtils.radToDeg(attitude.pitch),\n            roll: THREE.MathUtils.radToDeg(attitude.roll)\n        };\n    }\n\n    /**\n     * Reset the camera to looking north, in an orbiting movement around the target point instead\n     * of changing the yaw (which would be the camera rotating on itself).\n     */\n    pointToNorth() {\n        // Use pre-calculated target coordinates, otherwise we could call utility method to evaluate\n        // geo-coordinates here:\n        // targetGeoCoords = MapViewUtils.getTargetCoordinatesFromCamera(camera, projection)\n        this.m_startAzimuth =\n            Math.PI +\n            MapViewUtils.extractSphericalCoordinatesFromLocation(\n                this.mapView,\n                this.camera,\n                this.mapView.target\n            ).azimuth;\n        // Wrap between -PI and PI.\n        this.m_startAzimuth = Math.atan2(\n            Math.sin(this.m_startAzimuth),\n            Math.cos(this.m_startAzimuth)\n        );\n        if (this.m_startAzimuth === 0) {\n            return;\n        }\n        this.stopExistingAnimations();\n        this.m_resetNorthAnimationDuration = this.northResetAnimationDuration;\n        this.m_currentAzimuth = this.m_startAzimuth;\n        this.m_resetNorthStartTime = performance.now();\n        this.resetNorth();\n    }\n\n    /**\n     * Zooms and moves the map in such a way that the given target position remains at the same\n     * position after the zoom.\n     *\n     * @param targetPositionOnScreenXinNDC - Target x position in NDC space.\n     * @param targetPositionOnScreenYinNDC - Target y position in NDC space.\n     */\n    zoomOnTargetPosition(\n        targetPositionOnScreenXinNDC: number,\n        targetPositionOnScreenYinNDC: number,\n        zoomLevel: number\n    ) {\n        MapViewUtils.zoomOnTargetPosition(\n            this.mapView,\n            targetPositionOnScreenXinNDC,\n            targetPositionOnScreenYinNDC,\n            zoomLevel,\n            this.m_maxTiltAngle\n        );\n    }\n\n    /**\n     * Zooms to the desired location by the provided value.\n     *\n     * @param zoomLevel - Zoom level.\n     * @param screenTarget - Zoom target on screen.\n     */\n    setZoomLevel(\n        zoomLevel: number,\n        screenTarget: { x: number; y: number } | THREE.Vector2 = { x: 0, y: 0 }\n    ) {\n        if (!this.enabled || !this.zoomEnabled) {\n            return;\n        }\n\n        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n\n        // Register the zoom request\n        this.m_startZoom = this.currentZoom;\n        this.m_zoomDeltaRequested = zoomLevel - this.zoomLevelTargeted;\n\n        this.stopExistingAnimations();\n\n        // Assign the new animation start time.\n        this.m_zoomAnimationStartTime = performance.now();\n\n        this.m_zoomTargetNormalizedCoordinates.set(screenTarget.x, screenTarget.y);\n\n        this.handleZoom();\n\n        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n    }\n\n    /**\n     * Toggles the camera tilt between 0 (looking down) and the value at `this.tiltAngle`.\n     */\n    toggleTilt(): void {\n        if (!this.enabled || !this.tiltEnabled) {\n            return;\n        }\n\n        this.stopExistingAnimations();\n        this.m_startTilt = this.currentTilt;\n        const aimTilt = this.m_startTilt < EPSILON;\n        this.m_tiltRequested = aimTilt ? this.tiltAngle : 0;\n        this.m_tiltState = aimTilt ? TiltState.Tilted : TiltState.Down;\n        this.m_tiltAnimationStartTime = performance.now();\n        this.tilt();\n    }\n\n    /**\n     * Set the camera height.\n     */\n    set cameraHeight(height: number) {\n        //Set the cameras height according to the given zoom level.\n        this.camera.position.setZ(height);\n        this.camera.matrixWorldNeedsUpdate = true;\n    }\n\n    /**\n     * Get the current camera height.\n     */\n    get cameraHeight(): number {\n        // ### Sync with the way geoviz is computing the zoom level.\n        return this.mapView.camera.position.z;\n    }\n\n    /**\n     * Set camera max tilt angle. The value is clamped between 0 and 89 degrees. In sphere\n     * projection, at runtime, the value is also clamped so that the camera does not look above the\n     * horizon.\n     *\n     * @param angle - Angle in degrees.\n     */\n    set maxTiltAngle(angle: number) {\n        this.m_maxTiltAngle = Math.max(\n            0,\n            Math.min(DEFAULT_MAX_TILT_ANGLE, THREE.MathUtils.degToRad(angle))\n        );\n    }\n\n    /**\n     * Get the camera max tilt angle in degrees.\n     */\n    get maxTiltAngle(): number {\n        return THREE.MathUtils.radToDeg(this.m_maxTiltAngle);\n    }\n\n    /**\n     * Get the zoom level targeted by `MapControls`. Useful when inertia is on, to add incremented\n     * values to the target instead of getting the random zoomLevel value during the interpolation.\n     */\n    get zoomLevelTargeted(): number {\n        return this.m_targetedZoom === undefined ? this.currentZoom : this.m_targetedZoom;\n    }\n\n    /**\n     * Handy getter to know if the view is in the process of looking down or not.\n     */\n    get tiltState(): TiltState {\n        if (this.m_tiltState === undefined) {\n            this.m_tiltState =\n                this.currentTilt < EPSILON || this.m_tiltState === TiltState.Down\n                    ? TiltState.Tilted\n                    : TiltState.Down;\n        }\n        return this.m_tiltState;\n    }\n\n    private set currentZoom(zoom: number) {\n        this.m_currentZoom = zoom;\n    }\n\n    private get currentZoom(): number {\n        return this.m_currentZoom !== undefined ? this.m_currentZoom : this.mapView.zoomLevel;\n    }\n\n    private set currentTilt(tilt: number) {\n        this.m_currentTilt = tilt;\n    }\n\n    private get currentTilt(): number {\n        return THREE.MathUtils.degToRad(this.mapView.tilt);\n    }\n\n    private get targetedTilt(): number {\n        return this.m_targetedTilt === undefined\n            ? this.m_currentTilt === undefined\n                ? this.currentTilt\n                : this.m_currentTilt\n            : this.m_targetedTilt;\n    }\n\n    private assignZoomAfterTouchZoomRender() {\n        this.m_currentZoom = this.mapView.zoomLevel;\n        this.m_targetedZoom = this.mapView.zoomLevel;\n        this.mapView.removeEventListener(\n            MapViewEventNames.AfterRender,\n            this.assignZoomAfterTouchZoomRender\n        );\n    }\n\n    private stopExistingAnimations() {\n        this.stopResetNorth();\n        this.stopZoom();\n        this.stopPan();\n        this.stopTilt();\n    }\n\n    private resetNorth() {\n        const currentTime = performance.now();\n        const animationTime = (currentTime - this.m_resetNorthStartTime) / 1000;\n        if (this.inertiaEnabled) {\n            if (!this.m_resetNorthIsAnimated) {\n                this.m_resetNorthIsAnimated = true;\n                this.mapView.addEventListener(MapViewEventNames.AfterRender, this.resetNorth);\n            }\n            const resetNorthFinished = animationTime > this.m_resetNorthAnimationDuration;\n            if (resetNorthFinished) {\n                if (this.m_needsRenderLastFrame) {\n                    this.m_needsRenderLastFrame = false;\n                    this.stopResetNorth();\n                }\n            } else {\n                this.m_needsRenderLastFrame = true;\n            }\n        }\n        this.m_lastAzimuth = this.m_currentAzimuth;\n        this.m_currentAzimuth = this.inertiaEnabled\n            ? this.easeOutCubic(\n                  this.m_startAzimuth,\n                  0,\n                  Math.min(1, animationTime / this.m_resetNorthAnimationDuration)\n              )\n            : 0;\n\n        const deltaAzimuth = this.m_currentAzimuth - this.m_lastAzimuth;\n\n        MapViewUtils.orbitAroundScreenPoint(this.mapView, {\n            deltaAzimuth,\n            maxTiltAngle: this.m_maxTiltAngle\n        });\n        this.updateMapView();\n    }\n\n    private stopResetNorth() {\n        this.mapView.removeEventListener(MapViewEventNames.AfterRender, this.resetNorth);\n        this.m_resetNorthIsAnimated = false;\n    }\n\n    private tilt() {\n        if (this.m_tiltRequested !== undefined) {\n            this.m_targetedTilt = Math.max(Math.min(this.m_tiltRequested, this.maxTiltAngle), 0);\n            this.m_tiltRequested = undefined;\n        }\n\n        // Whether the tilt animation has reached full duration & a final frame is rendered. We need\n        // this to know when to stop the tilt (and hence deregister the methon )\n        let tiltAnimationFinished = false;\n        if (this.inertiaEnabled) {\n            if (!this.m_tiltIsAnimated) {\n                this.m_tiltIsAnimated = true;\n                this.mapView.addEventListener(MapViewEventNames.AfterRender, this.tilt);\n            }\n            const currentTime = performance.now();\n            this.m_tiltAnimationTime = (currentTime - this.m_tiltAnimationStartTime) / 1000;\n            const tiltFinished = this.m_tiltAnimationTime >= this.tiltToggleDuration;\n            if (tiltFinished) {\n                if (this.m_needsRenderLastFrame) {\n                    this.m_needsRenderLastFrame = false;\n                    this.m_tiltAnimationTime = this.tiltToggleDuration;\n                    tiltAnimationFinished = true;\n                }\n            } else {\n                this.m_needsRenderLastFrame = true;\n            }\n        }\n\n        this.m_currentTilt = this.inertiaEnabled\n            ? this.easeOutCubic(\n                  this.m_startTilt,\n                  this.targetedTilt,\n                  Math.min(1, this.m_tiltAnimationTime / this.tiltToggleDuration)\n              )\n            : this.targetedTilt;\n\n        const initialTilt = this.currentTilt;\n        const deltaTilt = this.m_currentTilt - initialTilt;\n\n        MapViewUtils.orbitAroundScreenPoint(this.mapView, {\n            deltaTilt,\n            maxTiltAngle: this.m_maxTiltAngle\n        });\n        this.updateMapView();\n\n        if (tiltAnimationFinished) {\n            this.stopTilt();\n        }\n    }\n\n    private stopTilt() {\n        this.mapView.removeEventListener(MapViewEventNames.AfterRender, this.tilt);\n        this.m_tiltIsAnimated = false;\n        this.m_targetedTilt = this.m_currentTilt = undefined;\n    }\n\n    private easeOutCubic(startValue: number, endValue: number, time: number): number {\n        // https://easings.net/#easeOutCubic\n        return startValue + (endValue - startValue) * (1 - Math.pow(1 - time, 3));\n    }\n\n    private easeOutCirc(startValue: number, endValue: number, time: number): number {\n        // https://easings.net/#easeOutCirc\n        const easing = Math.sqrt(1 - Math.pow(time - 1, 2));\n        return startValue + (endValue - startValue) * easing;\n    }\n\n    private handleZoom() {\n        let resetZoomState = false;\n        if (this.m_zoomDeltaRequested !== 0) {\n            this.m_targetedZoom = Math.max(\n                Math.min(this.zoomLevelTargeted + this.m_zoomDeltaRequested, this.maxZoomLevel),\n                this.minZoomLevel\n            );\n            this.m_zoomDeltaRequested = 0;\n        }\n        if (this.inertiaEnabled && this.zoomInertiaDampingDuration > 0) {\n            if (!this.m_zoomIsAnimated) {\n                this.m_zoomIsAnimated = true;\n                this.mapView.addEventListener(MapViewEventNames.AfterRender, this.handleZoom);\n            }\n            const currentTime = performance.now();\n            this.m_zoomAnimationTime = (currentTime - this.m_zoomAnimationStartTime) / 1000;\n            const zoomFinished = this.m_zoomAnimationTime > this.zoomInertiaDampingDuration;\n            if (zoomFinished) {\n                if (this.m_needsRenderLastFrame) {\n                    this.m_needsRenderLastFrame = false;\n                    this.m_zoomAnimationTime = this.zoomInertiaDampingDuration;\n\n                    resetZoomState = true;\n                    this.stopZoom();\n                }\n            } else {\n                this.m_needsRenderLastFrame = true;\n            }\n        }\n\n        this.currentZoom =\n            !this.inertiaEnabled || Math.abs(this.zoomLevelTargeted - this.m_startZoom) < EPSILON\n                ? this.zoomLevelTargeted\n                : this.easeOutCirc(\n                      this.m_startZoom,\n                      this.zoomLevelTargeted,\n                      Math.min(1, this.m_zoomAnimationTime / this.zoomInertiaDampingDuration)\n                  );\n\n        const success = MapViewUtils.zoomOnTargetPosition(\n            this.mapView,\n            this.m_zoomTargetNormalizedCoordinates.x,\n            this.m_zoomTargetNormalizedCoordinates.y,\n            this.currentZoom,\n            this.m_maxTiltAngle\n        );\n\n        if (resetZoomState || !success) {\n            this.m_targetedZoom = undefined;\n            this.m_currentZoom = undefined;\n        }\n        this.updateMapView();\n    }\n\n    private stopZoom() {\n        this.mapView.removeEventListener(MapViewEventNames.AfterRender, this.handleZoom);\n        this.m_zoomIsAnimated = false;\n    }\n\n    /**\n     * Method to flip crpes.\n     */\n    private handlePan() {\n        if (this.m_state === State.NONE && this.m_lastAveragedPanDistanceOrAngle === 0) {\n            return;\n        }\n\n        if (this.inertiaEnabled && !this.m_panIsAnimated) {\n            this.m_panIsAnimated = true;\n            this.mapView.addEventListener(MapViewEventNames.AfterRender, this.handlePan);\n        }\n\n        const applyInertia =\n            this.inertiaEnabled &&\n            this.panInertiaDampingDuration > 0 &&\n            this.m_state === State.NONE &&\n            this.m_lastAveragedPanDistanceOrAngle > 0;\n\n        if (applyInertia) {\n            const currentTime = performance.now();\n            this.m_panAnimationTime = (currentTime - this.m_panAnimationStartTime) / 1000;\n            const panFinished = this.m_panAnimationTime > this.panInertiaDampingDuration;\n\n            if (panFinished) {\n                if (this.m_needsRenderLastFrame) {\n                    this.m_needsRenderLastFrame = false;\n                    this.m_panAnimationTime = this.panInertiaDampingDuration;\n                    this.mapView.removeEventListener(MapViewEventNames.AfterRender, this.handlePan);\n                    this.m_panIsAnimated = false;\n                }\n            } else {\n                this.m_needsRenderLastFrame = true;\n            }\n\n            const animationTime = this.m_panAnimationTime / this.panInertiaDampingDuration;\n            this.m_currentInertialPanningSpeed = this.easeOutCubic(\n                this.m_lastAveragedPanDistanceOrAngle,\n                0,\n                Math.min(1, animationTime)\n            );\n            if (this.m_currentInertialPanningSpeed === 0) {\n                this.m_lastAveragedPanDistanceOrAngle = 0;\n            }\n            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n                this.m_panDistanceFrameDelta\n                    .copy(this.m_lastPanVector)\n                    .setLength(this.m_currentInertialPanningSpeed);\n            } else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n                this.m_rotateGlobeQuaternion\n                    .setFromAxisAngle(\n                        this.m_lastRotateGlobeAxis,\n                        this.m_currentInertialPanningSpeed\n                    )\n                    .normalize();\n            }\n        } else {\n            let panDistanceOrAngle: number = 0;\n            if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n                panDistanceOrAngle = this.m_lastPanVector\n                    .copy(this.m_panDistanceFrameDelta)\n                    .length();\n            } else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n                panDistanceOrAngle = this.m_lastRotateGlobeAngle;\n                this.m_rotateGlobeQuaternion.setFromAxisAngle(\n                    this.m_lastRotateGlobeAxis,\n                    this.m_lastRotateGlobeAngle\n                );\n                this.m_rotateGlobeQuaternion.normalize();\n            }\n            this.m_currentPanDistanceOrAngleIndex =\n                (this.m_currentPanDistanceOrAngleIndex + 1) % USER_INPUTS_TO_CONSIDER;\n            this.m_recentPanDistancesOrAngles[\n                this.m_currentPanDistanceOrAngleIndex\n            ] = panDistanceOrAngle;\n            this.m_lastAveragedPanDistanceOrAngle =\n                this.m_recentPanDistancesOrAngles.reduce((a, b) => a + b) / USER_INPUTS_TO_CONSIDER;\n        }\n\n        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n            MapViewUtils.panCameraAboveFlatMap(\n                this.mapView,\n                this.m_panDistanceFrameDelta.x,\n                this.m_panDistanceFrameDelta.y\n            );\n        } else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n            MapViewUtils.panCameraAroundGlobe(\n                this.mapView,\n                this.m_lastRotateGlobeFromVector,\n                this.m_tmpVector3\n                    .copy(this.m_lastRotateGlobeFromVector)\n                    .applyQuaternion(this.m_rotateGlobeQuaternion)\n            );\n        }\n        if (!applyInertia) {\n            this.m_panDistanceFrameDelta.set(0, 0, 0);\n            this.m_lastRotateGlobeAngle = 0;\n        }\n\n        this.updateMapView();\n    }\n\n    private stopPan() {\n        this.m_panDistanceFrameDelta.set(0, 0, 0);\n        this.m_lastAveragedPanDistanceOrAngle = 0;\n    }\n\n    private bindInputEvents(domElement: HTMLCanvasElement) {\n        const onContextMenu = this.contextMenu.bind(this);\n        const onMouseDown = this.mouseDown.bind(this);\n        const onMouseWheel = this.mouseWheel.bind(this);\n        const onTouchStart = this.touchStart.bind(this);\n        const onTouchEnd = this.touchEnd.bind(this);\n        const onTouchMove = this.touchMove.bind(this);\n        const onMouseDoubleClick = this.mouseDoubleClick.bind(this);\n\n        domElement.addEventListener(\"dblclick\", onMouseDoubleClick, false);\n        domElement.addEventListener(\"contextmenu\", onContextMenu, false);\n        domElement.addEventListener(\"mousedown\", onMouseDown, false);\n        domElement.addEventListener(\"wheel\", onMouseWheel, false);\n        domElement.addEventListener(\"touchstart\", onTouchStart, false);\n        domElement.addEventListener(\"touchend\", onTouchEnd, false);\n        domElement.addEventListener(\"touchmove\", onTouchMove, false);\n\n        this.dispose = () => {\n            domElement.removeEventListener(\"dblclick\", onMouseDoubleClick, false);\n            domElement.removeEventListener(\"contextmenu\", onContextMenu, false);\n            domElement.removeEventListener(\"mousedown\", onMouseDown, false);\n            domElement.removeEventListener(\"wheel\", onMouseWheel, false);\n            domElement.removeEventListener(\"touchstart\", onTouchStart, false);\n            domElement.removeEventListener(\"touchend\", onTouchEnd, false);\n            domElement.removeEventListener(\"touchmove\", onTouchMove, false);\n        };\n    }\n\n    private updateMapView() {\n        this.dispatchEvent(MAPCONTROL_EVENT);\n        this.mapView.update();\n    }\n\n    private mouseDoubleClick(event: MouseEvent) {\n        if (!this.enabled || !this.zoomEnabled) {\n            return;\n        }\n        const mousePos = this.getPointerPosition(event);\n        this.zoomOnDoubleClickOrTap(mousePos.x, mousePos.y);\n    }\n\n    private mouseDown(event: MouseEvent) {\n        if (this.enabled === false) {\n            return;\n        }\n\n        if (event.shiftKey) {\n            return;\n        }\n\n        event.stopPropagation();\n\n        if (this.m_state !== State.NONE) {\n            return;\n        }\n\n        // Support mac users who press ctrl key when wanting to right click\n        if (event.button === 0 && !event.ctrlKey && this.panEnabled) {\n            this.m_state = State.PAN;\n        } else if (event.button === 1) {\n            this.m_state = State.ROTATE;\n        } else if ((event.button === 2 || event.ctrlKey) && this.tiltEnabled) {\n            this.m_state = State.ORBIT;\n        } else {\n            return;\n        }\n\n        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n\n        const mousePos = this.getPointerPosition(event);\n        this.m_lastMousePosition.copy(mousePos);\n        if (event.altKey === true) {\n            const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n            this.m_initialMousePosition.copy(\n                utils.calculateNormalizedDeviceCoordinates(mousePos.x, mousePos.y, width, height)\n            );\n        } else {\n            CameraUtils.getPrincipalPoint(this.mapView.camera, this.m_initialMousePosition);\n        }\n\n        const onMouseMove = this.mouseMove.bind(this);\n        const onMouseUp = this.mouseUp.bind(this);\n\n        window.addEventListener(\"mousemove\", onMouseMove, false);\n        window.addEventListener(\"mouseup\", onMouseUp, false);\n\n        this.m_cleanupMouseEventListeners = () => {\n            window.removeEventListener(\"mousemove\", onMouseMove);\n            window.removeEventListener(\"mouseup\", onMouseUp);\n        };\n    }\n\n    private mouseMove(event: MouseEvent) {\n        if (this.enabled === false) {\n            return;\n        }\n\n        const mousePos = this.getPointerPosition(event);\n        this.m_mouseDelta.set(\n            mousePos.x - this.m_lastMousePosition.x,\n            mousePos.y - this.m_lastMousePosition.y\n        );\n\n        if (this.m_state === State.PAN) {\n            const vectors = this.getWorldPositionWithElevation(\n                this.m_lastMousePosition.x,\n                this.m_lastMousePosition.y,\n                mousePos.x,\n                mousePos.y\n            );\n            if (vectors === undefined) {\n                return;\n            }\n            const { fromWorld, toWorld } = vectors;\n            this.panFromTo(fromWorld, toWorld);\n        } else if (this.m_state === State.ROTATE) {\n            this.stopExistingAnimations();\n            MapViewUtils.rotate(\n                this.mapView,\n                -this.rotationMouseDeltaFactor * this.m_mouseDelta.x,\n                this.rotationMouseDeltaFactor * this.m_mouseDelta.y,\n                this.m_maxTiltAngle\n            );\n        } else if (this.m_state === State.ORBIT) {\n            this.stopExistingAnimations();\n\n            MapViewUtils.orbitAroundScreenPoint(this.mapView, {\n                center: this.m_tmpVector2.set(\n                    this.m_initialMousePosition.x,\n                    this.m_initialMousePosition.y\n                ),\n                deltaAzimuth: this.orbitingMouseDeltaFactor * this.m_mouseDelta.x,\n                deltaTilt: -this.orbitingMouseDeltaFactor * this.m_mouseDelta.y,\n                maxTiltAngle: this.m_maxTiltAngle\n            });\n        }\n\n        this.m_lastMousePosition.set(mousePos.x, mousePos.y);\n        this.m_zoomAnimationStartTime = performance.now();\n\n        this.updateMapView();\n        event.preventDefault();\n        event.stopPropagation();\n    }\n\n    private mouseUp(event: MouseEvent) {\n        if (this.enabled === false) {\n            return;\n        }\n\n        this.updateMapView();\n\n        event.preventDefault();\n        event.stopPropagation();\n\n        this.m_state = State.NONE;\n\n        if (this.m_cleanupMouseEventListeners) {\n            this.m_cleanupMouseEventListeners();\n        }\n\n        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n    }\n\n    private mouseWheel(event: WheelEvent) {\n        if (!this.enabled || !this.zoomEnabled) {\n            return;\n        }\n\n        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n        const screenTarget = utils.calculateNormalizedDeviceCoordinates(\n            event.offsetX,\n            event.offsetY,\n            width,\n            height\n        );\n\n        this.setZoomLevel(\n            this.mapView.zoomLevel - this.zoomLevelDeltaOnMouseWheel * Math.sign(event.deltaY),\n            screenTarget\n        );\n\n        event.preventDefault();\n        event.stopPropagation();\n    }\n\n    /**\n     * Calculates the angle of the vector, which is formed by two touch points in world space\n     * against the X axis in world space on the map. The resulting angle is in radians and between\n     * `-PI` and `PI`.\n     */\n    private updateCurrentRotation() {\n        if (\n            this.m_touchState.touches.length < 2 ||\n            this.m_touchState.touches[1].currentWorldPosition.length() === 0 ||\n            this.m_touchState.touches[0].currentWorldPosition.length() === 0\n        ) {\n            return;\n        }\n        let x = 0;\n        let y = 0;\n        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n            // Planar uses world space coordinates to return the angle of the vector between the two\n            // fingers' locations from the north direction.\n            x =\n                this.m_touchState.touches[1].currentWorldPosition.x -\n                this.m_touchState.touches[0].currentWorldPosition.x;\n            y =\n                this.m_touchState.touches[1].currentWorldPosition.y -\n                this.m_touchState.touches[0].currentWorldPosition.y;\n        } else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n            // Globe uses screen space coordinates, as the 3d coordinate system cannot define a\n            // reference rotation scalar for the vector between the two fingers' locations.\n            x =\n                this.m_touchState.touches[1].currentTouchPoint.x -\n                this.m_touchState.touches[0].currentTouchPoint.x;\n            // Below the subtraction is inverted, because the Y coordinate in screen space in HTML\n            // has its origin at the top and increases downwards.\n            y =\n                this.m_touchState.touches[0].currentTouchPoint.y -\n                this.m_touchState.touches[1].currentTouchPoint.y;\n            this.m_touchState.initialRotation = this.m_touchState.currentRotation;\n        }\n        this.m_touchState.currentRotation = Math.atan2(y, x);\n    }\n\n    /**\n     * Calculates the difference of the current distance of two touch points against their initial\n     * distance in world space.\n     */\n    private calculatePinchDistanceInWorldSpace(): number {\n        if (this.m_touchState.touches.length < 2) {\n            return 0;\n        }\n        const previousDistance = this.m_tmpVector3\n            .subVectors(\n                this.m_touchState.touches[0].initialWorldPosition,\n                this.m_touchState.touches[1].initialWorldPosition\n            )\n            .length();\n\n        const currentDistance = this.m_tmpVector3\n            .subVectors(\n                this.m_touchState.touches[0].currentWorldPosition,\n                this.m_touchState.touches[1].currentWorldPosition\n            )\n            .length();\n        return currentDistance - previousDistance;\n    }\n\n    private convertTouchPoint(touch: Touch, oldTouchState?: TouchState): TouchState | undefined {\n        // Acquire touch coordinates relative to canvas, this coordinates\n        // are then used to calculate NDC values.\n        const newTouchPoint = this.getPointerPosition(touch);\n\n        if (oldTouchState !== undefined) {\n            const oldTouchPoint = oldTouchState.currentTouchPoint;\n            const vectors = this.getWorldPositionWithElevation(\n                oldTouchPoint.x,\n                oldTouchPoint.y,\n                newTouchPoint.x,\n                newTouchPoint.y\n            );\n            const toWorld = vectors === undefined ? new THREE.Vector3() : vectors.toWorld;\n            // Unless the user is tilting, considering a finger losing the surface as a touchEnd\n            // event. Inertia will get triggered.\n            if (\n                toWorld.length() === 0 &&\n                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)\n            ) {\n                this.setTouchState([] as any);\n                this.m_state = State.NONE;\n                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n                return;\n            }\n            if (this.m_state !== State.TOUCH) {\n                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n            }\n            this.m_state = State.TOUCH;\n            return {\n                currentTouchPoint: newTouchPoint,\n                lastTouchPoint: newTouchPoint,\n                currentWorldPosition: toWorld,\n                initialWorldPosition: toWorld\n            };\n        } else {\n            const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n            const to = utils.calculateNormalizedDeviceCoordinates(\n                newTouchPoint.x,\n                newTouchPoint.y,\n                width,\n                height\n            );\n            const result = MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);\n            const toWorld = result === null ? new THREE.Vector3() : result;\n            // Unless the user is tilting, considering a finger losing the surface as a touchEnd\n            // event. Inertia will get triggered.\n            if (\n                toWorld.length() === 0 &&\n                !(this.m_touchState.touches.length === 3 && this.tiltEnabled)\n            ) {\n                this.setTouchState([] as any);\n                this.m_state = State.NONE;\n                this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n                return;\n            }\n            if (this.m_state !== State.TOUCH) {\n                this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n            }\n            this.m_state = State.TOUCH;\n            return {\n                currentTouchPoint: newTouchPoint,\n                lastTouchPoint: newTouchPoint,\n                currentWorldPosition: toWorld,\n                initialWorldPosition: toWorld\n            };\n        }\n    }\n\n    private setTouchState(touches: TouchList) {\n        this.m_touchState.touches = [];\n\n        // TouchList doesn't conform to iterator interface so we cannot use 'for of'\n        for (let i = 0; i < touches.length; ++i) {\n            const touchState = this.convertTouchPoint(touches[i]);\n            if (touchState !== undefined) {\n                this.m_touchState.touches.push(touchState);\n            }\n        }\n\n        if (this.m_touchState.touches.length !== 0) {\n            this.updateCurrentRotation();\n            this.m_touchState.initialRotation = this.m_touchState.currentRotation;\n        }\n    }\n\n    private updateTouches(touches: TouchList) {\n        const length = Math.min(touches.length, this.m_touchState.touches.length);\n        for (let i = 0; i < length; ++i) {\n            const oldTouchState = this.m_touchState.touches[i];\n            const newTouchState = this.convertTouchPoint(touches[i], oldTouchState);\n            if (newTouchState !== undefined && oldTouchState !== undefined) {\n                newTouchState.initialWorldPosition = oldTouchState.initialWorldPosition;\n                newTouchState.lastTouchPoint = oldTouchState.currentTouchPoint;\n                this.m_touchState.touches[i] = newTouchState;\n            }\n        }\n    }\n\n    private zoomOnDoubleClickOrTap(x: number, y: number) {\n        if (this.zoomLevelDeltaOnDoubleClick === 0) {\n            return;\n        }\n        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n        const ndcCoords = utils.calculateNormalizedDeviceCoordinates(x, y, width, height);\n        this.setZoomLevel(this.currentZoom + this.zoomLevelDeltaOnDoubleClick, ndcCoords);\n    }\n\n    private touchStart(event: TouchEvent) {\n        if (this.enabled === false) {\n            return;\n        }\n\n        this.m_tapStartTime = performance.now();\n        this.m_fingerMoved = false;\n\n        this.m_state = State.TOUCH;\n\n        this.dispatchEvent(MAPCONTROL_EVENT_BEGIN_INTERACTION);\n        this.setTouchState(event.touches);\n        this.updateTouches(event.touches);\n\n        event.preventDefault();\n        event.stopPropagation();\n    }\n\n    private touchMove(event: TouchEvent) {\n        if (this.enabled === false) {\n            return;\n        }\n\n        this.m_fingerMoved = true;\n        this.updateTouches(event.touches);\n\n        if (\n            this.panEnabled &&\n            this.m_touchState.touches.length <= 2 &&\n            this.m_touchState.touches[0] !== undefined\n        ) {\n            this.panFromTo(\n                this.m_touchState.touches[0].initialWorldPosition,\n                this.m_touchState.touches[0].currentWorldPosition\n            );\n        }\n\n        if (this.m_touchState.touches.length === 2) {\n            const touches = this.m_touchState.touches;\n            const center = new THREE.Vector2();\n\n            if (this.zoomEnabled === true || this.rotateEnabled === true) {\n                const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n                touches.forEach(touch => {\n                    const ndcPoint = utils.calculateNormalizedDeviceCoordinates(\n                        touch.currentTouchPoint.x,\n                        touch.currentTouchPoint.y,\n                        width,\n                        height\n                    );\n                    center.add(ndcPoint);\n                });\n                center.divideScalar(touches.length);\n            }\n            if (this.zoomEnabled) {\n                const pinchDistance = this.calculatePinchDistanceInWorldSpace();\n                if (Math.abs(pinchDistance) < EPSILON) {\n                    return;\n                }\n                const newZL = MapViewUtils.calculateZoomLevelFromDistance(\n                    this.mapView,\n                    this.mapView.targetDistance - pinchDistance\n                );\n\n                MapViewUtils.zoomOnTargetPosition(\n                    this.mapView,\n                    center.x,\n                    center.y,\n                    newZL,\n                    this.m_maxTiltAngle\n                );\n            }\n\n            if (this.rotateEnabled) {\n                this.updateCurrentRotation();\n                const deltaAzimuth =\n                    this.m_touchState.currentRotation - this.m_touchState.initialRotation;\n                this.stopExistingAnimations();\n\n                MapViewUtils.orbitAroundScreenPoint(this.mapView, {\n                    center: this.m_tmpVector2.set(center.x, center.y),\n                    deltaAzimuth,\n                    maxTiltAngle: this.m_maxTiltAngle\n                });\n            }\n        }\n\n        // Tilting\n        if (this.m_touchState.touches.length === 3 && this.tiltEnabled) {\n            const firstTouch = this.m_touchState.touches[0];\n            const diff = this.m_tmpVector2.subVectors(\n                firstTouch.currentTouchPoint,\n                firstTouch.lastTouchPoint\n            );\n            this.stopExistingAnimations();\n            MapViewUtils.orbitAroundScreenPoint(this.mapView, {\n                deltaAzimuth: this.orbitingTouchDeltaFactor * diff.x,\n                deltaTilt: -this.orbitingTouchDeltaFactor * diff.y,\n                maxTiltAngle: this.m_maxTiltAngle\n            });\n        }\n\n        this.m_zoomAnimationStartTime = performance.now();\n\n        this.updateMapView();\n        event.preventDefault();\n        event.stopPropagation();\n    }\n\n    private touchEnd(event: TouchEvent) {\n        if (this.enabled === false) {\n            return;\n        }\n        this.m_state = State.NONE;\n\n        this.handleDoubleTap();\n\n        this.setTouchState(event.touches);\n\n        this.dispatchEvent(MAPCONTROL_EVENT_END_INTERACTION);\n        this.updateMapView();\n\n        event.preventDefault();\n        event.stopPropagation();\n    }\n\n    private handleDoubleTap() {\n        // Continue only if no touchmove happened and zoom's enabled.\n        if (this.m_fingerMoved || !this.zoomEnabled) {\n            return;\n        }\n\n        const now = performance.now();\n        const tapDuration = now - this.m_tapStartTime;\n\n        // Continue only if proper tap.\n        if (tapDuration > MAX_TAP_DURATION) {\n            return;\n        }\n\n        // Continue only if this is the second valid tap.\n        if (!this.m_isDoubleTap) {\n            this.m_isDoubleTap = true;\n            this.m_lastSingleTapTime = now;\n            return;\n        }\n\n        // Continue only if the delay between the two taps is short enough.\n        if (now - this.m_lastSingleTapTime > this.doubleTapTime * 1000) {\n            // If too long, restart double tap validator too.\n            this.m_isDoubleTap = false;\n            return;\n        }\n\n        this.zoomOnDoubleClickOrTap(\n            this.m_touchState.touches[0].currentTouchPoint.x,\n            this.m_touchState.touches[0].currentTouchPoint.y\n        );\n\n        // Prevent a string of X valid taps and only consider pairs.\n        this.m_isDoubleTap = false;\n    }\n\n    private contextMenu(event: Event) {\n        event.preventDefault();\n    }\n\n    private getWorldPositionWithElevation(\n        fromX: number,\n        fromY: number,\n        toX: number,\n        toY: number\n    ): { fromWorld: THREE.Vector3; toWorld: THREE.Vector3 } | undefined {\n        const { width, height } = utils.getWidthAndHeightFromCanvas(this.domElement);\n\n        const from = utils.calculateNormalizedDeviceCoordinates(fromX, fromY, width, height);\n        const to = utils.calculateNormalizedDeviceCoordinates(toX, toY, width, height);\n\n        let toWorld: THREE.Vector3 | null;\n        let fromWorld: THREE.Vector3 | null;\n\n        let elevationProviderResult: THREE.Vector3 | undefined;\n\n        if (this.mapView.elevationProvider !== undefined) {\n            elevationProviderResult = this.mapView.elevationProvider.rayCast(fromX, fromY);\n        }\n\n        if (elevationProviderResult === undefined) {\n            fromWorld = MapViewUtils.rayCastWorldCoordinates(this.mapView, from.x, from.y);\n            toWorld = MapViewUtils.rayCastWorldCoordinates(this.mapView, to.x, to.y);\n        } else {\n            fromWorld = elevationProviderResult;\n            const fromGeoAltitude = this.mapView.projection.unprojectAltitude(fromWorld);\n\n            // We can ensure that points under the mouse stay there by projecting the to point onto\n            // a plane with the altitude based on the initial point.\n            toWorld = MapViewUtils.rayCastWorldCoordinates(\n                this.mapView,\n                to.x,\n                to.y,\n                fromGeoAltitude\n            );\n        }\n        if (fromWorld === null || toWorld === null) {\n            return;\n        }\n        return { fromWorld, toWorld };\n    }\n\n    private panFromTo(fromWorld: THREE.Vector3, toWorld: THREE.Vector3): void {\n        this.stopExistingAnimations();\n\n        // Assign the new animation start time.\n        this.m_panAnimationStartTime = performance.now();\n\n        if (this.mapView.projection.type === geoUtils.ProjectionType.Planar) {\n            this.m_panDistanceFrameDelta.subVectors(fromWorld, toWorld);\n        } else if (this.mapView.projection.type === geoUtils.ProjectionType.Spherical) {\n            this.m_lastRotateGlobeFromVector.copy(fromWorld);\n            this.m_lastRotateGlobeAxis.crossVectors(fromWorld, toWorld).normalize();\n            this.m_lastRotateGlobeAngle = fromWorld.angleTo(toWorld);\n            // When fromWorld and toWorld are too close, there is a risk of getting an NaN\n            // value. The following ensures that the controls don't break.\n            if (isNaN(this.m_lastRotateGlobeAngle)) {\n                this.m_lastRotateGlobeAngle = 0;\n            }\n        }\n\n        this.handlePan();\n    }\n\n    /**\n     * Acquire mouse or touch pointer position relative to canvas for `MouseEvent` or `Touch` event.\n     *\n     * Function takes into account canvas position in client space (including scrolling) as also\n     * canvas scaling factor.\n     *\n     * @param event - The mouse event.\n     * @returns [[THREE.Vector2]] containing _x_, _y_ mouse pointer position.\n     */\n    private getPointerPosition(event: MouseEvent | Touch): THREE.Vector2 {\n        const canvasSize = utils.getWidthAndHeightFromCanvas(this.domElement);\n        // Absolute size of a canvas\n        const rect = this.domElement.getBoundingClientRect();\n        // TODO: Test if scaling is needed and works on HiDPI devices.\n        const scaleX = Math.round(rect.width) / canvasSize.width;\n        const scaleY = Math.round(rect.height) / canvasSize.height;\n\n        // Scale mouse coordinates after they have, been adjusted to be relative to element.\n        return new THREE.Vector2(\n            (event.clientX - Math.floor(rect.left)) * scaleX,\n            (event.clientY - Math.floor(rect.top)) * scaleY\n        );\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { mercatorProjection, ProjectionType, sphereProjection } from \"@here/harp-geoutils\";\nimport { MapViewEventNames } from \"@here/harp-mapview\";\n\nimport { MapControls } from \"./MapControls\";\n\n/**\n * Option for MapControlsUI.\n */\ninterface MapControlsUIOptions {\n    /**\n     * If specified, turns on the zoom level display or zoom level input.\n     */\n    zoomLevel?: \"show\" | \"input\";\n\n    /**\n     * If specified, allows to switch between mercator and sphere projections at runtime.\n     */\n    projectionSwitch?: boolean;\n\n    /**\n     * Turns off default CSS styling for controls.\n     */\n    disableDefaultStyle?: boolean;\n}\n\n/**\n * Base class to handle UI overlay elements.\n */\nexport class MapControlsUI {\n    /**\n     * The DOM node containing the UI.\n     */\n    readonly domElement = document.createElement(\"div\");\n\n    private readonly m_buttonsElement: HTMLDivElement = document.createElement(\"div\");\n\n    /**\n     * Displays zoom level if [[MapControlsUIOptions.zoomLevel]] is defined.\n     */\n    private readonly m_zoomLevelElement: HTMLDivElement | HTMLInputElement | null = null;\n\n    /**\n     * Displays zoom level if [[MapControlsUIOptions.projectionSwitch]] is defined.\n     */\n    private readonly m_projectionSwitchElement: HTMLButtonElement | null = null;\n\n    /**\n     * Removes focus from input element.\n     */\n    private readonly m_onWindowClick: (event: MouseEvent) => void;\n\n    /**\n     * Updates the display of the zoom level.\n     */\n    private readonly m_onMapViewRenderEvent: () => void;\n\n    /**\n     * Constructor of the UI.\n     *\n     * @param controls - Controls referencing a [[MapView]].\n     */\n    constructor(readonly controls: MapControls, options: MapControlsUIOptions = {}) {\n        this.m_onMapViewRenderEvent = () => {\n            if (this.m_zoomLevelElement === null) {\n                return;\n            }\n\n            const zoom = this.controls.zoomLevelTargeted.toFixed(1);\n\n            if (this.m_zoomLevelElement.tagName === \"INPUT\") {\n                (this.m_zoomLevelElement as HTMLInputElement).value = zoom;\n            } else {\n                (this.m_zoomLevelElement as HTMLDivElement).innerHTML = zoom;\n            }\n        };\n\n        this.m_onWindowClick = (event: MouseEvent) => {\n            const input = this.m_zoomLevelElement as HTMLInputElement;\n            if (\n                !event ||\n                !event.target ||\n                !(event.target as any).contains ||\n                event.target === input ||\n                (event.target as HTMLElement).contains(input)\n            ) {\n                return;\n            }\n            input.blur();\n        };\n\n        // Empty element to dynamically align the controls vertically, depending on which buttons\n        // are enabled. Avoids unreliable style computations in the script.\n        const verticalAligner = document.createElement(\"span\");\n        verticalAligner.className = \"harp-gl_v-align\";\n        this.domElement.appendChild(verticalAligner);\n\n        // This element will receive the controls and ensure the vertical alignment in the CSS.\n        this.m_buttonsElement = document.createElement(\"div\");\n        this.m_buttonsElement.className = \"harp-gl_v-aligned\";\n        this.domElement.appendChild(this.m_buttonsElement);\n\n        const zoomInButton = document.createElement(\"button\");\n        zoomInButton.innerText = \"+\";\n        zoomInButton.className = \"harp-gl_controls_button-top\";\n        zoomInButton.classList.add(\"harp-gl_controls-button\");\n\n        const zoomOutButton = document.createElement(\"button\");\n        zoomOutButton.innerText = \"-\";\n        zoomOutButton.className = \"harp-gl_controls_button-bottom\";\n        zoomOutButton.classList.add(\"harp-gl_controls-button\");\n\n        const tiltButton = document.createElement(\"button\");\n        tiltButton.innerText = \"3D\";\n        tiltButton.id = \"harp-gl_controls_tilt-button-ui\";\n        tiltButton.title = \"Toggle tilt\";\n        tiltButton.classList.add(\"harp-gl_controls-button\");\n        tiltButton.classList.add(\"harp-gl_controls_button-bottom\");\n\n        const compassButton = document.createElement(\"button\");\n        compassButton.id = \"harp-gl_controls-button_compass\";\n        compassButton.title = \"Reset North\";\n        compassButton.classList.add(\"harp-gl_controls-button\");\n        compassButton.classList.add(\"harp-gl_controls_button-top\");\n        const compass = document.createElement(\"span\");\n        compass.id = \"harp-gl_controls_compass\";\n        compassButton.appendChild(compass);\n\n        // Optional zoom level displaying\n        if (options.zoomLevel === \"show\") {\n            this.m_zoomLevelElement = document.createElement(\"div\");\n            controls.mapView.addEventListener(\n                MapViewEventNames.Render,\n                this.m_onMapViewRenderEvent\n            );\n        } else if (options.zoomLevel === \"input\") {\n            const input = document.createElement(\"input\");\n            input.type = \"number\";\n            input.step = \"0.1\"; // Avoids messages in the UI on hovering, when a tenth value exists.\n            controls.mapView.addEventListener(\n                MapViewEventNames.Render,\n                this.m_onMapViewRenderEvent\n            );\n\n            const updateZoom = (event: KeyboardEvent | FocusEvent) => {\n                controls.setZoomLevel(parseFloat(input.value));\n                event.preventDefault();\n            };\n\n            input.addEventListener(\"blur\", updateZoom);\n            input.addEventListener(\"keypress\", event => {\n                if (event.key === \"Enter\") {\n                    updateZoom(event);\n                }\n            });\n            window.addEventListener(\"click\", this.m_onWindowClick);\n            this.m_zoomLevelElement = input;\n        }\n\n        if (options.projectionSwitch) {\n            const switcher = document.createElement(\"button\");\n            switcher.id = \"harp-gl_controls_switch_projection\";\n            switcher.classList.add(\"harp-gl_controls-button\");\n            const getTitle: () => string = () => {\n                return `Switch to ${\n                    this.controls.mapView.projection.type === ProjectionType.Spherical\n                        ? \"flat\"\n                        : \"globe\"\n                } projection`;\n            };\n            switcher.title = getTitle();\n            const globeSVG = getGlobeSVG();\n            const flatMapSVG = getFlatMapSVG();\n            switcher.innerHTML =\n                this.controls.mapView.projection.type === ProjectionType.Spherical\n                    ? flatMapSVG\n                    : globeSVG;\n            switcher.addEventListener(\"click\", () => {\n                this.controls.mapView.projection =\n                    this.controls.mapView.projection.type === ProjectionType.Spherical\n                        ? mercatorProjection\n                        : sphereProjection;\n                switcher.title = getTitle();\n                switcher.innerHTML =\n                    this.controls.mapView.projection.type === ProjectionType.Spherical\n                        ? flatMapSVG\n                        : globeSVG;\n            });\n            this.m_projectionSwitchElement = switcher;\n        }\n\n        this.m_buttonsElement.appendChild(zoomInButton);\n        if (this.m_zoomLevelElement !== null) {\n            this.m_buttonsElement.appendChild(this.m_zoomLevelElement);\n        }\n        this.m_buttonsElement.appendChild(zoomOutButton);\n        this.m_buttonsElement.appendChild(compassButton);\n        this.m_buttonsElement.appendChild(tiltButton);\n        if (this.m_projectionSwitchElement !== null) {\n            this.m_buttonsElement.appendChild(this.m_projectionSwitchElement);\n        }\n\n        zoomInButton.addEventListener(\"click\", event => {\n            const zoomLevel = controls.zoomLevelTargeted + controls.zoomLevelDeltaOnControl;\n            controls.setZoomLevel(zoomLevel);\n        });\n        zoomInButton.addEventListener(\"dblclick\", event => {\n            // HARP-10298: Avoid double click event propagation to canvas in WebKit-based browsers\n            // when a zoom button is quickly clicked multiple times.\n            event.stopPropagation();\n        });\n        zoomOutButton.addEventListener(\"click\", event => {\n            const zoomLevel = controls.zoomLevelTargeted - controls.zoomLevelDeltaOnControl;\n            controls.setZoomLevel(zoomLevel);\n        });\n        zoomOutButton.addEventListener(\"dblclick\", event => {\n            // HARP-10298: Avoid double click event propagation to canvas in WebKit-based browsers\n            // when a zoom button is quickly clicked multiple times.\n            event.stopPropagation();\n        });\n        tiltButton.addEventListener(\"click\", event => {\n            controls.toggleTilt();\n        });\n        compassButton.addEventListener(\"click\", event => {\n            controls.pointToNorth();\n        });\n        controls.mapView.addEventListener(MapViewEventNames.AfterRender, () => {\n            compass.style.transform = `rotate(${controls.mapView.heading}deg)`;\n        });\n\n        this.domElement.className = \"harp-gl_controls\";\n\n        if (this.m_zoomLevelElement !== null) {\n            this.m_zoomLevelElement.classList.add(\"harp-gl_controls_zoom-level\");\n        }\n\n        if (options.disableDefaultStyle !== true) {\n            this.initStyle();\n            this.domElement.style.cssText = `\n                position: absolute;\n                right: 5px;\n                top: 0;\n                height: 100%; /* Vertical alignment is done dynamically, in the rest of the CSS. */\n                pointer-events: none; /* Allows to click the map even though height is 100%. */\n            `;\n        }\n\n        return this;\n    }\n\n    get projectionSwitchElement(): HTMLButtonElement | null {\n        return this.m_projectionSwitchElement;\n    }\n\n    /**\n     * Destroy this [[MapControlsUI]] instance. Unregisters all event handlers used. This method\n     * should be called when you stop using [[MapControlsUI]].\n     */\n    dispose() {\n        if (this.m_zoomLevelElement !== null && this.m_zoomLevelElement.tagName === \"INPUT\") {\n            window.removeEventListener(\"click\", this.m_onWindowClick);\n        }\n\n        this.controls.mapView.removeEventListener(\n            MapViewEventNames.Render,\n            this.m_onMapViewRenderEvent\n        );\n\n        this.domElement.remove();\n    }\n\n    private initStyle() {\n        if (document.getElementById(\"here-harp-controls.map-controls-ui-styles\") !== null) {\n            return;\n        }\n        const style = document.createElement(\"style\");\n        style.id = \"here-harp-controls.map-controls-ui-styles\";\n        style.appendChild(document.createTextNode(getTextStyle()));\n        document.head.appendChild(style);\n    }\n}\n\nfunction getTextStyle() {\n    return `\n        /* CSS trick to align another div dynamically. */\n        .harp-gl_v-align{\n            height: 100%;\n            display: inline-block;\n            vertical-align: middle;\n        }\n        /* The target element to align vertically with vertical-align. */\n        .harp-gl_v-aligned{\n            pointer-events: all;\n            vertical-align: middle;\n            display: inline-block;\n        }\n        .harp-gl_controls-button {\n            display: block;\n            background-color: #272d37;\n            width: 40px;\n            height: 40px;\n            font-size: 22px;\n            font-weight: bold;\n            outline: none;\n            margin:0;\n            border: none;\n            color: rgba(255, 255, 255, 0.8);\n            cursor: pointer;\n            border-radius: 4px;\n            box-shadow: 0px 0px 5px 0 hsl(220, 4%, 40%);\n            transition: all 0.1s;\n            padding: 0 0 1px 1px;\n            user-select: none;\n            position:relative;\n        }\n        #harp-gl_controls_tilt-button-ui {\n            font-size: 16px;\n        }\n        .harp-gl_controls-button:active {\n            background-color: #37afaa;\n            color: #eee;\n        }\n        .harp-gl_controls-button:focus {\n            outline:none;\n        }\n        .harp-gl_controls_button-top{\n            margin-bottom:0;\n            border-bottom-right-radius:0;\n            border-bottom-left-radius:0;\n        }\n        .harp-gl_controls_button-bottom{\n            margin-top:1px;\n            border-top-right-radius:0;\n            border-top-left-radius:0;\n        }\n        .harp-gl_controls_zoom-level {\n            display: block;\n            background-color: #fff;\n            width: 40px;\n            height: 20px;\n            font-size: 12px;\n            font-weight: bold;\n            outline: none;\n            border: none;\n            color: #555;\n            opacity: 0.87;\n            box-shadow: 0px 0px 4px #aaa;\n            padding: 2px 0 0;\n            text-align: center;\n            user-select: text;\n        }\n        input.harp-gl_controls_zoom-level::-webkit-outer-spin-button,\n        input.harp-gl_controls_zoom-level::-webkit-inner-spin-button {\n            /* display: none; <- Crashes Chrome on hover */\n            -webkit-appearance: none;\n            margin: 0; /* <-- Apparently some margin are still there even though it's hidden */\n        }\n        input.harp-gl_controls_zoom-level[type=number] {\n            -moz-appearance:textfield; /* Firefox */\n        }\n        #harp-gl_controls-button_compass{\n            overflow: hidden;\n            margin: 5px 0 0 0;\n        }\n        #harp-gl_controls_compass{\n            pointer-events:none;\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            margin:0\n        }\n        #harp-gl_controls_compass::after{\n            content: \" \";\n            position:absolute;\n            left:50%;\n            margin-left:-3px;\n            top:50%;\n            margin-top: -18px;\n            border:solid 3px rgba(0,0,0,0);\n            border-bottom:solid 15px #a34f2e;\n        }\n        #harp-gl_controls_compass::before{\n            content: \" \";\n            position:absolute;\n            left:50%;\n            margin-left:-3px;\n            top:50%;\n            margin-top:0px;\n            border:solid 3px rgba(0,0,0,0);\n            border-top:solid 15px #eee;\n        }\n        #harp-gl_controls_switch_projection{\n            margin-top:5px;\n        }\n        .harp-gl_controls_switch_svg{\n            width: 25px;\n            height: 25px;\n            stroke: #d4d5d7;\n            fill: #d4d5d7;\n        }\n    `;\n}\n\nfunction getFlatMapSVG() {\n    return `\n    <svg style=\"margin-top:5px;\" class=\"harp-gl_controls_switch_svg\" width=\"25\" height=\"25\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:svg=\"http://www.w3.org/2000/svg\">\n        <rect id=\"svg_1\" stroke-width=\"2\" height=\"13.51524\" width=\"18.35821\" y=\"5.80349\" x=\"3.21307\" fill=\"none\"/>\n        <path id=\"svg_14\" d=\"m9.52018,7.71815l1.2357,-0.0032l-0.61945,1.18258l-0.61625,-1.17938z\"/>\n        <path id=\"svg_15\" d=\"m4.11409,7.32396l3.65718,-0.0032l0.28156,2.13991l-2.59042,1.57678l0.50682,1.80203l2.25254,0.8447l-0.90101,2.0836l0.28157,2.25254l-3.26619,-3.04093l0.67576,-2.02728l-0.61945,-1.97097l-1.01364,-3.15356l0.73528,-0.50362z\"/>\n        <path id=\"svg_17\" d=\"m13.23688,7.4929l2.02409,-0.0032l0.78839,1.29521l2.47779,-1.35152l2.75936,0.78839l0,1.57678l-0.73208,0.61945l-0.28157,1.97097c0,0 -0.67256,0.8479 -0.72888,0.90422c-0.05631,0.05631 0.28157,1.06996 0.33788,1.18258c0.05631,0.11263 -1.68941,-1.35152 -1.6926,-1.35472c-0.0032,-0.0032 -0.16574,1.29841 -0.16894,1.29521c-0.0032,-0.0032 -1.57358,-1.34832 -1.57678,-1.35152c-0.0032,-0.0032 -0.72888,0.67896 -0.73208,0.67576c-0.0032,-0.0032 -0.8415,-0.67256 -0.8447,-0.67576c-0.0032,-0.0032 0.73528,2.0868 0.79159,2.0868c0.05631,0 -0.50682,3.20987 -0.51002,3.20667c-0.0032,-0.0032 -1.2357,-0.16574 -1.34832,-0.16574c-0.11263,0 -0.95733,-1.52046 -0.90102,-1.57678c0.05631,-0.05631 0,-1.80203 -0.0032,-1.80523c-0.0032,-0.0032 -1.40464,-0.33468 -1.40784,-0.33788c-0.0032,-0.0032 -0.05311,-1.74252 -0.05631,-1.74572c-0.0032,-0.0032 1.18578,-0.8415 1.18258,-0.8447c-0.0032,-0.0032 1.69261,-0.16574 1.74892,-0.16574c0.05631,0 1.2389,-1.06996 1.2357,-1.07316c-0.0032,-0.0032 -1.91146,-0.10943 -1.91466,-0.11263c-0.0032,-0.0032 -1.96777,0.17214 -1.97097,0.16894c-0.0032,-0.0032 1.52366,-3.20667 1.52366,-3.20667z\"/>\n    </svg>`;\n}\n\nfunction getGlobeSVG() {\n    return `\n    <svg style=\"margin-top:5px;\" stroke-width=\"2\" class=\"harp-gl_controls_switch_svg\" width=\"50\" height=\"50\" viewBox=\"0 0 25 25\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:svg=\"http://www.w3.org/2000/svg\">\n        <ellipse ry=\"9.79855\" rx=\"4.56139\" id=\"svg_6\" cy=\"11.99798\" cx=\"11.99798\" fill=\"none\"/>\n        <line id=\"svg_8\" y2=\"8.16866\" x2=\"21.12086\" y1=\"8.16866\" x1=\"3.10044\"/>\n        <line id=\"svg_9\" y2=\"16.10887\" x2=\"21.0645\" y1=\"16.10887\" x1=\"3.04409\"/>\n        <ellipse id=\"svg_11\" ry=\"9.79855\" rx=\"9.82671\" cy=\"11.94167\" cx=\"12.02614\" fill=\"none\"/>\n    </svg>`;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector2, Vector3 } from \"three\";\n\n/**\n * Transforms the given point in screen space into NDC space by taking the given screen dimension\n * into account.\n *\n * @param screenCoordinateX - X coordinate in screen space.\n * @param screenCoordinateY - Y coordinate in screen space.\n * @param screenSizeX - Width of the reference screen size.\n * @param screenSizeY - Height of the reference screen size.\n */\nexport function calculateNormalizedDeviceCoordinates(\n    screenCoordinateX: number,\n    screenCoordinateY: number,\n    screenSizeX: number,\n    screenSizeY: number\n): Vector2 {\n    return new Vector2(\n        (screenCoordinateX / screenSizeX) * 2 - 1,\n        -((screenCoordinateY / screenSizeY) * 2) + 1\n    );\n}\n\n/**\n * Returns the direction vector that is described by the given azimuth and altitude.\n *\n * @param azimuth - Azimuth in radians.\n * @param altitude - Altitude in radians.\n */\nexport function azimuthAltitudeToDirection(azimuth: number, altitude: number): Vector3 {\n    azimuth = azimuth;\n    altitude = altitude;\n    //Shamelessly copied from Jan ;)\n    const result = new Vector3();\n    const cosAltitude = Math.cos(altitude);\n\n    result.setX(Math.sin(azimuth) * cosAltitude);\n    result.setY(Math.cos(azimuth) * cosAltitude);\n    result.setZ(Math.sin(altitude));\n\n    return result;\n}\n\n/**\n * Safely parses decimal value into `number`.\n *\n * Safely falls back to default value for `null`, `undefined`, `NaN`, empty strings, and strings\n * with characters other than digits.\n *\n * @param text - Number as a text to be parsed.\n * @param fallback - Default value, which is returned if `text` doesn't represent a valid number.\n */\nexport function safeParseDecimalInt(text: string | null | undefined, fallback: number): number {\n    if (text === null || text === undefined || text === \"\") {\n        return fallback;\n    }\n    if (!text.match(integerRe)) {\n        return fallback;\n    }\n    const result = Number.parseInt(text, 10);\n    if (isNaN(result)) {\n        return fallback;\n    }\n    return result;\n}\nconst integerRe = /^\\d+$/;\n\n/**\n * Extracts the CSS width and height of the given canvas if available, or width and height of the\n * canvas otherwise.\n *\n * @param canvas - The canvas.\n */\nexport function getWidthAndHeightFromCanvas(\n    canvas: HTMLCanvasElement\n): { width: number; height: number } {\n    return {\n        //use clientWidth and clientHeight to support HiDPI devices\n        width: safeParseDecimalInt(canvas.style.width, canvas.clientWidth),\n        height: safeParseDecimalInt(canvas.style.height, canvas.clientHeight)\n    };\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Decoder worker for {@ref MapView}.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/DataProvider\";\nexport * from \"./lib/TileDataSource\";\nexport * from \"./lib/TileLoader\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport \"@here/harp-fetch\";\n\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { EventDispatcher } from \"three\";\n\n/**\n * Interface for all `DataProvider` subclasses.\n *\n * @remarks\n * The `DataProvider` is an abstraction of the tile\n * loader which is only responsible for loading the data of a specific tile,\n * without any relation to displaying or even decoding the data.\n */\nexport abstract class DataProvider extends EventDispatcher {\n    private readonly m_clients: Set<Object> = new Set();\n    private m_connectPromise: Promise<void> | undefined;\n\n    /**\n     * Registers a client to the data provider.\n     *\n     * @param client - The client to register.\n     * @returns Promise to wait for successful (or failed) connection to the data source.\n     */\n    register(client: Object): Promise<void> {\n        if (this.m_clients.size === 0) {\n            this.m_connectPromise = this.connect();\n        }\n        this.m_clients.add(client);\n        return this.m_connectPromise!;\n    }\n\n    /**\n     * Unregisters a client from the data provider.\n     *\n     * @param client - The client to unregister.\n     */\n    unregister(client: Object) {\n        if (this.m_clients.delete(client) && this.m_clients.size === 0) {\n            this.dispose();\n        }\n    }\n\n    /**\n     * Returns `true` if it has been connected successfully.\n     */\n    abstract ready(): boolean;\n\n    /**\n     * Load the data of a {@link @here/map-view@Tile} asynchronously.\n     *\n     * @param tileKey - Address of a tile.\n     * @param abortSignal - Optional AbortSignal to cancel the request.\n     * @returns A promise delivering the data as an [[ArrayBufferLike]], or any object.\n     */\n    abstract getTile(tileKey: TileKey, abortSignal?: AbortSignal): Promise<ArrayBufferLike | {}>;\n\n    /**\n     * An event which fires when this `DataProvider` is invalidated.\n     *\n     * @param listener - A function to call when this `DataProvider` is invalidated.\n     * @returns The function to call to unregister the listener from this event.\n     *\n     * @example\n     * ```typescript\n     * const dispose = dataProvider.onDidInvalidate?.(() => {\n     *     console.log(\"invalidated\");\n     * });\n     * ```\n     */\n    onDidInvalidate?(listener: () => void): () => void;\n\n    /**\n     * Connect to the data source. Returns a promise to wait for successful (or failed) connection.\n     *\n     * @returns A promise which is resolved when the connection has been established.\n     */\n    protected abstract connect(): Promise<void>;\n\n    /**\n     * Destroys this `DataProvider`. Implementations of `DataProvider` must dispose of\n     * asynchronous operations and services here.\n     */\n    protected abstract dispose(): void;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    FlatTheme,\n    ITileDecoder,\n    OptionsMap,\n    StyleSet,\n    Theme,\n    TileInfo\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport {\n    ConcurrentDecoderFacade,\n    CopyrightInfo,\n    CopyrightProvider,\n    DataSource,\n    DataSourceOptions,\n    Tile,\n    TileLoaderState\n} from \"@here/harp-mapview\";\nimport { ThemeLoader } from \"@here/harp-mapview/lib/ThemeLoader\";\nimport { ILogger, LoggerManager } from \"@here/harp-utils\";\n\nimport { DataProvider } from \"./DataProvider\";\nimport { TileInfoLoader, TileLoader } from \"./TileLoader\";\n\n/**\n * Set of common options for all [[TileDataSource]]s.\n */\nexport interface TileDataSourceOptions extends DataSourceOptions {\n    /**\n     * The [[TilingScheme]] the data source is using.\n     */\n    tilingScheme: TilingScheme;\n\n    /**\n     * The [[DataProvider]] to use for downloading the actual data.\n     */\n    dataProvider: DataProvider;\n\n    /**\n     * Optional: Specify [[ITileDecoder]] instance.\n     */\n    decoder?: ITileDecoder;\n\n    /**\n     * Optional name of decoder service class.\n     * @see [[ConcurrentDecoderFacade]]\n     * @see [[ConcurrentWorkerSet]]\n     */\n    concurrentDecoderServiceName?: string;\n\n    /**\n     * Optional URL for decoder bundle to be loaded into web worker.\n     */\n    concurrentDecoderScriptUrl?: string;\n\n    /**\n     * Optional count of web workers to use with the decoder bundle.\n     */\n    concurrentDecoderWorkerCount?: number;\n\n    /**\n     * Timeout for connecting to the web worker in seconds. Default to 10s, search for:\n     * DEFAULT_WORKER_INITIALIZATION_TIMEOUT\n     */\n    workerConnectionTimeout?: number;\n\n    /**\n     * Optional, default copyright information of tiles provided by this data source.\n     * Implementation should provide this information from the source data if possible.\n     */\n    copyrightInfo?: CopyrightInfo[];\n\n    /**\n     * Optional copyright info provider for tiles provided by this data source. Copyrights from\n     * provider are concatenated with default ones from `copyrightInfo`.\n     */\n    copyrightProvider?: CopyrightProvider;\n}\n\n/**\n * Templated factory class to create instances of [[Tile]].\n */\nexport class TileFactory<TileType extends Tile> {\n    /**\n     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is\n     * created.\n     *\n     * @param m_modelConstructor - Constructor of (subclass of) [[Tile]].\n     */\n    constructor(\n        private readonly m_modelConstructor: new (\n            dataSource: DataSource,\n            tileKey: TileKey\n        ) => TileType\n    ) {}\n\n    /**\n     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments\n     * to the constructor of [[Tile]].\n     *\n     * @param dataSource - [[Datasource]] this class belongs to.\n     * @param tileKey - Quadtree address of the [[Tile]].\n     */\n    create(dataSource: TileDataSource<TileType>, tileKey: TileKey): TileType {\n        const tile = new this.m_modelConstructor(dataSource, tileKey);\n        tile.tileLoader = new TileLoader(\n            dataSource,\n            tileKey,\n            dataSource.dataProvider(),\n            dataSource.decoder\n        );\n        return tile;\n    }\n}\n\n/**\n * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the\n * tile content asynchronously. The decoder can be passed in as an option, or a default\n * asynchronous one is generated.\n */\nexport class TileDataSource<TileType extends Tile = Tile> extends DataSource {\n    protected readonly logger: ILogger = LoggerManager.instance.create(\"TileDataSource\");\n    protected readonly m_decoder: ITileDecoder;\n    private m_isReady: boolean = false;\n    private readonly m_unregisterClearTileCache?: () => void;\n\n    /**\n     * Set up the `TileDataSource`.\n     *\n     * @param m_tileFactory - Factory to create the [[Tile]] instances.\n     * @param m_options - Options specifying the parameters of the [[DataSource]].\n     */\n    constructor(\n        private readonly m_tileFactory: TileFactory<TileType>,\n        private readonly m_options: TileDataSourceOptions\n    ) {\n        super(m_options);\n        if (m_options.decoder) {\n            this.m_decoder = m_options.decoder;\n        } else if (m_options.concurrentDecoderServiceName) {\n            this.m_decoder = ConcurrentDecoderFacade.getTileDecoder(\n                m_options.concurrentDecoderServiceName,\n                m_options.concurrentDecoderScriptUrl,\n                m_options.concurrentDecoderWorkerCount,\n                m_options.workerConnectionTimeout\n            );\n        } else {\n            throw new Error(\n                `TileDataSource[${this.name}]: unable to create, missing decoder or ` +\n                    `concurrentDecoderServiceName`\n            );\n        }\n        this.useGeometryLoader = true;\n        this.cacheable = true;\n\n        this.m_unregisterClearTileCache = this.dataProvider().onDidInvalidate?.(() =>\n            this.mapView.markTilesDirty(this)\n        );\n    }\n\n    /** @override */\n    dispose() {\n        this.m_unregisterClearTileCache?.();\n        this.decoder.dispose();\n        this.dataProvider().unregister(this);\n    }\n\n    /** @override */\n    ready(): boolean {\n        return this.m_isReady && this.m_options.dataProvider.ready();\n    }\n\n    /**\n     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with\n     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].\n     */\n    get decoder(): ITileDecoder {\n        return this.m_decoder;\n    }\n\n    /** @override */\n    async connect() {\n        await Promise.all([this.m_options.dataProvider.register(this), this.m_decoder.connect()]);\n        this.m_isReady = true;\n\n        let customOptions: OptionsMap = {};\n        if (this.m_options.storageLevelOffset !== undefined) {\n            customOptions = {\n                storageLevelOffset: this.m_options.storageLevelOffset\n            };\n        }\n        this.m_decoder.configure({ languages: this.languages }, customOptions);\n    }\n\n    /**\n     * @override\n     */\n    setLanguages(languages: string[]): void {\n        this.languages = languages;\n\n        this.m_decoder.configure({\n            languages: this.languages\n        });\n        this.mapView.clearTileCache(this.name);\n    }\n\n    /**\n     * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.\n     *\n     * Applies new {@here/harp-datasource-protocol StyleSet} and definitions from theme only\n     * if matching styleset (see `styleSetName` property) is found in `theme`.\n     * @override\n     */\n    async setTheme(theme: Theme | FlatTheme, languages?: string[]): Promise<void> {\n        // Seems superfluent, but the call to  ThemeLoader.load will resolve extends etc.\n        theme = await ThemeLoader.load(theme);\n\n        let styleSet: StyleSet | undefined;\n        if (this.styleSetName !== undefined && theme.styles !== undefined) {\n            styleSet = theme.styles[this.styleSetName];\n        }\n        if (languages !== undefined) {\n            this.languages = languages;\n        }\n\n        if (styleSet !== undefined) {\n            this.m_decoder.configure({\n                styleSet,\n                definitions: theme.definitions,\n                priorities: theme.priorities,\n                labelPriorities: theme.labelPriorities,\n                languages\n            });\n            this.mapView.clearTileCache(this.name);\n        }\n    }\n\n    /**\n     * Get the [[DataProvider]] that has been passed in with the options.\n     */\n    dataProvider(): DataProvider {\n        return this.m_options.dataProvider;\n    }\n\n    /** @override */\n    getTilingScheme(): TilingScheme {\n        return this.m_options.tilingScheme;\n    }\n\n    /**\n     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will\n     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is\n     * initialized with default copyrights, concatenated with copyrights from copyright provider of\n     * this data source.\n     *\n     * @param tileKey - Quadtree address of the requested tile.\n     * @param delayLoad - If true, the Tile will be created, but Tile.load will not be called.\n     * @default false.\n     * @override\n     */\n    getTile(tileKey: TileKey, delayLoad: boolean = false): TileType | undefined {\n        const tile = this.m_tileFactory.create(this, tileKey);\n        tile.copyrightInfo = this.m_options.copyrightInfo;\n        if (this.m_options.copyrightProvider !== undefined) {\n            this.m_options.copyrightProvider\n                .getCopyrights(tile.geoBox, tileKey.level)\n                .then(copyrightInfo => {\n                    tile.copyrightInfo =\n                        tile.copyrightInfo === undefined\n                            ? copyrightInfo\n                            : [...tile.copyrightInfo, ...copyrightInfo];\n                    this.requestUpdate();\n                });\n        }\n        if (!delayLoad) {\n            tile.load();\n        }\n\n        return tile;\n    }\n\n    /**\n     * Get [[TileInfo]] of a tile.\n     *\n     * @param tileKey - Quadtree address of the requested tile.\n     * @returns A promise which will contain the [[TileInfo]] when resolved.\n     */\n    getTileInfo(tileKey: TileKey): Promise<TileInfo | undefined> {\n        const promise = new Promise<TileInfo | undefined>((resolve, reject) => {\n            const tileLoader = new TileInfoLoader(\n                this,\n                tileKey,\n                this.m_options.dataProvider,\n                this.decoder\n            );\n\n            tileLoader.loadAndDecode().then(loaderState => {\n                if (loaderState === TileLoaderState.Ready) {\n                    resolve(tileLoader.tileInfo);\n                } else {\n                    reject(\n                        new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`)\n                    );\n                }\n            });\n        });\n\n        return promise;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport \"@here/harp-fetch\";\n\nimport {\n    DecodedTile,\n    ITileDecoder,\n    RequestController,\n    TileInfo\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { BaseTileLoader, DataSource } from \"@here/harp-mapview\";\nimport { TileLoaderState } from \"@here/harp-mapview/lib/ITileLoader\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { DataProvider } from \"./DataProvider\";\n\n/**\n * Logger to write to console etc.\n */\nconst logger = LoggerManager.instance.create(\"TileLoader\");\n\n/**\n * The [[TileLoader]] manages the different states of loading and decoding for a [[Tile]]. Used by\n * the [[TileDataSource]].\n */\nexport class TileLoader extends BaseTileLoader {\n    /**\n     * The binary data in form of [[ArrayBufferLike]], or any object.\n     */\n    payload?: ArrayBufferLike | {};\n\n    /**\n     * The result of decoding the `payload`: The [[DecodedTile]].\n     */\n    decodedTile?: DecodedTile;\n\n    /**\n     * The  notifying the [[ITileDecoder]] to cancel decoding.\n     */\n    protected requestController?: RequestController;\n\n    /**\n     * Set up loading of a single [[Tile]].\n     *\n     * @param dataSource - The [[DataSource]] the tile belongs to.\n     * @param tileKey - The quadtree address of a [[Tile]].\n     * @param dataProvider - The [[DataProvider]] that retrieves the binary tile data.\n     * @param tileDecoder - The [[ITileDecoder]] that decodes the binary tile to a [[DecodeTile]].\n     */\n    constructor(\n        protected dataSource: DataSource,\n        protected tileKey: TileKey,\n        protected dataProvider: DataProvider,\n        protected tileDecoder: ITileDecoder\n    ) {\n        super(dataSource, tileKey);\n    }\n\n    /**\n     * @override\n     */\n    get priority(): number {\n        return this.m_priority;\n    }\n\n    /**\n     * @override\n     */\n    set priority(priority: number) {\n        this.m_priority = priority;\n        if (this.requestController !== undefined) {\n            this.requestController.priority = priority;\n        }\n    }\n\n    /**\n     * @override\n     */\n    protected loadImpl(\n        abortSignal: AbortSignal,\n        onDone: (doneState: TileLoaderState) => void,\n        onError: (error: Error) => void\n    ): void {\n        this.dataProvider\n            .getTile(this.tileKey, abortSignal)\n            .then(payload => {\n                if (abortSignal.aborted) {\n                    // safety belt if getTile doesn't really support cancellation tokens\n                    const err = new Error(\"Aborted\");\n                    err.name = \"AbortError\";\n                    throw err;\n                }\n                this.onLoaded(payload, onDone, onError);\n            })\n            .catch(error => {\n                // Handle abort messages from fetch and also our own.\n                if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                    return;\n                }\n                onError(error);\n            });\n    }\n\n    /**\n     * @override\n     */\n    protected cancelImpl(): void {\n        if (this.state === TileLoaderState.Decoding && this.requestController) {\n            // we should cancel any decodes already in progress!\n            this.requestController.abort();\n            this.requestController = undefined;\n        }\n    }\n\n    /**\n     * Start decoding the payload.\n     */\n    protected startDecodeTile(\n        onDone: (doneState: TileLoaderState) => void,\n        onError: (error: Error) => void\n    ) {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n\n        this.state = TileLoaderState.Decoding;\n        this.payload = undefined;\n\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new RequestController(this.priority);\n        this.requestController = requestController;\n\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .decodeTile(payload, this.tileKey, dataSource.projection, requestController)\n            .then(decodedTile => {\n                if (requestController.signal.aborted) {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n\n                this.onDecoded(decodedTile, onDone);\n            })\n            .catch(error => {\n                // Handle abort messages from fetch and also our own.\n                if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n                onError(error);\n            });\n    }\n\n    /**\n     * Called when binary data has been loaded. The loading state is now progressing to decoding.\n     *\n     * @param payload - Binary data in form of [[ArrayBufferLike]], or any object.\n     */\n    private onLoaded(\n        payload: ArrayBufferLike | {},\n        onDone: (doneState: TileLoaderState) => void,\n        onError: (error: Error) => void\n    ) {\n        this.state = TileLoaderState.Loaded;\n        this.payload = payload;\n\n        const byteLength = (payload as ArrayBufferLike).byteLength;\n        if (\n            byteLength === 0 ||\n            (payload.constructor === Object && Object.keys(payload).length === 0)\n        ) {\n            // Object is empty\n            this.onDecoded(\n                {\n                    geometries: [],\n                    techniques: []\n                },\n                onDone\n            );\n            return;\n        }\n\n        // TBD: we might suspend decode if tile is not visible ... ?\n        this.startDecodeTile(onDone, onError);\n    }\n\n    /**\n     * Called when the decoding is finished, and the [[DecodedTile]] has been created.\n     *\n     * @param decodedTile - The [[DecodedTile]].\n     */\n    private onDecoded(\n        decodedTile: DecodedTile | undefined,\n        onDone: (doneState: TileLoaderState) => void\n    ) {\n        this.decodedTile = decodedTile;\n        onDone(TileLoaderState.Ready);\n    }\n}\n\n/**\n * Subclass of [[TileLoader]] which is used by [[TileDataSource]] to load the [[TileInfo]] meta\n * data, not the tile data itself.\n */\nexport class TileInfoLoader extends TileLoader {\n    tileInfo?: TileInfo;\n\n    /** @override */\n    protected startDecodeTile(\n        onDone: (doneState: TileLoaderState) => void,\n        onError: (error: Error) => void\n    ) {\n        const payload = this.payload;\n        if (payload === undefined) {\n            logger.error(\"TileInfoLoader#startDecodeTile: Cannot decode without payload\");\n            return;\n        }\n\n        this.state = TileLoaderState.Decoding;\n        this.payload = undefined;\n\n        // Save our cancellation point, so we can be reliably cancelled by any subsequent decode\n        // attempts\n        const requestController = new RequestController(this.priority);\n        this.requestController = requestController;\n\n        const dataSource = this.dataSource;\n        this.tileDecoder\n            .getTileInfo(payload, this.tileKey, dataSource.projection, requestController)\n            .then(tileInfo => {\n                if (requestController.signal.aborted) {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n                this.tileInfo = tileInfo;\n\n                onDone(TileLoaderState.Ready);\n            })\n            .catch(error => {\n                // Handle abort messages from fetch and also our own.\n                if (error.name === \"AbortError\" || error.message === \"AbortError: Aborted\") {\n                    // our flow is cancelled, silently return\n                    return;\n                }\n                onError(error);\n            });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Functionality needed to render a map.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/AnimatedExtrusionHandler\";\nexport * from \"./lib/BaseTileLoader\";\nexport * from \"./lib/BoundsGenerator\";\nexport * from \"./lib/CameraMovementDetector\";\nexport * from \"./lib/CameraUtils\";\nexport * from \"./lib/ClipPlanesEvaluator\";\nexport * from \"./lib/ColorCache\";\nexport * from \"./lib/composing\";\nexport * from \"./lib/ConcurrentDecoderFacade\";\nexport * from \"./lib/ConcurrentTilerFacade\";\nexport * from \"./lib/copyrights/CopyrightElementHandler\";\nexport * from \"./lib/copyrights/CopyrightInfo\";\nexport * from \"./lib/copyrights/CopyrightProvider\";\nexport * from \"./lib/copyrights/CopyrightCoverageProvider\";\nexport * from \"./lib/copyrights/UrlCopyrightProvider\";\nexport * from \"./lib/DataSource\";\nexport * from \"./lib/EventDispatcher\";\nexport * from \"./lib/FixedClipPlanesEvaluator\";\nexport * from \"./lib/FovCalculation\";\nexport * from \"./lib/PolarTileDataSource\";\nexport * from \"./lib/DecodedTileHelpers\";\nexport * from \"./lib/DepthPrePass\";\nexport * from \"./lib/DisplacementMap\";\nexport * from \"./lib/ElevationProvider\";\nexport * from \"./lib/ElevationRangeSource\";\nexport * from \"./lib/ITileLoader\";\nexport * from \"./lib/image/Image\";\nexport * from \"./lib/image/ImageCache\";\nexport * from \"./lib/image/MapViewImageCache\";\nexport * from \"./lib/MapAnchors\";\nexport * from \"./lib/MapView\";\nexport * from \"./lib/MapViewAtmosphere\";\nexport * from \"./lib/MapViewFog\";\nexport * from \"./lib/MapViewPoints\";\nexport * from \"./lib/PickHandler\";\nexport * from \"./lib/poi/PoiManager\";\nexport * from \"./lib/poi/PoiTableManager\";\nexport * from \"./lib/Statistics\";\nexport * from \"./lib/text/TextElement\";\nexport * from \"./lib/text/TextElementsRenderer\";\nexport * from \"./lib/text/TextStyleCache\";\nexport * from \"./lib/TextureLoader\";\nexport * from \"./lib/ThemeLoader\";\nexport * from \"./lib/Tile\";\nexport * from \"./lib/geometry/TileDataAccessor\";\nexport * from \"./lib/geometry/TileGeometry\";\nexport * from \"./lib/Utils\";\nexport * from \"./lib/VisibleTileSet\";\nexport * from \"./lib/WorkerBasedDecoder\";\nexport * from \"./lib/WorkerBasedTiler\";\nexport * from \"./lib/workers/WorkerLoader\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    getPropertyValue,\n    isExtrudedPolygonTechnique,\n    MapEnv,\n    Technique\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { ExtrusionFeature, ExtrusionFeatureDefs } from \"@here/harp-materials\";\nimport { MathUtils } from \"@here/harp-utils\";\n\nimport { DataSource } from \"./DataSource\";\nimport { MapView } from \"./MapView\";\nimport { Tile } from \"./Tile\";\n\n/**\n * Animation states for extrusion effect\n */\nexport enum AnimatedExtrusionState {\n    None,\n    Started,\n    Finished\n}\n\nconst DEFAULT_EXTRUSION_DURATION = 750; // milliseconds\nconst DEFAULT_MIN_ZOOM_LEVEL = 1;\n\ninterface TileExtrusionState {\n    materials: ExtrusionFeature[];\n    animated: boolean;\n}\n\n// key is tile's morton code.\ntype TileMap = Map<number, TileExtrusionState>;\n\n/**\n * Handles animated extrusion effect of the buildings in {@link MapView}.\n */\nexport class AnimatedExtrusionHandler {\n    /**\n     * Animate the extrusion of the buildings if set to `true`.\n     */\n    enabled: boolean = true;\n    /**\n     * Duration of the building's extrusion in milliseconds\n     */\n    duration: number = DEFAULT_EXTRUSION_DURATION;\n\n    private m_minZoomLevel: number = DEFAULT_MIN_ZOOM_LEVEL;\n    private m_forceEnabled: boolean = false;\n\n    private readonly m_dataSourceMap: Map<DataSource, TileMap> = new Map();\n    private m_state: AnimatedExtrusionState = AnimatedExtrusionState.None;\n    private m_startTime: number = -1;\n\n    /**\n     * Creates an {@link AnimatedExtrusionHandler} in {@link MapView}.\n     *\n     * @param m_mapView - Instance of {@link MapView} on which the animation will run.\n     */\n    constructor(private readonly m_mapView: MapView) {}\n\n    /**\n     * Returns whether the extrusion animation is force enabled or not.\n     */\n    get forceEnabled(): boolean {\n        return this.m_forceEnabled;\n    }\n\n    /**\n     * If `forceEnabled` is set to `true` then `animateExtrusion` and `animateExtrusionDuration`\n     * values from [[extrudedPolygonTechnique]] will be ignored and\n     * `AnimatedExtrusionHandler.enabled` with `AnimatedExtrusionHandler.duration` will be used\n     */\n    set forceEnabled(force: boolean) {\n        this.m_forceEnabled = force;\n        this.duration = DEFAULT_EXTRUSION_DURATION;\n    }\n\n    /**\n     * Gets min zoom level at which extruded animation is enabled.\n     */\n    get minZoomLevel() {\n        return this.m_minZoomLevel;\n    }\n\n    /**\n     * Sets the extrusion animation properties obtained from a given technique.\n     * @internal\n     * @param technique - The technique where the extrusion animation properties are defined.\n     * @param env - The environment used to evaluate technique properties.\n     * @returns True if the technique has animation enabled (or animation is forced), false\n     * otherwise.\n     */\n    setAnimationProperties(technique: Technique, env: MapEnv) {\n        if (!isExtrudedPolygonTechnique(technique)) {\n            return false;\n        }\n\n        if (technique.hasOwnProperty(\"minZoomLevel\")) {\n            this.m_minZoomLevel = (technique as any).minZoomLevel;\n        }\n\n        if (this.forceEnabled) {\n            return this.enabled;\n        }\n\n        if (technique.animateExtrusionDuration !== undefined) {\n            this.duration = technique.animateExtrusionDuration;\n        }\n\n        const animateExtrusionValue = getPropertyValue(technique.animateExtrusion, env);\n\n        if (animateExtrusionValue === null) {\n            return this.enabled;\n        }\n\n        return typeof animateExtrusionValue === \"boolean\"\n            ? animateExtrusionValue\n            : typeof animateExtrusionValue === \"number\"\n            ? animateExtrusionValue !== 0\n            : false;\n    }\n\n    /**\n     * Updates the extrusion animation for every frame.\n     * @internal\n     */\n    update(zoomLevel: number) {\n        const extrusionVisible = this.m_dataSourceMap.size > 0 && zoomLevel >= this.m_minZoomLevel;\n\n        if (this.m_state === AnimatedExtrusionState.None && extrusionVisible) {\n            this.m_state = AnimatedExtrusionState.Started;\n        } else if (this.m_state !== AnimatedExtrusionState.None && !extrusionVisible) {\n            this.resetAnimation(true);\n        }\n\n        this.animateExtrusion();\n    }\n\n    /**\n     * Adds a tile to be animated.\n     * @internal\n     * @param tile - The tile to be animated.\n     * @param materials - Extruded materials belonging to the tile.\n     */\n    add(tile: Tile, materials: ExtrusionFeature[]): void {\n        tile.addDisposeCallback(this.removeTile.bind(this));\n        let animated = false;\n\n        if (this.m_state !== AnimatedExtrusionState.None) {\n            animated = this.skipAnimation(tile);\n            if (animated) {\n                // Set extrusion ratio to 1 if the tile skips the animation.\n                this.setTileExtrusionRatio(materials, 1);\n            } else if (this.m_state === AnimatedExtrusionState.Finished) {\n                // Otherwise, if animation was finished, restart animation but leave already\n                //  animated tiles untouched.\n                this.resetAnimation(false);\n            }\n        }\n        this.getOrCreateTileMap(tile.dataSource).set(tile.tileKey.mortonCode(), {\n            materials,\n            animated\n        });\n    }\n\n    /**\n     * Is `true` if there's any extrusion animation ongoing.\n     */\n    get isAnimating(): boolean {\n        return (\n            this.m_state !== AnimatedExtrusionState.Finished &&\n            this.m_state !== AnimatedExtrusionState.None\n        );\n    }\n\n    private getTileMap(dataSource: DataSource, create: boolean = false): TileMap | undefined {\n        return this.m_dataSourceMap.get(dataSource);\n    }\n\n    private getOrCreateTileMap(dataSource: DataSource): TileMap {\n        let tileMap = this.m_dataSourceMap.get(dataSource);\n        if (!tileMap) {\n            tileMap = new Map();\n            this.m_dataSourceMap.set(dataSource, tileMap);\n        }\n        return tileMap;\n    }\n\n    private skipAnimation(tile: Tile): boolean {\n        return this.wasAnyAncestorAnimated(tile) || this.wasAnyDescendantAnimated(tile);\n    }\n\n    private wasAnyAncestorAnimated(tile: Tile): boolean {\n        const minLevel = tile.dataSource.getDataZoomLevel(this.m_minZoomLevel);\n        const distanceToMinLevel = Math.max(0, tile.tileKey.level - minLevel);\n        const levelsUp = Math.min(\n            distanceToMinLevel,\n            this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceUp\n        );\n        const tileMap = this.getTileMap(tile.dataSource);\n        if (!tileMap) {\n            return false;\n        }\n        let lastTileKey = tile.tileKey;\n        for (let deltaUp = 1; deltaUp <= levelsUp; ++deltaUp) {\n            lastTileKey = lastTileKey.parent();\n            if (tileMap.get(lastTileKey.mortonCode())?.animated ?? false) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private wasAnyDescendantAnimated(tile: Tile): boolean {\n        const distanceToMaxLevel = tile.dataSource.maxDataLevel - tile.tileKey.level;\n        const levelsDown = Math.min(\n            distanceToMaxLevel,\n            this.m_mapView.visibleTileSet.options.quadTreeSearchDistanceDown\n        );\n\n        const tileMap = this.getTileMap(tile.dataSource);\n        if (!tileMap) {\n            return false;\n        }\n        const tilingScheme = tile.dataSource.getTilingScheme();\n        let nextTileKeys = [tile.tileKey];\n        let childTileKeys: TileKey[] = [];\n        for (let deltaDown = 1; deltaDown <= levelsDown; ++deltaDown) {\n            childTileKeys.length = 0;\n            for (const tileKey of nextTileKeys) {\n                for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n                    if (tileMap.get(childTileKey.mortonCode())?.animated ?? false) {\n                        return true;\n                    }\n                    childTileKeys.push(childTileKey);\n                }\n            }\n            // swap\n            [nextTileKeys, childTileKeys] = [childTileKeys, nextTileKeys];\n        }\n\n        return false;\n    }\n\n    private removeTile(tile: Tile): void {\n        const tileMap = this.getTileMap(tile.dataSource);\n        if (!tileMap) {\n            return;\n        }\n        tileMap.delete(tile.tileKey.mortonCode());\n\n        // Remove tile map if it's empty. That way, counting the number of data sources in the\n        // map is enough to know if there's any tile.\n        if (tileMap.size === 0) {\n            this.m_dataSourceMap.delete(tile.dataSource);\n        }\n    }\n\n    private animateExtrusion() {\n        if (this.m_state !== AnimatedExtrusionState.Started) {\n            return;\n        }\n\n        const currentTime = Date.now();\n        if (this.m_startTime < 0) {\n            this.m_startTime = currentTime;\n        }\n\n        const duration = this.duration;\n        const timeProgress = Math.min(currentTime - this.m_startTime, duration);\n\n        const extrusionRatio = MathUtils.easeInOutCubic(\n            ExtrusionFeatureDefs.DEFAULT_RATIO_MIN,\n            ExtrusionFeatureDefs.DEFAULT_RATIO_MAX,\n            timeProgress / duration\n        );\n        this.setExtrusionRatio(extrusionRatio);\n\n        if (timeProgress >= duration) {\n            this.m_state = AnimatedExtrusionState.Finished;\n        }\n\n        this.m_mapView.update();\n    }\n\n    private resetAnimation(resetTiles: boolean) {\n        this.m_state = AnimatedExtrusionState.None;\n        this.m_startTime = -1;\n        if (resetTiles) {\n            this.m_dataSourceMap.forEach(tileMap => {\n                tileMap.forEach(state => {\n                    state.animated = false;\n                });\n            });\n        }\n    }\n\n    private setExtrusionRatio(value: number) {\n        this.m_dataSourceMap.forEach(tileMap => {\n            tileMap.forEach(state => {\n                if (!state.animated) {\n                    this.setTileExtrusionRatio(state.materials, value);\n                    if (value >= 1) {\n                        state.animated = true;\n                    }\n                }\n            });\n        });\n    }\n\n    private setTileExtrusionRatio(materials: ExtrusionFeature[], value: number) {\n        materials.forEach(material => {\n            material.extrusionRatio = value;\n        });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FlatTheme, Theme } from \"@here/harp-datasource-protocol\";\nimport { TileKey, TilingScheme, webMercatorTilingScheme } from \"@here/harp-geoutils\";\n\nimport { DataSource } from \"./DataSource\";\nimport { addGroundPlane } from \"./geometry/AddGroundPlane\";\nimport { Tile } from \"./Tile\";\n\n/**\n * Provides background geometry for all tiles.\n */\nexport class BackgroundDataSource extends DataSource {\n    static readonly GROUND_RENDER_ORDER = Number.MIN_SAFE_INTEGER;\n    private static readonly DEFAULT_TILING_SCHEME = webMercatorTilingScheme;\n    private m_tilingScheme: TilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;\n\n    constructor() {\n        super({ name: \"background\" });\n        this.cacheable = true;\n        this.addGroundPlane = true;\n        this.enablePicking = false;\n    }\n\n    updateStorageLevelOffset() {\n        let storageLevelOffset: number | undefined;\n\n        this.mapView.dataSources.forEach(ds => {\n            if (ds === this) {\n                return;\n            }\n            const tilingScheme = ds.getTilingScheme();\n            if (tilingScheme === this.m_tilingScheme) {\n                storageLevelOffset =\n                    storageLevelOffset === undefined\n                        ? ds.storageLevelOffset\n                        : Math.max(storageLevelOffset, ds.storageLevelOffset);\n            }\n        });\n\n        if (storageLevelOffset === undefined) {\n            storageLevelOffset = 0;\n        }\n\n        if (storageLevelOffset !== this.storageLevelOffset) {\n            this.storageLevelOffset = storageLevelOffset;\n            this.mapView.clearTileCache(this.name);\n        }\n    }\n\n    /** @override */\n    async setTheme(theme: Theme | FlatTheme, languages?: string[]): Promise<void> {\n        this.mapView.clearTileCache(this.name);\n    }\n\n    setTilingScheme(tilingScheme?: TilingScheme) {\n        const newScheme = tilingScheme ?? BackgroundDataSource.DEFAULT_TILING_SCHEME;\n        if (newScheme === this.m_tilingScheme) {\n            return;\n        }\n\n        this.m_tilingScheme = newScheme;\n        this.updateStorageLevelOffset();\n        this.mapView.clearTileCache(this.name);\n    }\n\n    /** @override */\n    getTilingScheme(): TilingScheme {\n        return this.m_tilingScheme;\n    }\n\n    /** @override */\n    getTile(tileKey: TileKey): Tile | undefined {\n        const tile = new Tile(this, tileKey);\n        tile.forceHasGeometry(true);\n        addGroundPlane(tile, BackgroundDataSource.GROUND_RENDER_ORDER);\n\n        return tile;\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { DataSource } from \"./DataSource\";\nimport { ITileLoader, TileLoaderState } from \"./ITileLoader\";\n\nconst logger = LoggerManager.instance.create(\"BaseTileLoader\");\n\n/**\n * @internal\n * Base class for tile loaders that provides state handling, request abortion and a load promise.\n */\nexport abstract class BaseTileLoader implements ITileLoader {\n    state: TileLoaderState = TileLoaderState.Initialized;\n\n    /**\n     * Error object if loading or decoding failed.\n     */\n    error?: Error;\n\n    protected m_priority: number = 0;\n\n    /**\n     * The abort controller notifying the [[DataProvider]] to cancel loading.\n     */\n    private loadAbortController = new AbortController();\n\n    /**\n     * The promise which is resolved when loading and decoding have finished.\n     */\n    private donePromise?: Promise<TileLoaderState>;\n\n    /**\n     * The internal function that is called when loading and decoding have finished successfully.\n     */\n    private resolveDonePromise?: (state: TileLoaderState) => void;\n\n    /**\n     * The internal function that is called when loading and decoding failed.\n     */\n    private rejectedDonePromise?: (state: TileLoaderState) => void;\n\n    /**\n     * Set up loading of a single [[Tile]].\n     *\n     * @param dataSource - The [[DataSource]] the tile belongs to.\n     * @param tileKey - The quadtree address of a [[Tile]].\n     */\n    constructor(protected dataSource: DataSource, protected tileKey: TileKey) {}\n\n    /**\n     * @override\n     */\n    get priority(): number {\n        return this.m_priority;\n    }\n\n    /**\n     * @override\n     */\n    set priority(value: number) {\n        this.m_priority = value;\n    }\n\n    /**\n     * @override\n     */\n    loadAndDecode(): Promise<TileLoaderState> {\n        switch (this.state) {\n            case TileLoaderState.Loading:\n            case TileLoaderState.Loaded:\n            case TileLoaderState.Decoding:\n                // tile is already loading\n                return this.donePromise!;\n\n            case TileLoaderState.Ready:\n            case TileLoaderState.Failed:\n            case TileLoaderState.Initialized:\n            case TileLoaderState.Canceled:\n                // restart loading\n                this.load();\n                return this.donePromise!;\n        }\n    }\n\n    /**\n     * @override\n     */\n    waitSettled(): Promise<TileLoaderState> {\n        if (!this.donePromise) {\n            return Promise.resolve(this.state);\n        }\n        return this.donePromise;\n    }\n\n    /**\n     * @override\n     */\n    cancel(): void {\n        if (this.state === TileLoaderState.Loading) {\n            this.loadAbortController.abort();\n            this.loadAbortController = new AbortController();\n        }\n        this.cancelImpl();\n\n        this.onDone(TileLoaderState.Canceled);\n    }\n\n    /**\n     * @override\n     */\n    get isFinished(): boolean {\n        return (\n            this.state === TileLoaderState.Ready ||\n            this.state === TileLoaderState.Canceled ||\n            this.state === TileLoaderState.Failed\n        );\n    }\n\n    /**\n     * Called on load cancelation, may be overriden to extend behaviour.\n     */\n    protected cancelImpl(): void {}\n\n    /**\n     * Called on tile load.\n     *\n     * @param abortSignal - Signal emitted to abort loading.\n     * @param onDone - Callback that must be called once the loading is done.\n     * @param onError - Callback that must be called on loading error.\n     */\n    protected abstract loadImpl(\n        abortSignal: AbortSignal,\n        onDone: (doneState: TileLoaderState) => void,\n        onError: (error: Error) => void\n    ): void;\n\n    /**\n     * Start loading. Only call if loading did not start yet.\n     */\n    private load() {\n        this.loadImpl(\n            this.loadAbortController.signal,\n            this.onDone.bind(this),\n            this.onError.bind(this)\n        );\n\n        if (this.donePromise === undefined) {\n            this.donePromise = new Promise<TileLoaderState>((resolve, reject) => {\n                this.resolveDonePromise = resolve;\n                this.rejectedDonePromise = reject;\n            });\n        }\n        this.state = TileLoaderState.Loading;\n    }\n\n    /**\n     * Called when loading and decoding has finished successfully. Resolves loading promise if the\n     * state is Ready, otherwise it rejects the promise with the supplied state.\n     *\n     * @param doneState - The latest state of loading.\n     */\n    private onDone(doneState: TileLoaderState) {\n        if (this.resolveDonePromise && doneState === TileLoaderState.Ready) {\n            this.resolveDonePromise(doneState);\n        } else if (this.rejectedDonePromise) {\n            this.rejectedDonePromise(doneState);\n        }\n        this.resolveDonePromise = undefined;\n        this.rejectedDonePromise = undefined;\n        this.donePromise = undefined;\n        this.state = doneState;\n    }\n\n    /**\n     * Called when loading or decoding has finished with an error.\n     *\n     * @param error - Error object describing the failing.\n     */\n    private onError(error: Error) {\n        if (this.state === TileLoaderState.Canceled) {\n            // If we're canceled, we should simply ignore any state transitions and errors from\n            // underlying load/decode ops.\n            return;\n        }\n        const dataSource = this.dataSource;\n        logger.error(\n            `[${dataSource.name}]: failed to load tile ${this.tileKey.mortonCode()}`,\n            error\n        );\n\n        this.error = error;\n\n        this.onDone(TileLoaderState.Failed);\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GeoPolygon, Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport { PerspectiveCamera } from \"three\";\n\nimport { PlaneViewBounds } from \"./PlaneViewBounds\";\nimport { SphereViewBounds } from \"./SphereViewBounds\";\nimport { ViewBounds } from \"./ViewBounds\";\n\n/**\n * Generates Bounds for a camera view and a projection\n *\n * @internal\n */\nexport class BoundsGenerator {\n    private m_viewBounds!: ViewBounds;\n\n    constructor(\n        private readonly m_view: {\n            camera: PerspectiveCamera;\n            projection: Projection;\n            tileWrappingEnabled: boolean;\n        }\n    ) {\n        this.createViewBounds();\n    }\n\n    /**\n     * Generates a {@link @here/harp-geoutils#GeoPolygon} covering the visible map.\n     * The coordinates are sorted to ccw winding, so a polygon could be drawn with them.\n     * @returns The GeoPolygon with the view bounds or undefined if world is not in view.\n     */\n    generate(): GeoPolygon | undefined {\n        if (this.m_view.projection !== this.m_viewBounds.projection) {\n            this.createViewBounds();\n        }\n        return this.m_viewBounds.generate();\n    }\n\n    private createViewBounds() {\n        this.m_viewBounds =\n            this.m_view.projection.type === ProjectionType.Planar\n                ? new PlaneViewBounds(this.m_view.camera, this.m_view.projection, this.m_view)\n                : new SphereViewBounds(this.m_view.camera, this.m_view.projection);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3 } from \"three\";\n\nimport { MapView } from \"./MapView\";\nimport { MapViewUtils } from \"./Utils\";\n\n/**\n * The default value for camera movement throttling, in milliseconds.\n */\nconst DEFAULT_THROTTLING_TIMEOUT = 300;\n\n/**\n * The `CameraMovementDetector` class checks for changes in camera position and orientation, to\n * detect continuous movements without the animation mode activated in {@link MapView}. If the\n * interaction is not continuous enough, you can use a throttling timer to reduce the number of\n * callbacks.\n */\nexport class CameraMovementDetector {\n    private m_lastAttitude?: MapViewUtils.Attitude;\n    private readonly m_lastCameraPos = new Vector3();\n    private readonly m_newCameraPos = new Vector3();\n    private m_cameraMovedLastFrame: boolean | undefined;\n    private m_throttlingTimerId?: number = undefined;\n    private m_movementDetectorDeadline: number = 0;\n\n    /**\n     * Initializes the detector with timeout value and callbacks. {@link MapView} also provides\n     * events for client code to be notified when these cues occur.\n     *\n     * @param m_throttlingTimeout - The delay, in milliseconds, between the last user interaction\n     * detected and the call to `m_movementFinishedFunc`; the default is `300`.\n     * @param m_movementStartedFunc - Callback function, called when the user starts interacting.\n     * @param m_movementFinishedFunc - Callback function, called when the user stops interacting.\n     */\n    constructor(\n        private readonly m_throttlingTimeout: number | undefined,\n        private m_movementStartedFunc: (() => void) | undefined,\n        private m_movementFinishedFunc: (() => void) | undefined\n    ) {\n        if (this.m_throttlingTimeout === undefined) {\n            this.m_throttlingTimeout = DEFAULT_THROTTLING_TIMEOUT;\n        }\n    }\n\n    /**\n     * Checks if the camera has moved since the last time it was checked. The\n     * `m_movementStartedFunc` is called when a movement starts. If no movement\n     * is detected, a timer for `m_movementFinishedFunc` starts.\n     *\n     * @param mapView - [[Mapview]]'s position and camera are checked for modifications.\n     */\n    checkCameraMoved(mapView: MapView, now: number): boolean {\n        const newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n\n        if (this.m_lastAttitude === undefined) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n            return false;\n        }\n        const cameraMoved =\n            !this.m_lastCameraPos.equals(newCameraPos) ||\n            newAttitude.yaw !== this.m_lastAttitude.yaw ||\n            newAttitude.pitch !== this.m_lastAttitude.pitch ||\n            newAttitude.roll !== this.m_lastAttitude.roll;\n\n        if (cameraMoved) {\n            this.m_lastCameraPos.copy(newCameraPos);\n            this.m_lastAttitude = newAttitude;\n        }\n\n        if (cameraMoved !== this.m_cameraMovedLastFrame) {\n            if (cameraMoved) {\n                this.movementStarted();\n            }\n            this.m_cameraMovedLastFrame = cameraMoved;\n        }\n        if (cameraMoved) {\n            // Start timer\n            this.m_movementDetectorDeadline = now + this.m_throttlingTimeout!;\n            this.startMovementFinishedTimer(now);\n        }\n\n        return this.m_cameraMovedLastFrame;\n    }\n\n    /**\n     * Reset the saved camera position. Next time checkCameraMoved is called, it will return\n     * `false`.\n     */\n    clear(mapView: MapView) {\n        const newCameraPos = mapView.camera.getWorldPosition(this.m_newCameraPos);\n        this.m_lastCameraPos.set(newCameraPos.x, newCameraPos.y, newCameraPos.z);\n\n        const newAttitude = MapViewUtils.extractAttitude(mapView, mapView.camera);\n        this.m_lastAttitude = newAttitude;\n    }\n\n    /**\n     * Force change of camera position. Next time checkCameraMoved is called, it will return `true`.\n     */\n    forceMoved() {\n        this.m_lastCameraPos.set(Number.NaN, Number.NaN, Number.NaN);\n    }\n\n    /**\n     * Returns `true` if the camera of this {@link MapView} is currently moving. In this case the\n     * `m_movementFinishedFunc` is waiting to be called after the throttling timer runs out.\n     */\n    get cameraIsMoving() {\n        return this.m_throttlingTimerId !== undefined;\n    }\n\n    /**\n     * Disposes resources and kills the throttling timer.\n     */\n    dispose() {\n        this.removeMovementFinishedTimer();\n        this.m_movementStartedFunc = undefined;\n        this.m_movementFinishedFunc = undefined;\n    }\n\n    /**\n     * Returns `true` if the camera has moved in the last frame.\n     */\n    get cameraMovedLastFrame(): boolean {\n        return this.m_cameraMovedLastFrame === true;\n    }\n\n    private movementStarted() {\n        if (this.m_movementStartedFunc !== undefined) {\n            this.m_movementStartedFunc();\n        }\n    }\n\n    private movementFinished() {\n        this.removeMovementFinishedTimer();\n        if (this.m_movementFinishedFunc !== undefined) {\n            this.m_movementFinishedFunc();\n        }\n    }\n\n    private startMovementFinishedTimer(now: number) {\n        if (this.m_throttlingTimerId === undefined) {\n            const remainingTime = Math.max(0, this.m_movementDetectorDeadline - now);\n            this.m_throttlingTimerId = setTimeout(this.onDeadlineTimer, remainingTime) as any;\n        }\n    }\n\n    private readonly onDeadlineTimer = () => {\n        this.m_throttlingTimerId = undefined;\n        const now = performance.now();\n        if (now >= this.m_movementDetectorDeadline) {\n            this.movementFinished();\n        } else {\n            this.startMovementFinishedTimer(now);\n        }\n    };\n\n    private removeMovementFinishedTimer() {\n        if (this.m_throttlingTimerId !== undefined) {\n            clearTimeout(this.m_throttlingTimerId);\n            this.m_throttlingTimerId = undefined;\n        }\n    }\n}\n","/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector2Like } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { MAX_FOV_RAD, MIN_FOV_RAD } from \"./FovCalculation\";\n\n// In centered projections the principal point is at NDC origin, splitting vertical and horizontal\n// fovs in two equal halves.\nfunction isCenteredProjection(principalPoint: Vector2Like): boolean {\n    return principalPoint.x === 0 && principalPoint.y === 0;\n}\n\n/**\n * Computes the fov on the positive side of NDC x or y dimension (i.e. either right or top fov).\n * @param focalLength - Focal length in pixels. It must be larger than 0.\n * @param ppOffset - Principal point NDC offset either in y or x dimension.\n * @param viewportSide - Viewport height or width in pixels, must be same dimension as ppOffset.\n * @returns side fov in radians.\n */\nfunction computePosSideFov(focalLength: number, ppOffset: number, viewportSide: number): number {\n    // see diagram in computeFocalLengthFromFov().\n    assert(focalLength > 0, \"Focal length must be larger than 0\");\n    return Math.atan(((1 - ppOffset) * viewportSide * 0.5) / focalLength);\n}\n\n/**\n * Computes the vertical or horizontal fov.\n * @param focalLength - Focal length in pixels. It must be larger than 0.\n * @param ppOffset - Principal point NDC offset in y (vertical fov) or x dimension (horizontal fov).\n * @param viewportSide - Viewport height or width in pixels, must be same dimension as ppOffset.\n * @returns vertical or horizontal fov in radians.\n */\nfunction computeFov(focalLength: number, ppOffset: number, viewportSide: number): number {\n    assert(focalLength > 0, \"Focal length must be larger than 0\");\n    // For uncentered fov, compute the two fov sides separately. The fov on the negative NDC\n    // side is computed in the same way as that for the positive side but flipping the offset sign.\n    return ppOffset === 0\n        ? 2 * Math.atan((0.5 * viewportSide) / focalLength)\n        : computePosSideFov(focalLength, ppOffset, viewportSide) +\n              computePosSideFov(focalLength, -ppOffset, viewportSide);\n}\n\n/**\n * For off-center projections, fovs are asymmetric. In that case, the camera saves some of the side\n * fovs to save some computations. All values are in radians.\n */\ninterface Fovs {\n    top: number;\n    right: number;\n    horizontal: number; // left = horizontal - right.\n}\n\nfunction getFovs(camera: THREE.PerspectiveCamera): Fovs | undefined {\n    return camera.userData.fovs;\n}\n\n/**\n * Saves camera vertical fov and focal length. For off-center projections, saves side fovs as well.\n */\nfunction setCameraParams(\n    camera: THREE.PerspectiveCamera,\n    ppalPoint: Vector2Like,\n    focalLength: number,\n    viewportHeight: number,\n    verticalFov: number\n): void {\n    const viewportWidth = viewportHeight * camera.aspect;\n    let hFov = computeFov(focalLength, ppalPoint.x, viewportWidth);\n\n    if (hFov < MIN_FOV_RAD || hFov > MAX_FOV_RAD) {\n        // Invalid horizontal fov, clamp and compute again focal length and vertical fov.\n        hFov = THREE.MathUtils.clamp(hFov, MIN_FOV_RAD, MAX_FOV_RAD);\n        const focalLength = computeFocalLengthFromFov(hFov, viewportWidth, ppalPoint.x);\n        verticalFov = computeFov(focalLength, ppalPoint.y, viewportHeight);\n    }\n\n    camera.fov = THREE.MathUtils.radToDeg(verticalFov);\n\n    if (isCenteredProjection(ppalPoint)) {\n        delete camera.userData.fovs;\n    } else {\n        const width = viewportHeight * camera.aspect;\n        camera.userData.fovs = {\n            top: computePosSideFov(focalLength, ppalPoint.y, viewportHeight),\n            right: computePosSideFov(focalLength, ppalPoint.x, width),\n            horizontal: hFov\n        } as Fovs;\n    }\n    camera.userData.focalLength = focalLength;\n}\n\n/**\n * Computes a camera's focal length from vertical fov and viewport height or horizontal fov and\n * viewport width.\n * @beta\n *\n * @param fov - Vertical or horizontal field of view in radians.\n * @param viewportSide - Viewport height if fov is vertical, otherwise viewport width.\n * @param ppOffset - Principal point offset in y direction if fov is vertical,\n * otherwise in x direction.\n * @returns focal length in pixels.\n */\nfunction computeFocalLengthFromFov(fov: number, viewportSide: number, ppOffset: number): number {\n    //               C <- Projection center\n    //              /|-_\n    //             / |  -_                      pfov = fov along positive NDC side (tfov or rfov)\n    //            /  |    -_                    nfov = fov along negative NDC side (bfov or lfov)\n    //           /   |      -_\n    //          /    |        -_\n    //         /pfov |  nfov    -_\n    //        /      |            -_\n    //       /       |              -_\n    //    a /        |focal length(f) -_ b\n    //     /         |                  -_\n    //    /          |  Principal point   -_\n    //   /           | /      (pp)          -_\n    // A/____________P________________________-_B  Viewport\n    //  <------------><------------------------>\n    //  (1-ppOff)*s/2      (1+ppOff)*s/2\n    //  <-------------------------------------->\n    //     s = viewportSide (height or width)\n    //\n    // Diagram of fov splitting (potentially asymmetric) along a viewport side (height or width).\n    // For viewport height, fov is split into top (tfov) and bottom (bfov) fovs. For width, it's\n    // split into right fov (rfov) and left fov (lfov).\n\n    // Case 1. Symmetric fov split. Principal point is centered (centered projection):\n    const halfSide = viewportSide / 2;\n    const ppCentered = ppOffset === 0;\n    if (ppCentered) {\n        return halfSide / Math.tan(fov / 2);\n    }\n\n    // Case 2. Asymmetric fov split. Off-center perspective projection:\n    const eps = 1e-6;\n    const ppOffsetSq = ppOffset ** 2;\n\n    if (Math.abs(fov - Math.PI / 2) < eps) {\n        // Case 2a. Special case for (close to) right angle fov, tangent approaches infinity:\n        // 3 right triangles: ACB, APC, BPC. Use pythagorean theorem on each to get 3 equations:\n        // a^2 = f^2 + (1-ppOff)*s/2\n        // b^2 = f^2 + (1+ppOff)*s/2\n        // h^2 = a^2 + b^2\n        // Substitute a^2 and b^2 in third equation and solve for f to get:\n        // f = (s/2) * sqrt(1-ppOff^2)\n        return halfSide * Math.sqrt(1 - ppOffsetSq);\n    }\n\n    // Case 2b. General asymmetric fov case:\n    // (1)   tan(pfov) = (1-ppOff)*s / (2*f)\n    // (2)   tan(nfov) = (1+ppOff)*s / (2*f)\n    // Use formula for the tan of the sum of two angles:\n    // (3)   tan(fov) = tan(pfov+nfov) = (tan(pfov) + tan(nfov)) / (1 - (tan(pfov) * tan(nfov)))\n\n    // Substitute (1) and (2) in (3) and solve for f to get a quadratic equation:\n    // 4*(tan(fov))^2 - 4*s*f - tan(fov)(1-ppOff^2)*s^2 = 0 , solving for f:\n    // f = (s/2) * (1 +/- sqrt(1 + tan(fov)(1-ppOff^2)^2)) / tan(fov)\n\n    // ppOff (principal point offset) is in [-1,1], so there's two real solutions (radicant is >=1)\n    // and we choose the positive solution on each case:\n    // a) tan(fov) > 0, fov in (0,pi/2) -> f = (s/2) * (1 + sqrt(1 + tan(fov)^2(1-ppOff^2))) / tan(fov)\n    // b) tan(fov) < 0, fov in (pi/2,pi) -> f = (s/2) * (1 - sqrt(1 + tan(fov)^2(1-ppOff^2))) / tan(fov)\n\n    const tanFov = Math.tan(fov);\n    const sign = Math.sign(tanFov);\n    const sqrt = Math.sqrt(1 + tanFov ** 2 * (1 - ppOffsetSq));\n    const f = (halfSide * (1 + sign * sqrt)) / tanFov;\n    assert(f >= 0, \"Focal length must be larger than 0\");\n    return f;\n}\n\nexport namespace CameraUtils {\n    /**\n     * Returns the camera's focal length.\n     * @beta\n     *\n     * @param camera - The camera.\n     * @returns The focal length in pixels or `undefined` if not set.\n     */\n    export function getFocalLength(camera: THREE.PerspectiveCamera): number | undefined {\n        return camera.userData?.focalLength;\n    }\n\n    /**\n     * Sets a camera's focal length.\n     * @remarks The camera's vertical fov will be updated to achieve the given viewport height.\n     * @beta\n     *\n     * @param camera\n     * @param focalLength - Focal length in pixels. It must be larger than 0.\n     * @param viewportHeight - Viewport height in pixels, used to compute vertical fov.\n     * @returns The new camera's focal length in pixels.\n     */\n    export function setFocalLength(\n        camera: THREE.PerspectiveCamera,\n        focalLength: number,\n        viewportHeight: number\n    ): number {\n        const ppalPoint = getPrincipalPoint(camera);\n        const vFov = computeFov(focalLength, ppalPoint.y, viewportHeight);\n        if (vFov < MIN_FOV_RAD || vFov > MAX_FOV_RAD) {\n            // Invalid vertical fov, clamp and compute again focal length.\n            setVerticalFov(camera, vFov, viewportHeight);\n        } else {\n            setCameraParams(camera, ppalPoint, focalLength, viewportHeight, vFov);\n        }\n\n        // focal length might change in setCameraParams due to horizontal fov restrictions.\n        return getFocalLength(camera)!;\n    }\n\n    /**\n     * Returns the camera's vertical field of view.\n     * @param camera - The camera.\n     * @returns The vertical fov in radians.\n     */\n    export function getVerticalFov(camera: THREE.PerspectiveCamera): number {\n        return THREE.MathUtils.degToRad(camera.fov);\n    }\n\n    /**\n     * Sets a camera's vertical fov.\n     * @remarks The camera's focal length will be updated to achieve the given viewport height.\n     * @beta\n     *\n     * @param camera\n     * @param verticalFov - Vertical field of view in radians. It'll be clamped to\n     *                      [{@link MIN_FOV_RAD}, {@link MAX_FOV_RAD}].\n     * @param viewportHeight - Viewport height in pixels, used to compute focal length.\n     * @returns The new camera's vertical fov in radians.\n     */\n    export function setVerticalFov(\n        camera: THREE.PerspectiveCamera,\n        verticalFov: number,\n        viewportHeight: number\n    ): number {\n        verticalFov = THREE.MathUtils.clamp(verticalFov, MIN_FOV_RAD, MAX_FOV_RAD);\n        const ppalPoint = getPrincipalPoint(camera);\n        const focalLength = computeFocalLengthFromFov(verticalFov, viewportHeight, ppalPoint.y);\n\n        setCameraParams(camera, ppalPoint, focalLength, viewportHeight, verticalFov);\n\n        // vertical fov might change in setCameraParams due to horizontal fov restrictions.\n        return getVerticalFov(camera);\n    }\n\n    /**\n     * Calculates object's screen size based on the focal length and it's camera distance.\n     * @beta\n     *\n     * @param focalLength - Focal length in pixels (see {@link setVerticalFov})\n     * @param distance - Object distance in world space.\n     * @param worldSize - Object size in world space.\n     * @return object size in screen space.\n     */\n    export function convertWorldToScreenSize(\n        focalLength: number,\n        distance: number,\n        worldSize: number\n    ): number {\n        return (focalLength * worldSize) / distance;\n    }\n\n    /**\n     * Calculates object's world size based on the focal length and it's camera distance.\n     * @beta\n     *\n     * @param focalLength - Focal length in pixels (see {@link setVerticalFov})\n     * @param distance - Object distance in world space.\n     * @param screenSize - Object size in screen space.\n     * @return object size in world space.\n     */\n    export function convertScreenToWorldSize(\n        focalLength: number,\n        distance: number,\n        screenSize: number\n    ): number {\n        return (distance * screenSize) / focalLength;\n    }\n\n    /**\n     * Returns the camera's principal point (intersection of principal ray and image plane)\n     * in NDC coordinates.\n     * @beta\n     * @see https://en.wikipedia.org/wiki/Pinhole_camera_model\n     * @remarks This point coincides with the principal vanishing point. By default it's located at\n     * the image center (NDC coords [0,0]), and the resulting projection is centered or symmetric.\n     * But it may be offset (@see THREE.PerspectiveCamera.setViewOffset) for some use cases such as\n     * multiview setups (e.g. stereoscopic rendering), resulting in an asymmetric perspective\n     * projection.\n     * @param camera - The camera.\n     * @param result - Optional vector where the principal point coordinates will be copied.\n     * @returns A vector containing the principal point NDC coordinates.\n     */\n    export function getPrincipalPoint(\n        camera: THREE.PerspectiveCamera,\n        result: Vector2Like = new THREE.Vector2()\n    ): Vector2Like {\n        result.x = -camera.projectionMatrix.elements[8];\n        result.y = -camera.projectionMatrix.elements[9];\n        return result;\n    }\n\n    /**\n     * Sets the camera's principal point (intersection of principal ray and image plane)\n     * in NDC coordinates.\n     * @beta\n     * @see {@link getPrincipalPoint}\n     * @param camera - The camera.\n     * @param ndcCoords - The principal point's NDC coordinates, each coordinate can have values in\n     * the open interval (-1,1).\n     */\n    export function setPrincipalPoint(camera: THREE.PerspectiveCamera, ndcCoords: Vector2Like) {\n        // We only need to set to proper elements in the projection matrix:\n        // camera.projectionMatrix.elements[8] = -ndcCoords.x\n        // camera.projectionMatrix.elements[9] = -ndcCoords.y\n        // However, this can't be done directly, otherwise it'd be overwritten on the next call to\n        // camera.updateProjectionMatrix(). The only way to set the principal point is through a\n        // THREE.js camera method for multi-view setup, see:\n        // https://threejs.org/docs/#api/en/cameras/PerspectiveCamera.setViewOffset\n        const height = 1;\n        const width = camera.aspect;\n\n        // Principal point splits fov in two angles that must be strictly less than 90 degrees\n        // (each one belongs to a right triangle). Setting the principal point at the edges (-1 or\n        // 1) would make it impossible to achieve an fov >= 90. Thus, clamp the principal point\n        // coordinates to values slightly smaller than 1.\n        const maxNdcCoord = 1 - 1e-6;\n        camera.setViewOffset(\n            width,\n            height,\n            (-THREE.MathUtils.clamp(ndcCoords.x, -maxNdcCoord, maxNdcCoord) * width) / 2,\n            (THREE.MathUtils.clamp(ndcCoords.y, -maxNdcCoord, maxNdcCoord) * height) / 2,\n            width,\n            height\n        );\n    }\n\n    /**\n     * Returns the camera's horizontal field of view.\n     * @param camera - The camera.\n     * @returns The horizontal fov in radians.\n     */\n    export function getHorizontalFov(camera: THREE.PerspectiveCamera): number {\n        // If horizontal fov is not stored in camera, assume centered projection and compute\n        // it from the vertical fov.\n        return (\n            getFovs(camera)?.horizontal ??\n            2 * Math.atan(Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2) * camera.aspect)\n        );\n    }\n\n    /**\n     * Returns top fov angle for a given perspective camera.\n     * @beta\n     * @remarks In symmetric projections, the principal point coincides with the image center, and\n     * the vertical and horizontal FOVs are each split at that point in two equal halves.\n     * However, in asymmetric projections the principal point is not at the image center, and thus\n     * each fov is split unevenly in two parts:\n     *\n     *    Symmetric projection        Asymmetric projection\n     * -------------------------   --------------------------\n     * |           ^           |   |       ^                |\n     * |           |           |   |       |tFov            |\n     * |           |tFov       |   | lFov  v      rFov      |\n     * |           |           |   |<----->x<-------------->|\n     * |    lFov   v   rFov    |   |  ppal ^ point          |\n     * |<--------->x<--------->|   |       |    o           |\n     * | ppal point=img center |   |       | img center     |\n     * |           ^           |   |       |                |\n     * |           |bFov       |   |       |bFov            |\n     * |           |           |   |       |                |\n     * |           v           |   |       v                |\n     * -------------------------   --------------------------\n     *\n     * @param camera - The camera.\n     * @returns The top fov angle in radians.\n     */\n    export function getTopFov(camera: THREE.PerspectiveCamera): number {\n        return getFovs(camera)?.top ?? THREE.MathUtils.degToRad(camera.fov / 2);\n    }\n\n    /**\n     * Returns bottom fov angle for a given perspective camera.\n     * @see {@link CameraUtils.getTopFov}\n     * @beta\n     * @param camera - The camera.\n     * @returns The bottom fov angle in radians.\n     */\n    export function getBottomFov(camera: THREE.PerspectiveCamera): number {\n        return THREE.MathUtils.degToRad(camera.fov) - getTopFov(camera);\n    }\n\n    /**\n     * Returns right fov angle for a given perspective camera.\n     * @see {@link CameraUtils.getTopFov}\n     * @beta\n     * @param camera - The camera.\n     * @returns The right fov angle in radians.\n     */\n    export function getRightFov(camera: THREE.PerspectiveCamera): number {\n        return getFovs(camera)?.right ?? getHorizontalFov(camera) / 2;\n    }\n\n    /**\n     * Returns left fov angle for a given perspective camera.\n     * @see {@link CameraUtils.getTopFov}\n     * @beta\n     * @param camera - The camera.\n     * @returns The left fov angle in radians.\n     */\n    export function getLeftFov(camera: THREE.PerspectiveCamera): number {\n        return getFovs(camera)?.right !== undefined\n            ? getHorizontalFov(camera) - getRightFov(camera)\n            : getHorizontalFov(camera) / 2;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport { EarthConstants, Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { CameraUtils } from \"./CameraUtils\";\nimport { ElevationProvider } from \"./ElevationProvider\";\nimport { MapViewUtils } from \"./Utils\";\n\nconst epsilon = 0.000001;\n\nnamespace SphericalProj {\n    const tmpVectors: THREE.Vector3[] = [new THREE.Vector3(), new THREE.Vector3()];\n    const raycaster = new THREE.Raycaster();\n    const sphere = new THREE.Sphere(new THREE.Vector3(), EarthConstants.EQUATORIAL_RADIUS);\n\n    /**\n     * Calculate the horizon distance from a point above a sphere's surface.\n     *\n     * @remarks\n     * Returns zero if point is below surface or only very slightly above surface of sphere.\n     * @see https://en.wikipedia.org/wiki/Horizon#Derivation\n     * @param d - Distance from point to center of sphere.\n     * @param r - Radius of sphere.\n     */\n    function getHorizonDistance(d: number, r: number): number {\n        // There may be situations when maximum elevation still remains below sea level\n        // (elevation < 0) or it is negligible (elevation ~ epsilon)\n        return d - r < epsilon ? 0 : Math.sqrt(d * d - r * r);\n    }\n\n    /**\n     * Calculate furthest visible distance from camera position projected on eye direction.\n     *\n     * @remarks\n     * Furthest visible distance is assumed to be distance from camera to horizon\n     * plus distance from elevated geometry to horizon(so that high objects behind horizon\n     * remain visible).\n     * @see https://en.wikipedia.org/wiki/Horizon#Objects_above_the_horizon\n     * @param camera - The camera.\n     * @param d - Distance from camera to origin.\n     * @param minR - Min sphere radius.\n     * @param maxR - Max sphere radius.\n     */\n    export function getFarDistanceFromElevatedHorizon(\n        camera: THREE.PerspectiveCamera,\n        d: number,\n        minR: number,\n        maxR: number\n    ): number {\n        //                              F\n        //                         far +_\n        //         , - ~ ~ ~ - ,      +  <_\n        //     , '               ' , +     <_ E\n        //   ,           .          +,    . '\n        //  ,            .   maxR  + , '   /\n        // ,             .     ,  '    ,  /\n        // ,             . O '   +     , / te\n        // ,             | .    +      ,/\n        //  ,            |   . minR   ,/\n        //   ,           |     +.    ,/\n        //     ,         |    +   , '/\n        //       ' -_, _ | _ ,  '  / T (Tangent point = Horizon)\n        //     near      |  +     /\n        //             d | +    / t\n        //               | +   /\n        //               |+  /\n        //               C /---> up\n        //\n        // CF: Forward (look-at) vector.\n        // OC: Normal at camera\n        // OCF: Angle between camera normal and forward vector.\n        const t = getHorizonDistance(d, minR);\n\n        // Because we would like to see elevated geometry that may be visible beyond\n        // the tangent point on ground surface, we need to extend viewing distance along\n        // the tangent line by te (see graph above).\n        const te = getHorizonDistance(maxR, minR);\n\n        const normalToTanAngle = Math.asin(minR / d); // Angle OCT\n        // Angle between fwd vector (CF) and tangent (CT) in camera's up direction: FCT (= FCE)\n        const fwdToTanAngle = Math.abs(\n            normalToTanAngle - SphericalProj.getNormalToFwdAngle(camera)\n        );\n\n        // Project CE vector(length t + te) onto fwd vector (CF) to get far distance.\n        // |CF| = cos(FCE) * |CE| (angle CFE is the projection right angle).\n        const far = Math.cos(fwdToTanAngle) * (t + te);\n\n        return far;\n    }\n\n    /**\n     * Calculate distance to the nearest point where the near plane is tangent to the sphere,\n     * projected onto the camera forward vector.\n     * @param camera - The camera.\n     * @param bottomFov - Angle from camera forward vector to frustum bottom plane.\n     * @param R - The sphere radius.\n     * @returns The tangent point distance if the point is visible, otherwise `undefined`.\n     */\n    export function getProjNearPlaneTanDistance(\n        camera: THREE.Camera,\n        bottomFov: number,\n        R: number\n    ): number | undefined {\n        //                                                          ,^;;;;;;;;;;;;;;;;-\n        //                                                      ^^^^:                `;^^^:\n        //                          near plane              `++^                          '++^\n        //                              ,                 :?;                                `*?'\n        //                              +;              :\\\"                                     ^\\-\n        //                               {-           `/:                                         *>\n        //                                }`  :^^^^` :/                                            '{`\n        //                               ;\\N^^'     :|                                              `}`\n        //              fwdDir     ';^^^;` ,|      :(                                                 }`\n        // up                  :^^^^,   90 *>     }                                                  '}\n        //  ^            :^^^^,              ('   \\'                                                   (-\n        //  |      `;^^^;`                    }   }                                                     }\n        //  | ,^^^^:                          `}  }                                                     }\n        // CAM<--------------------------------{$?&-------------------------O                           {\n        //    \\ ';;;;;;;:`                      ^^}                  :^^^^,                             }\n        //     \\        `;;;;;;;;,               (%            -^^^^;`                                 `}\n        //      \\               `:;;;;;;;'        @, 90  '^^^^;`                                      (-\n        //       \\       camToTanVec     ';;;;;;;TAN`:^^^^\"   -R*fwdDir                               ,{\n        //        \\                              `:}@-                                               `}\n        //         \\                                *$                                              `}`\n        //   Bottom frustum plane                    }$`                                           \"(\n        //                                            }{^                                        `\\;\n        //                                            `}\"|:                                     >|`\n        //                                             '( ,*+`                               '**`\n        //                                              ;|   ^++-                         :+>:\n        //                                               ;      ;^^^;`               -;^^^,\n        //                                                          `;;;;;;;;;;;;;;;;\"\n\n        const fwdDir = camera.getWorldDirection(tmpVectors[0]);\n        const camToTanVec = tmpVectors[1].copy(fwdDir).multiplyScalar(-R).sub(camera.position);\n        const near = camToTanVec.dot(fwdDir);\n        const cosTanDirToFwdDir = near / camToTanVec.length();\n\n        // Tangent point visible if angle from fwdDir to tangent is less than to frustum bottom.\n        return cosTanDirToFwdDir > Math.cos(bottomFov) ? near : undefined;\n    }\n\n    /**\n     * Calculate the distance to the intersection of a given ray with the sphere,\n     * projected onto the camera forward vector.\n     * @param camera - The camera.\n     * @param ndcDir - Ray direction in NDC coordinates.\n     * @param R - The sphere radius.\n     * @returns Intersection distance or `undefined` if there's no intersection.\n     */\n    export function getProjSphereIntersectionDistance(\n        camera: THREE.Camera,\n        ndcDir: THREE.Vector2,\n        R: number\n    ): number | undefined {\n        raycaster.setFromCamera(ndcDir, camera);\n        sphere.radius = R;\n        const intersection = raycaster.ray.intersectSphere(sphere, tmpVectors[0]);\n\n        return intersection !== null\n            ? intersection.sub(camera.position).dot(camera.getWorldDirection(tmpVectors[1]))\n            : undefined;\n    }\n\n    /**\n     * Calculate angle between forward vector and surface normal at camera position.\n     * @param camera - The camera.\n     * @returns The angle in radians.\n     */\n    export function getNormalToFwdAngle(camera: THREE.PerspectiveCamera): number {\n        const camToOriginDir = tmpVectors[0].copy(camera.position).negate().normalize();\n        const cosAngle = camToOriginDir.dot(camera.getWorldDirection(tmpVectors[1]));\n        return Math.acos(THREE.MathUtils.clamp(cosAngle, -1.0, 1.0));\n    }\n}\n\nexport interface ClipPlanesEvaluator {\n    /**\n     * Minimum elevation to be rendered, values beneath the sea level are negative.\n     */\n    minElevation: number;\n\n    /**\n     * Set maximum elevation to be rendered, values above sea level are positive.\n     */\n    maxElevation: number;\n\n    /**\n     * Compute near and far clipping planes distance.\n     *\n     * @remarks\n     * Evaluation method should be called on every frame  and camera clip planes updated.\n     * This is related to evaluator implementation and its input data, that may suddenly change\n     * such as camera position or angle, projection type or so.\n     * Some evaluators may not depend on all or even any of input objects, but to preserve\n     * compatibility with any evaluator type it is strongly recommended to update on every frame.\n     * @note The camera clipping planes (near/far properties) aren't automatically updated\n     * via #evaluateClipPlanes() call, user should do it manually if needed.\n     * @param camera - The camera in use.\n     * @param projection - The geo-projection currently used for encoding geographic data.\n     * @param elevationProvider - The optional elevation provider for fine tuned range calculation,\n     * taking into account terrain variability and unevenness.\n     *\n     */\n    evaluateClipPlanes(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges;\n}\n\n/**\n * Abstract evaluator class that adds support for elevation constraints.\n *\n * @remarks\n * Classes derived from this should implement algorithms that takes into account rendered\n * features height (elevations), such as ground plane is no more flat (or spherical), but\n * contains geometry that should be overlapped by frustum planes.\n */\nexport abstract class ElevationBasedClipPlanesEvaluator implements ClipPlanesEvaluator {\n    private m_maxElevation: number;\n    private m_minElevation: number;\n\n    constructor(maxElevation: number, minElevation: number) {\n        assert(maxElevation >= minElevation);\n        this.m_minElevation = minElevation;\n        this.m_maxElevation = maxElevation;\n    }\n\n    abstract evaluateClipPlanes(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges;\n\n    /**\n     * Set maximum elevation above sea level to be rendered.\n     *\n     * @remarks\n     * @param elevation - the elevation (altitude) value in world units (meters).\n     * @note If you set this exactly to the maximum rendered feature height (altitude above\n     * the sea, you may notice some flickering or even polygons disappearing related to rounding\n     * errors or depth buffer precision. In such cases increase [[nearFarMargin]] or add a little\n     * bit offset to your assumed maximum elevation.\n     * @note Reasonable values are in between (-DeadSeeDepression, MtEverestHeight>, both values\n     * are defined in [[EarthConstant]] as [[EarthConstant.MIN_ELEVATION]] and\n     * [[EarthConstant.MAX_ELEVATION]] respectively.\n     * @see minElevation for more information about precision and rounding errors.\n     */\n    set maxElevation(elevation: number) {\n        this.m_maxElevation = elevation;\n        // Min elevation should be at least equal or smaller to max elevation.\n        this.m_minElevation = Math.min(elevation, this.m_minElevation);\n    }\n\n    /**\n     * Get maximum elevation to be covered by camera frustum.\n     */\n    get maxElevation(): number {\n        return this.m_maxElevation;\n    }\n\n    /**\n     * Set minimum elevation to be rendered, values beneath the sea level are negative.\n     *\n     * @remarks\n     * @param elevation - the minimum elevation (depression) in world units (meters).\n     * @note If you set this parameter to zero you may not see any features rendered if they are\n     * just below the sea level more than half of [[nearFarMargin]] assumed. Similarly if set to\n     * -100m and rendered features lays exactly in such depression, you may notice that problem.\n     * The errors usually come from projection precision loss and depth buffer nature (significant\n     * precision loss closer to far plane). Thus is such cases either increase the margin (if you\n     * are sure features are just at this elevation, or setup bigger offset for [[minElevation]].\n     * Reasonable values are between <-DeadSeaDepression, MtEverestHeight), where the first denotes\n     * lowest depression on the Earth defined as [[EarthConstants.MIN_ELEVATION]] and the second is\n     * the highest point our planet.\n     * @see https://developer.nvidia.com/content/depth-precision-visualized\n     */\n    set minElevation(elevation: number) {\n        this.m_minElevation = elevation;\n        // Max elevation should be at least equal or bigger than min elevation.\n        this.m_maxElevation = Math.max(elevation, this.m_maxElevation);\n    }\n\n    /**\n     * Get minimum elevation to be covered by camera frustum.\n     */\n    get minElevation(): number {\n        return this.m_minElevation;\n    }\n}\n\n/**\n * Top view, clip planes evaluator that computes view ranges based on ground distance and elevation.\n *\n * @deprecated Default evaluator {@link TiltViewClipPlanesEvaluator} supports top-down views.\n *\n * @remarks\n * This evaluator supports both planar and spherical projections, although it behavior is\n * slightly different in each case. General algorithm sets near plane and far plane close\n * to ground level, but taking into account maximum and minimum elevation of features on the ground.\n *\n * @note This evaluator supports only cameras which are always looking down the ground surface\n * (top-down view) along surface normal and does not preserve correct clip planes when\n * modifying camera pitch (tilt) angle. In simple words it is suitable only for top view camera\n * settings.\n */\nexport class TopViewClipPlanesEvaluator extends ElevationBasedClipPlanesEvaluator {\n    /**\n     * Helper for reducing number of objects created at runtime.\n     */\n    protected m_tmpVectors: THREE.Vector3[] = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n\n    /**\n     * Helper object for reducing performance impact.\n     */\n    protected m_tmpQuaternion: THREE.Quaternion = new THREE.Quaternion();\n\n    private readonly m_minimumViewRange: ViewRanges;\n\n    /**\n     * Allows to setup near/far offsets (margins), rendered geometry elevation relative to sea\n     * level as also minimum near plane and maximum far plane distance constraints.\n     *\n     * @remarks\n     * It is strongly recommended to set some reasonable [[nearFarMargin]] (offset) between near\n     * and far planes to avoid flickering.\n     * @param maxElevation - defines near plane offset from the ground in the surface normal\n     * direction, positive values allows to render elevated terrain features (mountains,\n     * buildings). Defaults to Burj Khalifa building height.\n     * @param minElevation - defines far plane offset from the ground surface, negative values moves\n     * far plane below the ground level (use it to render depressions). Default zero - sea level.\n     * @param nearMin - minimum allowable near plane distance from camera, must be bigger than zero.\n     * @param nearFarMarginRatio - minimum distance between near and far plane, as a ratio of\n     * average near/far plane distance, it have to be significantly bigger than zero (especially if\n     * [[maxElevation]] and [[minElevation]] are equal), otherwise you may notice flickering when\n     * rendering, or even render empty scene if frustum planes are almost equal.\n     * @param farMaxRatio - maximum ratio between ground and far plane distance, allows to limit\n     * viewing distance at overall. Have to be bigger than 1.0.\n     * @note Keep in mind that this evaluator does not evaluate terrain (or building) elevation\n     * automatically, to keep such features rendered (between frustum planes) use [[minElevation]],\n     * [[maxElevation]] constraints. You may change this parameters at any time, but it requires\n     * repeating [[evaluatePlanes]] step, if your camera is moving you need to evaluate planes\n     * anyway.\n     * @note You may treat [[minElevation]] and [[maxElevation]] parameters as the maximum and\n     * minimum renderable elevation respectively along the surface normal, when camera is\n     * constantly looking downwards (top-down view). If you need {@link ClipPlanesEvaluator} for\n     * cameras that support tilt or yaw please use {@link TiltViewClipPlanesEvaluator}.\n     * @note [[nearFarMaxRatio]] does not limit far plane when spherical projection is in use,\n     * the algorithm used there estimates distance to point on tangent where line from camera\n     * touches the sphere horizon and there is no reason to clamp it.\n     */\n    constructor(\n        maxElevation: number = EarthConstants.MAX_BUILDING_HEIGHT,\n        minElevation: number = 0,\n        readonly nearMin: number = 1.0,\n        readonly nearFarMarginRatio: number = 0.05,\n        readonly farMaxRatio = 6.0\n    ) {\n        super(maxElevation, minElevation);\n        assert(nearMin > 0);\n        assert(nearFarMarginRatio >= 0);\n        assert(farMaxRatio > 1.0);\n        const nearFarMargin = nearFarMarginRatio * nearMin;\n        this.m_minimumViewRange = {\n            near: nearMin,\n            far: nearMin + nearFarMargin,\n            minimum: this.nearMin,\n            maximum: Math.max(nearMin * farMaxRatio, nearMin + nearFarMargin)\n        };\n    }\n\n    /** @override */\n    evaluateClipPlanes(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        assert(camera instanceof THREE.PerspectiveCamera, \"Unsupported camera type.\");\n        const persCamera = camera as THREE.PerspectiveCamera;\n        if (projection.type === ProjectionType.Spherical) {\n            return this.evaluateDistanceSphericalProj(persCamera, projection, elevationProvider);\n        } else if (projection.type === ProjectionType.Planar) {\n            return this.evaluateDistancePlanarProj(persCamera, projection, elevationProvider);\n        }\n        assert(false, \"Unsupported projection type\");\n        return { ...this.minimumViewRange };\n    }\n\n    /**\n     * Get minimum view range that is possible to achieve with current evaluator settings.\n     * @note This value will not change after evaluator is constructed.\n     */\n    protected get minimumViewRange(): ViewRanges {\n        return this.m_minimumViewRange;\n    }\n\n    protected evaluateDistancePlanarProj(\n        camera: THREE.PerspectiveCamera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        assert(projection.type !== ProjectionType.Spherical);\n\n        let nearPlane: number = this.nearMin;\n        let farPlane: number = this.nearMin * this.farMaxRatio;\n\n        // Calculate distance to closest point on the ground.\n        const groundDistance = projection.groundDistance(camera.position);\n        const farMax = groundDistance * this.farMaxRatio;\n        // We could at least try to keep margins along the eye vector (center of the view) in\n        // tact with pitch angle changes, but this does not solve all tilt angle problems,\n        // rather use more sophisticated evaluator.\n        nearPlane = groundDistance - this.maxElevation;\n        farPlane = groundDistance - this.minElevation;\n\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.min(farPlane, farMax);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n\n        const viewRanges: ViewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: Math.max(farMax, farPlane)\n        };\n        return viewRanges;\n    }\n\n    protected evaluateDistanceSphericalProj(\n        camera: THREE.PerspectiveCamera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        assert(projection.type === ProjectionType.Spherical);\n\n        // The near plane calculus is quite straight forward and works the same as for planar\n        // projections. We simply search for the closest point of the ground just above\n        // the camera, then we apply margin (elevation) to it along the sphere surface normal:\n        const cameraAltitude = projection.groundDistance(camera.position);\n        let nearPlane = cameraAltitude - this.maxElevation;\n\n        const r = EarthConstants.EQUATORIAL_RADIUS;\n        const d = Math.max(epsilon, camera.position.length());\n\n        // This solution computes near and far plane for a set up where\n        // the camera is looking at the center of the scene.\n\n        // The far plane distance calculus requires finding the sphere tangent line that is\n        // co-linear with (goes thru) camera position, such tangent creates right angle\n        // with sphere diameter where it touches its surface (point T). Given that sphere is\n        // always at world origin and camera orbits around it we have (see\n        // #getTangentBasedFarPlane):\n        // angle(OTC) = 90\n        // sin(OCT) = sin(alpha) = r / d\n        // alpha = asin(r / d)\n        const alpha = Math.asin(r / d);\n        // If alpha it bigger than half fov angle, our visibility limit is set by tangent\n        // line, otherwise we need to find top (or right) plane intersection with sphere,\n        // which is definitely closer than the tangent point mentioned above.\n        // Take fov directly if it is vertical, otherwise we translate it using aspect ratio:\n\n        let halfFovAngle = THREE.MathUtils.degToRad(camera.fov / 2);\n        // If width > height, then we have to compute the horizontal FOV.\n        if (camera.aspect > 1) {\n            halfFovAngle = MapViewUtils.calculateHorizontalFovByVerticalFov(\n                halfFovAngle * 2,\n                camera.aspect\n            );\n        }\n\n        const maxR = r + this.maxElevation;\n        const farTangent = SphericalProj.getFarDistanceFromElevatedHorizon(camera, d, r, maxR);\n        let farPlane =\n            halfFovAngle > alpha\n                ? farTangent\n                : this.getFovBasedFarPlane(camera, d, r, 2 * halfFovAngle, projection);\n        // In extreme cases the largest depression assumed may be further than tangent\n        // based far plane distance, take it into account\n        const farMin = cameraAltitude - this.minElevation;\n        const farMax = cameraAltitude * this.farMaxRatio;\n        // Apply the constraints.\n        nearPlane = Math.max(nearPlane, this.nearMin);\n        farPlane = Math.max(farPlane, farMin);\n        // Apply margins\n        const nearFarMargin = (this.nearFarMarginRatio * (nearPlane + farPlane)) / 2;\n        nearPlane = Math.max(nearPlane - nearFarMargin / 2, this.nearMin);\n        farPlane = Math.max(farPlane + nearFarMargin / 2, nearPlane + nearFarMargin);\n\n        const viewRanges: ViewRanges = {\n            near: nearPlane,\n            far: farPlane,\n            minimum: this.nearMin,\n            maximum: farMax\n        };\n        return viewRanges;\n    }\n\n    protected getFovBasedFarPlane(\n        camera: THREE.PerspectiveCamera,\n        d: number,\n        r: number,\n        fovAngle: number,\n        projection: Projection\n    ) {\n        // Find intersection point that is closer to tangent point.\n        //\n        //         , - ~ ~ ~ - ,\n        //     , '               ' ,\n        //   ,           .           ,\n        //  ,            .     r     ,' T1\n        // ,             .     ,  '  / ,\n        // ,             . O.'  a   /  ,\n        // ,             | .  `  . /   ,\n        //  ,            |   .  r / TA,\n        //   ,           |    .  /   ,\n        //     ,         |     ./  ,'_____ far\n        //       ' -_, _ | _ , /' T0\n        //     near      |    /\n        //               |   / t\n        //             d | /\n        //               |/\n        //               C\n        //\n        // See:\n        // https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\n        // Vector from camera to world center\n        const dVec = camera.position;\n        // Extract camera X, Y, Z orientation axes into tmp vectors array.\n        camera.matrixWorld.extractBasis(\n            this.m_tmpVectors[0],\n            this.m_tmpVectors[1],\n            this.m_tmpVectors[2]\n        );\n        // Setup quaternion (X axis based) for angle between frustum plane and camera eye.\n        this.m_tmpQuaternion.setFromAxisAngle(this.m_tmpVectors[0], fovAngle / 2);\n        // Acquire camera (eye) forward vector from Z axis (keep it in tmpVectors[2]).\n        const cameraFwdVec = this.m_tmpVectors[2];\n        // Apply quaternion to forward vector, creating intersection vector, which is\n        // parallel to top or right frustum plane (depending on the aspect ratio).\n        const tVec = this.m_tmpVectors[1].copy(cameraFwdVec).applyQuaternion(this.m_tmpQuaternion);\n        // Calculate camera to origin vector projection onto frustum plane (top or right).\n        // This gives us the length of CTA segment:\n        const cta = dVec.dot(tVec);\n        // If it is negative, it means that the dVec and the tVec points in\n        // opposite directions - there is no intersection - or intersection could\n        // potentially be behind the intersection ray's origin (camera position).\n        if (cta < 0) {\n            // Intersection points are behind camera, camera looks in wrong direction.\n            const groundDistance = projection.groundDistance(camera.position);\n            // Setup far plane to maximum distance.\n            return groundDistance * this.farMaxRatio;\n        }\n        // Knowing the length of |CTA| we just need to subtract the length of |T0TA|\n        // segment from it to get far plane distance.\n        // In order to calculate |T0TA| we firstly need to use use Pythagorean theorem to\n        // find length of |OTA| = a. Here we use the right triangle formed by O-C-TA points:\n        // |OC|^2 = |CTA|^2 + |OTA|^2, where |OTA| = a, |OC| = d, |CTA| = cta\n        // a^2 = d^2 - cta^2\n        const a2 = dVec.dot(dVec) - cta * cta;\n        // Note that if a is greater than sphere radius the ray misses the sphere and\n        // thus there is no intersection at all.\n        const r2 = r * r;\n        assert(a2 <= r2, \"Please use this evaluator only for top view camera poses.\");\n        // Now to find the length of |T0TA| == |T1TA| we use the second right triangle\n        // formed by O-T0-TA points. Of course we know that |T0TA| segment length is\n        // equal to |T1TA|, and |OT0| segment is simply sphere radius.\n        // In order to find |T0TA| length we again use Pythagorean theorem, which says:\n        // |OT0|^2 = |OTA|^2 + |T0TA|^2, where |OTO| = r, |OTA| = a\n        // |T0TA|^2 = r^2 - a^2\n        const tota = Math.sqrt(r2 - a2);\n        // Finally our far plane (intersection point) is defined as:\n        return cta - tota;\n    }\n}\n\n/**\n * Evaluates camera clipping planes taking into account ground distance and camera tilt (pitch)\n * angle (angle between look-at vector and ground surface normal).\n */\nexport class TiltViewClipPlanesEvaluator extends TopViewClipPlanesEvaluator {\n    private readonly m_tmpV2 = new THREE.Vector2();\n\n    /** @override */\n    protected evaluateDistancePlanarProj(\n        camera: THREE.PerspectiveCamera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        // Find intersections of top/bottom frustum side's medians with the ground plane, taking\n        // into account min/max elevations.Top side intersection distance determines the far\n        // distance (it's further away than bottom intersection on tilted views), and bottom side\n        // intersection distance determines the near distance.\n        //   \n        //   C\n        //   |\\\n        //   |.\\ .\n        //   | . \\  . t\n        // z |  .  \\   .c2\n        //   |  c1.  \\e ___. max elev\n        //   |     .   \\      .\n        //___|a___D1.____\\E1_____.D2______ g\n        //   C1      .     \\ __. min elev\n        //            .      \\.E2\n        //          b  .    .\n        //              . .\n        //               .\n        // Where:\n        // - C gives the camera position.\n        // - z is the height of the camera above the ground.\n        // - z1 == z2 == z, for perspective camera all planes origin its the same\n        // - a is a right angle.\n        // - e is the look at vector of the camera.\n        // - t and b are the frustum planes of the camera (top and bottom respectively).\n        // - angle between c1 to c2 is the fov.\n        // - c1, c2 - vectors from camera to the ground along frustum planes.\n        // - angles between c1 and e or e and c2 splits fov on equal halves.\n        // - d1 and d2 are the intersection points of the frustum with the world/ground plane.\n        // - angle between z and e is the pitch of the camera.\n        // - angle between g and e is the tilt angle.\n        // - g is the ground/world surface\n        //\n        // The intersection distances to be found are |c1| (bottom plane) and |c2| (top plane).\n\n        assert(projection.type !== ProjectionType.Spherical);\n        const viewRanges = { ...this.minimumViewRange };\n        const halfPiLimit = Math.PI / 2 - epsilon;\n        const z = projection.groundDistance(camera.position);\n        const cameraTilt = MapViewUtils.extractCameraTilt(camera, projection);\n\n        // Angles between top/bottom plane and eye vector. For centered projections both are equal\n        // to half of the vertical fov.\n        const topFov = CameraUtils.getTopFov(camera);\n        const bottomFov = CameraUtils.getBottomFov(camera);\n        // Angle between z and c2\n        const topAngle = THREE.MathUtils.clamp(cameraTilt + topFov, -halfPiLimit, halfPiLimit);\n        // Angle between z and c1\n        const bottomAngle = THREE.MathUtils.clamp(\n            cameraTilt - bottomFov,\n            -halfPiLimit,\n            halfPiLimit\n        );\n\n        // Compute |c2|. This will determine the far distance (top intersection is further away than\n        // bottom intersection on tilted views), so take the furthest distance possible, i.e.the\n        // distance to the min elevation.\n        // cos(topAngle) = (z2 - minElev) / |c2|\n        // |c2| = (z2 - minElev) / cos(topAngle)\n        const topDist = Math.max(0, (z - this.minElevation) / Math.cos(topAngle));\n        // Compute |c1|. This will determine the near distance, so take the nearest distance\n        // possible, i.e.the distance to the max elevation.\n        const bottomDist = Math.max(0, (z - this.maxElevation) / Math.cos(bottomAngle));\n\n        // Project intersection distances onto the eye vector.\n        // cos(halfFov) = near / bottomDist\n        // near = cos(halfFov) * bottomDist\n        viewRanges.near = bottomDist * Math.cos(bottomFov);\n        // cos(halfFov) = far / topDist\n        // far = cos(halfFov) * topDist\n        viewRanges.far = topDist * Math.cos(topFov);\n\n        return this.applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider);\n    }\n\n    /** @override */\n    protected evaluateDistanceSphericalProj(\n        camera: THREE.PerspectiveCamera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        assert(projection.type === ProjectionType.Spherical);\n        const viewRanges = { ...this.minimumViewRange };\n\n        viewRanges.near = this.computeNearDistSphericalProj(camera, projection);\n        viewRanges.far = this.computeFarDistSphericalProj(camera, projection);\n\n        return this.applyViewRangeConstraints(viewRanges, camera, projection, elevationProvider);\n    }\n\n    private computeNearDistSphericalProj(\n        camera: THREE.PerspectiveCamera,\n        projection: Projection\n    ): number {\n        assert(projection.type === ProjectionType.Spherical);\n\n        // Default near plane approximation.\n        const defaultNear = projection.groundDistance(camera.position) - this.maxElevation;\n        const cameraBelowMaxElevation = defaultNear <= 0;\n        if (cameraBelowMaxElevation) {\n            // Near distance will be adjusted by constraints later.\n            return 0;\n        }\n\n        const maxR = EarthConstants.EQUATORIAL_RADIUS + this.maxElevation;\n\n        // Angles between bottom plane and eye vector. For centered projections it's equal to half\n        // of the vertical fov.\n        const bottomFov = CameraUtils.getBottomFov(camera);\n\n        // First, use the distance of the near plane's tangent point to the sphere.\n        const nearPlaneTanDist = SphericalProj.getProjNearPlaneTanDistance(camera, bottomFov, maxR);\n        if (nearPlaneTanDist !== undefined) {\n            return nearPlaneTanDist;\n        }\n        // If near plan tangent is not visible, use the distance to the closest frustum intersection\n        // with the sphere. If principal point has a y offset <= 0, bottom frustum intersection\n        // is at same distance or closer than top intersection, otherwise both need to be checked.\n        // At least one of the sides must intersect, if not the near plane tangent must have been\n        // visible.\n        CameraUtils.getPrincipalPoint(camera, this.m_tmpV2);\n        const checkTopIntersection = this.m_tmpV2.y > 0;\n        const bottomDist = SphericalProj.getProjSphereIntersectionDistance(\n            camera,\n            this.m_tmpV2.setComponent(1, -1),\n            maxR\n        );\n        const topDist = checkTopIntersection\n            ? SphericalProj.getProjSphereIntersectionDistance(\n                  camera,\n                  this.m_tmpV2.setComponent(1, 1),\n                  maxR\n              )\n            : Infinity;\n        const near = Math.min(bottomDist ?? Infinity, topDist ?? Infinity);\n        assert(near !== Infinity, \"No reference point for near distance found\");\n        return near ?? defaultNear;\n    }\n\n    private computeFarDistSphericalProj(\n        camera: THREE.PerspectiveCamera,\n        projection: Projection\n    ): number {\n        assert(projection.type === ProjectionType.Spherical);\n        const r = EarthConstants.EQUATORIAL_RADIUS;\n        const minR = r + this.minElevation;\n        const maxR = r + this.maxElevation;\n        const d = camera.position.length();\n\n        // If all frustum edges intersect the world, use as far distance the distance to the\n        // farthest intersection projected on eye vector. If principal point has a y offset <= 0,\n        // top frustum intersection is at same distance or farther than bottom intersection,\n        // otherwise both need to be checked.\n        CameraUtils.getPrincipalPoint(camera, this.m_tmpV2);\n        const isRightIntersectionFarther = this.m_tmpV2.x <= 0.0;\n        const ndcX = isRightIntersectionFarther ? 1 : -1;\n        const checkBottomIntersection = this.m_tmpV2.y > 0;\n\n        const topDist = SphericalProj.getProjSphereIntersectionDistance(\n            camera,\n            this.m_tmpV2.set(ndcX, 1),\n            minR\n        );\n        const bottomDist = checkBottomIntersection\n            ? SphericalProj.getProjSphereIntersectionDistance(\n                  camera,\n                  this.m_tmpV2.set(ndcX, -1),\n                  minR\n              )\n            : 0;\n        const largestDist = Math.max(topDist ?? Infinity, bottomDist ?? Infinity);\n        if (largestDist !== Infinity) {\n            return largestDist;\n        }\n\n        // If any frustum edge does not intersect (i.e horizon is visible in that viewport corner),\n        // use the horizon distance at the maximum elevation.\n        return SphericalProj.getFarDistanceFromElevatedHorizon(camera, d, r, maxR);\n    }\n\n    private applyViewRangeConstraints(\n        viewRanges: ViewRanges,\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        // Compute the focus point (target) distance for current camera and projection setup,\n        // in a same way the MapView component does.\n        const { distance } = MapViewUtils.getTargetAndDistance(\n            projection,\n            camera,\n            elevationProvider\n        );\n\n        // Apply the constraints.\n        const farMin = projection.groundDistance(camera.position) - this.minElevation;\n        const farMax = distance * this.farMaxRatio;\n        viewRanges.near = Math.max(viewRanges.near, this.nearMin);\n        viewRanges.far = THREE.MathUtils.clamp(viewRanges.far, farMin, farMax);\n\n        // Apply margins.\n        const nearFarMargin = (this.nearFarMarginRatio * (viewRanges.near + viewRanges.far)) / 2;\n        viewRanges.near = Math.max(viewRanges.near - nearFarMargin / 2, this.nearMin);\n        viewRanges.far = Math.max(\n            viewRanges.far + nearFarMargin / 2,\n            viewRanges.near + nearFarMargin\n        );\n\n        // Set minimum and maximum view range.\n        viewRanges.minimum = this.nearMin;\n        viewRanges.maximum = farMax;\n\n        return viewRanges;\n    }\n}\n\n/**\n * Creates default {@link ClipPlanesEvaluator}.\n * @internal\n */\nexport const createDefaultClipPlanesEvaluator = () => new TiltViewClipPlanesEvaluator();\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Use `ColorCache` to reuse a color specified by name and save allocation as well as\n * setup time.\n *\n * Implemented as a singleton. Do not modify colors after getting them from the `ColorCache`.\n */\nexport class ColorCache {\n    /**\n     * Return instance of `ColorCache`.\n     */\n    static get instance() {\n        return this.m_instance;\n    }\n\n    private static readonly m_instance: ColorCache = new ColorCache();\n    private readonly m_map: Map<string, THREE.Color> = new Map();\n\n    /**\n     * Returns the color for the given `colorCode`. This function may reuse a previously generated\n     * color, so you cannot modify the contents of the color.\n     *\n     * @param colorCode - ThreeJS color code or name. You must provide a valid color code or name,\n     * as this function does not do any validation.\n     */\n    getColor(colorCode: string | number): THREE.Color {\n        if (typeof colorCode === \"number\") {\n            colorCode = \"#\" + colorCode.toString(16).padStart(6, \"0\");\n        }\n\n        let color = this.m_map.get(colorCode);\n        if (color !== undefined) {\n            return color;\n        }\n        color = new THREE.Color(colorCode);\n        this.m_map.set(colorCode, color);\n        return color;\n    }\n\n    /**\n     * Returns the number of elements in the cache.\n     */\n    get size(): number {\n        return this.m_map.size;\n    }\n\n    /**\n     * Clears the cache. Only references to the THREE.Color are removed from the cache.\n     * Consequently, clearing the cache does not cause any negative visual impact.\n     */\n    clear(): void {\n        this.m_map.clear();\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ITileDecoder } from \"@here/harp-datasource-protocol\";\n\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\nimport { WorkerBasedDecoder } from \"./WorkerBasedDecoder\";\n\n/**\n * Default concurrent decoder helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to {@link WorkerBasedDecoder}s for data sources.\n */\nexport class ConcurrentDecoderFacade {\n    /**\n     * The URL containing a script to fall back (default) to when looking for worker sets\n     * and decoders.\n     */\n    static defaultScriptUrl: string = \"./decoder.bundle.js\";\n\n    /**\n     * The default number of workers.\n     */\n    static defaultWorkerCount?: number = undefined;\n\n    /**\n     * Returns a {@link WorkerBasedDecoder} instance.\n     *\n     * @param decoderServiceType - The name of the decoder service type.\n     * @param scriptUrl - The optional URL with the workers' script.\n     * @param workerCount - The number of web workers to use.\n     * @param workerConnectionTimeout - Timeout in seconds to connect to the web worker.\n     */\n    static getTileDecoder(\n        decoderServiceType: string,\n        scriptUrl?: string,\n        workerCount?: number,\n        workerConnectionTimeout?: number\n    ): ITileDecoder {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout);\n\n        return new WorkerBasedDecoder(workerSet, decoderServiceType);\n    }\n\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl - The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount - The number of web workers to use.\n     * @param workerConnectionTimeout - Timeout in seconds to connect to the web worker.\n     */\n    static getWorkerSet(\n        scriptUrl?: string,\n        workerCount?: number,\n        workerConnectionTimeout?: number\n    ): ConcurrentWorkerSet {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            const workerConnectionTimeoutInMs =\n                workerConnectionTimeout !== undefined ? workerConnectionTimeout * 1000 : undefined;\n            workerSet = new ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount ?? this.defaultWorkerCount,\n                workerConnectionTimeout: workerConnectionTimeoutInMs\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl: string) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n\n    /**\n     * Destroys this [[ConcurrentDecoderFacade]] if all of the [[ConcurrentWorkerSet]]s are\n     * terminated.\n     */\n    static destroyIfTerminated() {\n        let allWorkerSetsTerminated = true;\n        Object.keys(this.workerSets).forEach(name => {\n            if (!this.workerSets[name].terminated) {\n                allWorkerSetsTerminated = false;\n            }\n        });\n        if (allWorkerSetsTerminated) {\n            ConcurrentDecoderFacade.destroy();\n        }\n    }\n\n    /**\n     * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n     */\n    private static workerSets: {\n        [bundleUrl: string]: ConcurrentWorkerSet;\n    } = {};\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ITiler } from \"@here/harp-datasource-protocol\";\n\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\nimport { WorkerBasedTiler } from \"./WorkerBasedTiler\";\n\n/**\n * Default concurrent tiler helper.\n *\n * A convenient singleton that maintains a separate [[ConcurrentWorkerSet]] for each bundle\n * requested. Provides easy access to {@link WorkerBasedTiler}s for data sources.\n */\nexport class ConcurrentTilerFacade {\n    /**\n     * The URL containing a script to fall back (default) to when looking for worker sets\n     * and tilers.\n     */\n    static defaultScriptUrl: string = \"./decoder.bundle.js\";\n\n    /**\n     * The default number of workers.\n     */\n    static defaultWorkerCount: number = 1;\n\n    /**\n     * Returns a {@link WorkerBasedTiler} instance.\n     *\n     * @param tilerServiceType - The name of the tiler service type.\n     * @param scriptUrl - The optional URL with the workers' script.\n     * @param workerCount - The number of web workers to use.\n     * @param workerConnectionTimeout - Timeout in seconds to connect to the web worker.\n     */\n    static getTiler(\n        tilerServiceType: string,\n        scriptUrl?: string,\n        workerCount?: number,\n        workerConnectionTimeout?: number\n    ): ITiler {\n        const workerSet = this.getWorkerSet(scriptUrl, workerCount, workerConnectionTimeout);\n\n        return new WorkerBasedTiler(workerSet, tilerServiceType);\n    }\n\n    /**\n     * Returns a [[ConcurrentWorkerSet]] instance based on the script URL specified.\n     *\n     * @param scriptUrl - The optional URL with the workers' script. If not specified,\n     * the function uses [[defaultScriptUrl]] instead.\n     * @param workerCount - The number of web workers to use.\n     * @param workerConnectionTimeout - Timeout in seconds to connect to the web worker.\n     */\n    static getWorkerSet(\n        scriptUrl?: string,\n        workerCount?: number,\n        workerConnectionTimeout?: number\n    ): ConcurrentWorkerSet {\n        if (scriptUrl === undefined) {\n            scriptUrl = this.defaultScriptUrl;\n        }\n\n        let workerSet = this.workerSets[scriptUrl];\n        if (workerSet === undefined) {\n            const workerConnectionTimeoutInMs =\n                workerConnectionTimeout !== undefined ? workerConnectionTimeout * 1000 : undefined;\n            workerSet = new ConcurrentWorkerSet({\n                scriptUrl,\n                workerCount: workerCount ?? this.defaultWorkerCount,\n                workerConnectionTimeout: workerConnectionTimeoutInMs\n            });\n            this.workerSets[scriptUrl] = workerSet;\n        }\n        return workerSet;\n    }\n\n    /**\n     * Destroys a [[ConcurrentWorkerSet]] instance.\n     *\n     * @param scriptUrl - The worker script URL that was used to create the [[ConcurrentWorkerSet]].\n     */\n    static destroyWorkerSet(scriptUrl: string) {\n        const workerSet = this.workerSets[scriptUrl];\n        if (workerSet !== undefined) {\n            workerSet.destroy();\n            delete this.workerSets[scriptUrl];\n        }\n    }\n\n    /**\n     * Destroys all managed [[ConcurrentWorkerSet]]s.\n     */\n    static destroy() {\n        Object.keys(this.workerSets).forEach(name => {\n            this.workerSets[name].destroy();\n        });\n        this.workerSets = {};\n    }\n\n    /**\n     * Destroys this [[ConcurrentTilerFacade]] if all of the [[ConcurrentWorkerSet]]s are\n     * terminated.\n     */\n    static destroyIfTerminated() {\n        let allWorkerSetsTerminated = true;\n        Object.keys(this.workerSets).forEach(name => {\n            if (!this.workerSets[name].terminated) {\n                allWorkerSetsTerminated = false;\n            }\n        });\n        if (allWorkerSetsTerminated) {\n            ConcurrentTilerFacade.destroy();\n        }\n    }\n\n    /**\n     * The [[ConcurrentWorkerSet]] instances which are stored by the script URL.\n     */\n    private static workerSets: {\n        [bundleUrl: string]: ConcurrentWorkerSet;\n    } = {};\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { RequestController, WorkerServiceProtocol } from \"@here/harp-datasource-protocol\";\nimport {\n    getOptionValue,\n    IWorkerChannelMessage,\n    LoggerManager,\n    LogLevel,\n    WORKERCHANNEL_MSG_TYPE\n} from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { WorkerLoader } from \"./workers/WorkerLoader\";\n\nconst logger = LoggerManager.instance.create(\"ConcurrentWorkerSet\");\n\nexport function isLoggingMessage(message: IWorkerChannelMessage): message is IWorkerChannelMessage {\n    return message && typeof message.level === \"number\" && message.type === WORKERCHANNEL_MSG_TYPE;\n}\n\ninterface ReadyPromise {\n    count: number;\n    promise?: Promise<void>;\n    resolve: () => void;\n    reject: (reason: any) => void;\n    error?: any;\n}\n\ninterface RequestEntry {\n    promise: Promise<any>;\n    resolver: (error?: Error, response?: object) => void;\n}\n\nexport interface ConcurrentWorkerSetOptions {\n    /**\n     * The URL of the script for each worker to start.\n     */\n    scriptUrl: string;\n\n    /**\n     * The number of Web Workers for processing data.\n     *\n     * Defaults to CLAMP(`navigator.hardwareConcurrency` - 1, 1, 4) or [[DEFAULT_WORKER_COUNT]].\n     */\n    workerCount?: number;\n\n    /**\n     * Timeout in milliseconds, in which each worker should set initial message.\n     *\n     * @default 10 seconds, see [[DEFAULT_WORKER_INITIALIZATION_TIMEOUT]]\n     */\n    workerConnectionTimeout?: number;\n}\n\n/**\n * Interface for an item in the started worker list queue.\n */\ninterface WorkerEntry {\n    worker: Worker;\n    listener: EventListener;\n}\n\n/**\n * Interface for an item in the request queue. Stores the data to be decoded along with an\n * [[AbortController]].\n */\ninterface WorkerRequestEntry {\n    message: WorkerServiceProtocol.RequestMessage;\n    buffers?: ArrayBuffer[] | undefined;\n    requestController?: RequestController;\n}\n\n/**\n * The default number of Web Workers to use if `navigator.hardwareConcurrency` is unavailable.\n */\nconst DEFAULT_WORKER_COUNT = 2;\n\n/**\n * The default timeout for first message from worker.\n *\n * @see {@link WorkerLoader.startWorker}\n */\nexport const DEFAULT_WORKER_INITIALIZATION_TIMEOUT = 10000;\n\n/**\n * A set of concurrent Web Workers. Acts as a Communication Peer for [[WorkerService]] instances\n * running in Web Workers.\n *\n * Starts and manages a certain number of web workers and provides a means to communicate\n * with them using various communication schemes, such as:\n *  - [[addEventListener]] : receive a unidirectional messages\n *  - [[broadcastMessage]] : send unidirectional broadcast message\n *  - [[invokeRequest]] : send a request that waits for a response, with load balancing\n *  - [[postMessage]] : send a unidirectional message, with load balancing\n *\n * The request queue holds all requests before they are stuffed into the event queue, allows for\n * easy (and early) cancelling of requests. The workers now only get a single new RequestMessage\n * when they return their previous result, or if they are idle. When they are idle, they are stored\n * in m_availableWorkers.\n */\nexport class ConcurrentWorkerSet {\n    private readonly m_workerChannelLogger = LoggerManager.instance.create(\"WorkerChannel\");\n    private readonly m_eventListeners = new Map<string, (message: any) => void>();\n    private m_workers = new Array<Worker>();\n\n    // List of idle workers that can be given the next job. It is using a LIFO scheme to reduce\n    // memory consumption in idle workers.\n    private m_availableWorkers = new Array<Worker>();\n    private m_workerPromises = new Array<Promise<WorkerEntry | undefined>>();\n    private m_workerCount: number | undefined;\n\n    private readonly m_readyPromises = new Map<string, ReadyPromise>();\n    private readonly m_requests: Map<number, RequestEntry> = new Map();\n    private m_workerRequestQueue: WorkerRequestEntry[] = [];\n\n    private m_nextMessageId: number = 0;\n    private m_stopped: boolean = true;\n\n    private m_referenceCount: number = 0;\n\n    /**\n     * Creates a new `ConcurrentWorkerSet`.\n     *\n     * Creates as many Web Workers as specified in `options.workerCount`, from the script provided\n     * in `options.scriptUrl`. If `options.workerCount` is not specified, the value specified in\n     * `navigator.hardwareConcurrency` is used instead.\n     *\n     * The worker set is implicitly started when constructed.\n     */\n    constructor(private m_options: ConcurrentWorkerSetOptions) {\n        this.start();\n    }\n\n    /**\n     * Adds an external reference and increments the internal reference counter by one.\n     *\n     * To implement a reference-count based automatic resource cleanup, use this function with\n     * [[removeReference]].\n     */\n    addReference() {\n        this.m_referenceCount += 1;\n        if (this.m_referenceCount === 1 && this.m_stopped) {\n            this.start();\n        }\n    }\n\n    /**\n     * Decrements the internal reference counter by 1.\n     *\n     * When the internal reference counter reaches 0, this function calls [[dispose]] to clear the\n     * resources.\n     *\n     * Use with [[addReference]] to implement reference-count based automatic resource cleanup.\n     */\n    removeReference() {\n        this.m_referenceCount -= 1;\n        if (this.m_referenceCount === 0) {\n            this.destroy();\n        }\n    }\n\n    /**\n     * Starts workers.\n     *\n     * Use to start workers already stopped by [[stop]] or [[destroy]] calls.\n     *\n     * Note: The worker set is implicitly started on construction - no need to call [[start]] on\n     * fresh instance.\n     *\n     * @param options - optional, new worker set options\n     */\n    start(options?: ConcurrentWorkerSetOptions) {\n        if (options !== undefined) {\n            this.m_options = options;\n        }\n        if (!this.m_stopped) {\n            throw new Error(\"ConcurrentWorker set already started\");\n        }\n\n        this.m_workerCount = getOptionValue(\n            this.m_options.workerCount,\n            typeof navigator !== \"undefined\" && navigator.hardwareConcurrency !== undefined\n                ? // We need to have at least one worker\n                  THREE.MathUtils.clamp(navigator.hardwareConcurrency - 1, 1, 2)\n                : undefined,\n            DEFAULT_WORKER_COUNT\n        );\n\n        // Initialize the workers. The workers now have an ID to identify specific workers and\n        // handle their busy state.\n        const timeout = getOptionValue(\n            this.m_options.workerConnectionTimeout,\n            DEFAULT_WORKER_INITIALIZATION_TIMEOUT\n        );\n        for (let workerId = 0; workerId < this.m_workerCount; ++workerId) {\n            const workerPromise = WorkerLoader.startWorker(this.m_options.scriptUrl, timeout).then(\n                worker => {\n                    const listener = (evt: Event): void => {\n                        this.onWorkerMessage(workerId, evt as MessageEvent);\n                    };\n\n                    worker.addEventListener(\"message\", listener);\n                    this.m_workers.push(worker);\n                    this.m_availableWorkers.push(worker);\n                    return {\n                        worker,\n                        listener\n                    };\n                }\n            );\n            this.m_workerPromises.push(workerPromise);\n        }\n        this.m_stopped = false;\n    }\n\n    /**\n     * The number of workers started for this worker set. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount(): number | undefined {\n        return this.m_workerCount;\n    }\n\n    /**\n     * Stops workers.\n     *\n     * Waits for all pending requests to be finished and stops all workers.\n     *\n     * Use [[start]] to start this worker again.\n     *\n     * @returns `Promise` that resolves when all workers are destroyed.\n     */\n    async stop() {\n        this.m_stopped = true;\n\n        await this.waitForAllResponses().then(() => {\n            this.terminateWorkers();\n        });\n    }\n\n    /**\n     * Destroys all workers immediately.\n     *\n     * Resolves all pending request promises with a `worker destroyed` error.\n     *\n     * Use [[start]] to start this worker again.\n     */\n    destroy() {\n        this.m_stopped = true;\n\n        // respond with all pending request\n        this.m_requests.forEach(entry => {\n            entry.resolver(new Error(\"worker destroyed\"));\n        });\n        this.m_requests.clear();\n        this.m_workerRequestQueue = [];\n\n        this.terminateWorkers();\n\n        // clean other stuff\n        this.m_eventListeners.clear();\n    }\n\n    /**\n     * Is `true` if the workers have been terminated.\n     */\n    get terminated(): boolean {\n        return this.m_workers.length === 0;\n    }\n\n    /**\n     * Waits for `service` to be initialized in all workers.\n     *\n     * Each service that starts in a worker sends an [[isInitializedMessage]] to confirm that\n     * it has started successfully. This method resolves when all workers in a set have\n     * `service` initialized.\n     *\n     * Promise is rejected if any of worker fails to start.\n     *\n     * @param serviceId - The service identifier.\n     */\n    async connect(serviceId: string): Promise<void> {\n        this.ensureStarted();\n        await Promise.all(this.m_workerPromises);\n        return await this.getReadyPromise(serviceId).promise;\n    }\n\n    /**\n     * Registers an event listener for events that originated in a web worker, for a given\n     * `serviceId`. You can only set one event listener per `serviceId`.\n     *\n     * @param serviceId - The service to listen to.\n     * @param callback - The callback to invoke for matching events.\n     */\n    addEventListener(serviceId: string, callback: (message: any) => void) {\n        this.m_eventListeners.set(serviceId, callback);\n    }\n\n    /**\n     * Removes a previously set event listener for the given `serviceId`.\n     *\n     * @param serviceId - The service from which to remove the event listeners.\n     */\n    removeEventListener(serviceId: string) {\n        this.m_eventListeners.delete(serviceId);\n    }\n\n    /**\n     * Invokes a request that expects a response from a random worker.\n     *\n     * Sends [[RequestMessage]] and resolves when a matching [[ResponseMessage]] is received from\n     * workers. Use this function when interfacing with \"RPC-like\" calls to services.\n     *\n     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request - The request to process.\n     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.\n     * @param requestController - An optional [[RequestController]] to store state of cancelling.\n     *\n     * @returns A `Promise` that resolves with a response from the service.\n     */\n    invokeRequest<Res>(\n        serviceId: string,\n        request: WorkerServiceProtocol.ServiceRequest,\n        transferList?: ArrayBuffer[],\n        requestController?: RequestController\n    ): Promise<Res> {\n        this.ensureStarted();\n\n        const messageId = this.m_nextMessageId++;\n        let resolver: ((error?: any, response?: any) => void) | undefined;\n\n        const promise = new Promise<Res>((resolve, reject) => {\n            resolver = (error?: Error, response?: Res) => {\n                this.m_requests.delete(messageId);\n\n                if (error !== undefined) {\n                    reject(error);\n                } else {\n                    resolve(response as Res);\n                }\n            };\n        });\n        this.m_requests.set(messageId, {\n            promise,\n            resolver: resolver!\n        });\n\n        const message: WorkerServiceProtocol.RequestMessage = {\n            service: serviceId,\n            type: WorkerServiceProtocol.ServiceMessageName.Request,\n            messageId,\n            request\n        };\n        this.postRequestMessage(message, transferList, requestController);\n        return promise;\n    }\n\n    /**\n     * Invokes a request that expects responses from all workers.\n     *\n     * Send [[RequestMessage]]  to all workers and resolves when all workers have sent a matching\n     * [[ResponseMessage]]. Use this function to wait on request that need to happen on all workers\n     * before proceeding (like synchronous worker service creation).\n     *\n     * @param serviceId - The name of service, as registered with the [[WorkerClient]] instance.\n     * @param request - The request to process.\n     * @param transferList - An optional array of `ArrayBuffer`s to transfer to the worker context.\n     *\n     * @returns Array of `Promise`s that resolves with a response from each worker (unspecified\n     * order).\n     */\n    broadcastRequest<Res>(\n        serviceId: string,\n        request:\n            | WorkerServiceProtocol.WorkerServiceManagerRequest\n            | WorkerServiceProtocol.ServiceRequest,\n        transferList?: ArrayBuffer[]\n    ): Promise<Res[]> {\n        const promises = [];\n        for (const worker of this.m_workers) {\n            const messageId = this.m_nextMessageId++;\n\n            let resolver: ((error?: any, response?: any) => void) | undefined;\n            const promise = new Promise<Res>((resolve, reject) => {\n                resolver = (error: Error, response: Res) => {\n                    this.m_requests.delete(messageId);\n\n                    if (error !== undefined) {\n                        reject(error);\n                    } else {\n                        resolve(response as Res);\n                    }\n                };\n            });\n            promises.push(promise);\n\n            this.m_requests.set(messageId, {\n                promise,\n                resolver: resolver!\n            });\n\n            const message: WorkerServiceProtocol.RequestMessage = {\n                service: serviceId,\n                type: WorkerServiceProtocol.ServiceMessageName.Request,\n                messageId,\n                request\n            };\n            if (transferList !== undefined) {\n                worker.postMessage(message, transferList);\n            } else {\n                worker.postMessage(message);\n            }\n        }\n\n        return Promise.all(promises);\n    }\n\n    /**\n     * Posts a message to all workers.\n     *\n     * @param message - The message to send.\n     * @param buffers - Optional buffers to transfer to the workers.\n     */\n    broadcastMessage(message: any, buffers?: ArrayBuffer[] | undefined) {\n        this.ensureStarted();\n\n        if (buffers !== undefined) {\n            this.m_workers.forEach(worker => worker.postMessage(message, buffers));\n        } else {\n            this.m_workers.forEach(worker => worker.postMessage(message));\n        }\n    }\n\n    /**\n     * The size of the request queue for debugging and profiling.\n     */\n    get requestQueueSize() {\n        return this.m_workerRequestQueue.length;\n    }\n\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numWorkers() {\n        return this.m_workers.length;\n    }\n\n    /**\n     * The number of workers for debugging and profiling.\n     */\n    get numIdleWorkers() {\n        return this.m_availableWorkers.length;\n    }\n\n    /**\n     * Subclasses must call this function when a worker emits an event.\n     *\n     * @param event - The event to dispatch.\n     */\n    protected eventHandler(event: any) {\n        if (typeof event.data.type !== \"string\") {\n            return; // not an event generated by us, ignore.\n        }\n\n        this.dispatchEvent(event.data.type, event);\n    }\n\n    /**\n     * Handles messages received from workers. This method is protected so that the message\n     * reception can be simulated through an extended class, to avoid relying on real workers.\n     *\n     * @param workerId - The workerId of the web worker.\n     * @param event - The event to dispatch.\n     */\n    private readonly onWorkerMessage = (workerId: number, event: MessageEvent) => {\n        if (WorkerServiceProtocol.isResponseMessage(event.data)) {\n            const response = event.data;\n            if (response.messageId === null) {\n                logger.error(`[${this.m_options.scriptUrl}]: Bad ResponseMessage: no messageId`);\n                return;\n            }\n            const entry = this.m_requests.get(response.messageId);\n            if (entry === undefined) {\n                logger.error(\n                    `[${this.m_options.scriptUrl}]: Bad ResponseMessage: invalid messageId`\n                );\n                return;\n            }\n\n            if (workerId >= 0 && workerId < this.m_workers.length) {\n                const worker = this.m_workers[workerId];\n                this.m_availableWorkers.push(worker);\n                // Check if any new work has been put into the queue.\n                this.checkWorkerRequestQueue();\n            } else {\n                logger.error(`[${this.m_options.scriptUrl}]: onWorkerMessage: invalid workerId`);\n            }\n            if (response.errorMessage !== undefined) {\n                const error = new Error(response.errorMessage);\n                if (response.errorStack !== undefined) {\n                    error.stack = response.errorStack;\n                }\n                entry.resolver(error);\n            } else {\n                entry.resolver(undefined, response.response);\n            }\n        } else if (WorkerServiceProtocol.isInitializedMessage(event.data)) {\n            const readyPromise = this.getReadyPromise(event.data.service);\n            if (++readyPromise.count === this.m_workerPromises.length) {\n                readyPromise.resolve();\n            }\n        } else if (isLoggingMessage(event.data)) {\n            switch (event.data.level) {\n                case LogLevel.Trace:\n                    this.m_workerChannelLogger.trace(...event.data.message);\n                    break;\n                case LogLevel.Debug:\n                    this.m_workerChannelLogger.debug(...event.data.message);\n                    break;\n                case LogLevel.Log:\n                    this.m_workerChannelLogger.log(...event.data.message);\n                    break;\n                case LogLevel.Info:\n                    this.m_workerChannelLogger.info(...event.data.message);\n                    break;\n                case LogLevel.Warn:\n                    this.m_workerChannelLogger.warn(...event.data.message);\n                    break;\n                case LogLevel.Error:\n                    this.m_workerChannelLogger.error(...event.data.message);\n                    break;\n            }\n        } else {\n            this.eventHandler(event);\n        }\n    };\n\n    /**\n     * Posts a [[WorkerServiceProtocol.RequestMessage]] to an available worker. If no worker is\n     * available, the request is put into a queue.\n     *\n     * @param message - The message to send.\n     * @param buffers - Optional buffers to transfer to the worker.\n     * @param requestController - An optional [[RequestController]] to store state of cancelling.\n     */\n    private postRequestMessage(\n        message: WorkerServiceProtocol.RequestMessage,\n        buffers?: ArrayBuffer[] | undefined,\n        requestController?: RequestController\n    ) {\n        this.ensureStarted();\n        if (this.m_workers.length === 0) {\n            throw new Error(\"ConcurrentWorkerSet#postMessage: no workers started\");\n        }\n\n        // Check if the requestController has received the abort signal, in which case the request\n        // is ignored.\n        if (requestController !== undefined && requestController.signal.aborted) {\n            const entry = this.m_requests.get(message.messageId);\n            if (entry === undefined) {\n                logger.error(\n                    `[${this.m_options.scriptUrl}]: Bad RequestMessage: invalid messageId`\n                );\n                return;\n            }\n\n            const err = new Error(\"Aborted\");\n            err.name = \"AbortError\";\n\n            entry.resolver(err, undefined);\n            return;\n        }\n\n        if (this.m_availableWorkers.length > 0) {\n            const worker = this.m_availableWorkers.pop()!;\n\n            if (buffers !== undefined) {\n                worker.postMessage(message, buffers);\n            } else {\n                worker.postMessage(message);\n            }\n        } else {\n            // We need a priority to keep sorting stable, so we have to add a RequestController.\n            if (requestController === undefined) {\n                requestController = new RequestController(0);\n            }\n            if (requestController.priority === 0) {\n                // If the requests do not get a priority, they should keep their sorting order.\n                requestController.priority = -this.m_nextMessageId;\n            }\n            this.m_workerRequestQueue.unshift({\n                message,\n                buffers,\n                requestController\n            });\n        }\n    }\n\n    private ensureStarted() {\n        if (this.m_stopped) {\n            throw new Error(\"ConcurrentWorkerSet stopped\");\n        }\n    }\n\n    private async waitForAllResponses(): Promise<any> {\n        const promises = new Array<Promise<void>>();\n        this.m_requests.forEach(entry => {\n            promises.push(entry.promise);\n        });\n        await Promise.all(promises);\n    }\n\n    private dispatchEvent(id: string, message: any) {\n        const callback = this.m_eventListeners.get(id);\n        if (callback === undefined) {\n            return;\n        } // unknown event, ignore.\n        callback(message);\n    }\n\n    private terminateWorkers() {\n        // terminate all workers\n        this.m_workerPromises.forEach(workerPromise => {\n            workerPromise.then(workerEntry => {\n                if (workerEntry === undefined) {\n                    return;\n                }\n                workerEntry.worker.removeEventListener(\"message\", workerEntry.listener);\n                workerEntry.worker.terminate();\n            });\n        });\n        this.m_workers = [];\n        this.m_workerPromises = [];\n        this.m_availableWorkers = [];\n        this.m_readyPromises.clear();\n    }\n\n    private getReadyPromise(id: string): ReadyPromise {\n        const readyPromise = this.m_readyPromises.get(id);\n        if (readyPromise !== undefined) {\n            return readyPromise;\n        }\n\n        const newPromise: ReadyPromise = {\n            count: 0,\n            promise: undefined,\n            resolve: () => {\n                /* placeholder */\n            },\n            reject: (error: any) => {\n                newPromise.error = error;\n            },\n            error: undefined\n        };\n\n        newPromise.promise = new Promise<void>((resolve, reject) => {\n            const that = newPromise;\n\n            if (that.error !== undefined) {\n                reject(that.error);\n            } else if (that.count === this.m_workerPromises.length) {\n                resolve();\n            }\n\n            that.resolve = resolve;\n            that.reject = reject;\n        });\n\n        this.m_readyPromises.set(id, newPromise);\n        return newPromise;\n    }\n\n    /**\n     * Check the worker request queue, if there are any queued up decoding jobs and idle workers,\n     * they will be executed with postRequestMessage. The requests in the queue are sorted before\n     * the request with the highest priority is selected for processing.\n     */\n    private checkWorkerRequestQueue() {\n        if (this.m_workerRequestQueue.length === 0 || this.m_availableWorkers.length === 0) {\n            return;\n        }\n        this.m_workerRequestQueue.sort((a: WorkerRequestEntry, b: WorkerRequestEntry) => {\n            return a.requestController!.priority - b.requestController!.priority;\n        });\n\n        // Get the request with the highest priority and send it (again).\n        while (this.m_availableWorkers.length > 0 && this.m_workerRequestQueue.length > 0) {\n            const request = this.m_workerRequestQueue.pop()!;\n            this.postRequestMessage(request.message, request.buffers, request.requestController);\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { FlatTheme, Theme, ValueMap } from \"@here/harp-datasource-protocol\";\nimport { ExprPool } from \"@here/harp-datasource-protocol/lib/ExprPool\";\nimport { Projection, TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { MapView } from \"./MapView\";\nimport { Tile } from \"./Tile\";\n\nconst logger = LoggerManager.instance.create(\"DataSource\");\n\n/**\n * Options for a {@link DataSource}.\n */\nexport interface DataSourceOptions {\n    /**\n     * The unique name of a {@link DataSource} instance.\n     */\n    name?: string;\n    /**\n     * The name of the [[StyleSet]] to evaluate for the decoding.\n     */\n    styleSetName?: string;\n    /**\n     * Used to configure the languages used by the `DataSource` according to priority;\n     * the first language in the array has the highest priority.\n     *\n     *  An array of ISO 639-1 language codes.\n     */\n    languages?: string[];\n    /**\n     * The minimum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[minDataLevel]] and [[minDisplayLevel]] instead.\n     */\n    minZoomLevel?: number;\n    /**\n     * The maximum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[maxDataLevel]] and [[maxDisplayLevel]] instead.\n     */\n    maxZoomLevel?: number;\n    /**\n     * The minimum zoom level at which data is available.\n     */\n    minDataLevel?: number;\n    /**\n     * The maximum zoom level at which data is available.\n     */\n    maxDataLevel?: number;\n    /**\n     * The minimum zoom level at which {@link DataSource} is displayed.\n     */\n    minDisplayLevel?: number;\n    /**\n     * The maximum zoom level at which {@link DataSource} is displayed.\n     */\n    maxDisplayLevel?: number;\n    /**\n     * Storage level offset applied to this `DataSource`.\n     */\n    storageLevelOffset?: number;\n    /**\n     * Whether the datasource can overlap tiles. Such overlapping is necessary when zooming out and\n     * waiting for the tiles to load, in this case, we use cached tiles to fill the missing gaps if\n     * available (and in some cases, the tiles can overlap, i.e. for example when a child is next\n     * to a parent, the parent is rendered beneath the child), however for some datasources (those\n     * that produce transparent tiles for example), this gives bad results, and as such, it should\n     * be disabled to reduce flickering. Another way to put it is that loading tiles are replaced\n     * with cached tiles and we then fall (back/forward) to the next appropriate zoom level.\n     * @default true\n     */\n    allowOverlappingTiles?: boolean;\n\n    /**\n     * Whether features from these data source can picked by calling\n     * {@link MapView.intersectMapObjects}. Disabling picking for data sources that don't need it\n     * will improve picking performance.\n     * @default true\n     */\n    enablePicking?: boolean;\n\n    /**\n     * Maximum geometry height above ground level this {@link DataSource} can produce.\n     *\n     * @remarks\n     * Used in first stage of frustum culling before {@link Tile#maxGeometryHeight} data is\n     * available.\n     *\n     * @default [[EarthConstants.MAX_BUILDING_HEIGHT]].\n     */\n    maxGeometryHeight?: number;\n\n    /**\n     * Minimum geometry height below ground level this {@link DataSource} can produce. Negative\n     * values describe height below ground.\n     *\n     * @remarks\n     * Used in first stage of frustum culling before {@link Tile#minGeometryHeight} data is\n     * available.\n     *\n     * @default `0`.\n     */\n    minGeometryHeight?: number;\n\n    /**\n     * Number used to order [DataSource]'s relative to each other, see\n     * {@link DataSource.dataSourceOrder}\n     */\n    dataSourceOrder?: number;\n}\n\n/**\n * Derive a class from `DataSource` to contribute data and geometries to the {@link MapView}.\n */\nexport abstract class DataSource extends THREE.EventDispatcher {\n    /**\n     * Keep the update event here to avoid a global reference to the datasource (and thus prevent garbage collection).\n     */\n    private readonly UPDATE_EVENT = { type: \"update\" };\n\n    /**\n     * A counter to generate unique names for each `DataSource`, if no name is provided in the\n     * constructor.\n     */\n    private static uniqueNameCounter: number = 0;\n\n    /**\n     * Set to `true` if this `DataSource` is enabled; `false` otherwise.\n     */\n    enabled: boolean = true;\n\n    /**\n     * Set to `true` if the {@link MapView} can cache tiles produced by this `DataSource`.\n     */\n    cacheable: boolean = false;\n\n    /**\n     * Set to `true` if the loader should be used to get the tile contents.\n     */\n    useGeometryLoader: boolean = false;\n\n    /**\n     * The unique name of a `DataSource` instance.\n     */\n    name: string;\n\n    /**\n     * Whether the datasource should have a ground plane (this plane covers the tile entirely and\n     * has the minimum possible renderOrder), this can be required in some cases when fallback\n     * parent tiles need to be covered by the children, otherwise the content will overlap.\n     * Default is false\n     */\n    addGroundPlane: boolean = false;\n\n    /**\n     * The minimum zoom level at which data is available.\n     */\n    minDataLevel: number = 1;\n\n    /**\n     * The maximum zoom level at which data is available.\n     */\n    maxDataLevel: number = 20;\n\n    /**\n     * The minimum zoom level at which {@link DataSource} is displayed.\n     */\n    minDisplayLevel: number = 1;\n\n    /**\n     * The maximum zoom level at which {@link DataSource} is displayed.\n     */\n    maxDisplayLevel: number = 20;\n\n    allowOverlappingTiles: boolean = true;\n\n    enablePicking: boolean = true;\n\n    /**\n     * Overrides the default rendering order of this `DataSource`.\n     *\n     * @remarks\n     * When `dataSourceOrder` is defined, all the objects created by this `DataSource`\n     * will be rendered on top of the objects created by other `DataSource`s with\n     * lower `dataSourceOrder` values.\n     *\n     * @defaultValue undefined\n     */\n    dataSourceOrder: number = 0;\n\n    /**\n     * @internal\n     * @hidden\n     */\n    readonly exprPool = new ExprPool();\n\n    /**\n     * The {@link MapView} instance holding a reference to this `DataSource`.\n     */\n    private m_mapView?: MapView;\n\n    /**\n     * The name of the [[StyleSet]] to evaluate for the decoding.\n     */\n    private m_styleSetName?: string;\n\n    /**\n     * Current value of [[maxGeometryHeight]] property.\n     */\n    private m_maxGeometryHeight = 0;\n\n    /**\n     * Current value of [[minGeometryHeight]] property.\n     */\n    private m_minGeometryHeight = 0;\n\n    /**\n     * Storage level offset applied to this `DataSource`.\n     */\n    private m_storageLevelOffset: number = 0;\n\n    private readonly m_featureStateMap = new Map<number | string, ValueMap>();\n\n    /**\n     *  An array of ISO 639-1 language codes.\n     */\n    protected languages?: string[];\n\n    /**\n     * Constructs a new `DataSource`.\n     *\n     * @param options - The options to create the data source.\n     */\n    constructor(options: DataSourceOptions = {}) {\n        super();\n        let { name } = options;\n        const {\n            styleSetName,\n            languages,\n            minZoomLevel,\n            maxZoomLevel,\n            minDataLevel,\n            maxDataLevel,\n            minDisplayLevel,\n            maxDisplayLevel,\n            storageLevelOffset,\n            allowOverlappingTiles,\n            enablePicking,\n            minGeometryHeight,\n            maxGeometryHeight,\n            dataSourceOrder\n        } = options;\n        if (name === undefined || name.length === 0) {\n            name = `anonymous-datasource#${++DataSource.uniqueNameCounter}`;\n        }\n        this.name = name;\n\n        this.styleSetName = styleSetName;\n\n        if (languages !== undefined) {\n            this.languages = languages;\n        }\n\n        if (minDataLevel !== undefined) {\n            this.minDataLevel = minDataLevel;\n        }\n        if (maxDataLevel !== undefined) {\n            this.maxDataLevel = maxDataLevel;\n        }\n        if (minZoomLevel !== undefined) {\n            this.minZoomLevel = minZoomLevel;\n        }\n        if (maxZoomLevel !== undefined) {\n            this.maxZoomLevel = maxZoomLevel;\n        }\n        if (minDisplayLevel !== undefined) {\n            this.minDisplayLevel = minDisplayLevel;\n        }\n        if (maxDisplayLevel !== undefined) {\n            this.maxDisplayLevel = maxDisplayLevel;\n        }\n        if (storageLevelOffset !== undefined) {\n            this.m_storageLevelOffset = storageLevelOffset;\n        }\n        if (allowOverlappingTiles !== undefined) {\n            this.allowOverlappingTiles = allowOverlappingTiles;\n        }\n\n        if (enablePicking !== undefined) {\n            this.enablePicking = enablePicking;\n        }\n\n        if (minGeometryHeight !== undefined) {\n            this.minGeometryHeight = minGeometryHeight;\n        }\n        if (maxGeometryHeight !== undefined) {\n            this.maxGeometryHeight = maxGeometryHeight;\n        }\n        if (dataSourceOrder) {\n            this.dataSourceOrder = dataSourceOrder;\n        }\n    }\n\n    /**\n     * Gets the state of the given feature id.\n     *\n     * @param featureId - The id of the feature. Id numbers are deprecated in favor of strings.\n     */\n    getFeatureState(featureId: number | string): ValueMap | undefined {\n        return this.m_featureStateMap.get(featureId);\n    }\n\n    /**\n     * Clears the state of all the features of this {@link DataSource}.\n     */\n    clearFeatureState() {\n        this.m_featureStateMap.clear();\n    }\n\n    /**\n     * Sets the state of the given feature id.\n     *\n     * ```typescript\n     * dataSource.setFeatureState(featureId, { enabled: true });\n     * ```\n     *\n     * @param featureId - The id of the feature. Id numbers are deprecated in favor of strings.\n     * @param state - The new state of the feature.\n     */\n    setFeatureState(featureId: number | string, state: ValueMap) {\n        this.m_featureStateMap.set(featureId, state);\n    }\n\n    /**\n     * Removes the state associated to the given feature.\n     *\n     * @param featureId - The id of the feature. Id numbers are deprecated in favor of strings.\n     */\n    removeFeatureState(featureId: number | string) {\n        this.m_featureStateMap.delete(featureId);\n    }\n\n    /**\n     * Returns the name of the [[StyleSet]] to use for the decoding.\n     */\n    get styleSetName(): string | undefined {\n        return this.m_styleSetName;\n    }\n\n    /**\n     * Sets the name of the [[StyleSet]] to use for the decoding.\n     * If this {@link DataSource} is already\n     * attached to a {@link MapView}, this setter then reapplies\n     * [[StyleSet]] with this name found in\n     * {@link MapView}s theme.\n     */\n    set styleSetName(styleSetName: string | undefined) {\n        if (styleSetName !== this.m_styleSetName) {\n            this.m_styleSetName = styleSetName;\n            this.clearCache();\n            this.requestUpdate();\n        }\n    }\n\n    /**\n     * Destroys this `DataSource`.\n     */\n    dispose() {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Purges all the caching done by this `DataSource`\n     */\n    clearCache() {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Boolean which says whether a {@link DataSource} produces\n     * tiles that fully cover the tile, i.e.\n     * tiles underneath are completely hidden. Must be\n     * overridden for {@link DataSource}'s that don't\n     * have a ground plane, but which still fully\n     * cover the tile, e.g. web tiles.\n     */\n    isFullyCovering(): boolean {\n        return this.addGroundPlane;\n    }\n\n    /**\n     * Returns `true` if this `DataSource` is ready\n     * and the {@link MapView} can invoke `getTile()` to\n     * start requesting data.\n     */\n    ready(): boolean {\n        return true;\n    }\n\n    /**\n     * The {@link MapView} that is holding this `DataSource`.\n     */\n    get mapView(): MapView {\n        if (this.m_mapView === undefined) {\n            throw new Error(\"This DataSource was not added to MapView\");\n        }\n\n        return this.m_mapView;\n    }\n\n    /**\n     * The {@link @here/harp-geoutils#Projection} used by\n     * the {@link MapView} that is holding this `DataSource`.\n     *\n     * An `Error` is thrown if you call this method\n     * before this `DataSource` has been added\n     * to a {@link MapView}.\n     */\n    get projection(): Projection {\n        return this.mapView.projection;\n    }\n\n    /**\n     * This method is called when the `DataSource` is added to a {@link MapView}. Override this\n     * method to provide any custom initialization, such as, to establish a network connection,\n     * or to initialize complex data structures.\n     */\n    async connect(): Promise<void> {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Returns the {@link @here/harp-geoutils#TilingScheme} used by this `DataSource`.\n     */\n    abstract getTilingScheme(): TilingScheme;\n\n    /**\n     * This method is called when this `DataSource` is added to a {@link MapView}.\n     *\n     * Overrides of this method must invoke the definition of the super class.\n     *\n     * @param mapView - The instance of the {@link MapView}.\n     */\n    attach(mapView: MapView): void {\n        this.m_mapView = mapView;\n    }\n\n    /**\n     * This method is called when this `DataSource` is removed from a {@link MapView}.\n     *\n     * Overrides of this method must invoke the definition of the super class.\n     *\n     * @param mapView - The instance of the {@link MapView}.\n     */\n    detach(mapView: MapView) {\n        assert(this.m_mapView === mapView);\n        this.m_mapView = undefined;\n    }\n\n    /**\n     * @return Whether this `DataSource` is detached from the `MapView`\n     */\n\n    isDetached() {\n        return this.m_mapView === undefined;\n    }\n\n    /**\n     * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.\n     *\n     * If `DataSource` depends on a `styleSet` defined by this theme or `languages`, it must update\n     * its tiles' geometry.\n     *\n     * @param theme - The Theme to be applied\n     */\n    async setTheme(theme: Theme | FlatTheme): Promise<void>;\n\n    /**\n     * Apply the {@link @here/harp-datasource-protocol#Theme} to this data source.\n     *\n     * If `DataSource` depends on a `styleSet` defined by this theme or `languages`, it must update\n     * its tiles' geometry.\n     *\n     * @param theme - The Theme to be applied\n     * @param languages - optional: The languages in priority order to be applied\n     *\n     * @deprecated use setTheme( Theme | FlatTheme) and setLanguages(string[]) instead\n     */\n    async setTheme(theme: Theme | FlatTheme, languages?: string[]): Promise<void> {\n        // to be overwritten by subclasses\n    }\n\n    /**\n     * Used to configure the languages used by the `DataSource` according to priority;\n     * the first language in the array has the highest priority.\n     *\n     * @param languages - An array of ISO 639-1 language codes.\n     */\n    setLanguages(languages?: string[]): void {\n        this.languages = languages;\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Used to express different country point of view (political view).\n     *\n     * @note Set to `undefined` (or empty string) if you want to reset to default point of view.\n     * @param pov - The country code which point of view should be presented in lower-case\n     * ISO 3166-1 alpha-2 format.\n     */\n    setPoliticalView(pov?: string): void {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * This method is called when {@link MapView} needs to visualize or preload the content of a\n     * {@link @here/harp-geoutils#TileKey}.\n     *\n     * @param tileKey - The unique identifier for a map tile.\n     * @param delayLoad - If true, the Tile will be created, but Tile.load will not be called\n     * @default false.\n     */\n    abstract getTile(tileKey: TileKey, delayLoad?: boolean): Tile | undefined;\n\n    /**\n     * This method is called by {@link MapView} before the\n     * tile needs to be updated, for example after\n     * a theme change.\n     *\n     * @param tile - The {@link Tile} to update.\n     */\n    updateTile(tile: Tile) {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * This method is called by the {@link MapView} to determine if the content of the surrounding\n     * tiles must be preloaded.\n     *\n     * @returns `true` if the {@link MapView} should try to preload tiles surrounding the visible\n     * tiles; `false` otherwise. The default is `false`.\n     */\n    shouldPreloadTiles(): boolean {\n        return false;\n    }\n\n    /**\n     * The minimum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[minDataLevel]] and [[minDisplayLevel]] instead.\n     */\n    get minZoomLevel(): number {\n        logger.warn(\n            \"DataSource.minZoomLevel is deprecated. Use minDataLevel and maxDataLevel instead.\"\n        );\n        return this.minDataLevel;\n    }\n\n    set minZoomLevel(level: number) {\n        logger.warn(\n            \"DataSource.minZoomLevel is deprecated. Use minDataLevel and minDisplayLevel instead.\"\n        );\n        this.minDataLevel = level;\n    }\n\n    /**\n     * The maximum zoom level at which data is available or displayed at\n     * (depending on {@link DataSource} subclass).\n     * @deprecated Use [[maxDataLevel]] and [[maxDisplayLevel]] instead.\n     */\n    get maxZoomLevel(): number {\n        logger.warn(\n            \"DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.\"\n        );\n        return this.maxDataLevel;\n    }\n\n    set maxZoomLevel(level: number) {\n        logger.warn(\n            \"DataSource.maxZoomLevel is deprecated. Use maxDataLevel and maxDisplayLevel instead.\"\n        );\n        this.maxDataLevel = level;\n    }\n\n    /**\n     * Maximum geometry height above ground level this `DataSource` can produce.\n     *\n     * Used in first stage of frustum culling before\n     * {@link Tile.maxGeometryHeight} data is available.\n     *\n     * @default 0.\n     */\n    get maxGeometryHeight() {\n        return this.m_maxGeometryHeight;\n    }\n\n    set maxGeometryHeight(value: number) {\n        this.m_maxGeometryHeight = value;\n    }\n\n    /**\n     * Minimum geometry height below ground level this `DataSource` can produce. A negative number\n     * specifies a value below ground level.\n     *\n     * Used in first stage of frustum culling before\n     * {@link Tile.minGeometryHeight} data is available.\n     *\n     * @default 0.\n     */\n    get minGeometryHeight() {\n        return this.m_minGeometryHeight;\n    }\n\n    set minGeometryHeight(value: number) {\n        this.m_minGeometryHeight = value;\n    }\n\n    /**\n     * The difference between storage level and display level of tile.\n     *\n     * Storage level offset is a value applied (added) to current zoom level giving\n     * a final tile level being displayed. This way we may differentiate current\n     * zoom level from the storage level that is displayed, giving fine grained\n     * control over the tiles being decoded an displayed.\n     */\n    get storageLevelOffset() {\n        return this.m_storageLevelOffset;\n    }\n\n    /**\n     * Setup the relative offset between storage level and display level of tile.\n     *\n     * @param levelOffset - Difference between zoom level and display level.\n     */\n    set storageLevelOffset(levelOffset: number) {\n        this.m_storageLevelOffset = levelOffset;\n    }\n\n    /**\n     * Enables or disables overlay of geometry on elevation. It must be overloaded by data sources\n     * supporting this feature.\n     *\n     * @param value - True to enable, false to disable.\n     */\n    setEnableElevationOverlay(enable: boolean) {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Computes the data zoom level to use.\n     *\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     * @returns The data zoom level to use.\n     */\n    getDataZoomLevel(zoomLevel: number): number {\n        return THREE.MathUtils.clamp(\n            zoomLevel + this.m_storageLevelOffset,\n            this.minDataLevel,\n            this.maxDataLevel\n        );\n    }\n\n    /**\n     * Returns `true` if {@link DataSource} should be displayed for the zoom level.\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     */\n    isVisible(zoomLevel: number): boolean {\n        return zoomLevel >= this.minDisplayLevel && zoomLevel <= this.maxDisplayLevel;\n    }\n\n    /**\n     * Returns `true` if {@link DataSource} can load tile with\n     * given {@link @here/harp-geoutils#TileKey} and zoom level.\n     *\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     * @param tileKey - The unique identifier for a map tile.\n     * @returns `true` if the tile for the given {@link @here/harp-geoutils#TileKey} can be loaded.\n     */\n    canGetTile(zoomLevel: number, tileKey: TileKey): boolean {\n        return tileKey.level <= zoomLevel;\n    }\n\n    /**\n     * Returns `true` if {@link MapView} should traverse tiles\n     * further with given {@link @here/harp-geoutils#TileKey} and\n     * zoom level.\n     *\n     * @param zoomLevel - The zoom level of the {@link MapView}.\n     * @param tileKey - The unique identifier for a map tile.\n     * @returns `true` if the subtiles of the given {@link @here/harp-geoutils#TileKey} should be\n     * checked for collisions.\n     */\n    shouldSubdivide(zoomLevel: number, tileKey: TileKey): boolean {\n        return tileKey.level <= zoomLevel;\n    }\n\n    /**\n     * Returns `true` if {@link MapView} should render the text\n     * elements with the given {@link @here/harp-geoutils#TileKey} and\n     * zoom level.\n     *\n     * @remarks\n     * This is an additional check for the tiles that are already selected for rendering so the\n     * default implementation returns `true`.\n     *\n     * @param zoomLevel - The zoom level.\n     * @param tileKey - The unique identifier for a map tile.\n     * @returns `true` if the text elements created for the\n     *          given {@link @here/harp-geoutils#TileKey} should be rendered.\n     */\n    shouldRenderText(zoomLevel: number, tileKey: TileKey): boolean {\n        return true;\n    }\n\n    /**\n     * Sends a request to the {@link MapView} to redraw the scene.\n     */\n    requestUpdate() {\n        this.dispatchEvent(this.UPDATE_EVENT);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Usage in Modules:\n *\n * import { DebugContext, debugContext } from \"../lib/DebugContext\";\n *\n * Declare a debug option:\n * debugContext.settings.setOption(\"MY_DBG_OPT\", \"default\");\n *\n * Access an option:\n * if (debugContext.settings.option(\"MY_DBG_OPT\")) {\n *     ...\n * }\n *\n *\n * Access in browser console:\n *\n * window.__debugContext.settings.addEventListener(\"MY_DBG_OPT\", function(event) {\n *  console.log(\"name:\", event.type, \"value:\", event.value)});\n *\n */\n\n/**\n * Allows access to the global `window` object here. The constructor of [[DebugContext]] adds the\n * instance to `window`, so it is available from the browser console.\n */\n\ninterface DebugInfo {\n    __debugContext?: DebugContext;\n}\n\nconst isNode = typeof window === \"undefined\";\n\n/**\n * A `DebugOption` is a pair that consists of an option value and an array of change listeners.\n * Listeners are called up when setting the option's value.\n */\nclass DebugOption extends THREE.EventDispatcher {\n    static SET_EVENT_TYPE: string = \"set\";\n\n    /**\n     * Constructs the `DebugOption`.\n     *\n     * @param value - The value of the option.\n     */\n    constructor(public value: any) {\n        super();\n    }\n\n    /**\n     * Updates the value of a given option.\n     *\n     * @param value - The new value for the option.\n     * @param name - The name of the option to set.\n     */\n    set(value: any, name: string) {\n        this.value = value;\n        this.dispatchEvent({ type: DebugOption.SET_EVENT_TYPE, name, value });\n    }\n}\n\n/**\n * Maintains a map of [[DebugOption]]s. You can add listeners to debug options by passing their\n * names.\n */\nexport class DebugContext {\n    private readonly m_optionsMap: Map<string, DebugOption>;\n\n    /**\n     * Builds a `DebugContext`.\n     */\n    constructor() {\n        this.m_optionsMap = new Map<string, DebugOption>();\n\n        // If we have a `window` object, we store the context in it to make it available in the\n        // console.\n        if (!isNode && typeof window !== \"undefined\" && window) {\n            const debugInfo = window as DebugInfo;\n            debugInfo.__debugContext = this;\n        }\n    }\n\n    /**\n     * Sets the value of an option. Calls change listeners of that option, even if the value has\n     * not been changed. The change listeners provided here are not called during this set\n     * operation.\n     *\n     * @param name - Name of the option.\n     * @param value - Value of the option.\n     */\n    setValue(name: string, value: any): void {\n        let opt = this.m_optionsMap.get(name);\n        if (!opt) {\n            opt = new DebugOption(value);\n            this.m_optionsMap.set(name, opt);\n        } else {\n            opt.set(value, name);\n        }\n    }\n\n    /**\n     * Gets the option value.\n     *\n     * @param name - Name of option.\n     */\n    getValue(name: string): any {\n        const opt = this.m_optionsMap.get(name);\n        return opt ? opt.value : undefined;\n    }\n\n    /**\n     * Determines if the option is registered.\n     *\n     * @param name - Name of option.\n     */\n    hasOption(name: string): boolean {\n        return this.m_optionsMap.get(name) !== undefined;\n    }\n\n    /**\n     * Adds a listener to a debug option.\n     *\n     * @param name - Name of the option that requires a listener.\n     * @param listener - The listener function to add.\n     */\n    addEventListener(name: string, listener: (event: THREE.Event) => void) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.addEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        } else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n\n    /**\n     * Checks for a listener in a debug option.\n     *\n     * @param name - Name of the option to check for.\n     * @param listener - The listener function to check for.\n     */\n    hasEventListener(name: string, listener: (event: THREE.Event) => void) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            return opt.hasEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        } else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n\n    /**\n     * Removes a listener from a debug option.\n     *\n     * @param name - Name of the option from which to remove a listener.\n     * @param listener - The listener function to remove.\n     */\n    removeEventListener(name: string, listener: (event: THREE.Event) => void) {\n        const opt = this.m_optionsMap.get(name);\n        if (opt) {\n            opt.removeEventListener(DebugOption.SET_EVENT_TYPE, listener);\n        } else {\n            throw Error(\"Unknown option: \" + name);\n        }\n    }\n\n    /**\n     * Provides access to the options map. This method is useful for creating an automatic\n     * browser GUI.\n     */\n    get options(): Map<string, any> {\n        return this.m_optionsMap;\n    }\n\n    /**\n     * Clears away all debug options. Currently, `THREE.EventDispatcher` does not provide an API\n     * to remove all event listeners.\n     */\n    clear() {\n        this.m_optionsMap.forEach(option => {\n            option.set(undefined, \"\");\n        });\n    }\n}\n\nexport const debugContext = new DebugContext();\n","/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    BufferAttribute,\n    ColorUtils,\n    Env,\n    Expr,\n    getPropertyValue,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isShaderTechnique,\n    isTextureBuffer,\n    parseStringEncodedColor,\n    ShaderTechnique,\n    supportsTextures,\n    Technique,\n    TEXTURE_PROPERTY_KEYS,\n    TextureBuffer,\n    TextureProperties,\n    TRANSPARENCY_PROPERTY_KEYS,\n    Value\n} from \"@here/harp-datasource-protocol\";\nimport {\n    getTechniqueAutomaticAttrs,\n    getTechniqueDescriptor\n} from \"@here/harp-datasource-protocol/lib/TechniqueDescriptors\";\nimport {\n    CirclePointsMaterial,\n    disableBlending,\n    enableBlending,\n    HighPrecisionLineMaterial,\n    MapMeshBasicMaterial,\n    MapMeshStandardMaterial,\n    RawShaderMaterial,\n    SolidLineMaterial\n} from \"@here/harp-materials\";\nimport { assert, LoggerManager, pick } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { DisplacedMesh } from \"./geometry/DisplacedMesh\";\nimport { SolidLineMesh } from \"./geometry/SolidLineMesh\";\nimport { MapAdapterUpdateEnv, MapMaterialAdapter, StyledProperties } from \"./MapMaterialAdapter\";\nimport { Circles, Squares } from \"./MapViewPoints\";\nimport { toPixelFormat, toTextureDataType, toTextureFilter, toWrappingMode } from \"./ThemeHelpers\";\nimport { Tile } from \"./Tile\";\n\nconst logger = LoggerManager.instance.create(\"DecodedTileHelpers\");\n\n/**\n * The structure of the options to pass into [[createMaterial]].\n */\nexport interface MaterialOptions {\n    /**\n     * The shader [[Technique]] to choose.\n     */\n    technique: Technique;\n\n    /**\n     * Environment used to evaluate dynamic technique attributes.\n     *\n     * Usually {@link MapView.env}.\n     */\n    env: Env;\n\n    /**\n     * Properties to skip.\n     *\n     * @see [[applyTechniqueToMaterial]]\n     */\n    skipExtraProps?: string[];\n\n    /**\n     * `RawShaderMaterial` instances need to know about the fog at instantiation in order to avoid\n     * recompiling them manually later (ThreeJS does not update fog for `RawShaderMaterial`s).\n     */\n    fog?: boolean;\n\n    /**\n     * Whether shadows are enabled or not, this is required because we change the material used.\n     */\n    shadowsEnabled?: boolean;\n}\n\nfunction createTextureFromURL(\n    url: string,\n    onLoad: (texture: THREE.Texture) => void,\n    onError: (error: ErrorEvent | string) => void,\n    isObjectURL: boolean\n) {\n    const texture = new THREE.TextureLoader().load(\n        url,\n        onLoad,\n        undefined, // onProgress\n        onError\n    );\n\n    if (isObjectURL) {\n        // Remove object URL on dispose to avoid memory leaks.\n        texture.addEventListener(\"dispose\", () => {\n            URL.revokeObjectURL(url);\n        });\n    }\n}\n\nfunction createTextureFromRawImage(\n    textureBuffer: TextureBuffer,\n    onLoad: (texture: THREE.Texture) => void,\n    onError: (error: ErrorEvent | string) => void\n) {\n    const properties = textureBuffer.dataTextureProperties;\n    if (properties) {\n        const textureDataType: THREE.TextureDataType | undefined = properties.type\n            ? toTextureDataType(properties.type)\n            : undefined;\n        const buffer = getTextureBuffer(textureBuffer.buffer, textureDataType);\n\n        const texture = new THREE.DataTexture(\n            buffer,\n            properties.width,\n            properties.height,\n            properties.format ? toPixelFormat(properties.format) : undefined,\n            textureDataType\n        );\n        onLoad(texture);\n    } else {\n        onError(\"no data texture properties provided.\");\n    }\n}\n\nfunction initTextureProperties(texture: THREE.Texture, properties?: TextureProperties) {\n    if (!properties) {\n        return;\n    }\n    if (properties.wrapS !== undefined) {\n        texture.wrapS = toWrappingMode(properties.wrapS);\n    }\n    if (properties.wrapT !== undefined) {\n        texture.wrapT = toWrappingMode(properties.wrapT);\n    }\n    if (properties.magFilter !== undefined) {\n        texture.magFilter = toTextureFilter(properties.magFilter);\n    }\n    if (properties.minFilter !== undefined) {\n        texture.minFilter = toTextureFilter(properties.minFilter);\n    }\n    if (properties.flipY !== undefined) {\n        texture.flipY = properties.flipY;\n    }\n    if (properties.repeatU !== undefined) {\n        texture.repeat.x = properties.repeatU;\n    }\n    if (properties.repeatV !== undefined) {\n        texture.repeat.y = properties.repeatV;\n    }\n}\n\nfunction createTexture(\n    material: THREE.Material,\n    texturePropertyName: string,\n    options: MaterialOptions\n): Promise<THREE.Texture> | undefined {\n    const technique = options.technique;\n    let textureProperty = (technique as any)[texturePropertyName];\n    if (textureProperty === undefined) {\n        return undefined;\n    }\n\n    const texturePromise = new Promise<THREE.Texture>((resolve, reject) => {\n        const onLoad = (texture: THREE.Texture) => {\n            const properties: TextureProperties | undefined = (technique as any)[\n                texturePropertyName + \"Properties\"\n            ];\n            initTextureProperties(texture, properties);\n            (material as any)[texturePropertyName] = texture;\n            material.needsUpdate = true;\n            resolve(texture);\n        };\n        const onError = (error: ErrorEvent | string) => {\n            logger.error(\"#createMaterial: Failed to load texture: \", error);\n            reject(error);\n        };\n\n        if (Expr.isExpr(textureProperty)) {\n            textureProperty = getPropertyValue(textureProperty, options.env);\n            if (!textureProperty) {\n                // Expression may evaluate to a valid texture at any time, create a fake texture to\n                // avoid shader recompilation.\n                onLoad(new THREE.Texture());\n                return;\n            }\n        }\n\n        if (typeof textureProperty === \"string\") {\n            createTextureFromURL(textureProperty, onLoad, onError, false);\n        } else if (isTextureBuffer(textureProperty)) {\n            if (textureProperty.type === \"image/raw\") {\n                createTextureFromRawImage(textureProperty, onLoad, onError);\n            } else {\n                const textureBlob = new Blob([textureProperty.buffer], {\n                    type: textureProperty.type\n                });\n                createTextureFromURL(URL.createObjectURL(textureBlob), onLoad, onError, true);\n            }\n        } else if (\n            typeof textureProperty === \"object\" &&\n            (textureProperty.nodeName === \"IMG\" || textureProperty.nodeName === \"CANVAS\")\n        ) {\n            onLoad(new THREE.CanvasTexture(textureProperty));\n        }\n    });\n    return texturePromise;\n}\n\n/**\n * Create a material, depending on the rendering technique provided in the options.\n *\n * @param rendererCapabilities - The capabilities of the renderer that will use the material.\n * @param options - The material options the subsequent functions need.\n * @param onTextureCreated - Optional callback for each texture created for the material, getting\n * a promise that will be resolved once the texture is loaded. Texture is not uploaded to GPU.\n *\n * @returns new material instance that matches `technique.name`.\n *\n * @internal\n */\nexport function createMaterial(\n    rendererCapabilities: THREE.WebGLCapabilities,\n    options: MaterialOptions,\n    onTextureCreated?: (texture: Promise<THREE.Texture>) => void\n): THREE.Material | undefined {\n    const technique = options.technique;\n    const Constructor = getMaterialConstructor(technique, options.shadowsEnabled === true);\n\n    const settings: { [key: string]: any } = {};\n\n    if (Constructor === undefined) {\n        return undefined;\n    }\n\n    if (Constructor.prototype instanceof RawShaderMaterial) {\n        settings.rendererCapabilities = rendererCapabilities;\n        if (Constructor !== HighPrecisionLineMaterial) {\n            settings.fog = options.fog;\n        }\n    }\n    if (options.shadowsEnabled === true && technique.name === \"fill\") {\n        settings.removeDiffuseLight = true;\n    }\n\n    const material = new Constructor(settings);\n\n    if (technique.id !== undefined) {\n        material.name = technique.id;\n    }\n\n    if (isExtrudedPolygonTechnique(technique)) {\n        (material as MapMeshStandardMaterial).flatShading = true;\n    }\n\n    material.depthTest = isExtrudedPolygonTechnique(technique) && technique.depthTest !== false;\n\n    if (supportsTextures(technique)) {\n        TEXTURE_PROPERTY_KEYS.forEach((texturePropertyName: string) => {\n            const texturePromise = createTexture(material, texturePropertyName, options);\n            if (texturePromise) {\n                onTextureCreated?.(texturePromise);\n            }\n        });\n    }\n\n    if (isShaderTechnique(technique)) {\n        // Special case for ShaderTechnique.\n        applyShaderTechniqueToMaterial(technique, material);\n    } else {\n        MapMaterialAdapter.create(material, getMainMaterialStyledProps(technique));\n    }\n    return material;\n}\n\n/**\n * Returns a [[THREE.BufferAttribute]] created from a provided\n * {@link @here/harp-datasource-protocol#BufferAttribute} object.\n *\n * @param attribute - BufferAttribute a WebGL compliant buffer\n * @internal\n */\nexport function getBufferAttribute(attribute: BufferAttribute): THREE.BufferAttribute {\n    switch (attribute.type) {\n        case \"float\":\n            return new THREE.BufferAttribute(\n                new Float32Array(attribute.buffer),\n                attribute.itemCount\n            );\n        case \"uint8\":\n            return new THREE.BufferAttribute(\n                new Uint8Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"uint16\":\n            return new THREE.BufferAttribute(\n                new Uint16Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"uint32\":\n            return new THREE.BufferAttribute(\n                new Uint32Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"int8\":\n            return new THREE.BufferAttribute(\n                new Int8Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"int16\":\n            return new THREE.BufferAttribute(\n                new Int16Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        case \"int32\":\n            return new THREE.BufferAttribute(\n                new Int32Array(attribute.buffer),\n                attribute.itemCount,\n                attribute.normalized\n            );\n        default:\n            throw new Error(`unsupported buffer of type ${attribute.type}`);\n    } // switch\n}\n\n/**\n * Determines if a technique uses THREE.Object3D instances.\n * @param technique - The technique to check.\n * @returns true if technique uses THREE.Object3D, false otherwise.\n * @internal\n */\nexport function usesObject3D(technique: Technique): boolean {\n    const name = technique.name;\n    return (\n        name !== undefined &&\n        name !== \"text\" &&\n        name !== \"labeled-icon\" &&\n        name !== \"line-marker\" &&\n        name !== \"label-rejection-line\"\n    );\n}\n\n/**\n * Builds the object associated with the given technique.\n *\n * @param technique - The technique.\n * @param geometry - The object's geometry.\n * @param material - The object's material.\n * @param tile - The tile where the object is located.\n * @param elevationEnabled - True if elevation is enabled, false otherwise.\n *\n * @internal\n */\nexport function buildObject(\n    technique: Technique,\n    geometry: THREE.BufferGeometry,\n    material: THREE.Material | THREE.Material[],\n    tile: Tile,\n    elevationEnabled: boolean\n): THREE.Object3D {\n    assert(technique.name !== undefined);\n\n    switch (technique.name) {\n        case \"extruded-line\":\n        case \"standard\":\n        case \"extruded-polygon\":\n        case \"fill\":\n            return elevationEnabled\n                ? new DisplacedMesh(geometry, material, () => ({\n                      min: tile.elevationRange.minElevation,\n                      max: tile.elevationRange.maxElevation\n                  }))\n                : new THREE.Mesh(geometry, material);\n        case \"terrain\":\n            return new THREE.Mesh(geometry, material);\n        case \"dashed-line\":\n        case \"solid-line\":\n            return elevationEnabled\n                ? new DisplacedMesh(\n                      geometry,\n                      material,\n                      () => ({\n                          min: tile.elevationRange.minElevation,\n                          max: tile.elevationRange.maxElevation\n                      }),\n                      SolidLineMesh.raycast\n                  )\n                : new SolidLineMesh(geometry, material);\n\n        case \"circles\":\n            return new Circles(geometry, material);\n\n        case \"squares\":\n            return new Squares(geometry, material);\n\n        case \"line\":\n            return new THREE.LineSegments(geometry, material);\n\n        case \"segments\":\n            return new THREE.LineSegments(geometry, material);\n\n        case \"shader\": {\n            assert(isShaderTechnique(technique), \"Invalid technique\");\n\n            switch (technique.primitive) {\n                case \"line\":\n                    return new THREE.Line(geometry, material);\n                case \"segments\":\n                    return new THREE.LineSegments(geometry, material);\n                case \"point\":\n                    return new THREE.Points(geometry, material);\n                case \"mesh\":\n                    return new THREE.Mesh(geometry, material);\n            }\n        }\n    }\n    assert(false, \"Invalid technique\");\n    return new THREE.Object3D();\n}\n\n/**\n * Non material properties of `BaseTechnique`.\n * @internal\n */\nexport const BASE_TECHNIQUE_NON_MATERIAL_PROPS = [\"name\", \"id\", \"renderOrder\", \"transient\"];\n\n/**\n * Generic material type constructor.\n * @internal\n */\nexport type MaterialConstructor = new (params: any) => THREE.Material;\n\n/**\n * Returns a `MaterialConstructor` basing on provided technique object.\n *\n * @param technique - `Technique` object which the material will be based on.\n * @param shadowsEnabled - Whether the material can accept shadows, this is required for some\n *                         techniques to decide which material to create.\n *\n * @internal\n */\nexport function getMaterialConstructor(\n    technique: Technique,\n    shadowsEnabled: boolean\n): MaterialConstructor | undefined {\n    if (technique.name === undefined) {\n        return undefined;\n    }\n\n    switch (technique.name) {\n        case \"extruded-line\":\n            if (!isExtrudedLineTechnique(technique)) {\n                throw new Error(\"Invalid extruded-line technique\");\n            }\n            return technique.shading === \"standard\"\n                ? MapMeshStandardMaterial\n                : MapMeshBasicMaterial;\n\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\":\n            return MapMeshStandardMaterial;\n\n        case \"dashed-line\":\n        case \"solid-line\":\n            return SolidLineMaterial;\n\n        case \"fill\":\n            return shadowsEnabled ? MapMeshStandardMaterial : MapMeshBasicMaterial;\n\n        case \"squares\":\n            return THREE.PointsMaterial;\n\n        case \"circles\":\n            return CirclePointsMaterial;\n\n        case \"line\":\n        case \"segments\":\n            return THREE.LineBasicMaterial;\n\n        case \"shader\":\n            return THREE.ShaderMaterial;\n\n        case \"text\":\n        case \"labeled-icon\":\n        case \"line-marker\":\n        case \"label-rejection-line\":\n            return undefined;\n    }\n}\n\n/**\n * Styled properties of main material (created by [[createMaterial]]) managed by\n * [[MapObjectAdapter]].\n */\nfunction getMainMaterialStyledProps(technique: Technique): StyledProperties {\n    const automaticAttributes: any[] = getTechniqueAutomaticAttrs(technique);\n\n    switch (technique.name) {\n        case \"dashed-line\":\n        case \"solid-line\": {\n            const baseProps = pick(technique, automaticAttributes);\n            baseProps.lineWidth = buildMetricValueEvaluator(\n                technique.lineWidth ?? 0, // Compatibility: `undefined` lineWidth means hidden.\n                technique.metricUnit\n            );\n            baseProps.outlineWidth = buildMetricValueEvaluator(\n                technique.outlineWidth,\n                technique.metricUnit\n            );\n            baseProps.dashSize = buildMetricValueEvaluator(\n                technique.dashSize,\n                technique.metricUnit\n            );\n            baseProps.gapSize = buildMetricValueEvaluator(technique.gapSize, technique.metricUnit);\n            baseProps.offset = buildMetricValueEvaluator(technique.offset, technique.metricUnit);\n            return baseProps;\n        }\n        case \"fill\":\n            return pick(technique, automaticAttributes);\n        case \"standard\":\n        case \"terrain\":\n        case \"extruded-polygon\": {\n            const baseProps = pick(technique, automaticAttributes);\n            if (technique.vertexColors !== true) {\n                baseProps.color = technique.color;\n            }\n            return baseProps;\n        }\n        case \"circles\":\n        case \"squares\":\n            return pick(technique, automaticAttributes);\n        case \"extruded-line\":\n            return pick(technique, [\n                \"color\",\n                \"wireframe\",\n                \"transparent\",\n                \"opacity\",\n                \"polygonOffset\",\n                \"polygonOffsetFactor\",\n                \"polygonOffsetUnits\",\n                ...automaticAttributes\n            ]);\n        case \"line\":\n        case \"segments\":\n            return pick(technique, automaticAttributes);\n        default:\n            return {};\n    }\n}\n\n/**\n * Convert metric style property to expression that accounts {@link MapView.pixelToWorld} if\n * `metricUnit === 'Pixel'`.\n * @internal\n */\nexport function buildMetricValueEvaluator(\n    value: Expr | Value | undefined,\n    metricUnit: string | undefined\n) {\n    if (value === undefined || value === null) {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        if (value.endsWith(\"px\")) {\n            metricUnit = \"Pixel\";\n            value = Number.parseFloat(value);\n        } else if (value.endsWith(\"m\")) {\n            value = Number.parseFloat(value);\n        }\n    }\n    if (metricUnit === \"Pixel\") {\n        return (context: MapAdapterUpdateEnv) => {\n            const pixelToWorld = (context.env.lookup(\"$pixelToMeters\") as number) ?? 1;\n            const evaluated = getPropertyValue(value, context.env);\n            return pixelToWorld * evaluated;\n        };\n    } else {\n        return value;\n    }\n}\n\n/**\n * Allows to easy parse/encode technique's base color property value as number coded color.\n *\n * @remarks\n * Function takes care about property parsing, interpolation and encoding if neccessary.\n *\n * @see ColorUtils\n * @param technique - the technique where we search for base (transparency) color value\n * @param env - {@link @here/harp-datasource-protocol#Env} instance\n *              used to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of `Technique`\n * @returns `number` encoded color value (in custom #TTRRGGBB) format or `undefined` if\n * base color property is not defined in the technique passed.\n *\n * @internal\n */\nexport function evaluateBaseColorProperty(technique: Technique, env: Env): number | undefined {\n    const baseColorProp = getBaseColorProp(technique);\n    if (baseColorProp !== undefined) {\n        return evaluateColorProperty(baseColorProp, env);\n    }\n    return undefined;\n}\n\n/**\n * Apply `ShaderTechnique` parameters to material.\n *\n * @param technique - the `ShaderTechnique` which requires special handling\n * @param material - material to which technique will be applied\n *\n * @internal\n */\nfunction applyShaderTechniqueToMaterial(technique: ShaderTechnique, material: THREE.Material) {\n    if (technique.transparent) {\n        enableBlending(material);\n    } else {\n        disableBlending(material);\n    }\n\n    // The shader technique takes the argument from its `params' member.\n    const params = technique.params as { [key: string]: any };\n    // Remove base color and transparency properties from the processed set.\n    const baseColorPropName = getBaseColorPropName(technique);\n    const hasBaseColor = baseColorPropName && baseColorPropName in technique.params;\n    const props = Object.getOwnPropertyNames(params).filter(propertyName => {\n        // Omit base color and related transparency attributes if its defined in technique\n        if (\n            baseColorPropName === propertyName ||\n            (hasBaseColor && TRANSPARENCY_PROPERTY_KEYS.includes(propertyName))\n        ) {\n            return false;\n        }\n        const prop = propertyName as keyof typeof params;\n        if (prop === \"name\") {\n            // skip reserved property names\n            return false;\n        }\n        return true;\n    });\n\n    // Apply all technique properties omitting base color and transparency attributes.\n    props.forEach(propertyName => {\n        // TODO: Check if properties values should not be interpolated, possible bug in old code!\n        // This behavior is kept in the new version too, level is set to undefined.\n        applyTechniquePropertyToMaterial(material, propertyName, params[propertyName]);\n    });\n\n    if (hasBaseColor) {\n        const propColor = baseColorPropName as keyof THREE.Material;\n        // Finally apply base color and related properties to material (opacity, transparent)\n        applyBaseColorToMaterial(material, material[propColor], technique, params[propColor]);\n    }\n}\n\n/**\n * Apply single and generic technique property to corresponding material parameter.\n *\n * @note Special handling for material attributes of [[THREE.Color]] type is provided thus it\n * does not provide constructor that would take [[string]] or [[number]] values.\n *\n * @param material - target material\n * @param propertyName - material and technique parameter name (or index) that is to be transferred\n * @param techniqueAttrValue - technique property value which will be applied to material attribute\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used\n *              to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of [[Technique]]\n */\nfunction applyTechniquePropertyToMaterial(\n    material: THREE.Material,\n    propertyName: string,\n    techniqueAttrValue: Value,\n    env?: Env\n) {\n    const m = material as any;\n    if (m[propertyName] instanceof THREE.Color) {\n        applySecondaryColorToMaterial(\n            material[propertyName as keyof THREE.Material],\n            techniqueAttrValue,\n            env\n        );\n    } else {\n        const value = evaluateProperty(techniqueAttrValue, env);\n        if (value !== null) {\n            m[propertyName] = value;\n        }\n    }\n}\n\n/**\n * Apply technique color to material taking special care with transparent (RGBA) colors.\n *\n * @remarks\n * @note This function is intended to be used with secondary, triary etc. technique colors,\n * not the base ones that may contain transparency information. Such colors should be processed\n * with [[applyTechniqueBaseColorToMaterial]] function.\n *\n * @param technique - an technique the applied color comes from\n * @param material - the material to which color is applied\n * @param prop - technique property (color) name\n * @param value - color value\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used\n *              to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of `Technique`.\n *\n * @internal\n */\nexport function applySecondaryColorToMaterial(\n    materialColor: THREE.Color,\n    techniqueColor: Value | Expr,\n    env?: Env\n) {\n    let value = evaluateColorProperty(techniqueColor, env);\n    if (value === undefined) {\n        return;\n    }\n    if (ColorUtils.hasAlphaInHex(value)) {\n        logger.warn(\"Used RGBA value for technique color without transparency support!\");\n        // Just for clarity remove transparency component, even if that would be ignored\n        // by THREE.Color.setHex() function.\n        value = ColorUtils.removeAlphaFromHex(value);\n    }\n\n    materialColor.setHex(value);\n}\n\n/**\n * Apply technique base color (transparency support) to material with modifying material opacity.\n *\n * @remarks\n * This method applies main (or base) technique color with transparency support to the corresponding\n * material color, with an effect on entire [[THREE.Material]] __opacity__ and __transparent__\n * attributes.\n *\n * @note Transparent colors should be processed as the very last technique attributes,\n * since their effect on material properties like [[THREE.Material.opacity]] and\n * [[THREE.Material.transparent]] could be overridden by corresponding technique params.\n *\n * @param technique - an technique the applied color comes from\n * @param material - the material to which color is applied\n * @param prop - technique property (color) name\n * @param value - color value in custom number format\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate\n *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]\n *\n * @internal\n */\nexport function applyBaseColorToMaterial(\n    material: THREE.Material,\n    materialColor: THREE.Color,\n    technique: Technique,\n    techniqueColor: Value,\n    env?: Env\n) {\n    const colorValue = evaluateColorProperty(techniqueColor, env);\n    if (colorValue === undefined) {\n        return;\n    }\n\n    const { r, g, b, a } = ColorUtils.getRgbaFromHex(colorValue);\n    // Override material opacity and blending by mixing technique defined opacity\n    // with main color transparency\n    const tech = technique as any;\n    let opacity = a;\n    if (tech.opacity !== undefined) {\n        opacity *= evaluateProperty(tech.opacity, env);\n    }\n\n    opacity = THREE.MathUtils.clamp(opacity, 0, 1);\n    if (material instanceof RawShaderMaterial) {\n        material.setOpacity(opacity);\n    } else {\n        material.opacity = opacity;\n    }\n\n    materialColor.setRGB(r, g, b);\n\n    const opaque = opacity >= 1.0;\n    if (!opaque) {\n        enableBlending(material);\n    } else {\n        disableBlending(material);\n    }\n}\n\n/**\n * Calculates the value of the technique defined property.\n *\n * Function takes care about property interpolation (when @param `env` is set) as also parsing\n * string encoded numbers.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value - the value of color property defined in technique\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate\n *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]\n */\nfunction evaluateProperty(value: any, env?: Env): any {\n    if (env !== undefined && Expr.isExpr(value)) {\n        value = getPropertyValue(value, env);\n    }\n    return value;\n}\n\n/**\n * Calculates the numerical value of the technique defined color property.\n *\n * @remarks\n * Function takes care about color interpolation (when @param `env is set) as also parsing\n * string encoded colors.\n *\n * @note Use with care, because function does not recognize property type.\n * @param value - the value of color property defined in technique\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used to evaluate\n *              {@link @here/harp-datasource-protocol#Expr} based properties of [[Technique]]\n * @internal\n */\nexport function evaluateColorProperty(value: Value, env?: Env): number | undefined {\n    value = evaluateProperty(value, env);\n\n    if (value === undefined || value === null) {\n        return undefined;\n    }\n\n    if (typeof value === \"number\") {\n        return value;\n    }\n\n    if (typeof value === \"string\") {\n        const parsed = parseStringEncodedColor(value);\n        if (parsed !== undefined) {\n            return parsed;\n        }\n    }\n\n    logger.error(`Unsupported color format: '${value}'`);\n    return undefined;\n}\n\n/**\n * Allows to access base color property value for given technique.\n *\n * The color value may be encoded in [[number]], [[string]] or even as\n * [[InterpolateProperty]].\n *\n * @param technique - The techniqe where we seach for base color property.\n * @returns The value of technique color used to apply transparency.\n */\nfunction getBaseColorProp(technique: Technique): any {\n    const baseColorPropName = getBaseColorPropName(technique);\n    if (baseColorPropName !== undefined) {\n        if (!isShaderTechnique(technique)) {\n            const propColor = baseColorPropName as keyof typeof technique;\n            return technique[propColor];\n        } else {\n            const params = technique.params as { [key: string]: any };\n            const propColor = baseColorPropName as keyof typeof params;\n            return params[propColor];\n        }\n    }\n    return undefined;\n}\n\nfunction getBaseColorPropName(technique: Technique): string | undefined {\n    return getTechniqueDescriptor(technique)?.attrTransparencyColor;\n}\n\nfunction getTextureBuffer(\n    buffer: ArrayBuffer,\n    textureDataType: THREE.TextureDataType | undefined\n): BufferSource {\n    if (textureDataType === undefined) {\n        return new Uint8Array(buffer);\n    }\n\n    switch (textureDataType) {\n        case THREE.UnsignedByteType:\n            return new Uint8Array(buffer);\n        case THREE.ByteType:\n            return new Int8Array(buffer);\n        case THREE.ShortType:\n            return new Int16Array(buffer);\n        case THREE.UnsignedShortType:\n            return new Uint16Array(buffer);\n        case THREE.IntType:\n            return new Int32Array(buffer);\n        case THREE.UnsignedIntType:\n            return new Uint32Array(buffer);\n        case THREE.FloatType:\n            return new Float32Array(buffer);\n        case THREE.HalfFloatType:\n            return new Uint16Array(buffer);\n    }\n\n    throw new Error(\"Unsupported texture data type\");\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, ExtrudedPolygonTechnique } from \"@here/harp-datasource-protocol\";\nimport { ColorUtils } from \"@here/harp-datasource-protocol/lib/ColorUtils\";\nimport { enforceBlending, MapMeshStandardMaterial } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { evaluateBaseColorProperty } from \"./DecodedTileHelpers\";\n\n/**\n * Bitmask used for the depth pre-pass to prevent multiple fragments in the same screen position\n * from rendering color.\n * @internal\n */\nexport const DEPTH_PRE_PASS_STENCIL_MASK = 0x01;\n\n/**\n * Render order offset for the depth pre-pass to ensure that it's rendered first.\n */\nconst DEPTH_PRE_PASS_RENDER_ORDER_OFFSET = 1e-6;\n\n/**\n * Check if technique requires (and not disables) use of depth prepass.\n *\n * @remarks\n * Depth prepass is enabled if correct opacity is specified (in range `(0,1)`) _and_ not explicitly\n * disabled by `enableDepthPrePass` option.\n *\n * @param technique - `BaseStandardTechnique` instance to be checked\n * @param env - {@link @here/harp-datasource-protocol#Env} instance used\n *              to evaluate {@link @here/harp-datasource-protocol#Expr}\n *              based properties of `Technique`\n *\n * @internal\n */\nexport function isRenderDepthPrePassEnabled(technique: ExtrudedPolygonTechnique, env: Env) {\n    // Depth pass explicitly disabled\n    if (technique.enableDepthPrePass === false) {\n        return false;\n    }\n    let transparent =\n        technique.opacity !== undefined && technique.opacity > 0.0 && technique.opacity < 1.0;\n    // If not opaque then check if transparency may be modified via alpha in base color.\n    // Otherwise we don't need to even test base color because opacity mixed with any base alpha,\n    // will always produce some transparency effect.\n    if (!transparent) {\n        // We do not support switching depth pass during alpha interpolation, ignore zoom level\n        // when calculating base color value.\n        const color = evaluateBaseColorProperty(technique, env);\n        if (color !== undefined) {\n            const alpha = ColorUtils.getAlphaFromHex(color);\n            transparent = alpha > 0.0 && alpha < 1.0;\n        }\n    }\n    return transparent;\n}\n\n/**\n * Property identifying a material that is being used as a DepthPrePass material.\n */\nexport interface DepthPrePassProperties {\n    /**\n     * This material is a special depth prepass material.\n     */\n    isDepthPrepassMaterial?: true;\n}\n\n/**\n * Creates material for depth prepass.\n *\n * @remarks\n * Creates material that writes only to the z-buffer. Updates the original material instance, to\n * support depth prepass.\n *\n * @param baseMaterial - The base material of mesh that is updated to work with depth prepass\n *     and then used. This parameter is a template for depth prepass material that is returned.\n * @returns depth prepass material, which is a clone of `baseMaterial` with the adapted settings.\n *\n * @internal\n */\nexport function createDepthPrePassMaterial(baseMaterial: THREE.Material): THREE.Material {\n    baseMaterial.depthWrite = false;\n    baseMaterial.depthFunc = THREE.EqualDepth;\n    baseMaterial.colorWrite = true;\n    enforceBlending(baseMaterial);\n\n    const depthPassMaterial: THREE.Material & DepthPrePassProperties = baseMaterial.clone();\n    depthPassMaterial.isDepthPrepassMaterial = true;\n    depthPassMaterial.depthWrite = true;\n    depthPassMaterial.depthTest = true;\n    depthPassMaterial.depthFunc = THREE.LessDepth;\n    depthPassMaterial.colorWrite = false;\n    depthPassMaterial.opacity = 1.0;\n    depthPassMaterial.blending = THREE.NoBlending;\n    return depthPassMaterial;\n}\n\n/**\n * Checks if a given object is a depth prepass mesh.\n *\n * @param object - The object to check whether it's a depth prepass mesh.\n * @returns `true` if the object is a depth prepass mesh, `false` otherwise.\n *\n * @internal\n */\nexport function isDepthPrePassMesh(object: THREE.Object3D): boolean {\n    if ((object as any).isMesh !== true) {\n        return false;\n    }\n    const mesh = object as THREE.Mesh;\n    return mesh.material instanceof Array\n        ? mesh.material.every(material => (material as any).isDepthPrepassMaterial === true)\n        : (mesh.material as any).isDepthPrepassMaterial === true;\n}\n\n/**\n * Clones a given mesh to render it in the depth prepass with another material.\n *\n * @remarks\n * Both the original\n * and depth prepass meshes, when rendered in the correct order, create the proper depth prepass\n * effect. The original mesh material is slightly modified by [[createDepthPrePassMaterial]] to\n * support the depth prepass. This method is usable only if the material of this mesh has an\n * opacity value in the range `(0,1)`.\n *\n * The DepthPrePass object is created wis a slightly smaller `renderOrder` as the original mesh\n * to ensure that it's rendered first.\n *\n * @param mesh - original mesh\n * @returns `Mesh` depth pre pass\n *\n * @internal\n */\nexport function createDepthPrePassMesh(mesh: THREE.Mesh): THREE.Mesh {\n    const originalGeometry = mesh.geometry;\n\n    if (!(originalGeometry instanceof THREE.BufferGeometry)) {\n        throw new Error(\"#createDepthPassMesh only BufferGeometry is supported\");\n    }\n    const positionAttribute = originalGeometry.getAttribute(\"position\");\n    if (!positionAttribute) {\n        throw new Error(\"#createDepthPassMesh position attribute not found\");\n    }\n\n    const depthPassGeometry = new THREE.BufferGeometry();\n    depthPassGeometry.setAttribute(\"position\", positionAttribute);\n    const uvAttribute = originalGeometry.getAttribute(\"uv\");\n    if (uvAttribute) {\n        depthPassGeometry.setAttribute(\"uv\", uvAttribute);\n    }\n    const normalAttribute = originalGeometry.getAttribute(\"normal\");\n    if (normalAttribute) {\n        depthPassGeometry.setAttribute(\"normal\", normalAttribute);\n    }\n    const extrusionAxisAttribute = originalGeometry.getAttribute(\"extrusionAxis\");\n    if (extrusionAxisAttribute) {\n        depthPassGeometry.setAttribute(\"extrusionAxis\", extrusionAxisAttribute);\n    }\n\n    if (originalGeometry.index) {\n        depthPassGeometry.setIndex(originalGeometry.index);\n    }\n\n    for (const group of originalGeometry.groups) {\n        const { start, count, materialIndex } = group;\n        depthPassGeometry.addGroup(start, count, materialIndex);\n    }\n\n    const depthPassMaterial =\n        mesh.material instanceof Array\n            ? mesh.material.map(createDepthPrePassMaterial)\n            : createDepthPrePassMaterial(mesh.material);\n\n    const depthPassMesh = new THREE.Mesh(depthPassGeometry, depthPassMaterial);\n    depthPassMesh.renderOrder = mesh.renderOrder - DEPTH_PRE_PASS_RENDER_ORDER_OFFSET;\n\n    return depthPassMesh;\n}\n\n/**\n * Sets up all the needed stencil logic needed for the depth pre-pass.\n *\n * @remarks\n * This logic is in place to avoid z-fighting artifacts that can appear in geometries that have\n * coplanar triangles inside the same mesh.\n *\n * @param depthMesh - Mesh created by `createDepthPrePassMesh`.\n * @param colorMesh - Original mesh.\n * @internal\n */\nexport function setDepthPrePassStencil(depthMesh: THREE.Mesh, colorMesh: THREE.Mesh) {\n    function setupDepthMaterialStencil(depthMeshMaterial: THREE.Material) {\n        // Set up depth mesh stencil logic.\n        // Set the depth pre-pass stencil bit for all processed fragments. We use\n        // `THREE.AlwaysStencilFunc` and not `THREE.NotEqualStencilFunc` to force all fragments to pass\n        // the stencil test and write the correct depth value.\n        const depthMaterial = depthMeshMaterial as MapMeshStandardMaterial;\n        depthMaterial.stencilWrite = true;\n        depthMaterial.stencilFail = THREE.KeepStencilOp;\n        depthMaterial.stencilZFail = THREE.KeepStencilOp;\n        depthMaterial.stencilZPass = THREE.ReplaceStencilOp;\n        depthMaterial.stencilFunc = THREE.AlwaysStencilFunc;\n        depthMaterial.stencilRef = 0xff;\n        (depthMaterial as any).stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;\n    }\n\n    function setupColorMaterialStencil(colorMeshMaterial: THREE.Material) {\n        // Set up color mesh stencil logic.\n        // Only write color for pixels with the depth pre-pass stencil bit set. Also, once a pixel is\n        // rendered, set the stencil bit to 0 to prevent subsequent pixels in the same clip position\n        // from rendering color again.\n        const colorMaterial = colorMeshMaterial as MapMeshStandardMaterial;\n        colorMaterial.stencilWrite = true;\n        colorMaterial.stencilFail = THREE.KeepStencilOp;\n        colorMaterial.stencilZFail = THREE.KeepStencilOp;\n        colorMaterial.stencilZPass = THREE.ZeroStencilOp;\n        colorMaterial.stencilFunc = THREE.EqualStencilFunc;\n        colorMaterial.stencilRef = 0xff;\n        (colorMaterial as any).stencilFuncMask = DEPTH_PRE_PASS_STENCIL_MASK;\n    }\n\n    if (depthMesh.material instanceof Array) {\n        depthMesh.material.map(setupDepthMaterialStencil);\n    } else {\n        setupDepthMaterialStencil(depthMesh.material);\n    }\n\n    if (colorMesh.material instanceof Array) {\n        colorMesh.material.map(setupColorMaterialStencil);\n    } else {\n        setupColorMaterialStencil(colorMesh.material);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TilingScheme } from \"@here/harp-geoutils\";\nimport { TileKey } from \"@here/harp-geoutils/lib/tiling/TileKey\";\n\n/**\n * Status of the elevation range calculation.\n */\nexport enum CalculationStatus {\n    // Calculated approximately. A more precise result may be available later.\n    PendingApproximate,\n    // Calculation completed. The result is final, won't improve upon retrying.\n    FinalPrecise\n}\n\n/**\n * Elevation range with an optional calculation status.\n */\nexport interface ElevationRange {\n    minElevation: number;\n    maxElevation: number;\n    calculationStatus?: CalculationStatus;\n}\n\n/**\n * Source for elevation ranges per tile. The returned elevation ranges will be used in the visible\n * tile computation to calculate proper bounding boxes.\n */\nexport interface ElevationRangeSource {\n    /**\n     * Compute the elevation range for a given {@link @here/harp-geoutils#TileKey}.\n     * @param tileKey - The tile for which the elevation range should be computed.\n     */\n    getElevationRange(tileKey: TileKey): ElevationRange;\n\n    /**\n     * The tiling scheme of this {@link ElevationRangeSource}.\n     *\n     * @remarks\n     * {@link MapView} will only apply the elevation\n     * ranges returned by [[getElevationRange]] that have\n     * the same {@link @here/harp-geoutils#TilingScheme}.\n     */\n    getTilingScheme(): TilingScheme;\n\n    /**\n     * Connects to the underlying data.\n     */\n    connect(): Promise<void>;\n\n    /**\n     * Returns `true` if this `ElevationRangeSource` is ready and the {@link MapView} can invoke\n     * `getElevationRange()` to start requesting data.\n     */\n    ready(): boolean;\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * JavaScript events for custom objects. Stores all listeners to allow removing all listeners for\n * housekeeping.\n *\n * Will be replaced by `THREE.EventDispatcher` once https://github.com/mrdoob/three.js/pull/19844\n * is released.\n */\nexport class EventDispatcher {\n    private readonly m_listeners: Map<string, Array<(event: THREE.Event) => void>> = new Map();\n\n    /**\n     * Destroy this `EventDispatcher` instance.\n     *\n     * Unregister all event handlers used. This is method should be called when you stop\n     * using `EventDispatcher`.\n     */\n    dispose() {\n        this.removeAllEventListeners();\n    }\n\n    /**\n     * Checks if listener is added to an event type.\n     *\n     * @param type - The type of event to listen to.\n     * @param listener - The function that gets called when the event is fired.\n     */\n    hasEventListener(type: string, listener?: (event: THREE.Event) => void): boolean {\n        const listeners = this.m_listeners.get(type);\n        if (listeners === undefined) {\n            return false;\n        }\n        return listener !== undefined ? listeners.includes(listener) : true;\n    }\n\n    /**\n     * Add a new event listener to the event type.\n     *\n     * @param type - The type of event to listen to.\n     * @param listener - The function that gets called when the event is fired.\n     */\n    addEventListener(type: string, listener: (event: THREE.Event) => void): void {\n        let listeners = this.m_listeners.get(type);\n        if (listeners === undefined) {\n            listeners = [];\n            this.m_listeners.set(type, listeners);\n        }\n        if (!listeners.includes(listener)) {\n            listeners.push(listener);\n        }\n    }\n\n    /**\n     * Remove the listener from the event type.\n     *\n     * @param type - The type of event to listen to.\n     * @param listener - The function that gets called when the event is fired. If the value is\n     * `undefined`, all listeners will be removed.\n     */\n    removeEventListener(type: string, listener?: any): void {\n        const listeners = this.m_listeners.get(type);\n        if (listeners === undefined) {\n            return;\n        }\n        if (listener === undefined) {\n            this.m_listeners.delete(type);\n        } else {\n            const index = listeners.indexOf(listener);\n            if (index !== -1) {\n                listeners.splice(index, 1);\n                if (listeners.length === 0) {\n                    this.m_listeners.delete(type);\n                }\n            }\n        }\n    }\n\n    /**\n     * Remove all event listeners for housekeeping.\n     */\n    removeAllEventListeners() {\n        const events = Array.from(this.m_listeners.keys());\n        for (const event of events) {\n            this.removeEventListener(event);\n        }\n    }\n\n    /**\n     * Retrieve the registered event types.\n     *\n     * @returns Array of event types.\n     */\n    get eventTypes(): string[] {\n        return Array.from(this.m_listeners.keys());\n    }\n\n    /**\n     * Retrieve the registered listeners to the specified event.\n     *\n     * @param type - The type of event to listen to.\n     * @returns Array of event listeners.\n     */\n    listeners(type: string): Array<(event: THREE.Event) => void> | undefined {\n        return this.m_listeners.get(type);\n    }\n\n    /**\n     * Dispatch the event to the registered listeners.\n     *\n     * @param event - The event to dispatch.\n     */\n    dispatchEvent(event: THREE.Event) {\n        const listeners = this.m_listeners.get(event.type);\n        if (listeners !== undefined) {\n            event.target = this;\n\n            // Make a copy, in case listeners are removed while iterating.\n            const array = listeners.slice(0);\n\n            for (let i = 0, l = array.length; i < l; i++) {\n                array[i].call(this, event);\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport { Projection } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\nimport { ClipPlanesEvaluator } from \"./ClipPlanesEvaluator\";\nimport { ElevationProvider } from \"./ElevationProvider\";\n\n/**\n * Provides the most basic evaluation concept giving fixed values with some constraints.\n */\nexport class FixedClipPlanesEvaluator implements ClipPlanesEvaluator {\n    readonly minFar: number;\n    private m_nearPlane: number;\n    private m_farPlane: number;\n\n    constructor(readonly minNear: number = 1, readonly minFarOffset: number = 10) {\n        this.minFar = minNear + minFarOffset;\n        this.m_nearPlane = minNear;\n        this.m_farPlane = this.minFar;\n    }\n\n    get nearPlane(): number {\n        return this.m_nearPlane;\n    }\n\n    set nearPlane(fixedNear: number) {\n        this.invalidatePlanes(fixedNear, this.m_farPlane);\n    }\n\n    get farPlane(): number {\n        return this.m_farPlane;\n    }\n\n    set farPlane(fixedFar: number) {\n        this.invalidatePlanes(this.m_nearPlane, fixedFar);\n    }\n\n    set minElevation(elevation: number) {}\n\n    get minElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    set maxElevation(elevation: number) {}\n\n    get maxElevation(): number {\n        // This evaluator does not support elevation so its always set to 0.\n        return 0;\n    }\n\n    /** @override */\n    evaluateClipPlanes(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevationProvider?: ElevationProvider\n    ): ViewRanges {\n        // We do not need to perform actual evaluation cause results are precomputed and\n        // kept stable until somebody changes the properties.\n        const viewRanges: ViewRanges = {\n            near: this.m_nearPlane,\n            far: this.m_farPlane,\n            minimum: this.minNear,\n            maximum: this.m_farPlane\n        };\n        return viewRanges;\n    }\n\n    private invalidatePlanes(near: number, far: number) {\n        // When clamping prefer to extend far plane at about minimum distance, giving\n        // near distance setup priority over far.\n        const nearDist: number = Math.max(this.minNear, near);\n        const farDist: number = Math.max(this.minFar, far, nearDist + this.minFarOffset);\n        this.m_nearPlane = nearDist;\n        this.m_farPlane = farDist;\n    }\n}\n","/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Specifies how the FOV (Field of View) should be calculated.\n */\nexport interface FovCalculation {\n    /**\n     * How to interpret the [[fov]], can be either `fixed` or `dynamic`.\n     *\n     * `fixed` means that the FOV is fixed regardless of the [[viewportHeight]], such that shrinking\n     * the height causes the map to shrink to keep the content in view. The benefit is that,\n     * regardless of any resizes, the field of view is constant, which means there is no change in\n     * the distortion of buildings near the edges. However the trade off is that the zoom level\n     * changes, which means that the map will pull in new tiles, hence causing some flickering.\n     *\n     * `dynamic` means that the focal length is calculated based on the supplied [[fov]] and\n     * [[viewportHeight]], this means that the map doesn't scale (the image is essentially cropped\n     * but not shrunk) when the [[viewportHeight]] or [[viewportWidth]] is changed. The benefit is\n     * that the zoom level is (currently) stable during resize, because the focal length is used,\n     * however the tradeoff is that changing from a small to a big height will cause the fov to\n     * change a lot, and thus introduce distortion.\n     */\n    type: \"fixed\" | \"dynamic\";\n\n    /**\n     * Vertical field of view in degrees.\n     * If [[type]] is `fixed` then the supplied [[fov]] is fixed regardless of\n     * [[viewportHeight]] or [[viewportWidth]].\n     *\n     * If [[type]] is `dynamic` then the supplied [[fov]] is applied to the\n     * first frame, and the focal length calculated. Changes to the viewport\n     * height no longer shrink the content because the field of view is updated\n     * dynamically.\n     */\n    fov: number;\n}\n\nexport const DEFAULT_FOV_CALCULATION: FovCalculation = { type: \"dynamic\", fov: 40 };\nexport const MIN_FOV_DEG = 10;\nexport const MAX_FOV_DEG = 140;\nexport const MIN_FOV_RAD = THREE.MathUtils.degToRad(MIN_FOV_DEG);\nexport const MAX_FOV_RAD = THREE.MathUtils.degToRad(MAX_FOV_DEG);\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    OrientedBox3,\n    Projection,\n    ProjectionType,\n    TileKey,\n    TileKeyUtils,\n    TilingScheme\n} from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { DataSource } from \"./DataSource\";\nimport { CalculationStatus, ElevationRange, ElevationRangeSource } from \"./ElevationRangeSource\";\nimport { MapTileCuller } from \"./MapTileCuller\";\nimport { MapView } from \"./MapView\";\nimport { MapViewUtils } from \"./Utils\";\n\nconst tmpVectors3 = [new THREE.Vector3(), new THREE.Vector3()];\nconst tmpVector4 = new THREE.Vector4();\n\n/**\n * Represents a unique TileKey and the area it takes up on screen.\n *\n * Note, in certain tiling projections, it is possible to have an offset, which represents a tile\n * which has fully wrapped around, hence this defaults to 0 to simplify usage for projections which\n * don't require it.\n */\nexport class TileKeyEntry {\n    constructor(\n        public tileKey: TileKey,\n        public area: number,\n        public offset: number = 0,\n        public elevationRange?: ElevationRange,\n        public distance: number = 0\n    ) {}\n}\n\nfunction getGeoBox(tilingScheme: TilingScheme, childTileKey: TileKey, offset: number) {\n    const geoBox = tilingScheme.getGeoBox(childTileKey);\n    const longitudeOffset = 360.0 * offset;\n    geoBox.northEast.longitude += longitudeOffset;\n    geoBox.southWest.longitude += longitudeOffset;\n    return geoBox;\n}\n\n/**\n * Map tile keys to TileKeyEntry.\n * Keys are a combination of morton code and tile offset,\n * see [[TileOffsetUtils.getKeyForTileKeyAndOffset]].\n */\ntype TileKeyEntries = Map<number, TileKeyEntry>;\n\n/**\n * Map zoom level to map of visible tile key entries\n */\ntype ZoomLevelTileKeyMap = Map<number, TileKeyEntries>;\n\n/**\n * Result of frustum intersection\n */\ninterface IntersectionResult {\n    /**\n     * Tiles intersected by the frustum per zoom level.\n     */\n    readonly tileKeyEntries: ZoomLevelTileKeyMap;\n\n    /**\n     * True if the intersection was calculated using precise elevation data, false if it's an\n     * approximation.\n     */\n    calculationFinal: boolean;\n}\n\n/**\n * Computes the tiles intersected by the frustum defined by the current camera setup.\n */\nexport class FrustumIntersection {\n    private readonly m_frustum: THREE.Frustum = new THREE.Frustum();\n    // used to project global coordinates into camera local coordinates\n    private readonly m_viewProjectionMatrix = new THREE.Matrix4();\n    private readonly m_mapTileCuller: MapTileCuller;\n    private m_rootTileKeys: TileKeyEntry[] = [];\n    private readonly m_tileKeyEntries: ZoomLevelTileKeyMap = new Map();\n\n    constructor(\n        private readonly m_camera: THREE.PerspectiveCamera,\n        readonly mapView: MapView,\n        private readonly m_extendedFrustumCulling: boolean,\n        private readonly m_tileWrappingEnabled: boolean,\n        private readonly m_enableMixedLod: boolean,\n        private readonly m_tilePixelSize: number = 256\n    ) {\n        this.m_mapTileCuller = new MapTileCuller(m_camera);\n    }\n\n    /**\n     * Return camera used for generating frustum.\n     */\n    get camera(): THREE.PerspectiveCamera {\n        return this.m_camera;\n    }\n\n    /**\n     * Return projection used to convert geo coordinates to world coordinates.\n     */\n    get projection(): Projection {\n        return this.mapView.projection;\n    }\n\n    /**\n     * Updates the frustum to match the current camera setup.\n     */\n    updateFrustum(projectionMatrixOverride?: THREE.Matrix4) {\n        this.m_viewProjectionMatrix.multiplyMatrices(\n            projectionMatrixOverride !== undefined\n                ? projectionMatrixOverride\n                : this.m_camera.projectionMatrix,\n            this.m_camera.matrixWorldInverse\n        );\n\n        this.m_frustum.setFromProjectionMatrix(this.m_viewProjectionMatrix);\n\n        if (this.m_extendedFrustumCulling) {\n            this.m_mapTileCuller.setup();\n        }\n        this.computeRequiredInitialRootTileKeys(this.m_camera.position);\n    }\n\n    /**\n     * Computes the tiles intersected by the updated frustum, see [[updateFrustum]].\n     *\n     * @param tilingScheme - The tiling scheme used to generate the tiles.\n     * @param elevationRangeSource - Source of elevation range data if any.\n     * @param zoomLevels - A list of zoom levels to render.\n     * @param dataSources - A list of data sources to render.\n     * @returns The computation result, see [[FrustumIntersection.Result]].\n     */\n    compute(\n        tilingScheme: TilingScheme,\n        elevationRangeSource: ElevationRangeSource | undefined,\n        zoomLevels: number[],\n        dataSources: DataSource[]\n    ): IntersectionResult {\n        this.m_tileKeyEntries.clear();\n\n        // Compute target tile area in clip space size.\n        // A tile should take up roughly 256x256 pixels on screen in accordance to\n        // the zoom level chosen by [MapViewUtils.calculateZoomLevelFromDistance].\n        assert(this.mapView.viewportHeight !== 0);\n        const targetTileArea = Math.pow(this.m_tilePixelSize / this.mapView.viewportHeight, 2);\n        const useElevationRangeSource: boolean =\n            elevationRangeSource !== undefined &&\n            elevationRangeSource.getTilingScheme() === tilingScheme;\n        const obbIntersections =\n            this.mapView.projection.type === ProjectionType.Spherical || useElevationRangeSource;\n        const uniqueZoomLevels = new Set(zoomLevels);\n\n        // Gather the minimum and maximum geometry heights of all datasources to enlarge the\n        // bounding boxes of tiles for visibility tests.\n        let minGeometryHeight = 0;\n        let maxGeometryHeight = 0;\n        dataSources.forEach(dataSource => {\n            minGeometryHeight = Math.min(minGeometryHeight, dataSource.minGeometryHeight);\n            maxGeometryHeight = Math.max(maxGeometryHeight, dataSource.maxGeometryHeight);\n        });\n\n        const cache = {\n            calculationFinal: true,\n            tileBounds: obbIntersections ? new OrientedBox3() : new THREE.Box3()\n        };\n\n        // create tile key map per zoom level\n        for (const zoomLevel of uniqueZoomLevels) {\n            this.m_tileKeyEntries.set(zoomLevel, new Map());\n        }\n        for (const tileEntry of this.m_rootTileKeys) {\n            const tileKey = tileEntry.tileKey;\n            const offset = tileEntry.offset;\n\n            // We even check the root tiles against the frustum b/c it can happen that\n            // computeRequiredInitialRootTileKeys is producing false positives.\n            const tileKeyEntry = this.getTileKeyEntry(\n                tileKey,\n                offset,\n                tilingScheme,\n                cache,\n                minGeometryHeight,\n                maxGeometryHeight,\n                useElevationRangeSource ? elevationRangeSource : undefined\n            );\n\n            if (tileKeyEntry !== undefined) {\n                for (const zoomLevel of uniqueZoomLevels) {\n                    const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel)!;\n                    tileKeyEntries.set(\n                        TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset),\n                        tileKeyEntry\n                    );\n                }\n            }\n        }\n\n        const workList = [...this.m_rootTileKeys.values()];\n        while (workList.length > 0) {\n            const tileEntry = workList.pop();\n\n            if (tileEntry === undefined) {\n                break;\n            }\n\n            // Stop subdivision if hightest visible level is reached\n            const tileKey = tileEntry.tileKey;\n            const offset = tileEntry.offset;\n            const subdivide = dataSources.some((ds, i) =>\n                ds.shouldSubdivide(zoomLevels[i], tileKey)\n            );\n            if (!subdivide) {\n                continue;\n            }\n\n            // Stop subdivision if area of tile is too small(mixed LOD only)\n            if (this.m_enableMixedLod && tileEntry.area < targetTileArea) {\n                continue;\n            }\n\n            const tileKeyAndOffset = TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset);\n\n            // delete parent tile key from applicable zoom levels\n            for (const zoomLevel of uniqueZoomLevels) {\n                if (tileKey.level >= zoomLevel) {\n                    continue;\n                }\n\n                const tileKeyEntries = this.m_tileKeyEntries.get(zoomLevel)!;\n                tileKeyEntries.delete(tileKeyAndOffset);\n            }\n\n            for (const subTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n                const subTileEntry = this.getTileKeyEntry(\n                    subTileKey,\n                    offset,\n                    tilingScheme,\n                    cache,\n                    minGeometryHeight,\n                    maxGeometryHeight,\n                    useElevationRangeSource ? elevationRangeSource : undefined\n                );\n\n                if (subTileEntry !== undefined) {\n                    // insert sub tile entry into tile entries map per zoom level\n                    for (const zoomLevel of uniqueZoomLevels) {\n                        if (subTileEntry.tileKey.level > zoomLevel) {\n                            continue;\n                        }\n\n                        const subTileKeyAndOffset = TileKeyUtils.getKeyForTileKeyAndOffset(\n                            subTileKey,\n                            offset\n                        );\n                        this.m_tileKeyEntries\n                            .get(zoomLevel)!\n                            .set(subTileKeyAndOffset, subTileEntry);\n                    }\n\n                    workList.push(subTileEntry);\n                }\n            }\n        }\n        return { tileKeyEntries: this.m_tileKeyEntries, calculationFinal: cache.calculationFinal };\n    }\n\n    private getTileKeyEntry(\n        tileKey: TileKey,\n        offset: number,\n        tilingScheme: TilingScheme,\n        cache: { calculationFinal: boolean; tileBounds: OrientedBox3 | THREE.Box3 },\n        minGeometryHeight: number,\n        maxGeometryHeight: number,\n        elevationRangeSource?: ElevationRangeSource\n    ): TileKeyEntry | undefined {\n        const geoBox = getGeoBox(tilingScheme, tileKey, offset);\n\n        // For tiles without elevation range source, default 0 (getGeoBox always\n        // returns box with altitude min/max equal to zero) will be propagated as\n        // min and max elevation, these tiles most probably contains features that\n        // lays directly on the ground surface.\n        if (elevationRangeSource !== undefined) {\n            const range = elevationRangeSource!.getElevationRange(tileKey);\n            geoBox.southWest.altitude = range.minElevation;\n            geoBox.northEast.altitude = range.maxElevation;\n            cache.calculationFinal =\n                cache.calculationFinal &&\n                range.calculationStatus === CalculationStatus.FinalPrecise;\n        }\n\n        // Enlarge the bounding boxes of tiles with min/max geometry height for visibility tests.\n        geoBox.southWest.altitude = (geoBox.southWest.altitude ?? 0) + minGeometryHeight;\n        geoBox.northEast.altitude = (geoBox.northEast.altitude ?? 0) + maxGeometryHeight;\n\n        this.mapView.projection.projectBox(geoBox, cache.tileBounds);\n        const { area, distance } = this.computeTileAreaAndDistance(cache.tileBounds);\n\n        if (area > 0) {\n            return new TileKeyEntry(\n                tileKey,\n                area,\n                offset,\n                {\n                    minElevation: geoBox.southWest.altitude,\n                    maxElevation: geoBox.northEast.altitude\n                },\n                distance\n            );\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Estimate screen space area of tile and distance to center of tile\n     * @param tileBounds - The bounding volume of a tile\n     * @return Area estimate and distance to tile center in clip space\n     */\n    private computeTileAreaAndDistance(\n        tileBounds: THREE.Box3 | OrientedBox3\n    ): { area: number; distance: number } {\n        if (tileBounds instanceof THREE.Box3) {\n            if (\n                (this.m_extendedFrustumCulling &&\n                    !this.m_mapTileCuller.frustumIntersectsTileBox(tileBounds)) ||\n                !this.m_frustum.intersectsBox(tileBounds)\n            ) {\n                return {\n                    area: 0,\n                    distance: Infinity\n                };\n            }\n        } else if (!tileBounds.intersects(this.m_frustum)) {\n            return {\n                area: 0,\n                distance: Infinity\n            };\n        }\n\n        // Project tile bounds center\n        const center = tileBounds.getCenter(tmpVectors3[0]);\n        const projectedPoint = tmpVector4\n            .set(center.x, center.y, center.z, 1.0)\n            .applyMatrix4(this.m_viewProjectionMatrix);\n\n        // Estimate objects screen space size with diagonal of bounds\n        // Dividing by w projects object size to screen space\n        const size = tileBounds.getSize(tmpVectors3[1]);\n        const objectSize = (0.5 * size.length()) / projectedPoint.w;\n\n        return {\n            area: objectSize * objectSize,\n            //Dividing by w means we loose information for whether the point is behind the camera\n            //(i.e. it is in front of the near plane) or beyond the far plane, hence we first clamp\n            //to [-1, 1] range, before doing the division.\n            distance:\n                projectedPoint.z <= -projectedPoint.w\n                    ? -1\n                    : projectedPoint.z >= projectedPoint.w\n                    ? 1\n                    : projectedPoint.z / projectedPoint.w\n        };\n    }\n\n    /**\n     * Create a list of root nodes to test against the frustum. The root nodes each start at level 0\n     * and have an offset (see {@link Tile}) based on:\n     * - the current position [[worldCenter]].\n     * - the height of the camera above the world.\n     * - the field of view of the camera (the maximum value between the horizontal / vertical\n     *   values)\n     * - the tilt of the camera (because we see more tiles when tilted).\n     *\n     * @param worldCenter - The center of the camera in world space.\n     */\n    private computeRequiredInitialRootTileKeys(worldCenter: THREE.Vector3) {\n        this.m_rootTileKeys = [];\n        const rootTileKey = TileKey.fromRowColumnLevel(0, 0, 0);\n        const tileWrappingEnabled = this.mapView.projection.type === ProjectionType.Planar;\n\n        if (!tileWrappingEnabled || !this.m_tileWrappingEnabled) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, 0));\n            return;\n        }\n\n        const worldGeoPoint = this.mapView.projection.unprojectPoint(worldCenter);\n        const startOffset = Math.round(worldGeoPoint.longitude / 360.0);\n\n        // This algorithm computes the number of offsets we need to test. The following diagram may\n        // help explain the algorithm below.\n        //\n        //   |\n        //   |.\\ .\n        //   | . \\  .\n        // z |  .  \\   .c2\n        //   |  c1.  \\b    .\n        //   |     .   \\      .\n        //___|a___d1.____\\e______.d2______f\n        //\n        // Where:\n        // -  is the camera\n        // - z is the height of the camera above the ground.\n        // - a is a right angle.\n        // - b is the look at vector of the camera.\n        // - c1 and c2 are the frustum planes of the camera.\n        // - c1 to c2 is the fov.\n        // - d1 and d2 are the intersection points of the frustum with the world plane.\n        // - e is the tilt/pitch of the camera.\n        // - f is the world\n        //\n        // The goal is to find the distance from e->d2. This is a longitude value, and we convert it\n        // to some offset range. Note e->d2 >= e->d1 (because we can't have a negative tilt).\n        // To find e->d2, we use the right triangle , a, d2 and subtract the distance a->d2 with\n        // a->e.\n        // a->d2 is found using the angle between a and d2 from the , this is simply e (because of\n        // similar triangles, angle between a,  and e equals the tilt) + half of the fov (because\n        // we need the angle between e,  and d2) and using trigonometry, result is therefore:\n        // (tan(a->d2) * z).\n        // a->e needs just the tilt and trigonometry to compute, result is: (tan(a->e) * z).\n\n        const camera = this.m_camera;\n        const cameraPitch = MapViewUtils.extractAttitude(this.mapView, camera).pitch;\n        // Ensure that the aspect is >= 1.\n        const aspect = camera.aspect > 1 ? camera.aspect : 1 / camera.aspect;\n        // Angle between a->d2, note, the fov is vertical, hence we translate to horizontal.\n        const totalAngleRad = THREE.MathUtils.degToRad((camera.fov * aspect) / 2) + cameraPitch;\n        // Length a->d2\n        const worldLengthHorizontalFull = Math.tan(totalAngleRad) * camera.position.z;\n        // Length a->e\n        const worldLengthHorizontalSmallerHalf = Math.tan(cameraPitch) * camera.position.z;\n        // Length e -> d2\n        const worldLengthHorizontal = worldLengthHorizontalFull - worldLengthHorizontalSmallerHalf;\n        const worldLeftPoint = new THREE.Vector3(\n            worldCenter.x - worldLengthHorizontal,\n            worldCenter.y,\n            worldCenter.z\n        );\n        const worldLeftGeoPoint = this.mapView.projection.unprojectPoint(worldLeftPoint);\n        // We multiply by SQRT2 because we need to account for a rotated view (in which case there\n        // are more tiles that can be seen).\n        const offsetRange = THREE.MathUtils.clamp(\n            Math.ceil(\n                Math.abs((worldGeoPoint.longitude - worldLeftGeoPoint.longitude) / 360) * Math.SQRT2\n            ),\n            0,\n            // We can store currently up to 16 unique keys(2^4, where 4 is the default bit-shift\n            // value which is used currently in the VisibleTileSet methods) hence we can have a\n            // maximum range of 7 (because 2*7+1 = 15).\n            7\n        );\n        for (\n            let offset = -offsetRange + startOffset;\n            offset <= offsetRange + startOffset;\n            offset++\n        ) {\n            this.m_rootTileKeys.push(new TileKeyEntry(rootTileKey, Infinity, offset));\n        }\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DecodedTile } from \"@here/harp-datasource-protocol\";\n\n/**\n * The state the {@link ITileLoader}.\n */\nexport enum TileLoaderState {\n    Initialized,\n    Loading,\n    Loaded,\n    Decoding,\n    Ready,\n    Canceled,\n    Failed\n}\n\n/**\n * The interface for managing tile loading.\n */\nexport interface ITileLoader {\n    /**\n     * Current state of `TileLoader`.\n     */\n    state: TileLoaderState;\n\n    /**\n     * The result of decoding the `payload`: The [[DecodedTile]].\n     */\n    decodedTile?: DecodedTile;\n\n    /**\n     * `true` if [[Tile]] is still loading, `false` otherwise.\n     */\n    readonly isFinished: boolean;\n\n    /**\n     * Priority given to the tile loading task. The greater the number, the higher the priority.\n     */\n    priority: number;\n\n    /**\n     * Start loading and/or proceed through the various states of loading of this tile.\n     *\n     * @param client - Optional client requesting the load.\n     * @returns A promise which resolves the [[TileLoaderState]].\n     */\n    loadAndDecode(client?: any): Promise<TileLoaderState>;\n\n    /**\n     * Return the current state in form of a promise. Caller can then wait for the promise to be\n     * resolved.\n     *\n     * @returns A promise which resolves the current [[TileLoaderState]].\n     */\n    waitSettled(): Promise<TileLoaderState>;\n\n    /**\n     * Cancel loading of the [[Tile]].\n     * Cancellation token is notified, an internal state is cleaned up.\n     * @param client - Optional client requesting the cancelation. It's expected to match one of\n     * the clients that previously called {@link ITileLoader.loadAndDecode}.\n     */\n    cancel(client?: any): void;\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { StylePriority } from \"@here/harp-datasource-protocol\";\nimport {\n    GeoCoordinates,\n    isGeoCoordinatesLike,\n    isVector3Like,\n    Projection,\n    Vector3Like\n} from \"@here/harp-geoutils\";\nimport { GeoCoordLike } from \"@here/harp-geoutils/lib/coordinates/GeoCoordLike\";\nimport * as THREE from \"three\";\n\n/**\n * An interface describing [[THREE.Object3D]]s anchored on\n * given {@link @here/harp-geoutils#GeoCoordinates}.\n *\n * @remarkks\n * @example\n * Example:\n * ```typescript\n * const mesh: MapAnchor<THREE.Mesh> = new THREE.Mesh(geometry, material);\n * mesh.anchor = new GeoCoordinates(latitude, longitude, altitude);\n * mapView.mapAnchors.add(mesh);\n * ```\n */\nexport type MapAnchor<T extends THREE.Object3D = THREE.Object3D> = T & {\n    /**\n     * The position of this [[MapAnchor]] in {@link @here/harp-geoutils#GeoCoordinates}.\n     * @deprecated Use [[anchor]] instead.\n     */\n    geoPosition?: GeoCoordinates;\n\n    /**\n     * The anchor of this Object3D in {@link @here/harp-geoutils#GeoCoordinates}\n     * or world coordinates.\n     */\n    anchor?: GeoCoordLike | Vector3Like;\n\n    /**\n     * Flag defining if the object may be picked.\n     *\n     * @note By default all objects are pickable even if this flag is undefined.\n     */\n    pickable?: boolean;\n\n    /**\n     * The styleSet that owns this map object.\n     *\n     * @remarks\n     * This property is used together with [[Theme.priorities]] to compute the render\n     * order of this map object.\n     */\n    styleSet?: string;\n\n    /**\n     * The category of this style.\n     *\n     * @remarks\n     * This property is used together with [[Theme.priorities]] to compute the render\n     * order of this map object.\n     */\n    category?: string;\n\n    /**\n     * Whether to draw the anchor on top of labels.\n     * @defaultValue false\n     */\n    overlay?: boolean;\n};\n\n/**\n * Container holding [[MapAnchor]] objects.\n */\nexport class MapAnchors {\n    private m_anchors: MapAnchor[] = [];\n    private m_priorities: StylePriority[] = [];\n\n    /**\n     * All currently added [[MapAnchor]]s.\n     */\n    get children() {\n        return this.m_anchors;\n    }\n\n    /**\n     * Add a [[MapAnchor]].\n     * @param mapAnchor [[MapAnchor]] instance to add.\n     */\n    add(mapAnchor: MapAnchor) {\n        this.m_anchors.push(mapAnchor);\n    }\n\n    /**\n     * Remove a [[MapAnchor]].\n     * @param mapAnchor - [[MapAnchor]] instance to remove.\n     *\n     * @note This method is potentially slow when removing a lot of anchors.\n     * [[clear]]ing and [[add]]ing anchors should be considered in that case.\n     */\n    remove(mapAnchor: MapAnchor) {\n        const index = this.m_anchors.findIndex(element => element === mapAnchor);\n        if (index > -1) {\n            this.m_anchors.splice(index, 1);\n        }\n    }\n\n    /**\n     * Remove all [[MapAnchor]]s.\n     */\n    clear() {\n        this.m_anchors.length = 0;\n    }\n\n    setPriorities(priorities: StylePriority[]) {\n        this.m_priorities = priorities;\n    }\n\n    /**\n     * Update the map anchors.\n     * @param projection - Current projection\n     * @param cameraPosition - Current camera position\n     * @param rootNode - Node where normal anchors will be inserted.\n     * @param overlayRootNode - Node where overlay anchors will be insterted.\n     * @param priorities - Optional theme priority list\n     *\n     * @internal\n     * @hidden\n     */\n    update(\n        projection: Projection,\n        cameraPosition: THREE.Vector3,\n        rootNode: THREE.Object3D,\n        overlayRootNode: THREE.Object3D\n    ) {\n        const worldPosition = new THREE.Vector3();\n\n        this.m_anchors.forEach((mapAnchor: MapAnchor) => {\n            if (mapAnchor.styleSet !== undefined) {\n                const priority = this.m_priorities?.findIndex(\n                    entry =>\n                        entry.group === mapAnchor.styleSet && entry.category === mapAnchor.category\n                );\n\n                if (priority !== undefined && priority !== -1) {\n                    mapAnchor.renderOrder = (priority + 1) * 10;\n                }\n            }\n\n            const anchor =\n                mapAnchor.geoPosition !== undefined ? mapAnchor.geoPosition : mapAnchor.anchor;\n            if (anchor !== undefined) {\n                if (isVector3Like(anchor)) {\n                    worldPosition.set(anchor.x, anchor.y, anchor.z);\n                } else if (isGeoCoordinatesLike(anchor)) {\n                    projection.projectPoint(anchor, worldPosition);\n                }\n                mapAnchor.position.copy(worldPosition).sub(cameraPosition);\n            }\n\n            if (mapAnchor.overlay === true) {\n                overlayRootNode.add(mapAnchor);\n            } else {\n                rootNode.add(mapAnchor);\n            }\n        });\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    ColorUtils,\n    Expr,\n    getPropertyValue,\n    TEXTURE_PROPERTY_KEYS,\n    Value\n} from \"@here/harp-datasource-protocol\";\nimport { disableBlending, enableBlending, RawShaderMaterial } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { evaluateColorProperty } from \"./DecodedTileHelpers\";\nimport { MapView } from \"./MapView\";\n\n/**\n * @hidden\n *\n * Pick of {@link MapView} properties required to update materials used [[MapMaterialAdapter]].\n */\nexport type MapAdapterUpdateEnv = Pick<MapView, \"env\" | \"frameNumber\">;\n\n/**\n * @hidden\n *\n * Custom, callback based property evaluator used by [[MapObjectAdapter]] to evaluate dynamic\n * properties of object/material.\n */\nexport type StylePropertyEvaluator = (context: MapAdapterUpdateEnv) => Value;\n\n/**\n * @hidden\n *\n * Styled properties of material managed by [[MapMaterialAdapter]].\n */\nexport interface StyledProperties {\n    [name: string]: Expr | StylePropertyEvaluator | Value | undefined;\n}\n\nfunction isTextureProperty(propertyName: string): boolean {\n    return TEXTURE_PROPERTY_KEYS.includes(propertyName);\n}\n\n/**\n * @hidden\n *\n * {@link MapView} specific data assigned to `THREE.Material` instance in installed in `userData`.\n *\n * [[MapMaterialAdapter]] is registered in `usedData.mapAdapter` property of `THREE.Material`.\n */\nexport class MapMaterialAdapter {\n    /**\n     * Resolve `MapMaterialAdapter` associated with `material`.\n     */\n    static get(material: THREE.Material): MapMaterialAdapter | undefined {\n        const mapAdapter = material.userData?.mapAdapter;\n        if (mapAdapter instanceof MapMaterialAdapter) {\n            return mapAdapter;\n        } else if (mapAdapter !== undefined) {\n            // NOTE: we can rebuild MapMaterialAdapter here if userData.mapAdapter contains\n            // stylesed etc, this can be done to rebuild previously saved scene\n            return undefined;\n        } else {\n            return undefined;\n        }\n    }\n\n    static install(objData: MapMaterialAdapter): MapMaterialAdapter {\n        if (!objData.material.userData) {\n            objData.material.userData = {};\n        }\n        return (objData.material.userData.mapAdapter = objData);\n    }\n\n    static create(\n        material: THREE.Material,\n        styledProperties: StyledProperties\n    ): MapMaterialAdapter {\n        return MapMaterialAdapter.install(new MapMaterialAdapter(material, styledProperties));\n    }\n\n    static ensureUpdated(material: THREE.Material, context: MapAdapterUpdateEnv): boolean {\n        return MapMaterialAdapter.get(material)?.ensureUpdated(context) ?? false;\n    }\n\n    /**\n     * Associated material object.\n     */\n    readonly material: THREE.Material;\n\n    /**\n     * Styled material properties.\n     *\n     * Usually pick from [[Technique]] attributes that constitute material properties managed\n     * by this adapter.\n     */\n    readonly styledProperties: StyledProperties;\n\n    /**\n     * Current values of styled material properties.\n     *\n     * Actual values valid for scope of one frame updated in [[ensureUpdated]].\n     */\n    readonly currentStyledProperties: { [name: string]: Value | undefined };\n\n    private m_lastUpdateFrameNumber = -1;\n    private readonly m_dynamicProperties: Array<[string, Expr | StylePropertyEvaluator]>;\n    private readonly tmpColor = new THREE.Color();\n\n    constructor(material: THREE.Material, styledProperties: StyledProperties) {\n        this.material = material;\n        this.styledProperties = styledProperties;\n\n        this.currentStyledProperties = {};\n        this.m_dynamicProperties = [];\n        for (const propName in styledProperties) {\n            if (!styledProperties.hasOwnProperty(propName)) {\n                continue;\n            }\n            const propDefinition = styledProperties![propName];\n            if (Expr.isExpr(propDefinition) || typeof propDefinition === \"function\") {\n                this.m_dynamicProperties.push([propName, propDefinition as any]);\n            } else {\n                this.currentStyledProperties[propName] = propDefinition;\n            }\n        }\n        this.setupStaticProperties();\n    }\n\n    /**\n     * Serialize contents.\n     *\n     * `THREE.Material.userData` is serialized during `clone`/`toJSON`, so we need to ensure that\n     * we emit only \"data\" set of this object.\n     */\n    toJSON() {\n        return { styledProperties: this.styledProperties };\n    }\n\n    /**\n     * Ensure that underlying object is updated to current state of {@link MapView}.\n     *\n     * Updates dynamically styled properties of material by evaluating scene dependent expressions.\n     *\n     * Executes updates only once per frame basing on [[MapView.frameNumber]].\n     *\n     * @returns `true` if object performed some kind of update, `false` if no update was needed.\n     */\n    ensureUpdated(context: MapAdapterUpdateEnv) {\n        if (this.m_lastUpdateFrameNumber === context.frameNumber) {\n            return false;\n        }\n        this.m_lastUpdateFrameNumber = context.frameNumber;\n\n        return this.updateDynamicProperties(context);\n    }\n\n    /**\n     * Applies static properties to target material.\n     */\n    private setupStaticProperties() {\n        let updateBaseColor = false;\n        for (const propName in this.styledProperties) {\n            if (!this.styledProperties.hasOwnProperty(propName)) {\n                continue;\n            }\n            const currentValue = this.currentStyledProperties[propName];\n            if (currentValue === undefined || currentValue === null) {\n                continue;\n            }\n            if (propName === \"color\" || propName === \"opacity\") {\n                updateBaseColor = true;\n            } else if (!isTextureProperty(propName)) {\n                // Static textures are already set in the material during tile construction.\n                this.applyMaterialGenericProp(propName, currentValue);\n            }\n        }\n        if (updateBaseColor) {\n            const color = (this.currentStyledProperties.color as number) ?? 0xff0000;\n            const opacity = (this.currentStyledProperties.opacity as number) ?? 1;\n            this.applyMaterialBaseColor(color, opacity);\n        }\n    }\n\n    /**\n     * Applies static properties to target material.\n     */\n    private updateDynamicProperties(context: MapAdapterUpdateEnv) {\n        let somethingChanged = false;\n        if (this.m_dynamicProperties.length > 0) {\n            let updateBaseColor = false;\n\n            for (const [propName, propDefinition] of this.m_dynamicProperties) {\n                const newValue = Expr.isExpr(propDefinition)\n                    ? getPropertyValue(propDefinition, context.env)\n                    : propDefinition(context);\n                if (newValue === this.currentStyledProperties[propName]) {\n                    continue;\n                }\n                this.currentStyledProperties[propName] = newValue;\n\n                // `color` and `opacity` are special properties to support RGBA\n                if (propName === \"color\" || propName === \"opacity\") {\n                    updateBaseColor = true;\n                } else if (isTextureProperty(propName)) {\n                    this.applyMaterialTextureProp(propName, newValue);\n                    somethingChanged = true;\n                } else {\n                    this.applyMaterialGenericProp(propName, newValue);\n                    somethingChanged = true;\n                }\n            }\n\n            if (updateBaseColor) {\n                const color = this.currentStyledProperties.color ?? 0xff0000;\n                const opacity = (this.currentStyledProperties.opacity as number) ?? 1;\n                this.applyMaterialBaseColor(color, opacity);\n                somethingChanged = true;\n            }\n        }\n        return somethingChanged;\n    }\n\n    private applyMaterialTextureProp(propName: string, value: Value) {\n        const m = this.material as any;\n        // Wait until the texture is loaded for the first time on tile creation, that way,\n        // the old texture properties can be copied to the new texture.\n        if (!m[propName] || value === null) {\n            return;\n        }\n        const oldTexture = m[propName];\n        let newTexture: THREE.Texture | undefined;\n\n        if (typeof value === \"string\") {\n            newTexture = new THREE.TextureLoader().load(value, (texture: THREE.Texture) => {\n                m[propName] = texture;\n            });\n        } else if (typeof value === \"object\") {\n            const element = value as any;\n            const isImage = element.nodeName === \"IMG\";\n            const isCanvas = element.nodeName === \"CANVAS\";\n            if (isImage || isCanvas) {\n                newTexture = new THREE.CanvasTexture(element);\n\n                if (isImage && !element.complete) {\n                    const onLoad = () => {\n                        m[propName] = newTexture;\n                        element.removeEventListener(\"load\", onLoad);\n                    };\n                    element.addEventListener(\"load\", onLoad);\n                } else {\n                    m[propName] = newTexture;\n                }\n            }\n        }\n\n        if (newTexture) {\n            newTexture.wrapS = oldTexture.wrapS;\n            newTexture.wrapT = oldTexture.wrapT;\n            newTexture.magFilter = oldTexture.magFilter;\n            newTexture.minFilter = oldTexture.minFilter;\n            newTexture.flipY = oldTexture.flipY;\n            newTexture.repeat = oldTexture.repeat;\n        }\n    }\n\n    private applyMaterialGenericProp(propName: string, value: Value) {\n        const m = this.material as any;\n        if (m[propName] instanceof THREE.Color) {\n            let colorValue = value;\n            if (typeof colorValue !== \"number\") {\n                const parsed = evaluateColorProperty(colorValue);\n                if (parsed === undefined) {\n                    return;\n                }\n                colorValue = parsed;\n            }\n            const rgbValue = ColorUtils.removeAlphaFromHex(colorValue);\n            this.tmpColor.set(rgbValue);\n            // We set the value, i.e. using =, as opposed to setting the color directly using set\n            // because the material may be a custom material with a setter.\n            value = this.tmpColor;\n        }\n\n        m[propName] = value;\n    }\n\n    private applyMaterialBaseColor(color: Value, opacity: number | undefined) {\n        if (typeof color !== \"number\") {\n            const parsed = evaluateColorProperty(color);\n            if (parsed === undefined) {\n                return;\n            }\n            color = parsed;\n        }\n        const { r, g, b, a } = ColorUtils.getRgbaFromHex(color ?? 0xff0000);\n\n        const actualOpacity = a * THREE.MathUtils.clamp(opacity ?? 1, 0, 1);\n        if (this.material instanceof RawShaderMaterial) {\n            this.material.setOpacity(actualOpacity);\n        } else {\n            this.material.opacity = actualOpacity;\n        }\n\n        (this.material as any).color.setRGB(r, g, b);\n\n        const opaque = actualOpacity >= 1.0;\n        if (!opaque) {\n            enableBlending(this.material);\n        } else {\n            disableBlending(this.material);\n        }\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GeometryKind, Pickability, Technique } from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\n\nimport { DataSource } from \"./DataSource\";\nimport { MapAdapterUpdateEnv, MapMaterialAdapter } from \"./MapMaterialAdapter\";\n\n/**\n * @hidden\n *\n * Construction params of `MapObjectAdapter`.\n */\nexport interface MapObjectAdapterParams {\n    dataSource?: DataSource;\n    technique?: Technique;\n    kind?: GeometryKind[];\n    level?: number;\n    pickability?: Pickability;\n\n    // TODO: Move here in following refactor.\n    //featureData?: TileFeatureData;\n}\n\n/**\n * @hidden\n *\n * {@link MapView} specific data assigned to `THREE.Object3D` instance in installed in `userData`.\n *\n * `MapObjectAdapter` is registered in `usedData.mapAdapter` property of `THREE.Object3D`.\n */\nexport class MapObjectAdapter {\n    /**\n     * Resolve `MapObjectAdapter` associated with `object`.\n     */\n    static get(object: THREE.Object3D): MapObjectAdapter | undefined {\n        return object.userData?.mapAdapter instanceof MapObjectAdapter\n            ? object.userData.mapAdapter\n            : undefined;\n    }\n\n    static install(objData: MapObjectAdapter): MapObjectAdapter {\n        if (!objData.object.userData) {\n            objData.object.userData = {};\n        }\n        return (objData.object.userData.mapAdapter = objData);\n    }\n\n    static create(object: THREE.Object3D, params: MapObjectAdapterParams): MapObjectAdapter {\n        return MapObjectAdapter.install(new MapObjectAdapter(object, params));\n    }\n\n    static ensureUpdated(object: THREE.Object3D, context: MapAdapterUpdateEnv): boolean {\n        return MapObjectAdapter.get(object)?.ensureUpdated(context) ?? false;\n    }\n\n    /**\n     * Associated scene object.\n     */\n    readonly object: THREE.Object3D;\n\n    /**\n     * [[Technique]] that constituted this object.\n     */\n    readonly technique?: Technique;\n\n    /**\n     * [[GeometryKind]] of `object`.\n     */\n    readonly kind: GeometryKind[] | undefined;\n\n    readonly dataSource?: DataSource;\n\n    /**\n     * Which level this object exists on, must match the TileKey's level.\n     */\n    readonly level: number | undefined;\n\n    private readonly m_pickability: Pickability;\n    private m_lastUpdateFrameNumber = -1;\n    private m_notCompletlyTransparent = true;\n\n    constructor(object: THREE.Object3D, params: MapObjectAdapterParams) {\n        this.object = object;\n        this.technique = params.technique;\n        this.kind = params.kind;\n        this.dataSource = params.dataSource;\n        this.m_pickability = params.pickability ?? Pickability.onlyVisible;\n        this.m_notCompletlyTransparent = this.getObjectMaterials().some(\n            material => material.opacity > 0\n        );\n        this.level = params.level;\n    }\n\n    /**\n     * Serialize contents.\n     *\n     * `THREE.Object3d.userData` is serialized during `clone`/`toJSON`, so we need to ensure that\n     * we emit only \"data\" set of this object.\n     */\n    toJSON() {\n        return { kind: this.kind, technique: this.technique };\n    }\n\n    /**\n     * Ensure that underlying object is updated to current state of {@link MapView}.\n     *\n     * Updates object and attachments like materials to current state by evaluating scene dependent\n     * expressions.\n     *\n     * Executes updates only once per frame basing on [[MapView.frameNumber]].\n     *\n     * Delegates updates of materials to [[MapMaterialAdapter.ensureUpdated]].\n     *\n     * @returns `true` if object performed some kind of update, `false` if no update was needed.\n     */\n    ensureUpdated(context: MapAdapterUpdateEnv): boolean {\n        if (this.m_lastUpdateFrameNumber === context.frameNumber) {\n            return false;\n        }\n        this.m_lastUpdateFrameNumber = context.frameNumber;\n\n        return this.updateMaterials(context);\n    }\n\n    /**\n     * Whether underlying `THREE.Object3D` is actually visible in scene.\n     */\n    isVisible() {\n        return this.object.visible && this.m_notCompletlyTransparent;\n    }\n\n    /**\n     * Whether underlying `THREE.Object3D` should be pickable by {@link PickHandler}.\n     */\n    isPickable() {\n        // An object is pickable only if it's visible and Pickabilty.onlyVisible or\n        //  Pickabililty.all set.\n        return (\n            (this.pickability === Pickability.onlyVisible && this.isVisible()) ||\n            this.m_pickability === Pickability.all\n        );\n    }\n\n    get pickability(): Pickability {\n        return this.m_pickability;\n    }\n\n    private updateMaterials(context: MapAdapterUpdateEnv) {\n        let somethingChanged: boolean = false;\n        const materials = this.getObjectMaterials();\n        for (const material of materials) {\n            const changed = MapMaterialAdapter.ensureUpdated(material, context);\n            somethingChanged = somethingChanged || changed;\n        }\n        if (somethingChanged) {\n            this.m_notCompletlyTransparent = materials.some(material => material.opacity > 0);\n        }\n        return somethingChanged;\n    }\n\n    private getObjectMaterials(): THREE.Material[] {\n        const object = this.object as THREE.Mesh;\n        return Array.isArray(object.material)\n            ? object.material\n            : object.material !== undefined\n            ? [object.material]\n            : [];\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Second step tile culling: Do additional check for intersection of box and frustum by checking if\n * the frustum is outside any plane of the tiles `bbox` (oriented, not AABB). It's in the inverse of\n * the standard frustum test, which excludes many cases where the large terrain tiles straddle the\n * planes of the frustum.\n *\n * @see http://www.iquilezles.org/www/articles/frustumcorrect/frustumcorrect.htm\n */\nexport class MapTileCuller {\n    private m_globalFrustumMin = new THREE.Vector3();\n    private m_globalFrustumMax = new THREE.Vector3();\n\n    private readonly m_frustumCorners = [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ];\n\n    /**\n     * Constructs a `MapTileCuller`.\n     *\n     * @param m_camera - A `THREE.Camera`.\n     */\n    constructor(private readonly m_camera: THREE.Camera) {}\n\n    /**\n     * Sets up culling and computes frustum corners. You mus call this function before the culling\n     * starts.\n     */\n    setup() {\n        const frustumCorners = this.getFrustumCorners();\n\n        const matrix = this.m_camera.matrixWorld;\n\n        this.m_globalFrustumMin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        this.m_globalFrustumMax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n        for (const frustumCorner of frustumCorners) {\n            frustumCorner.applyMatrix4(matrix);\n\n            this.m_globalFrustumMin.x = Math.min(this.m_globalFrustumMin.x, frustumCorner.x);\n            this.m_globalFrustumMin.y = Math.min(this.m_globalFrustumMin.y, frustumCorner.y);\n            this.m_globalFrustumMin.z = Math.min(this.m_globalFrustumMin.z, frustumCorner.z);\n\n            this.m_globalFrustumMax.x = Math.max(this.m_globalFrustumMax.x, frustumCorner.x);\n            this.m_globalFrustumMax.y = Math.max(this.m_globalFrustumMax.y, frustumCorner.y);\n            this.m_globalFrustumMax.z = Math.max(this.m_globalFrustumMax.z, frustumCorner.z);\n        }\n    }\n\n    /**\n     * Checks if the tile's bounding box intersects with the current view's frustum.\n     *\n     * @param tileBounds - The bounding box for the tile.\n     */\n    frustumIntersectsTileBox(tileBounds: THREE.Box3): boolean {\n        const globalFrustumMin = this.m_globalFrustumMin;\n        const globalFrustumMax = this.m_globalFrustumMax;\n\n        if (\n            globalFrustumMax.x < tileBounds.min.x ||\n            globalFrustumMax.y < tileBounds.min.y ||\n            globalFrustumMax.z < tileBounds.min.z ||\n            globalFrustumMin.x > tileBounds.max.x ||\n            globalFrustumMin.y > tileBounds.max.y ||\n            globalFrustumMin.z > tileBounds.max.z\n        ) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the eight corners of the frustum.\n     */\n    private getFrustumCorners(): THREE.Vector3[] {\n        const frustumCorners = this.m_frustumCorners;\n        const invProjMatrix = (this.m_camera as any).projectionMatrixInverse as THREE.Matrix4;\n\n        let cornerIndex = 0;\n\n        function addPoint(x: number, y: number, z: number) {\n            frustumCorners[cornerIndex++].set(x, y, z).applyMatrix4(invProjMatrix);\n        }\n\n        const w = 1;\n        const h = 1;\n        const n = -1;\n        const f = 1;\n\n        // near\n        addPoint(-w, -h, n);\n        addPoint(w, -h, n);\n        addPoint(-w, h, n);\n        addPoint(w, h, n);\n\n        // far\n        addPoint(-w, -h, f);\n        addPoint(w, -h, f);\n        addPoint(-w, h, f);\n        addPoint(w, h, f);\n\n        return frustumCorners;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    Env,\n    FlatTheme,\n    FontCatalogConfig,\n    MapEnv,\n    PostEffects,\n    TextStyleDefinition,\n    Theme,\n    Value\n} from \"@here/harp-datasource-protocol\";\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport {\n    EarthConstants,\n    GeoBox,\n    GeoBoxExtentLike,\n    GeoCoordinates,\n    GeoPolygon,\n    isGeoBoxExtentLike,\n    isGeoCoordinatesLike,\n    isVector3Like,\n    mercatorProjection,\n    OrientedBox3,\n    Projection,\n    ProjectionType,\n    TilingScheme,\n    Vector3Like\n} from \"@here/harp-geoutils\";\nimport { GeoCoordLike } from \"@here/harp-geoutils/lib/coordinates/GeoCoordLike\";\nimport {\n    assert,\n    getOptionValue,\n    LoggerManager,\n    LogLevel,\n    PerformanceTimer,\n    TaskQueue,\n    UriResolver\n} from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { AnimatedExtrusionHandler } from \"./AnimatedExtrusionHandler\";\nimport { BackgroundDataSource } from \"./BackgroundDataSource\";\nimport { CameraMovementDetector } from \"./CameraMovementDetector\";\nimport { CameraUtils } from \"./CameraUtils\";\nimport { ClipPlanesEvaluator, createDefaultClipPlanesEvaluator } from \"./ClipPlanesEvaluator\";\nimport { IMapAntialiasSettings, IMapRenderingManager, MapRenderingManager } from \"./composing\";\nimport { ConcurrentDecoderFacade } from \"./ConcurrentDecoderFacade\";\nimport { ConcurrentTilerFacade } from \"./ConcurrentTilerFacade\";\nimport { CopyrightInfo } from \"./copyrights/CopyrightInfo\";\nimport { DataSource } from \"./DataSource\";\nimport { ElevationProvider } from \"./ElevationProvider\";\nimport { ElevationRangeSource } from \"./ElevationRangeSource\";\nimport { EventDispatcher } from \"./EventDispatcher\";\nimport {\n    DEFAULT_FOV_CALCULATION,\n    FovCalculation,\n    MAX_FOV_DEG,\n    MIN_FOV_DEG\n} from \"./FovCalculation\";\nimport { FrustumIntersection } from \"./FrustumIntersection\";\nimport { overlayOnElevation } from \"./geometry/overlayOnElevation\";\nimport { TileGeometryManager } from \"./geometry/TileGeometryManager\";\nimport { MapViewImageCache } from \"./image/MapViewImageCache\";\nimport { IntersectParams } from \"./IntersectParams\";\nimport { MapAnchors } from \"./MapAnchors\";\nimport { MapViewEnvironment } from \"./MapViewEnvironment\";\nimport { MapViewFog } from \"./MapViewFog\";\nimport { MapViewTaskScheduler } from \"./MapViewTaskScheduler\";\nimport { MapViewThemeManager } from \"./MapViewThemeManager\";\nimport { PickHandler, PickResult } from \"./PickHandler\";\nimport { PoiManager } from \"./poi/PoiManager\";\nimport { PoiTableManager } from \"./poi/PoiTableManager\";\nimport { PolarTileDataSource } from \"./PolarTileDataSource\";\nimport { ScreenProjector } from \"./ScreenProjector\";\nimport { FrameStats, PerformanceStatistics } from \"./Statistics\";\nimport { MapViewState } from \"./text/MapViewState\";\nimport { TextElement } from \"./text/TextElement\";\nimport { TextElementsRenderer } from \"./text/TextElementsRenderer\";\nimport { TextElementsRendererOptions } from \"./text/TextElementsRendererOptions\";\nimport { Tile } from \"./Tile\";\nimport { TileObjectRenderer } from \"./TileObjectsRenderer\";\nimport { MapViewUtils } from \"./Utils\";\nimport { ResourceComputationType, VisibleTileSet, VisibleTileSetOptions } from \"./VisibleTileSet\";\n\ndeclare const process: any;\n\n// Cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = process.env.NODE_ENV === \"production\";\nif (isProduction) {\n    // In production: silence logging below error.\n    LoggerManager.instance.setLogLevelForAll(LogLevel.Error);\n} else {\n    // In dev: silence logging below log (silences \"debug\" and \"trace\" levels).\n    LoggerManager.instance.setLogLevelForAll(LogLevel.Log);\n}\nexport enum TileTaskGroups {\n    FETCH_AND_DECODE = \"fetch\",\n    //DECODE = \"decode\",\n    CREATE = \"create\"\n    //UPLOAD = \"upload\"\n}\n\nexport enum MapViewEventNames {\n    /** Called before this `MapView` starts to render a new frame. */\n    Update = \"update\",\n    /** Called when the WebGL canvas is resized. */\n    Resize = \"resize\",\n    /** Called when the frame is about to be rendered. */\n    Render = \"render\",\n    /** Called after a frame has been rendered. */\n    AfterRender = \"didrender\",\n    /** Called after the first frame has been rendered. */\n    FirstFrame = \"first-render\",\n    /**\n     * Called when the rendered frame was complete, i.e. all the necessary tiles and resources\n     * are loaded and rendered.\n     */\n    FrameComplete = \"frame-complete\",\n    /** Called when the theme has been loaded with the internal {@link ThemeLoader}. */\n    ThemeLoaded = \"theme-loaded\",\n    /** Called when the animation mode has started. */\n    AnimationStarted = \"animation-started\",\n    /** Called when the animation mode has stopped. */\n    AnimationFinished = \"animation-finished\",\n    /** Called when a camera interaction has been detected. */\n    MovementStarted = \"movement-started\",\n    /** Called when a camera interaction has been stopped. */\n    MovementFinished = \"movement-finished\",\n    /** Called when a data source has been connected or failed to connect. */\n    DataSourceConnect = \"datasource-connect\",\n    /** Emitted when copyright info of rendered map has been changed. */\n    CopyrightChanged = \"copyright-changed\",\n    /** Called when the WebGL context is lost. */\n    ContextLost = \"webglcontext-lost\",\n    /** Called when the WebGL context is restored. */\n    ContextRestored = \"webglcontext-restored\",\n    /** Called when camera position has been changed. */\n    CameraPositionChanged = \"camera-changed\",\n    /** Called when dispose has been called, before any cleanup is done. */\n    Dispose = \"dispose\"\n}\n\nconst logger = LoggerManager.instance.create(\"MapView\");\nconst DEFAULT_CAM_NEAR_PLANE = 0.1;\nconst DEFAULT_CAM_FAR_PLANE = 4000000;\nconst DEFAULT_MIN_ZOOM_LEVEL = 1;\n\n/**\n * Default maximum zoom level.\n */\nconst DEFAULT_MAX_ZOOM_LEVEL = 20;\n\n/**\n * Default minimum camera height.\n */\nconst DEFAULT_MIN_CAMERA_HEIGHT = 20;\n\n/**\n * Style set used by {@link PolarTileDataSource} by default.\n */\nconst DEFAULT_POLAR_STYLE_SET_NAME = \"polar\";\n\n/**\n * The type of `RenderEvent`.\n */\nexport interface RenderEvent extends THREE.Event {\n    type: MapViewEventNames;\n    time?: number;\n}\n\nconst cache = {\n    vector2: [new THREE.Vector2()],\n    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],\n    rayCaster: new THREE.Raycaster(),\n    groundPlane: new THREE.Plane(),\n    groundSphere: new THREE.Sphere(undefined, EarthConstants.EQUATORIAL_RADIUS),\n    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],\n    transform: [\n        {\n            position: new THREE.Vector3(),\n            xAxis: new THREE.Vector3(),\n            yAxis: new THREE.Vector3(),\n            zAxis: new THREE.Vector3()\n        }\n    ],\n    color: new THREE.Color()\n};\n\n/**\n * Hint for the WebGL implementation on which power mode to prefer.\n *\n * @see https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12\n */\nexport enum MapViewPowerPreference {\n    /** Default value. */\n    Default = \"default\",\n    /** Lower power mode, used to conserve energy. */\n    LowPower = \"low-power\",\n    /** Maximum performance. */\n    HighPerformance = \"high-performance\"\n}\n\n/**\n * User configuration for the {@link MapView}.\n */\nexport interface MapViewOptions extends TextElementsRendererOptions, Partial<LookAtParams> {\n    /**\n     * The canvas element used to render the scene.\n     */\n    canvas: HTMLCanvasElement;\n\n    /**\n     * Optional WebGL Rendering Context.\n     * (https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext)\n     */\n    context?: WebGLRenderingContext;\n\n    /**\n     * `true` if the canvas contains an alpha (transparency) buffer or not. Default is `false`.\n     */\n    alpha?: boolean;\n\n    /**\n     * If `true`adds a Background Mesh for each tile\n     *\n     * @default `true`\n     */\n    addBackgroundDatasource?: boolean;\n\n    /**\n     * Whether the native WebGL antialiasing should be enabled. It is better to disable it if the\n     * MapView's MSAA is enabled.\n     *\n     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.\n     */\n    enableNativeWebglAntialias?: boolean;\n\n    /**\n     * Antialias settings for the map rendering. It is better to disable the native antialiasing if\n     * the custom antialiasing is enabled.\n     */\n    customAntialiasSettings?: IMapAntialiasSettings;\n\n    /**\n     * `Projection` used by the `MapView`.\n     *\n     * The default value is [[mercatorProjection]].\n     */\n    projection?: Projection;\n\n    /**\n     * The URL of the script that the decoder worker runs. The default URL is\n     * `./decoder.bundle.js`.\n     *\n     * Relative URIs are resolved to full URL using the document's base URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     */\n    decoderUrl?: string;\n\n    /**\n     * The number of Web Workers used to decode data. The default is\n     * CLAMP(`navigator.hardwareConcurrency` - 1, 1, 2).\n     */\n    decoderCount?: number;\n\n    /**\n     * The {@link @here/harp-datasource-protocol#Theme} used by Mapview.\n     *\n     * This Theme can be one of the following:\n     *  - `string` : the URI of the theme file used to style this map\n     *  - `Theme` : the `Theme` object already loaded\n     *  - `Promise<Theme>` : the future `Theme` object\n     *  - `undefined` : the theme is not yet set up, but can be set later. Rendering waits until\n     *     the theme is set.\n     *\n     * **Note:** Layers that use a theme do not render any content until that theme is available.\n     *\n     * Relative URIs are resolved to full URL using the document's base URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     *\n     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with help\n     * of [[uriResolver]].\n     *\n     * @see {@link ThemeLoader.load} for details how theme is loaded\n     */\n    theme?: string | Theme | FlatTheme | Promise<Theme>;\n\n    /**\n     * Resolve `URI` referenced in `MapView` assets using this resolver.\n     *\n     * Use, to support application/deployment specific `URI`s into actual `URLs` that can be loaded\n     * with `fetch`.\n     *\n     * Example:\n     * ```\n     * uriResolver: new PrefixMapUriResolver({\n     *     \"local://poiMasterList\": \"/assets/poiMasterList.json\",\n     *        // will match only 'local//:poiMasterList' and\n     *        // resolve to `/assets/poiMasterList.json`\n     *     \"local://icons/\": \"/assets/icons/\"\n     *        // will match only 'local//:icons/ANYPATH' (and similar) and\n     *        // resolve to `/assets/icons/ANYPATH`\n     * })\n     * ```\n     *\n     * @see {@link @here/harp-utils#UriResolver}\n     * @See {@link @here/harp-utils#PrefixMapUriResolver}\n     */\n    uriResolver?: UriResolver;\n\n    /**\n     * The minimum zoom level; default is `1`.\n     */\n    minZoomLevel?: number;\n\n    /**\n     * Determines the minimum camera height, in meters.\n     */\n    minCameraHeight?: number;\n\n    /**\n     * The maximum zoom level. The default is `14`.\n     */\n    maxZoomLevel?: number;\n\n    /**\n     * User-defined camera clipping planes distance evaluator.\n     * If not defined, {@link TiltViewClipPlanesEvaluator} will be used by {@link MapView}.\n     *\n     * @default {@link TiltViewClipPlanesEvaluator}\n     */\n    clipPlanesEvaluator?: ClipPlanesEvaluator;\n\n    /**\n     * Set to true to extend the frustum culling. This improves the rejection of some tiles, which\n     * normal frustum culling cannot detect. You can disable this property to measure performance.\n     *\n     * @default true\n     */\n    extendedFrustumCulling?: boolean;\n\n    /**\n     * The maximum number of tiles rendered from one data source at a time.\n     *\n     * @default See [[MapViewDefaults.maxVisibleDataSourceTiles]].\n     */\n    maxVisibleDataSourceTiles?: number;\n\n    /**\n     * Size of a tile cache for one data source.\n     *\n     * @default See [[MapViewDefaults.tileCacheSize]].\n     */\n    tileCacheSize?: number;\n\n    /**\n     * Specify if the cache should be counted in tiles or in megabytes.\n     *\n     * @see [[MapViewDefaults.resourceComputationType]].\n     */\n    resourceComputationType?: ResourceComputationType;\n\n    /**\n     * Limits the number of reduced zoom levels (lower detail)\n     * to be searched for fallback tiles.\n     *\n     * When zooming in, newly elected tiles may have not\n     * yet loaded. {@link MapView} searches through\n     * the tile cache for tiles ready to be displayed in\n     * lower zoom levels. The tiles may be\n     * located shallower in the quadtree.\n     *\n     * To disable a cache search, set the value to `0`.\n     *\n     * @default [[MapViewDefaults.quadTreeSearchDistanceUp]]\n     */\n    quadTreeSearchDistanceUp?: number;\n\n    /**\n     * Limits the number of higher zoom levels (more detailed)\n     * to be searched for fallback tiles.\n     *\n     * When zooming out, newly elected tiles may have not\n     * yet loaded. {@link MapView} searches through\n     * the tile cache for tiles ready to be displayed in\n     * higher zoom levels. These tiles may be\n     * located deeper in the quadtree.\n     *\n     * To disable a cache search, set the value to `0`.\n     *\n     * @default [[MapViewDefaults.quadTreeSearchDistanceDown]]\n     */\n    quadTreeSearchDistanceDown?: number;\n\n    /**\n     * Set to `true` to measure performance statistics.\n     */\n    enableStatistics?: boolean;\n\n    /**\n     * Preserve the buffers until they are cleared manually or overwritten.\n     *\n     * Set to `true` in order to copy {@link MapView} canvas contents\n     * to an image or another canvas.\n     *\n     * @default `false`.\n     * @see https://threejs.org/docs/#api/renderers/WebGLRenderer.preserveDrawingBuffer\n     */\n    preserveDrawingBuffer?: boolean;\n\n    /**\n     * @deprecated Not needed anymore, roads can be picked by default.\n     */\n    enableRoadPicking?: boolean;\n\n    /**\n     * Set to `true` to allow picking of technique information associated with objects.\n     */\n    enablePickTechnique?: boolean;\n\n    /**\n     * Maximum timeout, in milliseconds, before a [[MOVEMENT_FINISHED_EVENT]] is sent after the\n     * latest frame with a camera movement. The default is 300ms.\n     */\n    movementThrottleTimeout?: number;\n\n    /**\n     * How to calculate the Field of View, if not specified, then\n     * [[DEFAULT_FOV_CALCULATION]] is used.\n     */\n    fovCalculation?: FovCalculation;\n\n    /*\n     * An array of ISO 639-1 language codes for data sources.\n     */\n    languages?: string[];\n\n    /**\n     * Sets the data sources to use specific country point of view (political view).\n     *\n     * This option may result in rendering different country borders then commonly accepted for\n     * some regions and it mainly regards to so called __disputed borders__. Although not all\n     * data sources or themes may support it.\n     *\n     * @note Country code should be coded in lower-case ISO 3166-1 alpha-2 standard, if this option\n     * is `undefined` the majority point of view will be used.\n     */\n    politicalView?: string;\n\n    /**\n     * Set fixed pixel ratio for rendering. Useful when rendering on high resolution displays with\n     * low performance GPUs that may be fill-rate limited.\n     * @default `window.devicePixelRatio`\n     */\n    pixelRatio?: number;\n\n    /**\n     * Set fixed pixel ratio for rendering when the camera is moving or an animation is running.\n     * Useful when rendering on high resolution displays with low performance GPUs that may be\n     * fill-rate limited.\n     *\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. Values between 0.5 and\n     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger\n     * than `window.devicePixelRatio`.\n     *\n     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`\n     * defined, visual artifacts may occur, especially with thin lines..\n     *\n     * @note The resolution of icons and text labels is not affected.\n     *\n     * @default `undefined`\n     */\n    dynamicPixelRatio?: number;\n\n    /**\n     * Set maximum FPS (Frames Per Second). If VSync in enabled, the specified number may not be\n     * reached, but instead the next smaller number than `maxFps` that is equal to the refresh rate\n     * divided by an integer number.\n     *\n     * E.g.: If the monitors refresh rate is set to 60hz, and if `maxFps` is set to a value of `40`\n     * (60hz/1.5), the actual used FPS may be 30 (60hz/2). For displays that have a refresh rate of\n     * 60hz, good values for `maxFps` are 30, 20, 15, 12, 10, 6, 3 and 1. A value of `0` is ignored.\n     */\n    maxFps?: number;\n\n    /**\n     * Enable map repeat for planar projections.\n     * If `true`, map will be repeated in longitudinal direction continuously.\n     * If `false`, map will end on lon -180 & 180 deg.\n     *\n     * @default `true`\n     */\n    tileWrappingEnabled?: boolean;\n\n    /**\n     * Set tiling scheme for [[BackgroundDataSource]]\n     */\n    backgroundTilingScheme?: TilingScheme;\n\n    /**\n     * Should be the {@link PolarTileDataSource} used on spherical projection.\n     * Default is `true`.\n     */\n    enablePolarDataSource?: boolean;\n\n    /**\n     * The name of the [[StyleSet]] used by {@link PolarTileDataSource}\n     * to evaluate for the decoding.\n     * Default is `\"polar\"`.\n     */\n    polarStyleSetName?: string;\n\n    /**\n     * Storage level offset of regular tiles from reference datasource to align\n     * {@link PolarTileDataSource} tiles to.\n     * Default is `-1`.\n     */\n    polarGeometryLevelOffset?: number;\n\n    /**\n     * Hint for the WebGL implementation on which power mode to prefer.\n     */\n    powerPreference?: MapViewPowerPreference;\n\n    /**\n     * Set to `true` to allow rendering scene synchronously.\n     *\n     * By calling `renderSync()` scene draws immediately, opposite to default case when\n     * `update` method requests redraw and waits for the next animation frame.\n     *\n     * You need to set up your own render loop controller.\n     * Event `MapViewEventNames.Update` fired when {@link MapView} requests for an redraw.\n     * E.g.: When tiles loaded asynchronously and ready for rendering.\n     *\n     * @note Internal `maxFps` will be overridden and may not work properly as `renderSync`\n     * intended to be called from external render loop.\n     *\n     * @default false.\n     */\n    synchronousRendering?: boolean;\n\n    /**\n     * Set true to enable rendering mixed levels of detail (increases rendering performance).\n     * If not set will enable mixed levels of detail for spherical projection\n     * and disable for other projections.\n     *\n     * @default undefined\n     */\n    enableMixedLod?: boolean;\n\n    /**\n     * If enableMixedLod is `true`, this value will be used to calculate the minimum Pixel Size of a\n     * tile regarding to the screen size. When the area of a tile is smaller then this calculated\n     * area on the screen, the subdivision of tiles is stopped and therefore higher level tiles will\n     * be rendered instead.\n     * @beta\n     *\n     * @default 256\n     */\n    lodMinTilePixelSize?: number;\n\n    /**\n     * Enable shadows in the map. Shadows will only be casted on features that use the \"standard\"\n     * or \"extruded-polygon\" technique in the map theme.\n     * @default false\n     */\n    enableShadows?: boolean;\n\n    /**\n     * Enable throttling for the TaskScheduler\n     * @default false\n     * @beta\n     */\n    throttlingEnabled?: boolean;\n\n    /**\n     * If set, the view will constrained within the given bounds in geo coordinates.\n     */\n    maxBounds?: GeoBox;\n}\n\n/**\n * Default settings used by {@link MapView} collected in one place.\n * @internal\n */\nconst MapViewDefaults = {\n    projection: mercatorProjection,\n    addBackgroundDatasource: true,\n\n    maxVisibleDataSourceTiles: 100,\n    extendedFrustumCulling: true,\n\n    tileCacheSize: 200,\n    resourceComputationType: ResourceComputationType.EstimationInMb,\n    quadTreeSearchDistanceUp: 3,\n    quadTreeSearchDistanceDown: 2,\n\n    pixelRatio:\n        typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n            ? window.devicePixelRatio\n            : 1.0,\n    target: new GeoCoordinates(25, 0),\n    zoomLevel: 5,\n    tilt: 0,\n    heading: 0,\n    theme: {},\n    maxTilesPerFrame: 0\n};\n\n/**\n * Parameters for {@link (MapView.lookAt:WITH_PARAMS)}.\n */\nexport interface LookAtParams {\n    /**\n     * Target/look at point of the MapView.\n     *\n     * @note If the given point is not on the ground (altitude != 0) {@link MapView} will do a\n     * raycasting internally to find a target on the ground.\n     *\n     * As a consequence {@link MapView.target} and {@link MapView.zoomLevel}\n     * will not match the values\n     * that were passed into the {@link (MapView.lookAt:WITH_PARAMS)} method.\n     * @default `new GeoCoordinates(25, 0)` in {@link MapView.constructor} context.\n     * @default {@link MapView.target} in {@link (MapView.lookAt:WITH_PARAMS)} context.\n     */\n    target: GeoCoordLike;\n\n    /**\n     * Fit MapView to these boundaries.\n     *\n     * If specified, `zoomLevel` and `distance` parameters are ignored and `lookAt` calculates best\n     * `zoomLevel` to fit given bounds.\n     *\n     * * if `bounds` is {@link @here/harp-geoutils#GeoBox}, then `lookAt`\n     *   use {@link LookAtParams.target} or `bounds.target` and\n     *   ensure whole box is visible\n     *\n     * * if `bounds` is {@link @here/harp-geoutils#GeoPolygon}, then `lookAt`\n     *   use `bounds.getCentroid()` and ensure whole polygon is visible\n     *\n     * * if `bounds` is {@link @here/harp-geoutils#GeoBoxExtentLike},\n     *   then `lookAt` will use {@link LookAtParams.target} or\n     *   current {@link MapView.target} and ensure whole extents are visible\n     *\n     * * if `bounds` is [[GeoCoordLike]][], then `lookAt` will use {@link LookAtParams.target} or\n     *   calculated `target` as center of world box covering given points and ensure all points are\n     *   visible\n     *\n     * Note in sphere projection some points are not visible if you specify bounds that span more\n     * than 180 degrees in any direction.\n     *\n     * @see {@link (MapView.lookAt:WITH_PARAMS)} for details on how `bounds`\n     *      interact with `target` parameter\n     */\n    bounds: GeoBox | GeoBoxExtentLike | GeoCoordLike[] | GeoPolygon;\n\n    /**\n     * Camera distance to the target point in world units.\n     * @default zoomLevel defaults will be used if not set.\n     */\n    distance: number;\n\n    /**\n     * Zoomlevel of the MapView.\n     * @note Takes precedence over distance.\n     * @default 5 in {@link MapView.constructor} context.\n     * @default {@link MapView.zoomLevel} in {@link (MapView.lookAt:WITH_PARAMS)} context.\n     */\n    zoomLevel: number;\n\n    /**\n     * Tilt angle in degrees. 0 is top down view.\n     * @default 0 in {@link MapView.constructor} context.\n     * @default {@link MapView.tilt} in {@link (MapView.lookAt:WITH_PARAMS)} context.\n     * @note Maximum supported tilt is 89\n     */\n    tilt: number;\n\n    /**\n     * Heading angle in degrees and clockwise. 0 is north-up.\n     * @default 0 in {@link MapView.constructor} context.\n     * @default {@link MapView.heading} in {@link (MapView.lookAt:WITH_PARAMS)} context.\n     */\n    heading: number;\n}\n\n/**\n * The core class of the library to call in order to create a map visualization. It needs to be\n * linked to datasources.\n */\nexport class MapView extends EventDispatcher {\n    /**\n     * Keep the events here to avoid a global reference to MapView (and thus prevent garbage collection).\n     */\n    private readonly UPDATE_EVENT: RenderEvent = { type: MapViewEventNames.Update };\n    private readonly RENDER_EVENT: RenderEvent = { type: MapViewEventNames.Render };\n    private readonly DID_RENDER_EVENT: RenderEvent = { type: MapViewEventNames.AfterRender };\n    private readonly FIRST_FRAME_EVENT: RenderEvent = { type: MapViewEventNames.FirstFrame };\n    private readonly FRAME_COMPLETE_EVENT: RenderEvent = {\n        type: MapViewEventNames.FrameComplete\n    };\n\n    private readonly THEME_LOADED_EVENT: RenderEvent = {\n        type: MapViewEventNames.ThemeLoaded\n    };\n\n    private readonly ANIMATION_STARTED_EVENT: RenderEvent = {\n        type: MapViewEventNames.AnimationStarted\n    };\n\n    private readonly ANIMATION_FINISHED_EVENT: RenderEvent = {\n        type: MapViewEventNames.AnimationFinished\n    };\n\n    private readonly MOVEMENT_STARTED_EVENT: RenderEvent = {\n        type: MapViewEventNames.MovementStarted\n    };\n\n    private readonly MOVEMENT_FINISHED_EVENT: RenderEvent = {\n        type: MapViewEventNames.MovementFinished\n    };\n\n    private readonly CONTEXT_LOST_EVENT: RenderEvent = {\n        type: MapViewEventNames.ContextLost\n    };\n\n    private readonly CONTEXT_RESTORED_EVENT: RenderEvent = {\n        type: MapViewEventNames.ContextRestored\n    };\n\n    private readonly COPYRIGHT_CHANGED_EVENT: RenderEvent = {\n        type: MapViewEventNames.CopyrightChanged\n    };\n\n    private readonly DISPOSE_EVENT: RenderEvent = { type: MapViewEventNames.Dispose };\n\n    /**\n     * The instance of {@link MapRenderingManager} managing the rendering of the map. It is a public\n     * property to allow access and modification of some parameters of the rendering process at\n     * runtime.\n     */\n    readonly mapRenderingManager: IMapRenderingManager;\n\n    private m_renderLabels: boolean = true;\n\n    private m_movementFinishedUpdateTimerId?: any;\n    private m_postEffects?: PostEffects;\n\n    private readonly m_screenProjector: ScreenProjector;\n\n    private m_visibleTiles: VisibleTileSet;\n    private readonly m_tileObjectRenderer: TileObjectRenderer;\n\n    private m_elevationSource?: DataSource;\n    private m_elevationRangeSource?: ElevationRangeSource;\n    private m_elevationProvider?: ElevationProvider;\n    private m_visibleTileSetLock: boolean = false;\n    private readonly m_tileGeometryManager: TileGeometryManager;\n\n    private m_tileWrappingEnabled: boolean = true;\n\n    private m_zoomLevel: number = DEFAULT_MIN_ZOOM_LEVEL;\n    private m_minZoomLevel: number = DEFAULT_MIN_ZOOM_LEVEL;\n    private m_maxZoomLevel: number = DEFAULT_MAX_ZOOM_LEVEL;\n    private readonly m_minCameraHeight: number = DEFAULT_MIN_CAMERA_HEIGHT;\n    private m_geoMaxBounds?: GeoBox;\n    private m_worldMaxBounds?: THREE.Box3 | OrientedBox3;\n\n    private readonly m_camera: THREE.PerspectiveCamera;\n\n    /**\n     * Relative to eye camera.\n     *\n     * This camera is internal camera used to improve precision\n     * when rendering geometries.\n     */\n    private readonly m_rteCamera = new THREE.PerspectiveCamera();\n\n    private m_yaw = 0;\n    private m_pitch = 0;\n    private m_roll = 0;\n    private m_targetDistance = 0;\n    private m_targetGeoPos = GeoCoordinates.fromObject(MapViewDefaults.target!);\n    // Focus point world coords may be calculated after setting projection, use dummy value here.\n    private readonly m_targetWorldPos = new THREE.Vector3();\n    private readonly m_viewRanges: ViewRanges = {\n        near: DEFAULT_CAM_NEAR_PLANE,\n        far: DEFAULT_CAM_FAR_PLANE,\n        minimum: DEFAULT_CAM_NEAR_PLANE,\n        maximum: DEFAULT_CAM_FAR_PLANE\n    };\n\n    private m_pointOfView?: THREE.PerspectiveCamera;\n\n    private m_pixelToWorld?: number;\n    private m_pixelRatio?: number;\n\n    /** Default scene for map objects and map anchors */\n    private readonly m_scene: THREE.Scene = new THREE.Scene();\n    /** Separate scene for overlay map anchors */\n    private readonly m_overlayScene: THREE.Scene = new THREE.Scene();\n    /** Root node of [[m_scene]] that gets cleared every frame. */\n    private readonly m_sceneRoot = new THREE.Object3D();\n    /** Root node of [[m_overlayScene]] that gets cleared every frame. */\n    private readonly m_overlaySceneRoot = new THREE.Object3D();\n\n    private readonly m_mapAnchors: MapAnchors = new MapAnchors();\n\n    private m_animationCount: number = 0;\n    private m_animationFrameHandle: number | undefined;\n    private m_drawing: boolean = false;\n    private m_updatePending: boolean = false;\n    private readonly m_renderer: THREE.WebGLRenderer;\n    private m_frameNumber = 0;\n\n    private m_textElementsRenderer: TextElementsRenderer;\n\n    private m_forceCameraAspect: number | undefined = undefined;\n\n    // type any as it returns different types depending on the environment\n    private m_taskSchedulerTimeout: any = undefined;\n\n    //\n    // sources\n    //\n    private readonly m_tileDataSources: DataSource[] = [];\n    private readonly m_connectedDataSources = new Set<string>();\n    private readonly m_failedDataSources = new Set<string>();\n    private readonly m_polarDataSource?: PolarTileDataSource;\n    private readonly m_enablePolarDataSource: boolean = true;\n\n    // gestures\n    private readonly m_raycaster = new THREE.Raycaster();\n    private readonly m_plane = new THREE.Plane(new THREE.Vector3(0, 0, 1));\n    private readonly m_sphere = new THREE.Sphere(undefined, EarthConstants.EQUATORIAL_RADIUS);\n\n    private readonly m_options: MapViewOptions;\n    private readonly m_visibleTileSetOptions: VisibleTileSetOptions;\n\n    private readonly m_uriResolver?: UriResolver;\n\n    private m_previousFrameTimeStamp?: number;\n    private m_firstFrameRendered = false;\n    private m_firstFrameComplete = false;\n\n    private readonly handleRequestAnimationFrame: (frameStartTime: number) => void;\n\n    private readonly m_pickHandler: PickHandler;\n\n    private readonly m_userImageCache: MapViewImageCache = new MapViewImageCache();\n    private readonly m_env: MapEnv = new MapEnv({});\n\n    private readonly m_poiManager: PoiManager = new PoiManager(this);\n\n    private readonly m_poiTableManager: PoiTableManager = new PoiTableManager(this);\n\n    private readonly m_collisionDebugCanvas: HTMLCanvasElement | undefined;\n\n    // Detection of camera movement and scene change:\n    private readonly m_movementDetector: CameraMovementDetector;\n\n    private m_thisFrameTilesChanged: boolean | undefined;\n    private m_lastTileIds: string = \"\";\n    private m_languages: string[] | undefined;\n    private m_politicalView: string | undefined;\n    private m_copyrightInfo: CopyrightInfo[] = [];\n    private readonly m_animatedExtrusionHandler: AnimatedExtrusionHandler;\n\n    private m_enableMixedLod: boolean | undefined;\n    private readonly m_lodMinTilePixelSize: number | undefined;\n\n    private m_taskScheduler: MapViewTaskScheduler;\n    private readonly m_themeManager: MapViewThemeManager;\n    private readonly m_sceneEnvironment: MapViewEnvironment;\n\n    // `true` if dispose() has been called on `MapView`.\n    private m_disposed = false;\n\n    /**\n     * Constructs a new `MapView` with the given options or canvas element.\n     *\n     * @param options - The `MapView` options or the HTML canvas element used to display the map.\n     */\n    constructor(options: MapViewOptions) {\n        super();\n\n        // make a copy to avoid unwanted changes to the original options.\n        this.m_options = { ...options };\n\n        this.m_uriResolver = this.m_options.uriResolver;\n\n        if (this.m_options.minZoomLevel !== undefined) {\n            this.m_minZoomLevel = this.m_options.minZoomLevel;\n        }\n\n        if (this.m_options.maxZoomLevel !== undefined) {\n            this.m_maxZoomLevel = this.m_options.maxZoomLevel;\n        }\n\n        if (this.m_options.minCameraHeight !== undefined) {\n            this.m_minCameraHeight = this.m_options.minCameraHeight;\n        }\n\n        if (this.m_options.maxBounds !== undefined) {\n            this.m_geoMaxBounds = this.m_options.maxBounds;\n        }\n\n        if (this.m_options.decoderUrl !== undefined) {\n            ConcurrentDecoderFacade.defaultScriptUrl = this.m_uriResolver\n                ? this.m_uriResolver.resolveUri(this.m_options.decoderUrl)\n                : this.m_options.decoderUrl;\n        }\n\n        if (this.m_options.decoderCount !== undefined) {\n            ConcurrentDecoderFacade.defaultWorkerCount = this.m_options.decoderCount;\n        }\n\n        this.m_visibleTileSetOptions = {\n            ...MapViewDefaults,\n            clipPlanesEvaluator:\n                options.clipPlanesEvaluator !== undefined\n                    ? options.clipPlanesEvaluator\n                    : createDefaultClipPlanesEvaluator()\n        };\n\n        if (options.projection !== undefined) {\n            this.m_visibleTileSetOptions.projection = options.projection;\n        }\n\n        if (options.extendedFrustumCulling !== undefined) {\n            this.m_visibleTileSetOptions.extendedFrustumCulling = options.extendedFrustumCulling;\n        }\n\n        if (options.maxVisibleDataSourceTiles !== undefined) {\n            this.m_visibleTileSetOptions.maxVisibleDataSourceTiles =\n                options.maxVisibleDataSourceTiles;\n        }\n\n        if (options.tileCacheSize !== undefined) {\n            this.m_visibleTileSetOptions.tileCacheSize = options.tileCacheSize;\n        }\n\n        if (options.resourceComputationType !== undefined) {\n            this.m_visibleTileSetOptions.resourceComputationType = options.resourceComputationType;\n        }\n\n        if (options.quadTreeSearchDistanceUp !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceUp =\n                options.quadTreeSearchDistanceUp;\n        }\n\n        if (options.quadTreeSearchDistanceDown !== undefined) {\n            this.m_visibleTileSetOptions.quadTreeSearchDistanceDown =\n                options.quadTreeSearchDistanceDown;\n        }\n\n        if (options.enablePolarDataSource !== undefined) {\n            this.m_enablePolarDataSource = options.enablePolarDataSource;\n        }\n\n        this.m_pixelRatio = options.pixelRatio;\n        this.m_options.maxFps = this.m_options.maxFps ?? 0;\n\n        this.m_options.enableStatistics = this.m_options.enableStatistics === true;\n\n        this.m_languages = this.m_options.languages;\n        this.m_politicalView = this.m_options.politicalView;\n\n        this.handleRequestAnimationFrame = this.renderLoop.bind(this);\n\n        if (this.m_options.tileWrappingEnabled !== undefined) {\n            this.m_tileWrappingEnabled = this.m_options.tileWrappingEnabled;\n        }\n\n        // Initialization of the stats\n        this.setupStats(this.m_options.enableStatistics);\n\n        this.canvas.addEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.addEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n\n        // Initialization of the renderer, enable backward compatibility with three.js <= 0.117\n        this.m_renderer = new ((THREE as any).WebGL1Renderer ?? THREE.WebGLRenderer)({\n            canvas: this.canvas,\n            context: this.m_options.context,\n            antialias: this.nativeWebglAntialiasEnabled,\n            alpha: this.m_options.alpha,\n            preserveDrawingBuffer: this.m_options.preserveDrawingBuffer === true,\n            powerPreference:\n                this.m_options.powerPreference === undefined\n                    ? MapViewPowerPreference.Default\n                    : this.m_options.powerPreference\n        });\n        this.m_renderer.autoClear = false;\n        this.m_renderer.debug.checkShaderErrors = !isProduction;\n\n        // This is detailed at https://threejs.org/docs/#api/renderers/WebGLRenderer.info\n        // When using several WebGLRenderer#render calls per frame, it is the only way to get\n        // correct rendering data from ThreeJS.\n        this.m_renderer.info.autoReset = false;\n\n        this.m_tileObjectRenderer = new TileObjectRenderer(this.m_env, this.m_renderer);\n        this.setupRenderer(this.m_tileObjectRenderer);\n\n        this.m_options.fovCalculation =\n            this.m_options.fovCalculation === undefined\n                ? DEFAULT_FOV_CALCULATION\n                : this.m_options.fovCalculation;\n        this.m_options.fovCalculation.fov = THREE.MathUtils.clamp(\n            this.m_options.fovCalculation!.fov,\n            MIN_FOV_DEG,\n            MAX_FOV_DEG\n        );\n        // Initialization of mCamera and mVisibleTiles\n        const { width, height } = this.getCanvasClientSize();\n        const aspect = width / height;\n        this.m_camera = new THREE.PerspectiveCamera(\n            this.m_options.fovCalculation.fov,\n            aspect,\n            DEFAULT_CAM_NEAR_PLANE,\n            DEFAULT_CAM_FAR_PLANE\n        );\n        this.m_camera.up.set(0, 0, 1);\n        this.setFovOnCamera(this.m_options.fovCalculation, height);\n        this.projection.projectPoint(this.m_targetGeoPos, this.m_targetWorldPos);\n        this.m_scene.add(this.m_camera); // ensure the camera is added to the scene.\n        this.m_screenProjector = new ScreenProjector(this.m_camera);\n\n        // Scheduler must be initialized before VisibleTileSet.\n        this.m_taskScheduler = new MapViewTaskScheduler(this.maxFps);\n        this.m_tileGeometryManager = new TileGeometryManager(this);\n\n        if (options.enableMixedLod !== undefined) {\n            this.m_enableMixedLod = options.enableMixedLod;\n        }\n        if (options.lodMinTilePixelSize !== undefined) {\n            this.m_lodMinTilePixelSize = options.lodMinTilePixelSize;\n        }\n        // this.m_visibleTiles is set in createVisibleTileSet, set it here again only to let tsc\n        // know the member is set in the constructor.\n        this.m_visibleTiles = this.createVisibleTileSet();\n        this.m_sceneEnvironment = new MapViewEnvironment(this, options);\n\n        // setup camera with initial position\n        this.setupCamera();\n\n        this.m_pickHandler = new PickHandler(\n            this,\n            this.m_rteCamera,\n            this.m_options.enablePickTechnique === true\n        );\n\n        this.m_movementDetector = new CameraMovementDetector(\n            this.m_options.movementThrottleTimeout,\n            () => this.movementStarted(),\n            () => this.movementFinished()\n        );\n\n        const mapPassAntialiasSettings = this.m_options.customAntialiasSettings;\n        this.mapRenderingManager = new MapRenderingManager(\n            width,\n            height,\n            this.m_options.dynamicPixelRatio,\n            mapPassAntialiasSettings\n        );\n\n        this.m_animatedExtrusionHandler = new AnimatedExtrusionHandler(this);\n\n        if (this.m_enablePolarDataSource) {\n            const styleSetName =\n                options.polarStyleSetName !== undefined\n                    ? options.polarStyleSetName\n                    : DEFAULT_POLAR_STYLE_SET_NAME;\n\n            this.m_polarDataSource = new PolarTileDataSource({\n                styleSetName,\n                geometryLevelOffset: options.polarGeometryLevelOffset\n            });\n\n            this.updatePolarDataSource();\n        }\n\n        this.m_taskScheduler.addEventListener(MapViewEventNames.Update, () => {\n            this.update();\n        });\n\n        if (options.throttlingEnabled !== undefined) {\n            this.m_taskScheduler.throttlingEnabled = options.throttlingEnabled;\n        }\n\n        this.m_themeManager = new MapViewThemeManager(this, this.m_uriResolver);\n\n        // will initialize with an empty theme and updated when theme is loaded and set\n        this.m_textElementsRenderer = this.createTextRenderer();\n\n        this.setTheme(getOptionValue(this.m_options.theme, MapViewDefaults.theme));\n\n        this.update();\n    }\n\n    /**\n     * @returns The lights configured by the theme, this is just a convenience method, because the\n     * lights can still be accessed by traversing the children of the [[scene]].\n     */\n    get lights(): THREE.Light[] {\n        return this.m_sceneEnvironment.lights;\n    }\n\n    get taskQueue(): TaskQueue {\n        return this.m_taskScheduler.taskQueue;\n    }\n\n    /**\n     * @returns Whether label rendering is enabled.\n     */\n    get renderLabels() {\n        return this.m_renderLabels;\n    }\n\n    /**\n     * Enables or disables rendering of labels.\n     * @param value - `true` to enable labels `false` to disable them.\n     */\n    set renderLabels(value: boolean) {\n        this.m_renderLabels = value;\n    }\n\n    /**\n     * @returns Whether adding of new labels during interaction is enabled.\n     */\n    get delayLabelsUntilMovementFinished() {\n        return this.textElementsRenderer.delayLabelsUntilMovementFinished;\n    }\n\n    /**\n     * Enables or disables adding of  new labels during interaction. Has no influence on already\n     * placed labels\n     * @param value - `true` to enable adding `false` to disable them.\n     */\n    set delayLabelsUntilMovementFinished(value: boolean) {\n        this.textElementsRenderer.delayLabelsUntilMovementFinished = value;\n    }\n\n    /**\n     * @hidden\n     * The {@link TextElementsRenderer} select the visible {@link TextElement}s and renders them.\n     */\n    get textElementsRenderer(): TextElementsRenderer {\n        return this.m_textElementsRenderer;\n    }\n\n    /**\n     * @hidden\n     * The {@link CameraMovementDetector} detects camera movements. Made available for performance\n     * measurements.\n     */\n    get cameraMovementDetector(): CameraMovementDetector {\n        return this.m_movementDetector;\n    }\n\n    /**\n     * The {@link AnimatedExtrusionHandler} controls animated extrusion effect\n     * of the extruded objects in the {@link Tile}\n     */\n    get animatedExtrusionHandler(): AnimatedExtrusionHandler {\n        return this.m_animatedExtrusionHandler;\n    }\n\n    /**\n     * The [[TileGeometryManager]] manages geometry during loading and handles hiding geometry of\n     * specified [[GeometryKind]]s.\n     * @deprecated\n     */\n    get tileGeometryManager(): TileGeometryManager | undefined {\n        return this.m_tileGeometryManager;\n    }\n\n    get enableMixedLod(): boolean | undefined {\n        return this.m_enableMixedLod;\n    }\n\n    set enableMixedLod(enableMixedLod: boolean | undefined) {\n        // Skip unnecessary update\n        if (this.m_enableMixedLod === enableMixedLod) {\n            return;\n        }\n\n        this.m_enableMixedLod = enableMixedLod;\n        this.createVisibleTileSet();\n        this.update();\n    }\n\n    get tileWrappingEnabled(): boolean {\n        return this.m_tileWrappingEnabled;\n    }\n\n    set tileWrappingEnabled(enabled: boolean) {\n        if (this.projection.type === ProjectionType.Spherical) {\n            logger.warn(\"Setting this with spherical projection has no affect. Was this intended?\");\n            return;\n        }\n        if (enabled !== this.m_tileWrappingEnabled) {\n            this.m_tileWrappingEnabled = enabled;\n            this.createVisibleTileSet();\n        }\n        this.update();\n    }\n\n    /**\n     * Disposes this `MapView`.\n     * @override\n     *\n     * @param freeContext - `true` to force ThreeJS to loose the context. Supply `false` to keep\n     * the context for further use.\n     *\n     * @remarks\n     * This function cleans the resources that are managed manually including those that exist in\n     * shared caches.\n     *\n     * Note: This function does not try to clean objects that can be disposed off easily by\n     * TypeScript's garbage collecting mechanism. Consequently, if you need to perform a full\n     * cleanup, you must ensure that all references to this `MapView` are removed.\n     */\n    dispose(freeContext = true) {\n        // Enforce listeners that we are about to dispose.\n        this.DISPOSE_EVENT.time = Date.now();\n        this.dispatchEvent(this.DISPOSE_EVENT);\n\n        this.m_disposed = true;\n\n        if (this.m_movementFinishedUpdateTimerId) {\n            clearTimeout(this.m_movementFinishedUpdateTimerId);\n            this.m_movementFinishedUpdateTimerId = undefined;\n        }\n\n        if (this.m_animationFrameHandle !== undefined) {\n            cancelAnimationFrame(this.m_animationFrameHandle);\n            this.m_animationFrameHandle = undefined;\n        }\n\n        this.canvas.removeEventListener(\"webglcontextlost\", this.onWebGLContextLost);\n        this.canvas.removeEventListener(\"webglcontextrestored\", this.onWebGLContextRestored);\n\n        for (const dataSource of this.m_tileDataSources) {\n            dataSource.dispose();\n        }\n        this.m_visibleTiles.clearTileCache();\n        this.m_textElementsRenderer.clearRenderStates();\n        this.m_renderer.dispose();\n\n        if (freeContext) {\n            // See for a discussion of using this call to force freeing the context:\n            //   https://github.com/mrdoob/three.js/pull/17588\n            // The patch to call forceContextLoss() upon WebGLRenderer.dispose() had been merged,\n            // but has been reverted later:\n            //   https://github.com/mrdoob/three.js/pull/19022\n            this.m_renderer.forceContextLoss();\n        }\n\n        this.m_themeManager.dispose();\n        this.m_tileGeometryManager.clear();\n\n        this.m_movementDetector.dispose();\n\n        // Destroy the facade if the there are no workers active anymore.\n        ConcurrentDecoderFacade.destroyIfTerminated();\n        ConcurrentTilerFacade.destroyIfTerminated();\n\n        this.m_taskScheduler.clearQueuedTasks();\n\n        // Remove all event handlers.\n        super.dispose();\n    }\n\n    /**\n     * Is `true` if dispose() as been called on `MapView`.\n     */\n    get disposed(): boolean {\n        return this.m_disposed;\n    }\n\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType(): ResourceComputationType {\n        return this.m_visibleTiles.resourceComputationType;\n    }\n\n    set resourceComputationType(value: ResourceComputationType) {\n        this.m_visibleTiles.resourceComputationType = value;\n    }\n\n    /**\n     * Returns the cache size.\n     */\n    getCacheSize(): number {\n        return this.m_visibleTiles.getDataSourceCacheSize();\n    }\n\n    /**\n     * Sets the cache size in number of tiles.\n     *\n     * @param size - The cache size in tiles.\n     * @param numVisibleTiles - The number of tiles visible, which is size/2 by default.\n     */\n    setCacheSize(size: number, numVisibleTiles?: number): void {\n        this.m_visibleTiles.setDataSourceCacheSize(size);\n        numVisibleTiles = numVisibleTiles !== undefined ? numVisibleTiles : size / 2;\n        this.m_visibleTiles.setNumberOfVisibleTiles(Math.floor(numVisibleTiles));\n        this.m_themeManager.updateCache();\n        this.m_textElementsRenderer.invalidateCache();\n        this.update();\n    }\n\n    /**\n     * Specifies whether extended frustum culling is enabled or disabled.\n     */\n    get extendedFrustumCulling(): boolean {\n        return this.m_options.extendedFrustumCulling !== undefined\n            ? this.m_visibleTileSetOptions.extendedFrustumCulling\n            : true;\n    }\n\n    /**\n     * Enable of disable extended frustum culling.\n     */\n    set extendedFrustumCulling(value: boolean) {\n        this.m_visibleTileSetOptions.extendedFrustumCulling = value;\n    }\n\n    /**\n     * Returns the status of frustum culling after each update.\n     */\n    get lockVisibleTileSet(): boolean {\n        return this.m_visibleTileSetLock;\n    }\n\n    /**\n     * Enable of disable frustum culling after each update.\n     */\n    set lockVisibleTileSet(value: boolean) {\n        this.m_visibleTileSetLock = value;\n    }\n\n    /**\n     * Gets the optional camera used to render the scene.\n     */\n    get pointOfView(): THREE.PerspectiveCamera | undefined {\n        return this.m_pointOfView;\n    }\n\n    /**\n     * Sets the optional camera used to render the scene.\n     */\n    set pointOfView(pointOfView: THREE.PerspectiveCamera | undefined) {\n        this.m_pointOfView = pointOfView;\n        this.update();\n    }\n\n    /**\n     * Loads a post effects definition file.\n     *\n     * @param postEffectsFile - File URL describing the post effects.\n     */\n    loadPostEffects(postEffectsFile: string) {\n        fetch(postEffectsFile)\n            .then(response => response.json())\n            .then((postEffects: PostEffects) => {\n                this.m_postEffects = postEffects;\n                this.setPostEffects();\n            });\n    }\n\n    /**\n     * The abstraction of the {@link MapRenderingManager} API for post effects.\n     */\n    get postEffects(): PostEffects | undefined {\n        return this.m_postEffects;\n    }\n\n    set postEffects(postEffects: PostEffects | undefined) {\n        this.m_postEffects = postEffects;\n        this.setPostEffects();\n    }\n\n    /**\n     * Gets the current `Theme` used by this `MapView` to style map elements.\n     * @deprecated\n     */\n    get theme(): Theme {\n        return this.m_themeManager.theme;\n    }\n\n    /**\n     * Changes the `Theme` used by this `MapView` to style map elements.\n     * @deprecated use MapView.setTheme instead\n     */\n    set theme(theme: Theme) {\n        this.setTheme(theme);\n    }\n\n    /**\n     * Changes the `Theme`used by this `MapView`to style map elements.\n     */\n    async setTheme(theme: Theme | FlatTheme | string): Promise<Theme> {\n        const newTheme = await this.m_themeManager.setTheme(theme);\n\n        this.THEME_LOADED_EVENT.time = Date.now();\n        this.dispatchEvent(this.THEME_LOADED_EVENT);\n        this.update();\n        return newTheme;\n    }\n\n    /**\n     * Returns the currently set `Theme` as a `Promise` as it might be still loading/updating.\n     */\n    async getTheme(): Promise<Theme> {\n        return await this.m_themeManager.getTheme();\n    }\n\n    /**\n     * {@link @here/harp-utils#UriResolver} used to resolve application/deployment\n     * specific `URI`s into actual `URLs` that can be loaded with `fetch`.\n     */\n    get uriResolver(): UriResolver | undefined {\n        return this.m_uriResolver;\n    }\n\n    /**\n     * Gets the value of the forced custom camera aspect.\n     * Every time a frame is rendered, `MapView` resets the camera aspect.\n     *\n     * You can disable this behavior by setting the value to `undefined`.\n     */\n    get forceCameraAspect(): number | undefined {\n        return this.m_forceCameraAspect;\n    }\n\n    /**\n     * Sets the custom forced camera aspect ratio to use while rendering.\n     */\n    set forceCameraAspect(aspect: number | undefined) {\n        this.m_forceCameraAspect = aspect;\n    }\n\n    /**\n     * Lists the ISO 639-1 language codes for DataSources to use.\n     */\n    get languages(): string[] | undefined {\n        return this.m_languages;\n    }\n\n    /**\n     * Sets the list of ISO 639-1 language codes for DataSources to use.\n     */\n    set languages(languages: string[] | undefined) {\n        this.m_languages = languages;\n        this.m_tileDataSources.forEach((dataSource: DataSource) => {\n            dataSource.setLanguages(this.m_languages);\n        });\n        this.update();\n    }\n\n    /**\n     * Get currently presented political point of view - the country code.\n     *\n     * @note Country code is stored in lower-case ISO 3166-1 alpha-2 standard.\n     * @return Country code or undefined if default\n     * (majorly accepted) point of view is used.\n     */\n    get politicalView(): string | undefined {\n        return this.m_politicalView;\n    }\n\n    /**\n     * Set the political view (country code) to be used when rendering disputed features (borders).\n     *\n     * @note Country code should be encoded in lower-case ISO 3166-1 alpha-2 standard.\n     * @param pov - The code of the country which point of view should be presented,\n     * if `undefined` or empty string is set then \"defacto\" or most widely accepted point of view\n     * will be presented.\n     */\n    set politicalView(pov: string | undefined) {\n        if (this.m_politicalView === pov) {\n            return;\n        }\n        this.m_politicalView = pov;\n        this.m_tileDataSources.forEach((dataSource: DataSource) => {\n            dataSource.setPoliticalView(pov);\n        });\n    }\n\n    get copyrightInfo(): CopyrightInfo[] {\n        return this.m_copyrightInfo;\n    }\n\n    /**\n     * @hidden\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable: boolean) {\n        this.m_textElementsRenderer.disableFading = disable;\n    }\n\n    get disableFading(): boolean {\n        return this.m_textElementsRenderer.disableFading;\n    }\n\n    /**\n     * @hidden\n     * Return current frame number.\n     */\n    get frameNumber(): number {\n        return this.m_frameNumber;\n    }\n\n    /**\n     * @hidden\n     * Reset the frame number to 0.\n     */\n    resetFrameNumber() {\n        this.m_frameNumber = 0;\n        this.m_previousFrameTimeStamp = undefined;\n    }\n\n    /**\n     * Adds an event listener. There are various events that are sent before or after a new frame\n     * is rendered.\n     *\n     * @see [[MapViewEventNames]].\n     *\n     * @example\n     * ```TypeScript\n     * let frameCount = 0;\n     * mapView.addEventListener(MapViewEventNames.Render, () => {\n     *     ++frameCount;\n     * });\n     * ```\n     *\n     * @param type - One of the [[MapViewEventNames]] strings.\n     * @param listener - The callback invoked when the `MapView` needs to render a new frame.\n     */\n    addEventListener(type: MapViewEventNames, listener: (event: RenderEvent) => void): void;\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    addEventListener(type: string, listener: any): void {\n        super.addEventListener(type, listener);\n    }\n\n    /**\n     * Removes an event listener. There are various events that are sent before or after a new frame\n     * is rendered.\n     *\n     * @see [[MapViewEventNames]].\n     *\n     * @example\n     * ```TypeScript\n     * mapView.removeEventListener(MapViewEventNames.Render, listener);\n     * ```\n     *\n     * @param type - One of the [[MapViewEventNames]] strings.\n     * @param listener - The callback invoked when the `MapView` needs to render a new frame.\n     */\n    removeEventListener(type: MapViewEventNames, listener?: (event: RenderEvent) => void): void;\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    removeEventListener(type: string, listener?: any): void {\n        super.removeEventListener(type, listener);\n    }\n\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get canvas(): HTMLCanvasElement {\n        return this.m_options.canvas;\n    }\n\n    /**\n     * The HTML canvas element used by this `MapView`.\n     */\n    get collisionDebugCanvas(): HTMLCanvasElement | undefined {\n        return this.m_collisionDebugCanvas;\n    }\n\n    /**\n     * The THREE.js scene used by this `MapView`.\n     */\n    get scene(): THREE.Scene {\n        return this.m_scene;\n    }\n\n    /**\n     * The THREE.js overlay scene\n     */\n    get overlayScene(): THREE.Scene {\n        return this.m_overlayScene;\n    }\n\n    /**\n     * The MapViewEnvironment used by this `MapView`.\n     * @internal\n     */\n    get sceneEnvironment(): MapViewEnvironment {\n        return this.m_sceneEnvironment;\n    }\n\n    /**\n     * The THREE.js camera used by this `MapView` to render the main scene.\n     *\n     * @remarks\n     * When modifying the camera all derived properties like:\n     * - {@link MapView.target}\n     * - {@link MapView.zoomLevel}\n     * - {@link MapView.tilt}\n     * - {@link MapView.heading}\n     * could change.\n     * These properties are cached internally and will only be updated in the next animation frame.\n     * FIXME: Unfortunately THREE.js is not dispatching any events when camera properties change\n     * so we should have an API for enforcing update of cached values.\n     */\n    get camera(): THREE.PerspectiveCamera {\n        return this.m_camera;\n    }\n\n    /**\n     * The THREE.js `WebGLRenderer` used by this scene.\n     */\n    get renderer(): THREE.WebGLRenderer {\n        return this.m_renderer;\n    }\n\n    /**\n     * The color used to clear the view.\n     */\n    get clearColor() {\n        const rendererClearColor = this.m_renderer.getClearColor(cache.color);\n        return rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n    }\n\n    /**\n     * The color used to clear the view.\n     */\n    set clearColor(color: number) {\n        this.m_renderer.setClearColor(color);\n    }\n\n    /**\n     * The alpha used to clear the view.\n     */\n    get clearAlpha() {\n        const rendererClearAlpha = this.m_renderer.getClearAlpha();\n        return rendererClearAlpha !== undefined ? rendererClearAlpha : 0;\n    }\n\n    /**\n     * The alpha used to clear the view.\n     */\n    set clearAlpha(alpha: number) {\n        this.m_renderer.setClearAlpha(alpha);\n    }\n\n    /**\n     * The projection used to project geo coordinates to world coordinates.\n     */\n    get projection(): Projection {\n        return this.m_visibleTileSetOptions.projection;\n    }\n\n    /**\n     * Changes the projection at run time.\n     *\n     * @param projection - The {@link @here/harp-geoutils#Projection} instance to use.\n     */\n    set projection(projection: Projection) {\n        // Remember tilt and heading before setting the projection.\n        const tilt = this.tilt;\n        const heading = this.heading;\n\n        this.m_visibleTileSetOptions.projection = projection;\n        this.updatePolarDataSource();\n        this.clearTileCache();\n        this.textElementsRenderer.clearRenderStates();\n        this.m_visibleTiles = this.createVisibleTileSet();\n        // Set geo max bounds to compute world bounds with new projection.\n        this.geoMaxBounds = this.geoMaxBounds;\n\n        this.lookAtImpl({ tilt, heading });\n    }\n\n    /**\n     * Get camera clipping planes evaluator used.\n     */\n    get clipPlanesEvaluator(): ClipPlanesEvaluator {\n        return this.m_visibleTileSetOptions.clipPlanesEvaluator;\n    }\n\n    /**\n     * Changes the clip planes evaluator at run time.\n     */\n    set clipPlanesEvaluator(clipPlanesEvaluator: ClipPlanesEvaluator) {\n        this.m_visibleTileSetOptions.clipPlanesEvaluator = clipPlanesEvaluator;\n    }\n\n    /**\n     * The distance (in pixels) between the screen and the camera.\n     * @deprecated Use {@link CameraUtils.getFocalLength}\n     */\n    get focalLength(): number {\n        const focalLength = CameraUtils.getFocalLength(this.m_camera) ?? 0;\n        return focalLength;\n    }\n\n    /**\n     * Get geo coordinates of camera focus (target) point.\n     *\n     * @remarks\n     * This point is not necessarily on the ground, i.e.:\n     *  - if the tilt is high and projection is {@link @here/harp-geoutils#sphereProjection}`\n     *  - if the camera was modified directly and is not pointing to the ground.\n     * In any case the projection of the target point will be in the center of the screen.\n     *\n     * @returns geo coordinates of the camera focus point.\n     */\n    get target(): GeoCoordinates {\n        return this.m_targetGeoPos;\n    }\n\n    /** @internal\n     * Get world coordinates of camera focus point.\n     *\n     * @remarks\n     * @note The focus point coordinates are updated with each camera update so you don't need\n     * to re-calculate it, although if the camera started looking to the void, the last focus\n     * point is stored.\n     *\n     * @returns world coordinates of the camera focus point.\n     */\n    get worldTarget(): THREE.Vector3 {\n        return this.m_targetWorldPos;\n    }\n\n    /** @internal\n     * Get distance from camera to the point of focus in world units.\n     *\n     * @note If camera does not point to any ground anymore the last focus point distance is\n     * then returned.\n     *\n     * @returns Last known focus point distance.\n     */\n    get targetDistance(): number {\n        return this.m_targetDistance;\n    }\n\n    /**\n     * Get object describing frustum planes distances and min/max visibility range for actual\n     * camera setup.\n     *\n     * @remarks\n     * Near and far plane distance are self explanatory while minimum and maximum visibility range\n     * describes the extreme near/far planes distances that may be achieved with current camera\n     * settings, meaning at current zoom level (ground distance) and any possible orientation.\n     * @note Visibility is directly related to camera [[ClipPlaneEvaluator]] used and determines\n     * the maximum possible distance of camera far clipping plane regardless of tilt, but may change\n     * whenever zoom level changes. Distance is measured in world units which may be approximately\n     * equal to meters, but this depends on the distortion related to projection type used.\n     * @internal\n     */\n    get viewRanges(): ViewRanges {\n        return this.m_viewRanges;\n    }\n\n    /**\n     * The position in geo coordinates of the center of the scene.\n     * @internal\n     */\n    get geoCenter(): GeoCoordinates {\n        return this.projection.unprojectPoint(this.m_camera.position).normalized();\n    }\n\n    /**\n     * The position in geo coordinates of the center of the scene.\n     *\n     * @remarks\n     * Longitude values outside of -180 and +180 are acceptable.\n     */\n    set geoCenter(geoCenter: GeoCoordinates) {\n        if (geoCenter.altitude !== undefined) {\n            this.projection.projectPoint(geoCenter, this.m_camera.position);\n        } else {\n            // Preserve the current altitude\n            const altitude = this.geoCenter.altitude;\n\n            this.projection.projectPoint(\n                new GeoCoordinates(geoCenter.latitude, geoCenter.longitude, altitude),\n                this.m_camera.position\n            );\n        }\n\n        this.update();\n    }\n\n    /**\n     * The node in this MapView's scene containing the user {@link MapAnchor}s.\n     *\n     * @remarks\n     * All (first level) children of this node will be positioned in world space according to the\n     * [[MapAnchor.geoPosition]].\n     * Deeper level children can be used to position custom objects relative to the anchor node.\n     */\n    get mapAnchors(): MapAnchors {\n        return this.m_mapAnchors;\n    }\n\n    /**\n     * The position in world coordinates of the center of the scene.\n     */\n    get worldCenter(): THREE.Vector3 {\n        return this.m_camera.position;\n    }\n\n    /**\n     * Get the [[PickHandler]] for this `mapView`.\n     */\n    get pickHandler(): PickHandler {\n        return this.m_pickHandler;\n    }\n\n    /**\n     * @internal\n     * Get the {@link ImageCache} that belongs to this `MapView`.\n     *\n     * Images stored in this cache are primarily used for POIs (icons) and they are used with the\n     * current theme. Although images can be explicitly added and removed from the cache, it is\n     * advised not to remove images from this cache. If an image that is part of client code\n     * should be removed at any point other than changing the theme, the {@link useImageCache}\n     * should be used instead.\n     */\n    get imageCache(): MapViewImageCache {\n        return this.m_themeManager.imageCache;\n    }\n\n    /**\n     * Get the {@link ImageCache} for user images that belongs to this `MapView`.\n     *\n     * Images added to this cache can be removed if no longer required.\n     */\n    get userImageCache(): MapViewImageCache {\n        return this.m_userImageCache;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     * Get the {@link PoiManager} that belongs to this `MapView`.\n     */\n    get poiManager(): PoiManager {\n        return this.m_poiManager;\n    }\n\n    /**\n     * @hidden\n     * Get the array of {@link PoiTableManager} that belongs to this `MapView`.\n     */\n    get poiTableManager(): PoiTableManager {\n        return this.m_poiTableManager;\n    }\n\n    /**\n     * The minimum camera height in meters.\n     */\n    get minCameraHeight(): number {\n        return this.m_minCameraHeight;\n    }\n\n    /**\n     * The minimum zoom level.\n     */\n    get minZoomLevel(): number {\n        return this.m_minZoomLevel;\n    }\n\n    /**\n     * The minimum zoom level.\n     */\n    set minZoomLevel(zoomLevel: number) {\n        this.m_minZoomLevel = zoomLevel;\n        this.update();\n    }\n\n    /**\n     * The maximum zoom level. Default is 14.\n     */\n    get maxZoomLevel(): number {\n        return this.m_maxZoomLevel;\n    }\n\n    /**\n     * The maximum zoom level.\n     */\n    set maxZoomLevel(zoomLevel: number) {\n        this.m_maxZoomLevel = zoomLevel;\n        this.update();\n    }\n\n    /**\n     * The view's maximum bounds in geo coordinates if any.\n     */\n    get geoMaxBounds(): GeoBox | undefined {\n        return this.m_geoMaxBounds;\n    }\n\n    /**\n     * Sets or clears the view's maximum bounds in geo coordinates.\n     *\n     * @remarks\n     * If set, the view will be\n     * constrained to the given geo bounds.\n     */\n    set geoMaxBounds(bounds: GeoBox | undefined) {\n        this.m_geoMaxBounds = bounds;\n        this.m_worldMaxBounds = this.m_geoMaxBounds\n            ? this.projection.projectBox(\n                  this.m_geoMaxBounds,\n                  this.projection.type === ProjectionType.Planar\n                      ? new THREE.Box3()\n                      : new OrientedBox3()\n              )\n            : undefined;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     * The view's maximum bounds in world coordinates if any.\n     */\n    get worldMaxBounds(): THREE.Box3 | OrientedBox3 | undefined {\n        return this.m_worldMaxBounds;\n    }\n\n    /**\n     * Returns the zoom level for the given camera setup.\n     */\n    get zoomLevel(): number {\n        return this.m_zoomLevel;\n    }\n\n    set zoomLevel(zoomLevel: number) {\n        this.lookAtImpl({ zoomLevel });\n    }\n\n    /**\n     * Returns tilt angle in degrees.\n     */\n    get tilt(): number {\n        return THREE.MathUtils.radToDeg(this.m_pitch);\n    }\n\n    /**\n     * Set the tilt angle of the map.\n     * @param tilt -: New tilt angle in degrees.\n     */\n    set tilt(tilt: number) {\n        this.lookAtImpl({ tilt });\n    }\n\n    /**\n     * Returns heading angle in degrees.\n     */\n    get heading(): number {\n        return -THREE.MathUtils.radToDeg(this.m_yaw);\n    }\n\n    /**\n     * Set the heading angle of the map.\n     * @param heading -: New heading angle in degrees.\n     */\n    set heading(heading: number) {\n        this.lookAtImpl({ heading });\n    }\n\n    /**\n     * Environment used to evaluate dynamic scene expressions.\n     */\n    get env(): Env {\n        return this.m_env;\n    }\n\n    /**\n     * Returns the storage level for the given camera setup.\n     * @remarks\n     * Actual storage level of the rendered data also depends\n     * on {@link DataSource.storageLevelOffset}.\n     */\n    get storageLevel(): number {\n        return THREE.MathUtils.clamp(\n            Math.floor(this.m_zoomLevel),\n            this.m_minZoomLevel,\n            this.m_maxZoomLevel\n        );\n    }\n\n    /**\n     * Returns height of the viewport in pixels.\n     */\n    get viewportHeight(): number {\n        return this.canvas.height;\n    }\n\n    /**\n     * Returns `true` if the native WebGL antialiasing is enabled.\n     *\n     * @default `true` for `pixelRatio` < `2.0`, `false` otherwise.\n     */\n    get nativeWebglAntialiasEnabled(): boolean {\n        return this.m_options.enableNativeWebglAntialias === undefined\n            ? this.pixelRatio < 2.0\n            : this.m_options.enableNativeWebglAntialias;\n    }\n\n    /**\n     * Returns {@link DataSource}s displayed by this `MapView`.\n     */\n    get dataSources(): DataSource[] {\n        return this.m_tileDataSources;\n    }\n\n    /**\n     * Set's the way in which the fov is calculated on the map view.\n     *\n     * @remarks\n     * Note, for this to take visual effect, the map should be rendered\n     * after calling this function.\n     * @param fovCalculation - How the FOV is calculated.\n     */\n    setFovCalculation(fovCalculation: FovCalculation) {\n        this.m_options.fovCalculation = fovCalculation;\n        this.updateCameras();\n    }\n\n    /**\n     * Returns the unique {@link DataSource} matching the given name.\n     */\n    getDataSourceByName(dataSourceName: string): DataSource | undefined {\n        return this.m_tileDataSources.find(ds => ds.name === dataSourceName);\n    }\n\n    /**\n     * Returns the array of {@link DataSource}s referring to the same [[StyleSet]].\n     */\n    getDataSourcesByStyleSetName(styleSetName: string): DataSource[] {\n        return this.m_tileDataSources.filter(ds => ds.styleSetName === styleSetName);\n    }\n\n    /**\n     * Returns true if the specified {@link DataSource} is enabled.\n     */\n    isDataSourceEnabled(dataSource: DataSource): boolean {\n        return (\n            dataSource.enabled &&\n            dataSource.ready() &&\n            this.m_connectedDataSources.has(dataSource.name) &&\n            dataSource.isVisible(this.zoomLevel)\n        );\n    }\n\n    /**\n     * Adds a new {@link DataSource} to this `MapView`.\n     *\n     * @remarks\n     * `MapView` needs at least one {@link DataSource} to display something.\n     * @param dataSource - The data source.\n     */\n    async addDataSource(dataSource: DataSource): Promise<void> {\n        const twinDataSource = this.getDataSourceByName(dataSource.name);\n        if (twinDataSource !== undefined) {\n            throw new Error(\n                `A DataSource with the name \"${dataSource.name}\" already exists in this MapView.`\n            );\n        }\n\n        dataSource.attach(this);\n        dataSource.setEnableElevationOverlay(this.m_elevationProvider !== undefined);\n        const conflictingDataSource = this.m_tileDataSources.find(\n            ds => ds.addGroundPlane === true && !(ds instanceof BackgroundDataSource)\n        );\n        if (dataSource.addGroundPlane === true && conflictingDataSource !== undefined) {\n            // eslint-disable-next-line no-console\n            console.warn(\n                `The DataSources ${dataSource.name} and ${conflictingDataSource.name} both have a ground plane added, this will cause problems with the fallback logic, see HARP-14728 & HARP-15488.`\n            );\n        }\n        this.m_tileDataSources.push(dataSource);\n        this.m_sceneEnvironment?.updateBackgroundDataSource();\n\n        try {\n            await dataSource.connect();\n\n            const alreadyRemoved = !this.m_tileDataSources.includes(dataSource);\n            if (alreadyRemoved) {\n                return;\n            }\n            dataSource.addEventListener(MapViewEventNames.Update, () => {\n                this.update();\n            });\n\n            const theme = await this.getTheme();\n            dataSource.setLanguages(this.m_languages);\n\n            if (theme !== undefined && theme.styles !== undefined) {\n                await dataSource.setTheme(theme);\n            }\n\n            this.m_connectedDataSources.add(dataSource.name);\n\n            this.dispatchEvent({\n                type: MapViewEventNames.DataSourceConnect,\n                dataSourceName: dataSource.name\n            });\n\n            this.update();\n        } catch (error) {\n            // error is a string if a promise was rejected.\n            logger.error(\n                `Failed to connect to datasource ${dataSource.name}: ${\n                    (error as Error).message ?? error\n                }`\n            );\n\n            this.m_failedDataSources.add(dataSource.name);\n            this.dispatchEvent({\n                type: MapViewEventNames.DataSourceConnect,\n                dataSourceName: dataSource.name,\n                error\n            });\n        }\n    }\n\n    /**\n     * Removes {@link DataSource} from this `MapView`.\n     *\n     * @param dataSource - The data source to be removed\n     */\n    removeDataSource(dataSource: DataSource) {\n        const dsIndex = this.m_tileDataSources.indexOf(dataSource);\n        if (dsIndex === -1) {\n            return;\n        }\n        dataSource.detach(this);\n\n        this.m_visibleTiles.removeDataSource(dataSource);\n        this.m_tileDataSources.splice(dsIndex, 1);\n        this.m_connectedDataSources.delete(dataSource.name);\n        this.m_failedDataSources.delete(dataSource.name);\n\n        this.m_sceneEnvironment.updateBackgroundDataSource();\n\n        this.update();\n    }\n\n    /**\n     * Access the `VisibleTileSet` to get access to all current datasources and their visible tiles.\n     */\n    get visibleTileSet(): VisibleTileSet {\n        return this.m_visibleTiles;\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    addOverlayText(textElements: TextElement[]): void {\n        this.m_textElementsRenderer.addOverlayText(textElements);\n        this.update();\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    clearOverlayText(): void {\n        this.m_textElementsRenderer.clearOverlayText();\n    }\n\n    /**\n     * Adjusts the camera to look at a given geo coordinate with tilt and heading angles.\n     *\n     * @remarks\n     * #### Note on `target` and `bounds`\n     *\n     * If `bounds` are specified, `zoomLevel` and `distance` parameters are ignored and `lookAt`\n     * calculates best zoomLevel (and possibly target) to fit given bounds.\n     *\n     * Following table shows how relation between `bounds` and target.\n     *\n     * | `bounds`             | `target`    | actual `target`\n     * | ------               | ------      | --------\n     * | {@link @here/harp-geoutils#GeoBox}           | _defined_   | `params.target` is used\n     * | {@link @here/harp-geoutils#GeoBox}           | `undefined` | `bounds.center` is used as new `target`\n     * | {@link @here/harp-geoutils#GeoBoxExtentLike} | `undefined` | current `MapView.target` is used\n     * | {@link @here/harp-geoutils#GeoBoxExtentLike} | _defined_   | `params.target` is used\n     * | [[GeoCoordLike]][]   | `undefined` | new `target` is calculated as center of world box covering given points\n     * | [[GeoCoordLike]][]   | _defined_   | `params.target` is used and zoomLevel is adjusted to view all given geo points\n     *\n     * In each case, `lookAt` finds minimum `zoomLevel` that covers given extents or geo points.\n     *\n     * With flat projection, if `bounds` represents points on both sides of anti-meridian, and\n     * {@link MapViewOptions.tileWrappingEnabled} is used, `lookAt` will use this knowledge and find\n     * minimal view that may cover \"next\" or \"previous\" world.\n     *\n     * With sphere projection if `bounds` represents points on both sides of globe, best effort\n     * method is used to find best `target``.\n     *\n     * #### Examples\n     *\n     * ```typescript\n     * mapView.lookAt({heading: 90})\n     *     // look east retaining current `target`, `zoomLevel` and `tilt`\n     *\n     * mapView.lookAt({lat: 40.707, lng: -74.01})\n     *    // look at Manhattan, New York retaining other view params\n     *\n     * mapView.lookAt(bounds: { latitudeSpan: 10, longitudeSpan: 10})\n     *    // look at current `target`, but extending zoomLevel so we see 10 degrees of lat/long span\n     * ```\n     *\n     * @see More examples in [[LookAtExample]].\n     *\n     * @param params - {@link LookAtParams}\n     *\n     * {@labels WITH_PARAMS}\n     */\n    lookAt(params: Partial<LookAtParams>): void;\n\n    /**\n     * The method that sets the camera to the desired angle (`tiltDeg`) and `distance` (in meters)\n     * to the `target` location, from a certain heading (`headingAngle`).\n     *\n     * @remarks\n     * @param target - The location to look at.\n     * @param distance - The distance of the camera to the target in meters.\n     * @param tiltDeg - The camera tilt angle in degrees (0 is vertical), curbed below 89deg\n     *                @default 0\n     * @param headingDeg - The camera heading angle in degrees and clockwise (as opposed to yaw)\n     *                   @default 0\n     * starting north.\n     * @deprecated Use lookAt version with {@link LookAtParams} object parameter.\n     */\n    lookAt(target: GeoCoordLike, distance: number, tiltDeg?: number, headingDeg?: number): void;\n\n    lookAt(\n        targetOrParams: GeoCoordLike | Partial<LookAtParams>,\n        distance?: number,\n        tiltDeg?: number,\n        headingDeg?: number\n    ): void {\n        if (isGeoCoordinatesLike(targetOrParams)) {\n            const zoomLevel =\n                distance !== undefined\n                    ? MapViewUtils.calculateZoomLevelFromDistance(this, distance)\n                    : undefined;\n\n            const params: Partial<LookAtParams> = {\n                target: targetOrParams,\n                zoomLevel,\n                tilt: tiltDeg,\n                heading: headingDeg\n            };\n            this.lookAtImpl(params);\n        } else if (typeof targetOrParams === \"object\") {\n            this.lookAtImpl(targetOrParams as Partial<LookAtParams>);\n        }\n    }\n\n    /**\n     * Moves the camera to the specified {@link @here/harp-geoutils#GeoCoordinates},\n     * sets the desired `zoomLevel` and\n     * adjusts the yaw and pitch.\n     *\n     * @remarks\n     * The pitch of the camera is\n     * always curbed so that the camera cannot\n     * look above the horizon. This paradigm is necessary\n     * in {@link @here/harp-map-controls#MapControls}, where the center of\n     * the screen is used for the orbiting interaction (3 fingers / right mouse button).\n     *\n     * @param geoPos - Geolocation to move the camera to.\n     * @param zoomLevel - Desired zoom level.\n     * @param yawDeg - Camera yaw in degrees, counter-clockwise (as opposed to heading), starting\n     * north.\n     * @param pitchDeg - Camera pitch in degrees.\n     * @deprecated Use {@link (MapView.lookAt:WITH_PARAMS)} instead.\n     */\n    setCameraGeolocationAndZoom(\n        geoPos: GeoCoordinates,\n        zoomLevel: number,\n        yawDeg: number = 0,\n        pitchDeg: number = 0\n    ): void {\n        this.geoCenter = geoPos;\n        let limitedPitch = Math.min(MapViewUtils.MAX_TILT_DEG, pitchDeg);\n        if (this.projection.type === ProjectionType.Spherical) {\n            const maxPitchRadWithCurvature = Math.asin(\n                EarthConstants.EQUATORIAL_RADIUS /\n                    (MapViewUtils.calculateDistanceToGroundFromZoomLevel(this, zoomLevel) +\n                        EarthConstants.EQUATORIAL_RADIUS)\n            );\n            const maxPitchDegWithCurvature = THREE.MathUtils.radToDeg(maxPitchRadWithCurvature);\n            limitedPitch = Math.min(limitedPitch, maxPitchDegWithCurvature);\n        }\n        MapViewUtils.zoomOnTargetPosition(this, 0, 0, zoomLevel);\n        MapViewUtils.setRotation(this, yawDeg, limitedPitch);\n        this.update();\n    }\n\n    /**\n     * Updates the value of a dynamic property.\n     *\n     * @remarks\n     * Property names starting with a `$`-sign are reserved and any attempt to change their value\n     * will result in an error.\n     *\n     * Themes can access dynamic properties using the `Expr` operator `[\"dynamic-properties\"]`,\n     * for example:\n     *\n     *   `[\"get\", \"property name\", [\"dynamic-properties\"]]`\n     *\n     * @param name - The name of the property.\n     * @param value - The value of the property.\n     */\n    setDynamicProperty(name: string, value: Value) {\n        if (name.startsWith(\"$\")) {\n            throw new Error(`failed to update the value of the dynamic property '${name}'`);\n        }\n        this.m_env.entries[name] = value;\n        this.update();\n    }\n\n    /**\n     * Removes the given dynamic property from this {@link MapView}.\n     *\n     * @remarks\n     * Property names starting with a `$`-sign are reserved and any attempt to change their value\n     * will result in an error.\n     *\n     * @param name - The name of the property to remove.\n     */\n    removeDynamicProperty(name: string) {\n        if (name.startsWith(\"$\")) {\n            throw new Error(`failed to remove the dynamic property '${name}'`);\n        }\n        delete this.m_env.entries[name];\n        this.update();\n    }\n\n    /**\n     * Returns `true` if this `MapView` is constantly redrawing the scene.\n     */\n    get animating(): boolean {\n        return this.m_animationCount > 0;\n    }\n\n    /**\n     * Begin animating the scene.\n     */\n    beginAnimation() {\n        if (this.m_animationCount++ === 0) {\n            this.update();\n            this.ANIMATION_STARTED_EVENT.time = Date.now();\n            this.dispatchEvent(this.ANIMATION_STARTED_EVENT);\n        }\n    }\n\n    /**\n     * Stop animating the scene.\n     */\n    endAnimation() {\n        if (this.m_animationCount > 0) {\n            --this.m_animationCount;\n        }\n\n        if (this.m_animationCount === 0) {\n            this.ANIMATION_FINISHED_EVENT.time = Date.now();\n            this.dispatchEvent(this.ANIMATION_FINISHED_EVENT);\n        }\n    }\n\n    /**\n     * Returns `true` if the camera moved in the last frame.\n     */\n    get cameraIsMoving() {\n        return this.m_movementDetector.cameraIsMoving;\n    }\n\n    /**\n     * Returns `true` if the current frame will immediately be followed by another frame.\n     * @deprecated This should only be used for the internal handling of the render loop,\n     * if you use your own RenderLoop use {@link MapView::renderSync} in combination with\n     * {@link MapViewEventNames.FrameComplete}\n     **/\n    get isDynamicFrame(): boolean {\n        return (\n            !this.m_visibleTiles.allVisibleTilesLoaded ||\n            this.m_themeManager.isUpdating() ||\n            this.cameraIsMoving ||\n            this.animating ||\n            this.m_updatePending ||\n            this.m_animatedExtrusionHandler.isAnimating ||\n            this.m_textElementsRenderer.isUpdatePending ||\n            this.m_textElementsRenderer.loading\n        );\n    }\n\n    /**\n     * Returns the ratio between a pixel and a world unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get pixelToWorld(): number {\n        if (this.m_pixelToWorld === undefined) {\n            // At this point fov calculation should be always defined.\n            assert(this.m_options.fovCalculation !== undefined);\n            // NOTE: Look at distance is the distance to camera focus (and pivot) point.\n            // In screen space this point is located in the center of canvas.\n            // Given that zoom level is not modified (clamped by camera pitch), the following\n            // formulas are all equivalent:\n            // lookAtDistance = (EQUATORIAL_CIRCUMFERENCE * focalLength) / (256 * zoomLevel^2);\n            // lookAtDistance = abs(cameraPos.z) / cos(cameraPitch);\n            // Here we may use precalculated target distance (once pre frame):\n            const lookAtDistance = this.m_targetDistance;\n            const focalLength = CameraUtils.getFocalLength(this.m_camera);\n            assert(focalLength !== undefined);\n\n            // Find world space object size that corresponds to one pixel on screen.\n            this.m_pixelToWorld = CameraUtils.convertScreenToWorldSize(\n                focalLength!,\n                lookAtDistance,\n                1\n            );\n        }\n        return this.m_pixelToWorld;\n    }\n\n    /**\n     * Returns the ratio between a world and a pixel unit for the current camera (in the center of\n     * the camera projection).\n     */\n    get worldToPixel() {\n        return 1.0 / this.pixelToWorld;\n    }\n\n    get pixelRatio(): number {\n        if (this.m_pixelRatio !== undefined) {\n            return this.m_pixelRatio;\n        }\n        return typeof window !== \"undefined\" && window.devicePixelRatio !== undefined\n            ? window.devicePixelRatio\n            : 1.0;\n    }\n\n    /**\n     * PixelRatio in the WebGlRenderer. May contain values > 1.0 for high resolution screens\n     * (HiDPI).\n     *\n     * @remarks\n     * A value of `undefined` will make the getter return `window.devicePixelRatio`, setting a value\n     * of `1.0` will disable the use of HiDPI on all devices.\n     *\n     * @note Since the current pixelRatio may have been used in some calculations (e.g. the icons)\n     * they may appear in the wrong size now. To ensure proper display of data, a call to\n     * `clearTileCache()` is required if the pixelRatio is changed after tiles have been loaded.\n     *\n     * @memberof MapView\n     */\n    set pixelRatio(pixelRatio: number) {\n        this.m_pixelRatio = pixelRatio;\n        if (this.renderer.getPixelRatio() !== this.pixelRatio) {\n            this.renderer.setPixelRatio(this.pixelRatio);\n        }\n    }\n\n    /**\n     * Maximum FPS (Frames Per Second).\n     *\n     * @remarks\n     * If VSync in enabled, the specified number may not be\n     * reached, but instead the next smaller number than `maxFps` that is equal to the refresh rate\n     * divided by an integer number.\n     *\n     * E.g.: If the monitors refresh rate is set to 60hz, and if `maxFps` is set to a value of `40`\n     * (60hz/1.5), the actual used FPS may be 30 (60hz/2). For displays that have a refresh rate of\n     * 60hz, good values for `maxFps` are 30, 20, 15, 12, 10, 6, 3 and 1. A value of `0` is ignored.\n     */\n    set maxFps(value: number) {\n        this.m_options.maxFps = value;\n        this.m_taskScheduler.maxFps = value;\n    }\n\n    get maxFps(): number {\n        //this cannot be undefined, as it is defaulting to 0 in the constructor\n        return this.m_options.maxFps as number;\n    }\n\n    /**\n     * PixelRatio ratio for rendering when the camera is moving or an animation is running.\n     *\n     * @remarks\n     * Useful when rendering on high resolution displays with low performance GPUs\n     * that may be fill-rate-limited.\n     *\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. Values between 0.5 and\n     * `window.devicePixelRatio` can be tried to give  good results. The value should not be larger\n     * than `window.devicePixelRatio`.\n     *\n     * @note Since no anti-aliasing is applied during dynamic rendering with `dynamicPixelRatio`\n     * defined, visual artifacts may occur, especially with thin lines..\n     *\n     * @note The resolution of icons and text labels is not affected.\n     *\n     * @default `undefined`\n     */\n    set dynamicPixelRatio(ratio: number | undefined) {\n        this.mapRenderingManager.lowResPixelRatio = ratio;\n    }\n\n    get dynamicPixelRatio(): number | undefined {\n        return this.mapRenderingManager.lowResPixelRatio;\n    }\n\n    /**\n     * Returns the screen position of the given geo or world position.\n     *\n     * @param pos - The position as a {@link @here/harp-geoutils#GeoCoordLike} or\n     * {@link https://threejs.org/docs/#api/en/math/Vector3 | THREE.Vector3} world position.\n     * @returns The screen position in CSS/client coordinates (no pixel ratio applied) or\n     * `undefined`.\n     */\n    getScreenPosition(pos: GeoCoordLike | THREE.Vector3): THREE.Vector2 | undefined {\n        if (isVector3Like(pos)) {\n            cache.vector3[0].copy(pos);\n        } else {\n            this.projection.projectPoint(GeoCoordinates.fromObject(pos), cache.vector3[0]);\n        }\n        const p = this.m_screenProjector.project(cache.vector3[0]);\n        if (p !== undefined) {\n            const { width, height } = this.getCanvasClientSize();\n            p.x = p.x + width / 2;\n            p.y = height - (p.y + height / 2);\n        }\n        return p;\n    }\n\n    getWorldPositionAt(x: number, y: number, fallback: true): THREE.Vector3;\n    getWorldPositionAt(x: number, y: number, fallback?: boolean): THREE.Vector3 | null;\n\n    /**\n     * Returns the world space position from the given screen position.\n     *\n     * @remarks\n     * If `fallback !== true` the return value can be `null`, in case the camera has a high tilt\n     * and the given `(x, y)` value is not intersecting the ground plane.\n     * If `fallback === true` the return value will always exist but it might not be on the earth\n     * surface.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     * @param fallback - Whether to compute a fallback position if the earth surface is not hit.\n     */\n    getWorldPositionAt(x: number, y: number, fallback?: boolean): THREE.Vector3 | null {\n        this.m_raycaster.setFromCamera(this.getNormalizedScreenCoordinates(x, y), this.m_camera);\n        const worldPos =\n            this.projection.type === ProjectionType.Spherical\n                ? this.m_raycaster.ray.intersectSphere(this.m_sphere, cache.vector3[0])\n                : this.m_raycaster.ray.intersectPlane(this.m_plane, cache.vector3[0]);\n\n        if (worldPos === null && fallback === true) {\n            // Fall back to the far plane\n            const cosAlpha = this.m_camera\n                .getWorldDirection(cache.vector3[0])\n                .dot(this.m_raycaster.ray.direction);\n\n            return cache.vector3[0]\n                .copy(this.m_raycaster.ray.direction)\n                .multiplyScalar(this.m_camera.far / cosAlpha)\n                .add(this.m_camera.position);\n        }\n        return worldPos;\n    }\n\n    /**\n     * Same as {@link MapView.getGeoCoordinatesAt} but always returning a geo coordinate.\n     */\n    getGeoCoordinatesAt(x: number, y: number, fallback: true): GeoCoordinates;\n\n    /**\n     * Returns the {@link @here/harp-geoutils#GeoCoordinates} from the\n     * given screen position.\n     *\n     * @remarks\n     * If `fallback !== true` the return value can be `null`, in case the camera has a high tilt\n     * and the given `(x, y)` value is not intersecting the ground plane.\n     * If `fallback === true` the return value will always exist but it might not be on the earth\n     * surface.\n     * If {@link MapView.tileWrappingEnabled} is `true` the returned geo coordinates will have a\n     * longitude clamped to [-180,180] degrees.\n     * The returned geo coordinates are not normalized so that a map object placed at that position\n     * will be below the (x,y) screen coordinates, regardless which world repetition was on screen.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     * @param fallback - Whether to compute a fallback position if the earth surface is not hit.\n     * @returns Un-normalized geo coordinates\n     */\n    getGeoCoordinatesAt(x: number, y: number, fallback?: boolean): GeoCoordinates | null;\n\n    getGeoCoordinatesAt(x: number, y: number, fallback?: boolean): GeoCoordinates | null {\n        const worldPosition = this.getWorldPositionAt(x, y, fallback);\n        if (!worldPosition) {\n            return null;\n        }\n\n        const geoPos = this.projection.unprojectPoint(worldPosition);\n        if (!this.tileWrappingEnabled && this.projection.type === ProjectionType.Planar) {\n            // When the map is not wrapped we clamp the longitude\n            geoPos.longitude = THREE.MathUtils.clamp(geoPos.longitude, -180, 180);\n        }\n        return geoPos;\n    }\n\n    /**\n     * Returns the normalized screen coordinates from the given pixel position.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     */\n    getNormalizedScreenCoordinates(x: number, y: number): THREE.Vector3 {\n        // use clientWidth and clientHeight as it does not apply the pixelRatio and\n        // therefore supports also HiDPI devices\n        const { width, height } = this.getCanvasClientSize();\n        return new THREE.Vector3((x / width) * 2 - 1, -((y / height) * 2) + 1, 0);\n    }\n\n    /**\n     * Do a raycast on all objects in the scene. Useful for picking.\n     *\n     * @remarks\n     * Limited to objects that THREE.js can raycast, the solid lines\n     * that get their geometry in the shader cannot be tested\n     * for intersection.\n     *\n     * Note, if a {@link DataSource} adds an [[Object3D]]\n     * to a {@link Tile}, it will be only pickable once\n     * {@link MapView.render} has been called, this is because\n     * {@link MapView.render} method creates the\n     * internal three.js root [[Object3D]] which is used in the [[PickHandler]] internally.\n     * This method will not test for intersection custom objects added to the scene by for\n     * example calling directly the [[scene.add]] method from THREE.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     * @param parameters - The intersection test behaviour may be adjusted by providing an instance\n     * of {@link IntersectParams}.\n     * @returns The list of intersection results.\n     */\n    intersectMapObjects(x: number, y: number, parameters?: IntersectParams): PickResult[] {\n        return this.m_pickHandler.intersectMapObjects(x, y, parameters);\n    }\n\n    /**\n     * Resize the HTML canvas element and the THREE.js `WebGLRenderer`.\n     *\n     * @param width - The new width.\n     * @param height - The new height.\n     */\n    resize(width: number, height: number) {\n        this.m_renderer.setSize(width, height, false);\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n\n        if (this.mapRenderingManager !== undefined) {\n            this.mapRenderingManager.setSize(width, height);\n        }\n\n        if (this.collisionDebugCanvas !== undefined) {\n            this.collisionDebugCanvas.width = width;\n            this.collisionDebugCanvas.height = height;\n        }\n\n        this.updateCameras();\n        this.update();\n\n        this.dispatchEvent({\n            type: MapViewEventNames.Resize,\n            size: {\n                width,\n                height\n            }\n        });\n    }\n\n    /**\n     * Redraws scene immediately\n     *\n     * @remarks\n     * @note Before using this method, set `synchronousRendering` to `true`\n     * in the {@link MapViewOptions}\n     *\n     * @param frameStartTime - Optional timestamp for start of frame.\n     * Default: [[PerformanceTimer.now()]]\n     */\n    renderSync(frameStartTime?: number) {\n        if (frameStartTime === undefined) {\n            frameStartTime = PerformanceTimer.now();\n        }\n        this.render(frameStartTime);\n    }\n\n    /**\n     * Requests a redraw of the scene.\n     */\n    update() {\n        if (this.disposed) {\n            logger.warn(\"update(): MapView has been disposed of.\");\n            return;\n        }\n\n        this.dispatchEvent(this.UPDATE_EVENT);\n\n        // Skip if update is already in progress\n        if (this.m_updatePending) {\n            return;\n        }\n\n        // Set update flag\n        this.m_updatePending = true;\n\n        this.startRenderLoop();\n    }\n\n    /**\n     * Returns `true` if an update has already been requested, such that after a currently rendering\n     * frame, the next frame will be rendered immediately.\n     */\n    get updatePending(): boolean {\n        return this.m_updatePending;\n    }\n\n    /**\n     * Requests a redraw of the scene.\n     * @deprecated Use the [[update]] method instead.\n     */\n    requestUpdateIfNeeded() {\n        this.update();\n    }\n\n    /**\n     * Clear the tile cache.\n     *\n     * @remarks\n     * Remove the {@link Tile} objects created by cacheable\n     * {@link DataSource}s. If a {@link DataSource} name is\n     * provided, this method restricts the eviction the {@link DataSource} with the given name.\n     *\n     * @param dataSourceName - The name of the {@link DataSource}.\n     * @param filter Optional tile filter\n     */\n    clearTileCache(dataSourceName?: string, filter?: (tile: Tile) => boolean) {\n        if (this.m_visibleTiles === undefined) {\n            // This method is called in the shadowsEnabled function, which is initialized in the\n            // setupRenderer function,\n            return;\n        }\n        if (dataSourceName !== undefined) {\n            const dataSource = this.getDataSourceByName(dataSourceName);\n            if (dataSource) {\n                this.m_visibleTiles.clearTileCache(dataSource, filter);\n                dataSource.clearCache();\n            }\n        } else {\n            this.m_visibleTiles.clearTileCache(undefined, filter);\n            this.m_tileDataSources.forEach(dataSource => dataSource.clearCache());\n        }\n\n        if (this.m_elevationProvider !== undefined) {\n            this.m_elevationProvider.clearCache();\n        }\n    }\n\n    /**\n     * Apply visitor to all visible tiles.\n     *\n     * @param fun - Visitor function\n     */\n    forEachVisibleTile(fun: (tile: Tile) => void) {\n        this.m_visibleTiles.forEachVisibleTile(fun);\n    }\n\n    /**\n     * Apply a visitor function to all tiles in the cache.\n     *\n     * @param visitor - Visitor function\n     */\n    forEachCachedTile(visitor: (tile: Tile) => void) {\n        this.m_visibleTiles.forEachCachedTile(visitor);\n    }\n\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     * @remarks\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance\n     * are processed. If `undefined`, tiles from all {@link DataSource}s are processed.\n     * @param filter Optional tile filter\n     */\n    markTilesDirty(dataSource?: DataSource, filter?: (tile: Tile) => boolean) {\n        this.m_visibleTiles.markTilesDirty(dataSource, filter);\n        this.update();\n    }\n\n    /**\n     * Sets the DataSource which contains the elevations, the elevation range source, and the\n     * elevation provider.\n     *\n     * @remarks\n     * Only a single elevation source is possible per {@link MapView}.\n     * If the terrain-datasource is merged with this repository, we could internally construct\n     * the {@link ElevationRangeSource} and the {@link ElevationProvider}\n     * and access would be granted to\n     * the application when it asks for it, to simplify the API.\n     *\n     * @param elevationSource - The datasource containing the terrain tiles.\n     * @param elevationRangeSource - Allows access to the elevation min / max per tile.\n     * @param elevationProvider - Allows access to the elevation at a given location or a ray\n     *      from the camera.\n     */\n    async setElevationSource(\n        elevationSource: DataSource,\n        elevationRangeSource: ElevationRangeSource,\n        elevationProvider: ElevationProvider\n    ) {\n        // Remove previous elevation source if present\n        if (this.m_elevationSource && this.m_elevationSource !== elevationSource) {\n            this.removeDataSource(this.m_elevationSource);\n        }\n\n        // Add as datasource if it was not added before\n        const isPresent = this.m_tileDataSources.includes(elevationSource);\n        if (!isPresent) {\n            await this.addDataSource(elevationSource);\n        }\n        this.m_elevationSource = elevationSource;\n        this.m_elevationRangeSource = elevationRangeSource;\n        if (!this.m_elevationRangeSource.ready()) {\n            await this.m_elevationRangeSource.connect();\n        }\n        this.m_elevationProvider = elevationProvider;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(true);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback((tile: Tile) => {\n            overlayOnElevation(tile);\n        });\n        this.clearTileCache();\n    }\n\n    /**\n     * Clears any elevation sources and provider previously set.\n     * @param elevationSource - The datasource to be cleared.\n     */\n    clearElevationSource(elevationSource: DataSource) {\n        this.removeDataSource(elevationSource);\n        this.m_elevationSource = undefined;\n        this.m_elevationRangeSource = undefined;\n        this.m_elevationProvider = undefined;\n        this.dataSources.forEach(dataSource => {\n            dataSource.setEnableElevationOverlay(false);\n        });\n        this.m_tileGeometryManager.setTileUpdateCallback(undefined);\n        this.clearTileCache();\n    }\n\n    /**\n     * Public access to {@link MapViewFog} allowing to toggle it by setting its `enabled` property.\n     */\n    get fog(): MapViewFog {\n        return this.m_sceneEnvironment.fog;\n    }\n\n    private setPostEffects() {\n        // First clear all the effects, then enable them from what is specified.\n        this.mapRenderingManager.bloom.enabled = false;\n        this.mapRenderingManager.outline.enabled = false;\n        this.mapRenderingManager.vignette.enabled = false;\n        this.mapRenderingManager.sepia.enabled = false;\n\n        if (this.m_postEffects !== undefined) {\n            if (this.m_postEffects.bloom !== undefined) {\n                this.mapRenderingManager.bloom = this.m_postEffects.bloom;\n            }\n            if (this.m_postEffects.outline !== undefined) {\n                this.mapRenderingManager.outline.enabled = this.m_postEffects.outline.enabled;\n                this.mapRenderingManager.updateOutline(this.m_postEffects.outline);\n            }\n            if (this.m_postEffects.vignette !== undefined) {\n                this.mapRenderingManager.vignette = this.m_postEffects.vignette;\n            }\n            if (this.m_postEffects.sepia !== undefined) {\n                this.mapRenderingManager.sepia = this.m_postEffects.sepia;\n            }\n        }\n    }\n\n    /**\n     * Returns the elevation provider.\n     */\n    get elevationProvider(): ElevationProvider | undefined {\n        return this.m_elevationProvider;\n    }\n\n    /**\n     * @beta\n     */\n    get throttlingEnabled(): boolean {\n        return this.m_taskScheduler.throttlingEnabled === true;\n    }\n\n    /**\n     * @beta\n     */\n    set throttlingEnabled(enabled: boolean) {\n        this.m_taskScheduler.throttlingEnabled = enabled;\n    }\n\n    get shadowsEnabled(): boolean {\n        return this.m_options.enableShadows === true;\n    }\n\n    set shadowsEnabled(enabled: boolean) {\n        // shadowMap is undefined if we are testing (three.js always set it to be defined).\n        if (\n            this.m_renderer.shadowMap === undefined ||\n            enabled === this.m_renderer.shadowMap.enabled\n        ) {\n            return;\n        }\n        this.m_options.enableShadows = enabled;\n        // There is a bug in three.js where this doesn't currently work once enabled.\n        this.m_renderer.shadowMap.enabled = enabled;\n        // TODO: Make this configurable. Note, there is currently issues when using the\n        // VSMShadowMap type, this should be investigated if this type is requested.\n        this.m_renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        this.clearTileCache();\n    }\n\n    private extractAttitude() {\n        const camera = this.m_camera;\n        const projection = this.projection;\n\n        const cameraPos = cache.vector3[1];\n        const transform = cache.transform[0];\n        const tangentSpaceMatrix = cache.matrix4[1];\n        // 1. Build the matrix of the tangent space of the camera.\n        cameraPos.setFromMatrixPosition(camera.matrixWorld); // Ensure using world position.\n        projection.localTangentSpace(this.m_targetGeoPos, transform);\n        tangentSpaceMatrix.makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);\n\n        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.\n        cache.matrix4[0].copy(tangentSpaceMatrix).invert().multiply(camera.matrixWorld);\n        transform.xAxis.setFromMatrixColumn(cache.matrix4[0], 0);\n        transform.yAxis.setFromMatrixColumn(cache.matrix4[0], 1);\n        transform.zAxis.setFromMatrixColumn(cache.matrix4[0], 2);\n\n        // 3. Deduce orientation from the base axes.\n        let yaw = 0;\n        let pitch = 0;\n        let roll = 0;\n\n        // Decompose rotation matrix into Z0 X Z1 Euler angles.\n        const epsilon = 1e-10;\n        const d = transform.zAxis.dot(cameraPos.set(0, 0, 1));\n        if (d < 1.0 - epsilon) {\n            if (d > -1.0 + epsilon) {\n                yaw = Math.atan2(transform.zAxis.x, -transform.zAxis.y);\n                pitch = Math.acos(transform.zAxis.z);\n                roll = Math.atan2(transform.xAxis.x, transform.yAxis.z);\n            } else {\n                // Looking bottom-up with space.z.z == -1.0\n                yaw = -Math.atan2(-transform.yAxis.x, transform.xAxis.x);\n                pitch = 180;\n                roll = 0;\n            }\n        } else {\n            // Looking top-down with space.z.z == 1.0\n            yaw = Math.atan2(-transform.yAxis.x, transform.xAxis.x);\n            pitch = 0.0;\n            roll = 0.0;\n        }\n\n        return {\n            yaw,\n            pitch,\n            roll\n        };\n    }\n\n    private lookAtImpl(params: Partial<LookAtParams>): void {\n        const tilt = Math.min(getOptionValue(params.tilt, this.tilt), MapViewUtils.MAX_TILT_DEG);\n        const heading = getOptionValue(params.heading, this.heading);\n        const distance =\n            params.zoomLevel !== undefined\n                ? MapViewUtils.calculateDistanceFromZoomLevel(\n                      this,\n                      THREE.MathUtils.clamp(\n                          params.zoomLevel,\n                          this.m_minZoomLevel,\n                          this.m_maxZoomLevel\n                      )\n                  )\n                : params.distance !== undefined\n                ? params.distance\n                : this.m_targetDistance;\n\n        let target: GeoCoordinates | undefined;\n        if (params.bounds !== undefined) {\n            let geoPoints: GeoCoordLike[];\n\n            if (params.bounds instanceof GeoBox) {\n                target = params.target\n                    ? GeoCoordinates.fromObject(params.target)\n                    : params.bounds.center;\n                geoPoints = MapViewUtils.geoBoxToGeoPoints(params.bounds);\n            } else if (params.bounds instanceof GeoPolygon) {\n                target = params.bounds.getCentroid();\n                geoPoints = params.bounds.coordinates;\n            } else if (isGeoBoxExtentLike(params.bounds)) {\n                target = params.target ? GeoCoordinates.fromObject(params.target) : this.target;\n                const box = GeoBox.fromCenterAndExtents(target, params.bounds);\n                geoPoints = MapViewUtils.geoBoxToGeoPoints(box);\n            } else if (Array.isArray(params.bounds)) {\n                geoPoints = params.bounds;\n                if (params.target !== undefined) {\n                    target = GeoCoordinates.fromObject(params.target);\n                }\n            } else {\n                throw Error(\"#lookAt: Invalid 'bounds' value\");\n            }\n            if (\n                // if the points are created from the corners of the geoBox don't cluster them\n                !(params.bounds instanceof GeoBox || params.bounds instanceof GeoPolygon) &&\n                this.m_tileWrappingEnabled &&\n                this.projection.type === ProjectionType.Planar\n            ) {\n                // In flat projection, with wrap around enabled, we should detect clusters of\n                // points around  anti-meridian and possible move some points to sibling worlds.\n                //\n                // Here, we fit points into minimal geo box taking world wrapping into account.\n                geoPoints = MapViewUtils.wrapGeoPointsToScreen(geoPoints, target!);\n            }\n            const worldPoints = geoPoints.map(point =>\n                this.projection.projectPoint(GeoCoordinates.fromObject(point), new THREE.Vector3())\n            );\n            const worldTarget = new THREE.Vector3();\n            if (target! === undefined) {\n                const box = new THREE.Box3().setFromPoints(worldPoints);\n                box.getCenter(worldTarget);\n                this.projection.scalePointToSurface(worldTarget);\n                target = this.projection.unprojectPoint(worldTarget);\n            } else {\n                this.projection.projectPoint(target, worldTarget);\n            }\n\n            if (params.zoomLevel !== undefined || params.distance !== undefined) {\n                return this.lookAtImpl({\n                    tilt,\n                    heading,\n                    distance,\n                    target\n                });\n            }\n\n            return this.lookAtImpl(\n                MapViewUtils.getFitBoundsLookAtParams(target, worldTarget, worldPoints, {\n                    tilt,\n                    heading,\n                    minDistance: MapViewUtils.calculateDistanceFromZoomLevel(\n                        this,\n                        this.maxZoomLevel\n                    ),\n                    projection: this.projection,\n                    camera: this.camera\n                })\n            );\n        }\n        target =\n            params.target !== undefined ? GeoCoordinates.fromObject(params.target) : this.target;\n\n        // MapViewUtils#setRotation uses pitch, not tilt, which is different in sphere projection.\n        // But in sphere, in the tangent space of the target of the camera, pitch = tilt. So, put\n        // the camera on the target, so the tilt can be passed to getRotation as a pitch.\n        MapViewUtils.getCameraRotationAtTarget(\n            this.projection,\n            target,\n            -heading,\n            tilt,\n            this.camera.quaternion\n        );\n        MapViewUtils.getCameraPositionFromTargetCoordinates(\n            target,\n            distance,\n            -heading,\n            tilt,\n            this.projection,\n            this.camera.position\n        );\n        this.camera.updateMatrixWorld(true);\n\n        // Make sure to update all properties that are accessible via API (e.g. zoomlevel) b/c\n        // otherwise they would be updated as recently as in the next animation frame.\n        this.updateLookAtSettings();\n        this.update();\n    }\n\n    /**\n     * Plug-in PolarTileDataSource for spherical projection and plug-out otherwise\n     */\n    private updatePolarDataSource() {\n        const dataSource = this.m_polarDataSource;\n        if (this.m_enablePolarDataSource === true && dataSource !== undefined) {\n            const twinDataSource = this.getDataSourceByName(dataSource.name);\n\n            if (this.projection.type === ProjectionType.Spherical) {\n                if (twinDataSource === undefined) {\n                    this.addDataSource(dataSource);\n                }\n            } else {\n                if (twinDataSource !== undefined) {\n                    this.removeDataSource(dataSource);\n                }\n            }\n        }\n    }\n\n    /**\n     * Updates the camera and the projections and resets the screen collisions,\n     * note, setupCamera must be called before this is called.\n     *\n     * @remarks\n     * @param viewRanges - optional parameter that supplies new view ranges, most importantly\n     * near/far clipping planes distance. If parameter is not provided view ranges will be\n     * calculated from [[ClipPlaneEvaluator]] used in {@link VisibleTileSet}.\n     */\n    private updateCameras(viewRanges?: ViewRanges) {\n        // Update look at settings first, so that other components (e.g. ClipPlanesEvaluator) get\n        // the up to date tilt, targetDistance, ...\n        this.m_camera.updateMatrixWorld(false);\n        this.updateLookAtSettings();\n\n        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);\n        this.m_camera.aspect =\n            this.m_forceCameraAspect !== undefined ? this.m_forceCameraAspect : width / height;\n        this.setFovOnCamera(this.m_options.fovCalculation!, height);\n\n        // When calculating clip planes account for the highest building on the earth,\n        // multiplying its height by projection scaling factor. This approach assumes\n        // constantHeight property of extruded polygon technique is set as default false,\n        // otherwise the near plane margins will be bigger then required, but still correct.\n        const projectionScale = this.projection.getScaleFactor(this.camera.position);\n        const maxGeometryHeightScaled =\n            projectionScale *\n            this.m_tileDataSources.reduce((r, ds) => Math.max(r, ds.maxGeometryHeight), 0);\n\n        const minGeometryHeightScaled =\n            projectionScale *\n            this.m_tileDataSources.reduce((r, ds) => Math.min(r, ds.minGeometryHeight), 0);\n\n        // Copy all properties from new view ranges to our readonly object.\n        // This allows to keep all view ranges references valid and keeps up-to-date\n        // information within them. Works the same as copping all properties one-by-one.\n        Object.assign(\n            this.m_viewRanges,\n            viewRanges === undefined\n                ? this.m_visibleTiles.updateClipPlanes(\n                      maxGeometryHeightScaled,\n                      minGeometryHeightScaled\n                  )\n                : viewRanges\n        );\n        this.m_camera.near = this.m_viewRanges.near;\n        this.m_camera.far = this.m_viewRanges.far;\n\n        this.m_camera.updateProjectionMatrix();\n\n        // Update the \"relative to eye\" camera. Copy the public camera parameters\n        // and place the \"relative to eye\" at the world's origin.\n        this.m_rteCamera.copy(this.m_camera);\n        this.m_rteCamera.position.setScalar(0);\n        this.m_rteCamera.updateMatrixWorld(true);\n\n        this.m_textElementsRenderer?.updateCamera();\n\n        this.m_screenProjector.update(this.camera, width, height);\n\n        this.m_pixelToWorld = undefined;\n        this.m_sceneEnvironment.update();\n    }\n\n    /**\n     * Derive the look at settings (i.e. target, zoom, ...) from the current camera.\n     */\n    private updateLookAtSettings() {\n        let { target, distance, final } = MapViewUtils.getTargetAndDistance(\n            this.projection,\n            this.camera,\n            this.elevationProvider\n        );\n        if (!final) {\n            this.update();\n        }\n        if (this.geoMaxBounds) {\n            ({ target, distance } = MapViewUtils.constrainTargetAndDistanceToViewBounds(\n                target,\n                distance,\n                this\n            ));\n        }\n\n        this.m_targetWorldPos.copy(target);\n        this.m_targetGeoPos = this.projection.unprojectPoint(this.m_targetWorldPos);\n        this.m_targetDistance = distance;\n        this.m_zoomLevel = MapViewUtils.calculateZoomLevelFromDistance(this, this.m_targetDistance);\n\n        const { yaw, pitch, roll } = this.extractAttitude();\n        this.m_yaw = yaw;\n        this.m_pitch = pitch;\n        this.m_roll = roll;\n    }\n\n    /**\n     * Update `Env` instance used for style `Expr` evaluations.\n     */\n    private updateEnv() {\n        this.m_env.entries.$zoom = this.m_zoomLevel;\n\n        // This one introduces unnecessary calculation of pixelToWorld, even if it's barely\n        // used in our styles.\n        this.m_env.entries.$pixelToMeters = this.pixelToWorld;\n\n        this.m_env.entries.$frameNumber = this.m_frameNumber;\n    }\n\n    /**\n     * Transfer the NDC point to view space.\n     * @param vector - Vector to transform.\n     * @param result - Result to place calculation.\n     */\n    public ndcToView(vector: Vector3Like, result: THREE.Vector3): THREE.Vector3 {\n        result\n            .set(vector.x, vector.y, vector.z)\n            .applyMatrix4(this.camera.projectionMatrixInverse)\n            // Make sure to apply rotation, hence use the rte camera\n            .applyMatrix4(this.m_rteCamera.matrixWorld);\n        return result;\n    }\n\n    /**\n     * Render loop callback that should only be called by [[requestAnimationFrame]].\n     * Will trigger [[requestAnimationFrame]] again if updates are pending or  animation is running.\n     * @param frameStartTime - The start time of the current frame\n     */\n    private renderLoop(frameStartTime: number) {\n        // Render loop shouldn't run when synchronous rendering is enabled or if `MapView` has been\n        // disposed of.\n        if (this.m_options.synchronousRendering === true || this.disposed) {\n            return;\n        }\n\n        if (this.maxFps === 0) {\n            // Render with max fps\n            this.render(frameStartTime);\n        } else {\n            // Limit fps by skipping frames\n\n            // Magic ingredient to compensate time flux.\n            const fudgeTimeInMs = 3;\n            const frameInterval = 1000 / this.maxFps;\n            const previousFrameTime =\n                this.m_previousFrameTimeStamp === undefined ? 0 : this.m_previousFrameTimeStamp;\n            const targetTime = previousFrameTime + frameInterval - fudgeTimeInMs;\n\n            if (frameStartTime >= targetTime) {\n                this.render(frameStartTime);\n            }\n        }\n\n        // Continue rendering if update is pending or animation is running\n        if (this.isDynamicFrame) {\n            this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);\n        } else {\n            // Stop rendering if no update is pending\n            this.m_animationFrameHandle = undefined;\n        }\n    }\n\n    /**\n     * Start render loop if not already running.\n     */\n    private startRenderLoop() {\n        if (this.m_animationFrameHandle !== undefined || this.m_options.synchronousRendering) {\n            return;\n        }\n\n        this.m_animationFrameHandle = requestAnimationFrame(this.handleRequestAnimationFrame);\n    }\n\n    /**\n     * Returns the list of the enabled data sources.\n     */\n    private getEnabledTileDataSources(): DataSource[] {\n        // ### build this list once decoders && datasources are ready\n\n        const enabledDataSources: DataSource[] = [];\n\n        for (const dataSource of this.m_tileDataSources) {\n            if (this.isDataSourceEnabled(dataSource)) {\n                enabledDataSources.push(dataSource);\n            }\n        }\n\n        return enabledDataSources;\n    }\n\n    /**\n     * Renders the current frame.\n     */\n    private render(frameStartTime: number): void {\n        if (this.m_drawing) {\n            return;\n        }\n\n        if (this.disposed) {\n            logger.warn(\"render(): MapView has been disposed of.\");\n            return;\n        }\n\n        this.RENDER_EVENT.time = frameStartTime;\n        this.dispatchEvent(this.RENDER_EVENT);\n\n        this.m_tileObjectRenderer.prepareRender();\n\n        ++this.m_frameNumber;\n\n        let currentFrameEvent: FrameStats | undefined;\n        const stats = PerformanceStatistics.instance;\n        const gatherStatistics: boolean = stats.enabled;\n        if (gatherStatistics) {\n            currentFrameEvent = stats.currentFrame;\n\n            if (this.m_previousFrameTimeStamp !== undefined) {\n                // In contrast to fullFrameTime we also measure the application code\n                // for the FPS. This means FPS != 1000 / fullFrameTime.\n                const timeSincePreviousFrame = frameStartTime - this.m_previousFrameTimeStamp;\n                currentFrameEvent.setValue(\"render.fps\", 1000 / timeSincePreviousFrame);\n            }\n\n            // We store the last frame statistics at the beginning of the next frame b/c additional\n            // work (i.e. geometry creation) is done outside of the animation frame but still needs\n            // to be added to the `fullFrameTime` (see [[TileGeometryLoader]]).\n            stats.storeAndClearFrameInfo();\n\n            currentFrameEvent = currentFrameEvent as FrameStats;\n            currentFrameEvent.setValue(\"renderCount.frameNumber\", this.m_frameNumber);\n        }\n\n        this.m_previousFrameTimeStamp = frameStartTime;\n\n        let setupTime: number | undefined;\n        let cullTime: number | undefined;\n        let textPlacementTime: number | undefined;\n        let drawTime: number | undefined;\n        let textDrawTime: number | undefined;\n        let endTime: number | undefined;\n\n        this.m_renderer.info.reset();\n\n        this.m_updatePending = false;\n        this.m_thisFrameTilesChanged = undefined;\n\n        this.m_drawing = true;\n\n        if (this.m_renderer.getPixelRatio() !== this.pixelRatio) {\n            this.m_renderer.setPixelRatio(this.pixelRatio);\n        }\n\n        this.updateCameras();\n        this.updateEnv();\n\n        this.m_renderer.clear();\n\n        // clear the scenes\n        this.m_sceneRoot.children.length = 0;\n        this.m_overlaySceneRoot.children.length = 0;\n\n        if (gatherStatistics) {\n            setupTime = PerformanceTimer.now();\n        }\n\n        // TBD: Update renderList only any of its params (camera, etc...) has changed.\n        if (!this.lockVisibleTileSet) {\n            const viewRangesStatus = this.m_visibleTiles.updateRenderList(\n                this.storageLevel,\n                Math.floor(this.zoomLevel),\n                this.getEnabledTileDataSources(),\n                this.m_frameNumber,\n                this.m_elevationRangeSource\n            );\n            // View ranges has changed due to features (with elevation) that affects clip planes\n            // positioning, update cameras with new clip planes positions.\n            if (viewRangesStatus.viewRangesChanged) {\n                this.updateCameras(viewRangesStatus.viewRanges);\n            }\n        }\n\n        if (gatherStatistics) {\n            cullTime = PerformanceTimer.now();\n        }\n\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n\n        // no need to check everything if we're not going to create text renderer.\n        renderList.forEach(({ zoomLevel, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                this.m_tileObjectRenderer.render(\n                    tile,\n                    zoomLevel,\n                    this.zoomLevel,\n                    this.m_camera.position,\n                    this.m_sceneRoot\n                );\n\n                //We know that rendered tiles are visible (in the view frustum), so we update the\n                //frame number, note we don't do this for the visibleTiles because some may still be\n                //loading (and therefore aren't visible in the sense of being seen on the screen).\n                //Note also, this number isn't currently used anywhere so should be considered to be\n                //removed in the future (though could be good for debugging purposes).\n                tile.frameNumLastVisible = this.m_frameNumber;\n            });\n        });\n\n        this.m_mapAnchors.update(\n            this.projection,\n            this.camera.position,\n            this.m_sceneRoot,\n            this.m_overlaySceneRoot\n        );\n\n        this.m_animatedExtrusionHandler.update(this.zoomLevel);\n\n        if (currentFrameEvent !== undefined) {\n            // Make sure the counters all have a value.\n            currentFrameEvent.addValue(\"renderCount.numTilesRendered\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesVisible\", 0);\n            currentFrameEvent.addValue(\"renderCount.numTilesLoading\", 0);\n\n            // Increment the counters for all data sources.\n            renderList.forEach(({ zoomLevel, renderedTiles, visibleTiles, numTilesLoading }) => {\n                currentFrameEvent!.addValue(\"renderCount.numTilesRendered\", renderedTiles.size);\n                currentFrameEvent!.addValue(\"renderCount.numTilesVisible\", visibleTiles.length);\n                currentFrameEvent!.addValue(\"renderCount.numTilesLoading\", numTilesLoading);\n            });\n        }\n\n        if (this.m_movementDetector.checkCameraMoved(this, frameStartTime)) {\n            //FIXME: Shouldn't we use target here?\n            const { latitude, longitude, altitude } = this.geoCenter;\n            this.dispatchEvent({\n                type: MapViewEventNames.CameraPositionChanged,\n                latitude,\n                longitude,\n                altitude,\n                // FIXME: Can we remove yaw, pitch and roll\n                yaw: this.m_yaw,\n                pitch: this.m_pitch,\n                roll: this.m_roll,\n                tilt: this.tilt,\n                heading: this.heading,\n                zoom: this.zoomLevel\n            });\n        }\n\n        // The camera used to render the scene.\n        const camera = this.m_pointOfView !== undefined ? this.m_pointOfView : this.m_rteCamera;\n\n        if (this.renderLabels && !this.m_pointOfView) {\n            this.m_textElementsRenderer.placeText(renderList, frameStartTime);\n        }\n\n        if (gatherStatistics) {\n            textPlacementTime = PerformanceTimer.now();\n        }\n\n        this.mapRenderingManager.render(\n            this.m_renderer,\n            this.m_scene,\n            camera,\n            !this.isDynamicFrame\n        );\n\n        if (gatherStatistics) {\n            drawTime = PerformanceTimer.now();\n        }\n\n        if (this.renderLabels && !this.m_pointOfView) {\n            this.m_textElementsRenderer.renderText(this.m_viewRanges.maximum);\n        }\n\n        if (this.m_overlaySceneRoot.children.length > 0) {\n            this.m_renderer.render(this.m_overlayScene, camera);\n        }\n\n        if (gatherStatistics) {\n            textDrawTime = PerformanceTimer.now();\n        }\n\n        if (!this.m_firstFrameRendered) {\n            this.m_firstFrameRendered = true;\n\n            if (gatherStatistics) {\n                stats.appResults.set(\"firstFrame\", frameStartTime);\n            }\n\n            this.FIRST_FRAME_EVENT.time = frameStartTime;\n            this.dispatchEvent(this.FIRST_FRAME_EVENT);\n        }\n\n        this.m_visibleTiles.disposePendingTiles();\n\n        this.m_drawing = false;\n\n        this.checkCopyrightUpdates();\n\n        // do this post paint therefore use a Timeout, if it has not been executed cancel and\n        // create a new one\n        if (this.m_taskSchedulerTimeout !== undefined) {\n            clearTimeout(this.m_taskSchedulerTimeout);\n        }\n        this.m_taskSchedulerTimeout = setTimeout(() => {\n            this.m_taskSchedulerTimeout = undefined;\n            this.m_taskScheduler.processPending(frameStartTime);\n        }, 0);\n\n        if (currentFrameEvent !== undefined) {\n            endTime = PerformanceTimer.now();\n\n            const frameRenderTime = endTime - frameStartTime;\n\n            currentFrameEvent.setValue(\"render.setupTime\", setupTime! - frameStartTime);\n            currentFrameEvent.setValue(\"render.cullTime\", cullTime! - setupTime!);\n            currentFrameEvent.setValue(\"render.textPlacementTime\", textPlacementTime! - cullTime!);\n            currentFrameEvent.setValue(\"render.drawTime\", drawTime! - textPlacementTime!);\n            currentFrameEvent.setValue(\"render.textDrawTime\", textDrawTime! - drawTime!);\n            currentFrameEvent.setValue(\"render.cleanupTime\", endTime - textDrawTime!);\n            currentFrameEvent.setValue(\"render.frameRenderTime\", frameRenderTime);\n\n            // Initialize the fullFrameTime with the frameRenderTime If we also create geometry in\n            // this frame, this number will be increased in the TileGeometryLoader.\n            currentFrameEvent.setValue(\"render.fullFrameTime\", frameRenderTime);\n            currentFrameEvent.setValue(\"render.geometryCreationTime\", 0);\n\n            // Add THREE.js statistics\n            stats.addWebGLInfo(this.m_renderer.info);\n\n            // Add memory statistics\n            // FIXME:\n            // This will only measure the memory of the rendering and not of the geometry creation.\n            // Assuming the garbage collector is not kicking in immediately we will at least see\n            // the geometry creation memory consumption accounted in the next frame.\n            stats.addMemoryInfo();\n        }\n\n        this.DID_RENDER_EVENT.time = frameStartTime;\n        this.dispatchEvent(this.DID_RENDER_EVENT);\n\n        // After completely rendering this frame, it is checked if this frame was the first complete\n        // frame, with no more tiles, geometry and labels waiting to be added, and no animation\n        // running. The initial placement of text in this render call may have changed the loading\n        // state of the TextElementsRenderer, so this has to be checked again.\n        // HARP-10919: Fading is currently ignored by the frame complete event.\n        if (!this.isDynamicFrame) {\n            if (this.m_firstFrameComplete === false) {\n                this.m_firstFrameComplete = true;\n                if (gatherStatistics) {\n                    stats.appResults.set(\"firstFrameComplete\", frameStartTime);\n                }\n            }\n\n            this.FRAME_COMPLETE_EVENT.time = frameStartTime;\n            this.dispatchEvent(this.FRAME_COMPLETE_EVENT);\n        }\n    }\n\n    private setupCamera() {\n        assert(this.m_visibleTiles !== undefined);\n\n        this.m_options.target = GeoCoordinates.fromObject(\n            getOptionValue(this.m_options.target, MapViewDefaults.target)\n        );\n        // ensure that look at target has height of 0\n        (this.m_options.target as GeoCoordinates).altitude = 0;\n        this.m_options.tilt = getOptionValue(this.m_options.tilt, MapViewDefaults.tilt);\n\n        this.m_options.heading = getOptionValue(this.m_options.heading, MapViewDefaults.heading);\n\n        this.m_options.zoomLevel = getOptionValue(\n            this.m_options.zoomLevel,\n            MapViewDefaults.zoomLevel\n        );\n\n        this.lookAtImpl(this.m_options);\n\n        // ### move & customize\n        const { width, height } = this.getCanvasClientSize();\n        this.resize(width, height);\n    }\n\n    private createVisibleTileSet(): VisibleTileSet {\n        assert(this.m_tileGeometryManager !== undefined);\n\n        if (this.m_visibleTiles) {\n            // Dispose of all resources before the old instance is replaced.\n            this.m_visibleTiles.clearTileCache();\n            this.m_visibleTiles.disposePendingTiles();\n        }\n\n        const enableMixedLod =\n            this.m_enableMixedLod === undefined\n                ? this.projection.type === ProjectionType.Spherical\n                : this.m_enableMixedLod;\n\n        this.m_visibleTiles = new VisibleTileSet(\n            new FrustumIntersection(\n                this.m_camera,\n                this,\n                this.m_visibleTileSetOptions.extendedFrustumCulling,\n                this.m_tileWrappingEnabled,\n                enableMixedLod,\n                this.m_lodMinTilePixelSize\n            ),\n            this.m_tileGeometryManager,\n            this.m_visibleTileSetOptions,\n            this.taskQueue\n        );\n        return this.m_visibleTiles;\n    }\n\n    private movementStarted() {\n        this.m_textElementsRenderer.movementStarted();\n\n        this.MOVEMENT_STARTED_EVENT.time = Date.now();\n        this.dispatchEvent(this.MOVEMENT_STARTED_EVENT);\n    }\n\n    private movementFinished() {\n        this.m_textElementsRenderer.movementFinished();\n\n        this.MOVEMENT_FINISHED_EVENT.time = Date.now();\n        this.dispatchEvent(this.MOVEMENT_FINISHED_EVENT);\n\n        // render at the next possible time.\n        if (!this.animating) {\n            if (this.m_movementFinishedUpdateTimerId !== undefined) {\n                clearTimeout(this.m_movementFinishedUpdateTimerId);\n            }\n            this.m_movementFinishedUpdateTimerId = setTimeout(() => {\n                this.m_movementFinishedUpdateTimerId = undefined;\n                this.update();\n            }, 0);\n        }\n    }\n\n    /**\n     * Check if the set of visible tiles changed since the last frame.\n     *\n     * May be called multiple times per frame.\n     *\n     * Equality is computed by creating a string containing the IDs of the tiles.\n     */\n    private checkIfTilesChanged() {\n        if (this.m_thisFrameTilesChanged !== undefined) {\n            return this.m_thisFrameTilesChanged;\n        }\n        const renderList = this.m_visibleTiles.dataSourceTileList;\n\n        const tileIdList: string[] = [];\n\n        tileIdList.length = 0;\n\n        renderList.forEach(({ dataSource, renderedTiles }) => {\n            renderedTiles.forEach(tile => {\n                tileIdList.push(dataSource.name + \"-\" + tile.tileKey.mortonCode());\n            });\n        });\n\n        tileIdList.sort();\n\n        const newTileIds = tileIdList.join(\"#\");\n\n        if (newTileIds !== this.m_lastTileIds) {\n            this.m_lastTileIds = newTileIds;\n            this.m_thisFrameTilesChanged = true;\n        } else {\n            this.m_thisFrameTilesChanged = false;\n        }\n\n        return this.m_thisFrameTilesChanged;\n    }\n\n    private checkCopyrightUpdates() {\n        if (!this.checkIfTilesChanged()) {\n            return;\n        }\n\n        const newCopyrightInfo = this.getRenderedTilesCopyrightInfo();\n        if (newCopyrightInfo === this.m_copyrightInfo) {\n            return;\n        }\n        if (newCopyrightInfo.length === this.m_copyrightInfo.length) {\n            let allEqual = true;\n            for (let i = 0; i < newCopyrightInfo.length; i++) {\n                const a = newCopyrightInfo[i];\n                const b = this.m_copyrightInfo[i];\n                if (a.label !== b.label) {\n                    allEqual = false;\n                    break;\n                }\n            }\n            if (allEqual) {\n                return;\n            }\n        }\n        this.m_copyrightInfo = newCopyrightInfo;\n        this.dispatchEvent(this.COPYRIGHT_CHANGED_EVENT);\n    }\n\n    private getRenderedTilesCopyrightInfo(): CopyrightInfo[] {\n        let result: CopyrightInfo[] = [];\n        for (const tileList of this.m_visibleTiles.dataSourceTileList) {\n            for (const tile of tileList.renderedTiles.values()) {\n                const tileCopyrightInfo = tile.copyrightInfo;\n                if (tileCopyrightInfo === undefined || tileCopyrightInfo.length === 0) {\n                    continue;\n                }\n                result = CopyrightInfo.mergeArrays(result, tileCopyrightInfo);\n            }\n        }\n        return result;\n    }\n\n    private setupStats(enable: boolean) {\n        new PerformanceStatistics(enable, 1000);\n    }\n\n    private setupRenderer(tileObjectRenderer: TileObjectRenderer) {\n        this.m_scene.add(this.m_sceneRoot);\n        this.m_overlayScene.add(this.m_overlaySceneRoot);\n\n        this.shadowsEnabled = this.m_options.enableShadows ?? false;\n\n        tileObjectRenderer.setupRenderer();\n    }\n\n    private createTextRenderer(): TextElementsRenderer {\n        return new TextElementsRenderer(\n            new MapViewState(this, this.checkIfTilesChanged.bind(this)),\n            this.m_screenProjector,\n            this.m_poiManager,\n            this.m_renderer,\n            [this.imageCache, this.userImageCache],\n            this.m_options\n        );\n    }\n\n    /**\n     * @internal\n     * @param fontCatalogs\n     * @param textStyles\n     * @param defaultTextStyle\n     */\n    public async resetTextRenderer(\n        fontCatalogs?: FontCatalogConfig[],\n        textStyles?: TextStyleDefinition[],\n        defaultTextStyle?: TextStyleDefinition\n    ): Promise<void> {\n        await this.m_textElementsRenderer.updateFontCatalogs(fontCatalogs);\n        await this.m_textElementsRenderer.updateTextStyles(textStyles, defaultTextStyle);\n        this.update();\n    }\n\n    /**\n     * Default handler for webglcontextlost event.\n     *\n     * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n     */\n    private readonly onWebGLContextLost = (event: Event) => {\n        this.dispatchEvent(this.CONTEXT_LOST_EVENT);\n        logger.warn(\"WebGL context lost\", event);\n    };\n\n    /**\n     * Default handler for webglcontextrestored event.\n     *\n     * Note: The renderer `this.m_renderer` may not be initialized when this function is called.\n     */\n    private readonly onWebGLContextRestored = (event: Event) => {\n        this.dispatchEvent(this.CONTEXT_RESTORED_EVENT);\n        if (this.m_renderer !== undefined) {\n            this.textElementsRenderer.restoreRenderers(this.m_renderer);\n            this.getTheme().then(theme => {\n                this.m_sceneEnvironment.updateClearColor(theme.clearColor, theme.clearAlpha);\n                this.update();\n            });\n        }\n        logger.warn(\"WebGL context restored\", event);\n    };\n\n    /**\n     * Sets the field of view calculation, and applies it immediately to the camera.\n     *\n     * @param fovCalculation - How to calculate the FOV\n     * @param height - Viewport height.\n     */\n    private setFovOnCamera(fovCalculation: FovCalculation, height: number) {\n        const fovRad = THREE.MathUtils.degToRad(fovCalculation.fov);\n\n        if (fovCalculation.type === \"fixed\") {\n            CameraUtils.setVerticalFov(this.m_camera, fovRad, height);\n            return;\n        }\n\n        let focalLength = CameraUtils.getFocalLength(this.m_camera);\n        if (focalLength === undefined) {\n            CameraUtils.setVerticalFov(this.m_camera, fovRad, height);\n            focalLength = CameraUtils.getFocalLength(this.m_camera);\n        }\n        CameraUtils.setFocalLength(this.m_camera, focalLength!, height);\n    }\n\n    /**\n     * Get canvas client size in css/client pixels.\n     *\n     * Supports canvases not attached to DOM, which have 0 as `clientWidth` and `clientHeight` by\n     * calculating it from actual canvas size and current pixel ratio.\n     */\n    private getCanvasClientSize(): { width: number; height: number } {\n        const { clientWidth, clientHeight } = this.canvas;\n        if (\n            clientWidth === 0 ||\n            clientHeight === 0 ||\n            typeof clientWidth !== \"number\" ||\n            typeof clientHeight !== \"number\"\n        ) {\n            const pixelRatio = this.m_renderer.getPixelRatio();\n            return {\n                width: Math.round(this.canvas.width / pixelRatio),\n                height: Math.round(this.canvas.height / pixelRatio)\n            };\n        } else {\n            return { width: clientWidth, height: clientHeight };\n        }\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Theme } from \"@here/harp-datasource-protocol\";\nimport { EarthConstants, Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport { GroundAtmosphereMaterial, SkyAtmosphereMaterial } from \"@here/harp-materials\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { TiltViewClipPlanesEvaluator } from \"./ClipPlanesEvaluator\";\nimport { MapAnchor, MapAnchors } from \"./MapAnchors\";\n\n/**\n * Atmosphere effect variants.\n */\nenum AtmosphereVariant {\n    Ground = 0x1,\n    Sky = 0x2,\n    SkyAndGround = 0x3\n}\n\n/**\n * Atmosphere shader variants.\n */\nenum AtmosphereShadingVariant {\n    ScatteringShader,\n    SimpleColor,\n    Wireframe\n}\n\n/**\n * Lists light modes.\n */\nexport enum AtmosphereLightMode {\n    LightOverhead = 0,\n    LightDynamic = 1\n}\n\n/**\n * Maximum altitude that atmosphere reaches as the percent of the Earth radius.\n */\nconst SKY_ATMOSPHERE_ALTITUDE_FACTOR = 0.025;\n\n/**\n * Maximum altitude that ground atmosphere is visible as the percent of the Earth radius.\n */\nconst GROUND_ATMOSPHERE_ALTITUDE_FACTOR = 0.0001;\n\n/**\n * Utility cache for holding temporary values.\n */\nconst cache = {\n    clipPlanes: { near: 0, far: 0 }\n};\n\n/**\n * Class that provides {@link MapView}'s atmospheric scattering effect.\n */\nexport class MapViewAtmosphere {\n    /**\n     * User data name attribute assigned to created mesh.\n     */\n    static SkyAtmosphereUserName: string = \"SkyAtmosphere\";\n    /**\n     * User data name attribute assigned to created mesh.\n     */\n    static GroundAtmosphereUserName: string = \"GroundAtmosphere\";\n\n    /**\n     * Check if map anchors have already atmosphere effect added.\n     *\n     * @param mapAnchors - MapAnchors to check.\n     */\n    static isPresent(mapAnchors: MapAnchors): boolean {\n        for (const mapAnchor of mapAnchors.children) {\n            if (\n                mapAnchor.name === MapViewAtmosphere.SkyAtmosphereUserName ||\n                mapAnchor.name === MapViewAtmosphere.GroundAtmosphereUserName\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private m_enabled: boolean = true;\n    private m_skyGeometry?: THREE.BufferGeometry;\n    private m_skyMaterial?: THREE.Material;\n    private m_skyMesh?: THREE.Mesh;\n    private m_groundGeometry?: THREE.BufferGeometry;\n    private m_groundMaterial?: THREE.Material;\n    private m_groundMesh?: THREE.Mesh;\n\n    private readonly m_clipPlanesEvaluator = new TiltViewClipPlanesEvaluator(\n        EarthConstants.EQUATORIAL_RADIUS * SKY_ATMOSPHERE_ALTITUDE_FACTOR,\n        0,\n        1.0,\n        0.05,\n        10000000.0\n    );\n    // TODO: Support for Theme definition should be added.\n    //private m_cachedTheme: Theme = { styles: {} };\n\n    private readonly m_lightDirection = new THREE.Vector3(0.0, 1.0, 0.0);\n\n    /**\n     * Creates and adds `Atmosphere` effects to the scene.\n     *\n     * @note Currently works only with globe projection.\n     *\n     * @param m_mapAnchors - The {@link MapAnchors} instance where the effect will be added.\n     * @param m_sceneCamera - The camera used to render entire scene.\n     * @param m_projection - The geo-projection used to transform geo coordinates to\n     *                       cartesian space.\n     * @param m_rendererCapabilities The capabilities of the WebGL renderer.\n     * @param m_updateCallback - The optional callback to that should be called whenever atmosphere\n     * configuration changes, may be used to inform related components (`MapView`) to redraw.\n     * @param m_atmosphereVariant - The optional atmosphere configuration variant enum\n     * [[AtmosphereVariant]], which denotes where the atmosphere scattering effect should be\n     * applied, it may be ground or sky atmosphere only or most realistic for both, which is\n     * chosen by default.\n     * @param m_materialVariant - The optional material variant to be used, mainly for\n     * testing and tweaking purposes.\n     */\n    constructor(\n        private readonly m_mapAnchors: MapAnchors,\n        private readonly m_sceneCamera: THREE.Camera,\n        private readonly m_projection: Projection,\n        private readonly m_rendererCapabilities: THREE.WebGLCapabilities,\n        private readonly m_updateCallback?: () => void,\n        private readonly m_atmosphereVariant: AtmosphereVariant = AtmosphereVariant.SkyAndGround,\n        private readonly m_materialVariant = AtmosphereShadingVariant.ScatteringShader\n    ) {\n        if (this.m_atmosphereVariant & AtmosphereVariant.Sky) {\n            this.createSkyGeometry();\n        }\n        if (this.m_atmosphereVariant & AtmosphereVariant.Ground) {\n            this.createGroundGeometry();\n        }\n        this.addToMapAnchors(this.m_mapAnchors);\n    }\n\n    get skyMesh(): THREE.Mesh | undefined {\n        return this.m_skyMesh;\n    }\n\n    get groundMesh(): THREE.Mesh | undefined {\n        return this.m_groundMesh;\n    }\n\n    /**\n     * Allows to enable/disable the atmosphere effect, regardless of the theme settings.\n     *\n     * Use this method to change the setup in runtime without defining corresponding theme setup.\n     *\n     * @param enable - A boolean that specifies whether the atmosphere should be enabled or\n     *                 disabled.\n     */\n    set enabled(enable: boolean) {\n        // Check already disposed.\n        if (this.disposed) {\n            return;\n        }\n        if (this.m_enabled === enable) {\n            return;\n        }\n        this.m_enabled = enable;\n        const isAdded = MapViewAtmosphere.isPresent(this.m_mapAnchors);\n        if (enable && !isAdded) {\n            this.addToMapAnchors(this.m_mapAnchors);\n        } else if (!enable && isAdded) {\n            this.removeFromMapAnchors(this.m_mapAnchors);\n        }\n    }\n\n    /**\n     * Returns the current atmosphere status, enabled or disabled.\n     */\n    get enabled(): boolean {\n        return this.m_enabled;\n    }\n\n    set lightMode(lightMode: AtmosphereLightMode) {\n        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {\n            return;\n        }\n        const dynamicLight = lightMode === AtmosphereLightMode.LightDynamic;\n        if (this.m_groundMaterial !== undefined) {\n            const groundMat = this.m_groundMaterial as GroundAtmosphereMaterial;\n            groundMat.setDynamicLighting(dynamicLight);\n        }\n        if (this.m_skyMaterial !== undefined) {\n            const skyMat = this.m_skyMaterial as SkyAtmosphereMaterial;\n            skyMat.setDynamicLighting(dynamicLight);\n        }\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        // Unlink from scene and mapview anchors\n        if (this.enabled) {\n            this.enabled = false;\n        }\n\n        this.m_skyMaterial?.dispose();\n        this.m_groundMaterial?.dispose();\n\n        this.m_skyGeometry?.dispose();\n        this.m_groundGeometry?.dispose();\n\n        // After disposal we may no longer enable effect.\n        this.m_skyGeometry = undefined;\n        this.m_groundGeometry = undefined;\n\n        this.m_skyMaterial = undefined;\n        this.m_groundMaterial = undefined;\n\n        this.m_skyMesh = undefined;\n        this.m_groundMesh = undefined;\n    }\n\n    /**\n     * Sets the atmosphere depending on the\n     * {@link @here/harp-datasource-protocol#Theme} instance provided.\n     *\n     * This function is called when a theme is loaded. Atmosphere is added only if the theme\n     * contains a atmosphere definition with a:\n     * - `color` property, used to set the atmosphere color.\n     *\n     * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.\n     */\n    reset(theme: Theme) {\n        //this.m_cachedTheme = theme;\n    }\n\n    private get disposed() {\n        return this.m_skyMesh === undefined && this.m_groundMesh === undefined;\n    }\n\n    /**\n     * Handles atmosphere effect adding.\n     */\n    private addToMapAnchors(mapAnchors: MapAnchors) {\n        assert(!MapViewAtmosphere.isPresent(mapAnchors), \"Atmosphere already added\");\n        if (this.m_skyMesh !== undefined) {\n            mapAnchors.add(createMapAnchor(this.m_skyMesh, Number.MIN_SAFE_INTEGER));\n        }\n        if (this.m_groundMesh !== undefined) {\n            mapAnchors.add(createMapAnchor(this.m_groundMesh, Number.MAX_SAFE_INTEGER));\n        }\n\n        // Request an update once the anchor is added to {@link MapView}.\n        if (this.m_updateCallback) {\n            this.m_updateCallback();\n        }\n    }\n\n    /**\n     * Handles atmosphere effect removal.\n     */\n    private removeFromMapAnchors(mapAnchors: MapAnchors) {\n        if (!MapViewAtmosphere.isPresent(mapAnchors)) {\n            return;\n        }\n        let update = false;\n        if (this.m_skyMesh !== undefined) {\n            mapAnchors.remove(this.m_skyMesh);\n            update = true;\n        }\n        if (this.m_groundMesh !== undefined) {\n            mapAnchors.remove(this.m_groundMesh);\n            update = true;\n        }\n        if (update && this.m_updateCallback) {\n            this.m_updateCallback();\n        }\n    }\n\n    private createSkyGeometry() {\n        switch (this.m_projection.type) {\n            case ProjectionType.Spherical:\n                this.m_skyGeometry = new THREE.SphereGeometry(\n                    EarthConstants.EQUATORIAL_RADIUS * (1 + SKY_ATMOSPHERE_ALTITUDE_FACTOR),\n                    256,\n                    256\n                );\n                break;\n            default: {\n                this.m_skyGeometry = new THREE.PlaneGeometry(200, 200);\n                break;\n            }\n        }\n\n        this.m_skyGeometry.translate(0, 0, 0);\n\n        if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {\n            this.m_skyMaterial = new SkyAtmosphereMaterial({\n                rendererCapabilities: this.m_rendererCapabilities\n            });\n        } else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {\n            this.m_skyMaterial = new THREE.MeshBasicMaterial({\n                color: new THREE.Color(0xc4f8ed),\n                opacity: 0.4,\n                transparent: false,\n                depthTest: true, // hide atmosphere behind globe (note: transparent changes order)\n                depthWrite: false,\n                side: THREE.BackSide,\n                blending: THREE.NormalBlending,\n                fog: false\n            });\n        } else {\n            this.m_skyMaterial = new THREE.MeshStandardMaterial({\n                color: 0x7fffff,\n                depthTest: false,\n                depthWrite: false,\n                normalScale: new THREE.Vector2(-1, -1),\n                side: THREE.BackSide, // not truly supported in wireframe mode\n                wireframe: true\n            });\n        }\n\n        this.m_skyMesh = new THREE.Mesh(this.m_skyGeometry, this.m_skyMaterial);\n        // Assign custom name so sky object may be easily recognized withing the scene.\n        this.m_skyMesh.name = MapViewAtmosphere.SkyAtmosphereUserName;\n        this.setupSkyForRendering();\n    }\n\n    private createGroundGeometry() {\n        switch (this.m_projection.type) {\n            case ProjectionType.Spherical:\n                this.m_groundGeometry = new THREE.SphereGeometry(\n                    EarthConstants.EQUATORIAL_RADIUS * (1 + GROUND_ATMOSPHERE_ALTITUDE_FACTOR),\n                    256,\n                    256\n                );\n                break;\n            default: {\n                this.m_groundGeometry = new THREE.PlaneGeometry(200, 200);\n                break;\n            }\n        }\n        this.m_groundGeometry.translate(0, 0, 0);\n\n        if (this.m_materialVariant === AtmosphereShadingVariant.ScatteringShader) {\n            this.m_groundMaterial = new GroundAtmosphereMaterial({\n                rendererCapabilities: this.m_rendererCapabilities\n            });\n        } else if (this.m_materialVariant === AtmosphereShadingVariant.SimpleColor) {\n            this.m_groundMaterial = new THREE.MeshBasicMaterial({\n                color: new THREE.Color(0x00c5ff),\n                opacity: 0.4,\n                transparent: true,\n                depthTest: false,\n                depthWrite: false,\n                side: THREE.FrontSide,\n                blending: THREE.NormalBlending,\n                fog: false\n            });\n        } else {\n            this.m_groundMaterial = new THREE.MeshStandardMaterial({\n                color: 0x11899a,\n                depthTest: true, // FrontSide is not fully supported, so need depth test\n                depthWrite: false,\n                side: THREE.FrontSide,\n                wireframe: true\n            });\n        }\n\n        this.m_groundMesh = new THREE.Mesh(this.m_groundGeometry, this.m_groundMaterial);\n        // Assign name so object may be recognized withing the scene.\n        this.m_groundMesh.name = MapViewAtmosphere.GroundAtmosphereUserName;\n\n        this.setupGroundForRendering();\n    }\n\n    private setupSkyForRendering(): void {\n        if (this.m_skyMesh === undefined) {\n            return;\n        }\n        // Depending on material variant we need to update uniforms or only\n        // update camera near/far planes cause camera need to see further then\n        // actual earth geometry.\n        let onBeforeCallback: (_camera: THREE.Camera, _material: THREE.Material) => void;\n        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {\n            // Setup only further clip planes before rendering.\n            onBeforeCallback = (camera: THREE.Camera, _material: THREE.Material) => {\n                this.overrideClipPlanes(camera);\n            };\n        } else {\n            // Setup proper clip planes and update uniforms values.\n            onBeforeCallback = (camera: THREE.Camera, material: THREE.Material) => {\n                this.overrideClipPlanes(camera);\n                // Check material wasn't swapped.\n                assert(material instanceof SkyAtmosphereMaterial);\n                const mat = this.m_skyMaterial as SkyAtmosphereMaterial;\n                mat.updateUniforms(mat, this.m_skyMesh!, camera, this.m_lightDirection);\n            };\n        }\n\n        // Sky material should be already created with mesh.\n        assert(this.m_skyMaterial !== undefined);\n        this.m_skyMesh.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.BufferGeometry,\n            material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            onBeforeCallback(camera, material);\n        };\n\n        this.m_skyMesh.onAfterRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.BufferGeometry,\n            _material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            this.revertClipPlanes(camera);\n        };\n    }\n\n    private setupGroundForRendering(): void {\n        if (this.m_groundMesh === undefined) {\n            return;\n        }\n        if (this.m_materialVariant !== AtmosphereShadingVariant.ScatteringShader) {\n            return;\n        }\n        // Ground material should be already created.\n        assert(this.m_groundMaterial !== undefined);\n        // Ground mesh does not need custom clip planes and uses the same camera setup as\n        // real (data source based) geometry.\n        this.m_groundMesh.onBeforeRender = (\n            _renderer: THREE.WebGLRenderer,\n            _scene: THREE.Scene,\n            camera: THREE.Camera,\n            _geometry: THREE.BufferGeometry,\n            material: THREE.Material,\n            _group: THREE.Group\n        ) => {\n            assert(material instanceof GroundAtmosphereMaterial);\n            const mat = this.m_groundMaterial as GroundAtmosphereMaterial;\n            mat.updateUniforms(mat, this.m_groundMesh!, camera, this.m_lightDirection);\n        };\n    }\n\n    private overrideClipPlanes(rteCamera: THREE.Camera) {\n        // Store current clip planes used by global camera before modifying them.\n        const sceneCam = this.m_sceneCamera as THREE.PerspectiveCamera;\n        cache.clipPlanes.near = sceneCam.near;\n        cache.clipPlanes.far = sceneCam.far;\n        // Calculate view ranges using world camera.\n        // NOTE: ElevationProvider is not passed to evaluator, leaves min/max altitudes unchanged.\n        const viewRanges = this.m_clipPlanesEvaluator.evaluateClipPlanes(\n            this.m_sceneCamera,\n            this.m_projection\n        );\n        // Update relative to eye camera used internally in rendering.\n        assert(rteCamera instanceof THREE.PerspectiveCamera);\n        const c = rteCamera as THREE.PerspectiveCamera;\n        c.near = viewRanges.near;\n        // Small margin ensures that we never cull small triangles just below or at\n        // horizon - possible due to frustum culling in-precisions.\n        c.far = viewRanges.far + EarthConstants.EQUATORIAL_RADIUS * 0.1;\n        c.updateProjectionMatrix();\n    }\n\n    private revertClipPlanes(rteCamera: THREE.Camera) {\n        assert(rteCamera instanceof THREE.PerspectiveCamera);\n        const c = rteCamera as THREE.PerspectiveCamera;\n        // Restore scene camera clip planes.\n        c.near = cache.clipPlanes.near;\n        c.far = cache.clipPlanes.far;\n        c.updateProjectionMatrix();\n    }\n}\n\nfunction createMapAnchor(mesh: THREE.Mesh, renderOrder: number): MapAnchor<THREE.Mesh> {\n    const anchor = mesh as MapAnchor<THREE.Mesh>;\n    anchor.renderOrder = renderOrder;\n    anchor.pickable = false;\n    anchor.anchor = new THREE.Vector3(0, 0, 0);\n    return anchor;\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GradientSky, Light, Sky } from \"@here/harp-datasource-protocol\";\nimport { ProjectionType, Vector3Like } from \"@here/harp-geoutils\";\nimport { getOptionValue, LoggerManager } from \"@here/harp-utils\";\nimport THREE = require(\"three\");\n\nimport { BackgroundDataSource } from \"./BackgroundDataSource\";\nimport { MapView, MapViewOptions } from \"./MapView\";\nimport { MapViewFog } from \"./MapViewFog\";\nimport { SkyBackground } from \"./SkyBackground\";\nimport { createLight } from \"./ThemeHelpers\";\n\nconst logger = LoggerManager.instance.create(\"MapViewEnvironment\");\n\n//  the default breaks the ibct tests, seems it had not been used in all cases before\n\nexport const DEFAULT_CLEAR_COLOR = 0xffffff; //0xefe9e1;\n\nconst cache = {\n    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],\n    frustumPoints: [\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        new THREE.Vector3()\n    ]\n};\n\nexport type MapViewEnvironmentOptions = Pick<\n    MapViewOptions,\n    \"addBackgroundDatasource\" | \"backgroundTilingScheme\"\n>;\n/**\n * Class handling the Scene Environment, like fog, sky, background datasource, clearColor etc\n *  for MapView\n */\nexport class MapViewEnvironment {\n    private readonly m_fog: MapViewFog;\n    private m_skyBackground?: SkyBackground;\n    private m_createdLights?: THREE.Light[];\n    private m_overlayCreatedLights?: THREE.Light[];\n    private readonly m_backgroundDataSource?: BackgroundDataSource;\n\n    constructor(private readonly m_mapView: MapView, options: MapViewEnvironmentOptions) {\n        this.m_fog = new MapViewFog(this.m_mapView.scene);\n        if (options.addBackgroundDatasource !== false) {\n            this.m_backgroundDataSource = new BackgroundDataSource();\n            this.m_mapView.addDataSource(this.m_backgroundDataSource);\n        }\n        if (\n            options.backgroundTilingScheme !== undefined &&\n            this.m_backgroundDataSource !== undefined\n        ) {\n            this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);\n        }\n        this.updateClearColor();\n    }\n\n    get lights(): THREE.Light[] {\n        return this.m_createdLights ?? [];\n    }\n\n    get fog(): MapViewFog {\n        return this.m_fog;\n    }\n\n    updateBackgroundDataSource() {\n        if (this.m_backgroundDataSource) {\n            this.m_backgroundDataSource.updateStorageLevelOffset();\n        }\n    }\n\n    clearBackgroundDataSource() {\n        if (this.m_backgroundDataSource !== undefined) {\n            this.m_mapView.clearTileCache(this.m_backgroundDataSource.name);\n        }\n    }\n\n    update() {\n        this.m_fog.update(this.m_mapView, this.m_mapView.viewRanges.maximum);\n        if (\n            this.m_skyBackground !== undefined &&\n            this.m_mapView.projection.type === ProjectionType.Planar\n        ) {\n            this.m_skyBackground.updateCamera(this.m_mapView.camera);\n        }\n        this.updateLights();\n    }\n\n    updateClearColor(clearColor?: string, clearAlpha?: number) {\n        if (clearColor !== undefined) {\n            this.m_mapView.renderer.setClearColor(new THREE.Color(clearColor), clearAlpha);\n        } else {\n            this.m_mapView.renderer.setClearColor(DEFAULT_CLEAR_COLOR, clearAlpha);\n        }\n    }\n\n    updateSkyBackground(sky?: Sky, clearColor?: string) {\n        if (this.m_skyBackground instanceof SkyBackground && sky !== undefined) {\n            // there is a sky in the view and there is a sky option in the theme. Update the colors\n            this.updateSkyBackgroundColors(sky, clearColor);\n        } else if (this.m_skyBackground === undefined && sky !== undefined) {\n            // there is no sky in the view but there is a sky option in the theme\n            this.addNewSkyBackground(sky, clearColor);\n            return;\n        } else if (this.m_skyBackground instanceof SkyBackground && sky === undefined) {\n            // there is a sky in the view, but not in the theme\n            this.removeSkyBackGround();\n        }\n    }\n\n    updateLighting(lights?: Light[]) {\n        if (this.m_createdLights) {\n            this.m_createdLights.forEach((light: THREE.Light) => {\n                this.m_mapView.scene.remove(light);\n            });\n        }\n\n        this.m_overlayCreatedLights?.forEach(light => {\n            this.m_mapView.overlayScene.remove(light);\n            if (light instanceof THREE.DirectionalLight) {\n                this.m_mapView.overlayScene.remove(light.target);\n            }\n        });\n\n        if (lights !== undefined) {\n            this.m_createdLights = [];\n            this.m_overlayCreatedLights = [];\n\n            lights.forEach((lightDescription: Light) => {\n                const light = createLight(lightDescription);\n                if (!light) {\n                    logger.warn(\n                        `MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`\n                    );\n                    return;\n                }\n                this.m_mapView.scene.add(light);\n\n                if ((light as any).isDirectionalLight) {\n                    const directionalLight = light as THREE.DirectionalLight;\n                    // This is needed so that the target is updated automatically, see:\n                    // https://threejs.org/docs/#api/en/lights/DirectionalLight.target\n                    this.m_mapView.scene.add(directionalLight.target);\n                }\n                this.m_createdLights!.push(light);\n\n                const clonedLight: THREE.Light = light.clone() as THREE.Light;\n                this.m_mapView.overlayScene.add(clonedLight);\n                if (clonedLight instanceof THREE.DirectionalLight) {\n                    this.m_mapView.overlayScene.add(clonedLight.target.clone());\n                }\n            });\n        }\n    }\n\n    /**\n     * Update the directional light camera. Note, this requires the cameras to first be updated.\n     */\n    updateLights() {\n        // TODO: HARP-9479 Globe doesn't support shadows.\n        if (\n            !this.m_mapView.shadowsEnabled ||\n            this.m_mapView.projection.type === ProjectionType.Spherical ||\n            this.m_createdLights === undefined ||\n            this.m_createdLights.length === 0\n        ) {\n            return;\n        }\n\n        const points: Vector3Like[] = [\n            // near plane points\n            { x: -1, y: -1, z: -1 },\n            { x: 1, y: -1, z: -1 },\n            { x: -1, y: 1, z: -1 },\n            { x: 1, y: 1, z: -1 },\n\n            // far planes points\n            { x: -1, y: -1, z: 1 },\n            { x: 1, y: -1, z: 1 },\n            { x: -1, y: 1, z: 1 },\n            { x: 1, y: 1, z: 1 }\n        ];\n        const transformedPoints = points.map((p, i) =>\n            this.m_mapView.ndcToView(p, cache.frustumPoints[i])\n        );\n\n        this.m_createdLights.forEach(element => {\n            const directionalLight = element as THREE.DirectionalLight;\n            if (directionalLight.isDirectionalLight === true) {\n                const lightDirection = cache.vector3[0];\n                lightDirection.copy(directionalLight.target.position);\n                lightDirection.sub(directionalLight.position);\n                lightDirection.normalize();\n\n                const normal = cache.vector3[1];\n                if (this.m_mapView.projection.type === ProjectionType.Planar) {\n                    // -Z points to the camera, we can't use Projection.surfaceNormal, because\n                    // webmercator and mercator give different results.\n                    normal.set(0, 0, -1);\n                } else {\n                    // Enable shadows for globe...\n                    //this.projection.surfaceNormal(target, normal);\n                }\n\n                // The camera of the shadow has the same height as the map camera, and the target is\n                // also the same. The position is then calculated based on the light direction and\n                // the height\n                // using basic trigonometry.\n                const tilt = this.m_mapView.tilt;\n                const cameraHeight =\n                    this.m_mapView.targetDistance * Math.cos(THREE.MathUtils.degToRad(tilt));\n                const lightPosHyp = cameraHeight / normal.dot(lightDirection);\n\n                directionalLight.target.position\n                    .copy(this.m_mapView.worldTarget)\n                    .sub(this.m_mapView.camera.position);\n                directionalLight.position.copy(this.m_mapView.worldTarget);\n                directionalLight.position.addScaledVector(lightDirection, -lightPosHyp);\n                directionalLight.position.sub(this.m_mapView.camera.position);\n                directionalLight.updateMatrixWorld();\n                directionalLight.shadow.updateMatrices(directionalLight);\n\n                const camera = directionalLight.shadow.camera;\n                const pointsInLightSpace = transformedPoints.map(p =>\n                    this.viewToLightSpace(p.clone(), camera)\n                );\n\n                const box = new THREE.Box3();\n                pointsInLightSpace.forEach(point => {\n                    box.expandByPoint(point);\n                });\n                camera.left = box.min.x;\n                camera.right = box.max.x;\n                camera.top = box.max.y;\n                camera.bottom = box.min.y;\n                // Moving back to the light the near plane in order to catch high buildings, that\n                // are not visible by the camera, but existing on the scene.\n                camera.near = -box.max.z * 0.95;\n                camera.far = -box.min.z;\n                camera.updateProjectionMatrix();\n            }\n        });\n    }\n\n    private addNewSkyBackground(sky: Sky, clearColor: string | undefined) {\n        if (sky.type === \"gradient\" && (sky as GradientSky).groundColor === undefined) {\n            sky.groundColor = getOptionValue(clearColor, \"#000000\");\n        }\n        this.m_skyBackground = new SkyBackground(\n            sky,\n            this.m_mapView.projection.type,\n            this.m_mapView.camera\n        );\n        this.m_mapView.scene.background = this.m_skyBackground.texture;\n    }\n\n    private removeSkyBackGround() {\n        this.m_mapView.scene.background = null;\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.dispose();\n            this.m_skyBackground = undefined;\n        }\n    }\n\n    private updateSkyBackgroundColors(sky: Sky, clearColor: string | undefined) {\n        if (sky.type === \"gradient\" && (sky as GradientSky).groundColor === undefined) {\n            sky.groundColor = getOptionValue(clearColor, \"#000000\");\n        }\n        if (this.m_skyBackground !== undefined) {\n            this.m_skyBackground.updateTexture(sky, this.m_mapView.projection.type);\n            this.m_mapView.scene.background = this.m_skyBackground?.texture;\n        }\n    }\n\n    /**\n     * Transfer from view space to camera space.\n     * @param viewPos - position in view space, result is stored here.\n     */\n    private viewToLightSpace(viewPos: THREE.Vector3, camera: THREE.Camera): THREE.Vector3 {\n        return viewPos.applyMatrix4(camera.matrixWorldInverse);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Fog } from \"@here/harp-datasource-protocol\";\nimport { HighPrecisionLineMaterial } from \"@here/harp-materials\";\nimport { RawShaderMaterial } from \"@here/harp-materials/lib/RawShaderMaterial\";\nimport { assert, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { MapView } from \"./MapView\";\n\n/**\n * Manages the fog display in {@link MapView}.\n */\nexport class MapViewFog {\n    private m_enabled: boolean = true;\n    private m_fog: THREE.Fog = new THREE.Fog(0x000000); // Default color asked by DefinitelyTyped.\n    private m_fogIsDefined: boolean = false;\n    private m_cachedFog: Fog | undefined;\n\n    /**\n     * Constructs a `MapViewFog` instance.\n     *\n     * @param m_scene - The scene used in {@link MapView} that contains the map objects.\n     */\n    constructor(private m_scene: THREE.Scene) {}\n\n    /**\n     * Allows for disabling the fog, even if it is defined in the theme. Use this property for\n     * custom views like the demo app's debug camera. However, if the theme does not define a\n     * fog, enabling this property here has no effect.\n     *\n     * @param value - A boolean that specifies whether the fog should be enabled or disabled.\n     */\n    set enabled(enableFog: boolean) {\n        this.m_enabled = enableFog;\n        if (enableFog && this.m_fogIsDefined && this.m_scene.fog === null) {\n            this.add();\n        } else if (!enableFog && this.m_scene.fog !== null) {\n            this.remove();\n        }\n    }\n\n    /**\n     * Returns the current fog status, enabled or disabled.\n     */\n    get enabled(): boolean {\n        return this.m_enabled;\n    }\n\n    /**\n     * Sets the fog depending on the {@link @here/harp-datasource-protocol#Theme}\n     * instance provided. This function is called when a\n     * theme is loaded. Fog is added only if the theme contains a fog definition with a:\n     * - `color` property, used to set the fog color.\n     * - `startRatio` property, used to set the start distance of the fog as a ratio of the far\n     * clipping plane distance.\n     *\n     * @param theme - A {@link @here/harp-datasource-protocol#Theme} instance.\n     */\n    reset(fog?: Fog) {\n        this.m_cachedFog = fog;\n        if (fog !== undefined && fog.color !== undefined && fog.startRatio !== undefined) {\n            this.m_fogIsDefined = true;\n            this.m_fog.color.set(fog.color);\n            if (this.m_enabled && this.m_scene.fog === null) {\n                this.add();\n            }\n        } else {\n            this.m_fogIsDefined = false;\n            if (this.m_scene.fog !== null) {\n                this.remove();\n            }\n        }\n    }\n\n    /**\n     * Updates the fog at runtime, depending on the camera.\n     *\n     * @param camera - An instance of a `THREE.Camera` with a `far` property.\n     */\n    update(mapView: MapView, viewDistance?: number) {\n        if (\n            this.m_scene.fog !== null &&\n            this.m_cachedFog !== undefined &&\n            this.m_cachedFog &&\n            this.m_cachedFog.startRatio !== undefined &&\n            (mapView.camera.far !== undefined || viewDistance !== undefined)\n        ) {\n            // If maximum visibility range is available use it instead of camera.far distance,\n            // this makes fog independent from dynamic camera planes and keeps consistent\n            // distance based \"melting\" (fog) effect during a tilt.\n            const viewRange = viewDistance !== undefined ? viewDistance : mapView.camera.far;\n            // TODO: We may move below constants to theme Fog definition\n            // Density of the fog when viewing straight along the horizon line.\n            const horizontalDensity = 1.0;\n            // Theoretical density of the fog when viewing straight from top to down.\n            const verticalDensity = 0.0;\n            // The fraction of the maximum viewing distance along the eye vector\n            // to start applying the fog.\n            const startRatio = this.m_cachedFog.startRatio;\n            // The fraction of maximum viewing range at which fog fully covers geometry.\n            const endRatio = 1.0;\n            assert(startRatio <= endRatio);\n            const t = Math.abs(Math.cos(mapView.tilt));\n            const density = MathUtils.smoothStep(horizontalDensity, verticalDensity, t);\n            this.m_fog.near = THREE.MathUtils.lerp(\n                viewRange * startRatio,\n                viewRange,\n                1.0 - density\n            );\n            this.m_fog.far = THREE.MathUtils.lerp(viewRange * endRatio, viewRange, density);\n            this.m_fog.near = Math.min(this.m_fog.near, mapView.camera.far);\n            this.m_fog.far = Math.min(this.m_fog.far, mapView.camera.far);\n        }\n    }\n\n    /**\n     * Handles fog addition.\n     */\n    private add() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = this.m_fog;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(true);\n    }\n\n    /**\n     * Handles fog removal.\n     */\n    private remove() {\n        // When the fog is changed, ThreeJS takes care of recompiling its built-in materials...\n        this.m_scene.fog = null;\n        // ...except the `RawShaderMaterial`, on purpose, so it needs to be updated from the app.\n        this.setFogInRawShaderMaterials(false);\n    }\n\n    /**\n     * ThreeJS lets users manage the `RawShaderMaterial` themselves, so they need to be modified\n     * explicitly.\n     *\n     * @see https://github.com/mrdoob/three.js/blob/dev/src/renderers/webgl/WebGLProgram.js#L298\n     */\n    private setFogInRawShaderMaterials(enableFog: boolean) {\n        this.m_scene.traverse(object => {\n            if (object instanceof THREE.Mesh) {\n                const material = object.material;\n                if (\n                    material instanceof THREE.Material &&\n                    // HighPrecisionLineMaterial does not support fog:\n                    !(material instanceof HighPrecisionLineMaterial) &&\n                    // We may skip redundant updates:\n                    material.fog !== enableFog\n                ) {\n                    material.fog = enableFog;\n                    if (material instanceof RawShaderMaterial) {\n                        // Fog properties can't be easily changed at runtime (once the material\n                        // is rendered at least once) and thus requires building of new shader\n                        // program - force material update.\n                        material.invalidateFog();\n                    }\n                }\n            }\n        });\n    }\n}\n","/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { PickingRaycaster } from \"./PickingRaycaster\";\n\n/**\n * `MapViewPoints` is a class to extend for the `\"circles\"` and `\"squares\"` techniques to\n * implement raycasting of `THREE.Points` as expected in {@link MapView},\n * that are in screen space.\n *\n * @remarks\n * It copies the behaviour of the `raycast` method in [[THREE.Points]] and dispatches it to its\n * children classes, {@link Circles} and {@link Squares}, who hold the intersection testing in the\n * `testPoint` method. This class also has the ability to dismiss the testing via the\n * `enableRayTesting` flag.\n *\n * Its main motivation is to handle the point styles of XYZ projects.\n *\n * @see https://github.com/mrdoob/three.js/blob/master/src/objects/Points.js\n *\n * @internal\n */\nexport abstract class MapViewPoints extends THREE.Points {\n    /**\n     * This allows to discard the ray testing.\n     */\n    enableRayTesting: boolean = true;\n\n    /**\n     * Implements the intersection testing in screen space between the drawn points and the ray.\n     *\n     * @remarks The drawing of the points being different between {@link Circles}\n     * and {@link Squares}, this method is implemented in these child classes.\n     *\n     * @param point - The point to test.\n     * @param screenPosition - The point position on screen.\n     * @param pickCoordinates - The picking position on screen.\n     * @param index - The index of the point in the [[THREE.BufferGeometry]].\n     * @param distance - The distance between the point and the ray origin.\n     * @param intersects - The results array.\n     */\n    abstract testPoint(\n        point: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        pickCoordinates: THREE.Vector2,\n        index: number,\n        distance: number,\n        intersects: THREE.Intersection[]\n    ): void;\n\n    /**\n     * This method is similar to the original method `raycast` in [[THREE.Points]] except that it\n     * then calls the tailored `testPoint` method in the children classes to test intersections\n     * depending on whether the points are circles or squares, which [[THREE.Points]] cannot do.\n     *\n     * @param raycaster - The raycaster.\n     * @param intersects - The array to fill with the results.\n     */\n    raycast(raycaster: PickingRaycaster, intersects: THREE.Intersection[]) {\n        if (!this.enableRayTesting) {\n            return;\n        }\n\n        const geometry = this.geometry;\n        const matrixWorld = this.matrixWorld;\n        const ndc = raycaster.ray.origin\n            .clone()\n            .add(raycaster.ray.direction)\n            .project(raycaster.camera);\n        const mouseCoords = ndcToScreen(ndc, raycaster);\n\n        const testPoint = (point: THREE.Vector3, index: number) => {\n            const pointInfo = getPointInfo(point, matrixWorld, raycaster);\n            if (pointInfo.pointIsOnScreen) {\n                this.testPoint(\n                    point,\n                    pointInfo.absoluteScreenPosition!,\n                    mouseCoords,\n                    index,\n                    pointInfo.distance!,\n                    intersects\n                );\n            }\n        };\n\n        const point = new THREE.Vector3();\n        const index = geometry.index;\n        const attributes = geometry.attributes;\n        const positions = attributes.position.array;\n        if (index !== null) {\n            const indices = index.array;\n            for (let i = 0, il = indices.length; i < il; i++) {\n                testPoint(point.fromArray(positions as number[], indices[i] * 3), i);\n            }\n        } else {\n            for (let i = 0, l = positions.length / 3; i < l; i++) {\n                testPoint(point.fromArray(positions as number[], i * 3), i);\n            }\n        }\n    }\n}\n\nfunction ndcToScreen(ndc: THREE.Vector3, raycaster: PickingRaycaster): THREE.Vector2 {\n    return new THREE.Vector2(ndc.x + 1, 1 - ndc.y)\n        .divideScalar(2)\n        .multiply(raycaster.canvasSize)\n        .ceil();\n}\n\nfunction getPointInfo(\n    point: THREE.Vector3,\n    matrixWorld: THREE.Matrix4,\n    raycaster: PickingRaycaster\n): {\n    pointIsOnScreen: boolean;\n    absoluteScreenPosition?: THREE.Vector2;\n    distance?: number;\n} {\n    const worldPosition = point.clone().applyMatrix4(matrixWorld);\n    const distance = worldPosition.distanceTo(raycaster.ray.origin);\n    const ndc = worldPosition.project(raycaster.camera);\n    const pointIsOnScreen = ndc.x < 1 && ndc.x > -1 && ndc.y < 1 && ndc.y > -1;\n    if (pointIsOnScreen) {\n        const absoluteScreenPosition = ndcToScreen(ndc, raycaster);\n        return {\n            absoluteScreenPosition,\n            pointIsOnScreen,\n            distance\n        };\n    }\n    return {\n        pointIsOnScreen\n    };\n}\n\n/**\n * Point object that implements the raycasting of circles in screen space.\n * @internal\n */\nexport class Circles extends MapViewPoints {\n    /** @override */\n    testPoint(\n        point: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        pickCoordinates: THREE.Vector2,\n        index: number,\n        distance: number,\n        intersects: THREE.Intersection[]\n    ) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const dist = Math.sqrt(dx * dx + dy * dy);\n        const radius = (this.material as THREE.PointsMaterial).size / 2;\n\n        if (dist <= radius) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\n\n/**\n * Point object that implements the raycasting of squares in screen space.\n * @internal\n */\nexport class Squares extends MapViewPoints {\n    /** @override */\n    testPoint(\n        point: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        pickCoordinates: THREE.Vector2,\n        index: number,\n        distance: number,\n        intersects: THREE.Intersection[]\n    ) {\n        const dx = screenPosition.x - pickCoordinates.x;\n        const dy = screenPosition.y - pickCoordinates.y;\n        const halfSize = (this.material as THREE.PointsMaterial).size / 2;\n\n        if (Math.abs(dx) <= halfSize && Math.abs(dy) <= halfSize) {\n            intersects.push({\n                point,\n                distance,\n                index,\n                object: this\n            });\n        }\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { PerformanceTimer, Task, TaskQueue } from \"@here/harp-utils\";\nimport THREE = require(\"three\");\n\nimport { TileTaskGroups } from \"./MapView\";\nimport { PerformanceStatistics } from \"./Statistics\";\n\nconst DEFAULT_MAX_FPS = 60;\nconst DEFAULT_PROCESSING_ESTIMATE_TIME = 2;\nconst UPDATE_EVENT = { type: \"update\" };\n\nexport class MapViewTaskScheduler extends THREE.EventDispatcher {\n    private readonly m_taskQueue: TaskQueue;\n    private m_throttlingEnabled: boolean = false;\n\n    constructor(private m_maxFps: number = DEFAULT_MAX_FPS) {\n        super();\n        this.m_taskQueue = new TaskQueue({\n            groups: [TileTaskGroups.FETCH_AND_DECODE, TileTaskGroups.CREATE],\n            prioSortFn: (a: Task, b: Task) => {\n                return a.getPriority() - b.getPriority();\n            }\n        });\n        this.maxFps = m_maxFps;\n    }\n\n    set maxFps(fps: number) {\n        this.m_maxFps = fps <= 0 ? DEFAULT_MAX_FPS : fps;\n    }\n\n    get maxFps(): number {\n        return this.m_maxFps;\n    }\n\n    get taskQueue() {\n        return this.m_taskQueue;\n    }\n\n    get throttlingEnabled(): boolean {\n        return this.m_throttlingEnabled === true;\n    }\n\n    set throttlingEnabled(enabled: boolean) {\n        this.m_throttlingEnabled = enabled;\n    }\n\n    /**\n     * Sends a request to the [[MapView]] to redraw the scene.\n     */\n    requestUpdate() {\n        this.dispatchEvent(UPDATE_EVENT);\n    }\n\n    /**\n     * Processes the pending Tasks of the underlying [[TaskQueue]]\n     * !! This should run at the end of the renderLoop, so the calculations of the available\n     * frame time are better estimated\n     *\n     * @param frameStartTime the start time of the current frame, is used to calculate the\n     * still available time in the frame to process Tasks\n     *\n     */\n    processPending(frameStartTime: number) {\n        const stats = PerformanceStatistics.instance;\n        const currentFrameEvent = stats.enabled ? stats.currentFrame : undefined;\n        let startTime: number | undefined;\n        if (stats.enabled) {\n            startTime = PerformanceTimer.now();\n        }\n\n        //update the task queue, to remove expired and sort with priority\n        this.m_taskQueue.update();\n        let numItemsLeft = this.taskQueue.numItemsLeft();\n        currentFrameEvent?.setValue(\"TaskScheduler.numPendingTasks\", numItemsLeft);\n\n        if (this.throttlingEnabled) {\n            // get the available time in this frame to achieve a max fps rate\n            let availableTime = this.spaceInFrame(frameStartTime);\n            // get some buffer to balance the inaccurate estimates\n            availableTime = availableTime > 2 ? availableTime - 2 : availableTime;\n            currentFrameEvent?.setValue(\"TaskScheduler.estimatedAvailableTime\", availableTime);\n\n            let counter = 0;\n            // check if ther is still time available and tasks left\n            while (availableTime > 0 && numItemsLeft > 0) {\n                counter++;\n                // create a processing condition for the tasks\n                function shouldProcess(task: Task) {\n                    // if there is a time estimate use it, otherwise default to 1 ms\n                    // TODO: check whats a sane default, 1 seems to do it for now\n                    availableTime -=\n                        task.estimatedProcessTime?.() ?? DEFAULT_PROCESSING_ESTIMATE_TIME;\n                    // always process at least 1 Task, so in the worst case the fps over tiles\n                    // paradigma is sacrificed to not have an empty screen\n                    if (availableTime > 0 || counter === 1) {\n                        return true;\n                    }\n                    return false;\n                }\n\n                // process the CREATE tasks first, as they will have a faster result on the\n                // visual outcome and have already spend time in the application during\n                // fetching and decoding\n                // fetching has lower priority as it wont make to much of a difference if not\n                // called at the exact frame, and the tile might expire in the next anyway\n                [TileTaskGroups.CREATE, TileTaskGroups.FETCH_AND_DECODE].forEach(tag => {\n                    if (this.m_taskQueue.numItemsLeft(tag)) {\n                        //TODO:\n                        // * if one tag task does not fit another might, how to handle this?\n                        // *    ** what if a task of another group could fit instead\n                        // * whats the average of time we have here at this point in the programm?\n                        this.m_taskQueue.processNext(tag, shouldProcess);\n                    }\n                });\n                numItemsLeft = this.m_taskQueue.numItemsLeft();\n            }\n            // if there is tasks left in the TaskQueue, request an update to be able to process them\n            // in a next frame\n            numItemsLeft = this.m_taskQueue.numItemsLeft();\n            if (numItemsLeft > 0) {\n                currentFrameEvent?.setValue(\n                    \"TaskScheduler.pendingTasksNotYetProcessed\",\n                    numItemsLeft\n                );\n                this.requestUpdate();\n            }\n        } else {\n            //if throttling is disabled, process all pending tasks\n            this.m_taskQueue.processNext(\n                TileTaskGroups.CREATE,\n                undefined,\n                this.m_taskQueue.numItemsLeft(TileTaskGroups.CREATE)\n            );\n            this.m_taskQueue.processNext(\n                TileTaskGroups.FETCH_AND_DECODE,\n                undefined,\n                this.m_taskQueue.numItemsLeft(TileTaskGroups.FETCH_AND_DECODE)\n            );\n        }\n\n        if (stats.enabled) {\n            currentFrameEvent?.setValue(\n                \"TaskScheduler.pendingTasksTime\",\n                PerformanceTimer.now() - startTime!\n            );\n        }\n    }\n\n    /**\n     * Removes all tasks that have been queued.\n     */\n    clearQueuedTasks() {\n        this.m_taskQueue.clear();\n    }\n\n    private spaceInFrame(frameStartTime: number): number {\n        const passedTime = (performance || Date).now() - frameStartTime;\n        return Math.max(1000 / this.m_maxFps - passedTime, 0);\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    FlatTheme,\n    ImageDefinitions,\n    ImageTexture,\n    PoiTableRef,\n    Theme\n} from \"@here/harp-datasource-protocol\";\nimport { LoggerManager, UriResolver } from \"@here/harp-utils\";\n\nimport { MapViewImageCache } from \"./image/MapViewImageCache\";\nimport { MapView } from \"./MapView\";\nimport { ThemeLoader } from \"./ThemeLoader\";\n\nconst logger = LoggerManager.instance.create(\"MapViewThemeManager\");\n\n/**\n * Class handling theme updates for MapView\n */\nexport class MapViewThemeManager {\n    private readonly m_imageCache: MapViewImageCache;\n    private m_updatePromise: Promise<void> | undefined;\n    private m_abortControllers: AbortController[] = [];\n    private m_theme: Theme = {};\n\n    constructor(private readonly m_mapView: MapView, private readonly m_uriResolver?: UriResolver) {\n        this.m_imageCache = new MapViewImageCache();\n    }\n\n    async setTheme(theme: Theme | FlatTheme | string): Promise<Theme> {\n        if (this.isUpdating()) {\n            logger.warn(\"Formerly set Theme is still updating, update will be canceled\");\n            this.cancelThemeUpdate();\n        }\n\n        this.m_updatePromise = this.loadTheme(theme).then(async theme => {\n            await this.updateTheme(theme);\n        });\n        await this.m_updatePromise;\n        this.m_updatePromise = undefined;\n        return this.m_theme;\n    }\n\n    async getTheme(): Promise<Theme> {\n        if (this.isUpdating()) {\n            await this.m_updatePromise;\n        }\n        return this.m_theme;\n    }\n\n    isUpdating(): boolean {\n        return this.m_updatePromise !== undefined;\n    }\n\n    /**\n     * @deprecated\n     * A helper for the deprecated MapView.theme getter, remove when\n     * after deprecation\n     */\n    get theme() {\n        return this.isUpdating() ? {} : this.m_theme;\n    }\n\n    private async loadTheme(theme: Theme | string | FlatTheme): Promise<Theme> {\n        let loadedTheme: Theme = {};\n        if (typeof theme === \"string\" || !ThemeLoader.isThemeLoaded(theme)) {\n            try {\n                loadedTheme = await ThemeLoader.load(theme, {\n                    uriResolver: this.m_uriResolver,\n                    signal: this.createAbortController().signal\n                });\n            } catch (error) {\n                if (error.name === \"AbortError\") {\n                    logger.warn(`theme loading was aborted due to: ${error}`);\n                } else {\n                    logger.error(`failed to load theme: ${error}`);\n                }\n            }\n        } else {\n            loadedTheme = theme as Theme;\n        }\n        return loadedTheme;\n    }\n\n    private async updateTheme(theme: Theme): Promise<void> {\n        const environment = this.m_mapView.sceneEnvironment;\n        // Fog and sky.\n        this.m_theme.fog = theme.fog;\n        this.m_theme.sky = theme.sky;\n        environment.updateSkyBackground(theme.sky);\n        environment.fog.reset(theme.fog);\n\n        this.m_theme.lights = theme.lights;\n        environment.updateLighting(theme.lights);\n\n        // Clear color.\n        this.m_theme.clearColor = theme.clearColor;\n        this.m_theme.clearAlpha = theme.clearAlpha;\n        environment.updateClearColor(theme.clearColor, theme.clearAlpha);\n\n        // Images.\n        this.m_theme.images = theme.images;\n        this.m_theme.imageTextures = theme.imageTextures;\n        await this.updateImages(theme.images, theme.imageTextures);\n\n        // POI tables.\n        this.m_theme.poiTables = theme.poiTables;\n        await this.loadPoiTables(theme.poiTables);\n        // Text.\n        this.m_theme.textStyles = theme.textStyles;\n        this.m_theme.defaultTextStyle = theme.defaultTextStyle;\n        this.m_theme.fontCatalogs = theme.fontCatalogs;\n\n        await this.m_mapView.resetTextRenderer(\n            theme.fontCatalogs,\n            theme.textStyles,\n            theme.defaultTextStyle\n        );\n\n        if (Array.isArray(theme.priorities)) {\n            this.m_theme.priorities = theme.priorities;\n        }\n        this.m_mapView.mapAnchors.setPriorities(theme.priorities ?? []);\n\n        if (Array.isArray(theme.labelPriorities)) {\n            this.m_theme.labelPriorities = theme.labelPriorities;\n        }\n\n        if (this.m_theme.styles === undefined) {\n            this.m_theme.styles = {};\n        }\n\n        this.m_theme.styles = theme.styles ?? {};\n        this.m_theme.definitions = theme.definitions;\n\n        environment.clearBackgroundDataSource();\n        for (const dataSource of this.m_mapView.dataSources) {\n            await dataSource.setTheme(this.m_theme);\n        }\n    }\n\n    updateCache() {\n        this.updateImages(this.m_theme.images, this.m_theme.imageTextures);\n        this.m_mapView.sceneEnvironment.updateLighting(this.m_theme.lights);\n        this.m_mapView.sceneEnvironment.updateSkyBackground(\n            this.m_theme.sky,\n            this.m_theme.clearColor\n        );\n    }\n\n    get imageCache(): MapViewImageCache {\n        return this.m_imageCache;\n    }\n\n    dispose() {\n        this.m_imageCache.clear();\n    }\n\n    private async loadPoiTables(poiTables?: PoiTableRef[]) {\n        this.m_mapView.poiTableManager.clear();\n\n        // Add the POI tables defined in the theme.\n        await this.m_mapView.poiTableManager.loadPoiTables(poiTables);\n    }\n\n    private cancelThemeUpdate() {\n        for (var i = 0; i < this.m_abortControllers.length; i++) {\n            this.m_abortControllers[i].abort();\n        }\n        this.m_abortControllers = [];\n        this.m_imageCache.clear();\n        this.m_mapView.poiManager.clear();\n        this.m_mapView.poiTableManager.clear();\n    }\n\n    private createAbortController(): AbortController {\n        this.m_abortControllers.push(new AbortController());\n        return this.m_abortControllers[this.m_abortControllers.length - 1];\n    }\n\n    private async updateImages(images?: ImageDefinitions, imageTextures?: ImageTexture[]) {\n        this.m_imageCache.clear();\n        this.m_mapView.poiManager.clear();\n\n        if (images !== undefined) {\n            for (const name of Object.keys(images)) {\n                const image = images[name];\n                this.m_imageCache.addImage(name, image.url, image.preload === true);\n                if (typeof image.atlas === \"string\") {\n                    await this.m_mapView.poiManager.addTextureAtlas(\n                        name,\n                        image.atlas,\n                        this.createAbortController().signal\n                    );\n                }\n            }\n        }\n\n        if (imageTextures !== undefined) {\n            imageTextures.forEach((imageTexture: ImageTexture) => {\n                this.m_mapView.poiManager.addImageTexture(imageTexture);\n            });\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\n/**\n * This path in world coordinates is projected to screen space and blocks all other labels.\n *\n * It could be used for example:\n * - Border rejects labels.\n * - Route blocks street labels from being rendered underneath.\n *\n * Could potentially be expanded in future to have a priority, however for now, this isn't required.\n */\n\nexport class PathBlockingElement {\n    /**\n     * Note, [[screenSpaceLines]] is only used as a performance improvement and contains no\n     * useful information. They are used to contain the screen space coordinates of the\n     * points. By allocating the space here, we avoid per frame allocations, see\n     * [[TextElementsRenderer.prepopulateScreenWithBlockingElements]].\n     */\n    readonly screenSpaceLines: THREE.Line3[];\n\n    /**\n     * Constructs a path from a list of points.\n     * Pre allocates the [[screenSpaceLines]] used to render.\n     * @param points - Points in world coordinates.\n     */\n    constructor(readonly points: Vector3Like[]) {\n        this.screenSpaceLines = new Array<THREE.Line3>(points.length >= 2 ? points.length - 1 : 0);\n        for (let i = 0; i < this.screenSpaceLines.length; i++) {\n            this.screenSpaceLines[i] = new THREE.Line3(new THREE.Vector3(), new THREE.Vector3());\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryType, getFeatureId, Technique } from \"@here/harp-datasource-protocol\";\nimport { OrientedBox3, TileKey } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\nimport { IntersectParams } from \"./IntersectParams\";\nimport { MapView } from \"./MapView\";\nimport { MapViewPoints } from \"./MapViewPoints\";\nimport { PickingRaycaster } from \"./PickingRaycaster\";\nimport { PickListener } from \"./PickListener\";\nimport { Tile, TileFeatureData } from \"./Tile\";\nimport { MapViewUtils } from \"./Utils\";\n\n/**\n * Describes the general type of a picked object.\n */\nexport enum PickObjectType {\n    /**\n     * Unspecified.\n     */\n    Unspecified = 0,\n\n    /**\n     * A point object.\n     */\n    Point,\n\n    /**\n     * A line object.\n     */\n    Line,\n\n    /**\n     * An area object.\n     */\n    Area,\n\n    /**\n     * The text part of a {@link TextElement}\n     */\n    Text,\n\n    /**\n     * The Icon of a {@link TextElement}.\n     */\n    Icon,\n\n    /**\n     * Any general 3D object, for example, a landmark.\n     */\n    Object3D\n}\n\n/**\n * A general pick result. You can access the details of a picked geometry from the property\n * `intersection`, which is available if a geometry was hit. If a road was hit, a [[RoadPickResult]]\n * is returned, which has additional information, but no `intersection`.\n */\nexport interface PickResult {\n    /**\n     * General type of object.\n     */\n    type: PickObjectType;\n\n    /**\n     * A 2D point in screen coordinates, or a 3D point in world coordinates.\n     */\n    point: THREE.Vector2 | THREE.Vector3;\n\n    /**\n     * Distance from the camera to the picking point; used to determine the closest object.\n     */\n    distance: number;\n\n    /**\n     * Uniquely identifies the data source which provided the picked object.\n     */\n    dataSourceName: string | undefined;\n\n    /**\n     * Data source order, useful for sorting a collection of picking results.\n     * A number for objects/features coming from tiles (as those have data sources attached),\n     * an undefined when objects are added via \"mapView.mapAnchors.add(object)\" - those are treated as\n     * base layer objects during picking (same as \"dataSourceOrder: 0\").\n     */\n    dataSourceOrder: number | undefined;\n\n    /**\n     * Render order of the intersected object.\n     */\n    renderOrder?: number;\n\n    /**\n     * An optional feature ID of the picked object.\n     * @remarks The ID may be assigned by the object's {@link DataSource}, for example in case of\n     * Optimized Map Vector (OMV) and GeoJSON data sources.\n     */\n    featureId?: number | string;\n\n    /**\n     * Defined for geometry only.\n     */\n    intersection?: THREE.Intersection;\n\n    /**\n     * Defined for roads or if `enableTechniqueInfo` option is enabled.\n     */\n    technique?: Technique;\n\n    /**\n     * Optional user data that has been defined in the picked object.\n     *\n     * @remarks\n     * This object points directly to\n     * information contained in the original {@link TileFeatureData}\n     * stored in {@link MapView}, and should\n     * not be modified.\n     */\n    userData?: any;\n\n    /**\n     * The tile key containing the picked object.\n     */\n    tileKey?: TileKey;\n}\n\nconst tmpV3 = new THREE.Vector3();\nconst tmpOBB = new OrientedBox3();\n\n// Intersects the dependent tile objects using the supplied raycaster. Note, because multiple\n// tiles can point to the same dependency we need to store which results we have already\n// raycasted, see checkedDependencies.\nfunction intersectDependentObjects(\n    tile: Tile,\n    intersects: THREE.Intersection[],\n    rayCaster: THREE.Raycaster,\n    checkedDependencies: Set<number>,\n    mapView: MapView\n) {\n    for (const tileKey of tile.dependencies) {\n        const mortonCode = tileKey.mortonCode();\n        if (checkedDependencies.has(mortonCode)) {\n            continue;\n        }\n        checkedDependencies.add(mortonCode);\n        const otherTile = mapView.visibleTileSet.getCachedTile(\n            tile.dataSource,\n            tileKey,\n            tile.offset,\n            mapView.frameNumber\n        );\n        if (otherTile !== undefined) {\n            rayCaster.intersectObjects(otherTile.objects, true, intersects);\n        }\n    }\n}\n\n/**\n * Handles the picking of scene geometry and roads.\n * @internal\n */\nexport class PickHandler {\n    private readonly m_pickingRaycaster: PickingRaycaster;\n\n    constructor(\n        readonly mapView: MapView,\n        readonly camera: THREE.Camera,\n        public enablePickTechnique = false\n    ) {\n        this.m_pickingRaycaster = new PickingRaycaster(\n            mapView.renderer.getSize(new THREE.Vector2())\n        );\n    }\n\n    /**\n     * Does a raycast on all objects in the scene; useful for picking.\n     *\n     * @param x - The X position in CSS/client coordinates, without the applied display ratio.\n     * @param y - The Y position in CSS/client coordinates, without the applied display ratio.\n     * @param parameters - The intersection test behaviour may be adjusted by providing an instance\n     * of {@link IntersectParams}.\n     * @returns the list of intersection results.\n     */\n    intersectMapObjects(x: number, y: number, parameters?: IntersectParams): PickResult[] {\n        const ndc = this.mapView.getNormalizedScreenCoordinates(x, y);\n        const rayCaster = this.setupRaycaster(x, y);\n        const pickListener = new PickListener(parameters);\n\n        if (this.mapView.textElementsRenderer !== undefined) {\n            const { clientWidth, clientHeight } = this.mapView.canvas;\n            const screenX = ndc.x * clientWidth * 0.5;\n            const screenY = ndc.y * clientHeight * 0.5;\n            const scenePosition = new THREE.Vector2(screenX, screenY);\n            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickListener);\n        }\n\n        const intersects: THREE.Intersection[] = [];\n        const intersectedTiles = this.getIntersectedTiles(rayCaster);\n\n        // This ensures that we check a given dependency only once (because multiple tiles could\n        // have the same dependency).\n        const checkedDependencies = new Set<number>();\n\n        for (const { tile, distance } of intersectedTiles) {\n            if (pickListener.done && pickListener.furthestResult!.distance < distance) {\n                // Stop when the listener has all results it needs and remaining tiles are further\n                // away than then furthest pick result found so far.\n                break;\n            }\n\n            intersects.length = 0;\n            rayCaster.intersectObjects(tile.objects, true, intersects);\n            intersectDependentObjects(\n                tile,\n                intersects,\n                rayCaster,\n                checkedDependencies,\n                this.mapView\n            );\n\n            for (const intersect of intersects) {\n                pickListener.addResult(this.createResult(intersect, tile));\n            }\n        }\n\n        // Intersect any objects added by the user.\n        intersects.length = 0;\n        for (const child of this.mapView.mapAnchors.children) {\n            rayCaster.intersectObject(child, true, intersects);\n\n            for (const intersect of intersects) {\n                pickListener.addResult(this.createResult(intersect));\n            }\n        }\n\n        pickListener.finish();\n        return pickListener.results;\n    }\n\n    /**\n     * Returns a ray caster using the supplied screen positions.\n     *\n     * @param x - The X position in css/client coordinates (without applied display ratio).\n     * @param y - The Y position in css/client coordinates (without applied display ratio).\n     *\n     * @return Raycaster with origin at the camera and direction based on the supplied x / y screen\n     * points.\n     */\n    raycasterFromScreenPoint(x: number, y: number): THREE.Raycaster {\n        this.m_pickingRaycaster.setFromCamera(\n            this.mapView.getNormalizedScreenCoordinates(x, y),\n            this.camera\n        );\n\n        this.mapView.renderer.getSize(this.m_pickingRaycaster.canvasSize);\n        return this.m_pickingRaycaster;\n    }\n\n    private createResult(intersection: THREE.Intersection, tile?: Tile): PickResult {\n        const pickResult: PickResult = {\n            type: PickObjectType.Unspecified,\n            point: intersection.point,\n            distance: intersection.distance,\n            dataSourceName: intersection.object.userData?.dataSource,\n            dataSourceOrder: tile?.dataSource?.dataSourceOrder,\n            intersection,\n            tileKey: tile?.tileKey\n        };\n\n        if (\n            intersection.object.userData === undefined ||\n            intersection.object.userData.feature === undefined\n        ) {\n            return pickResult;\n        }\n\n        if (this.enablePickTechnique) {\n            pickResult.technique = intersection.object.userData.technique;\n        }\n        pickResult.renderOrder = intersection.object?.renderOrder;\n\n        const featureData: TileFeatureData = intersection.object.userData.feature;\n        this.addObjInfo(featureData, intersection, pickResult);\n        if (pickResult.userData) {\n            const featureId = getFeatureId(pickResult.userData);\n            pickResult.featureId = featureId === 0 ? undefined : featureId;\n        }\n\n        let pickObjectType: PickObjectType;\n\n        switch (featureData.geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                pickObjectType = PickObjectType.Point;\n                break;\n            case GeometryType.Line:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.SolidLine:\n            case GeometryType.TextPath:\n                pickObjectType = PickObjectType.Line;\n                break;\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                pickObjectType = PickObjectType.Area;\n                break;\n            case GeometryType.Object3D:\n                pickObjectType = PickObjectType.Object3D;\n                break;\n            default:\n                pickObjectType = PickObjectType.Unspecified;\n        }\n\n        pickResult.type = pickObjectType;\n        return pickResult;\n    }\n\n    private getIntersectedTiles(\n        rayCaster: THREE.Raycaster\n    ): Array<{ tile: Tile; distance: number }> {\n        const tiles = new Array<{\n            tile: Tile;\n            distance: number;\n        }>();\n        const tileList = this.mapView.visibleTileSet.dataSourceTileList;\n        tileList.forEach(dataSourceTileList => {\n            if (!dataSourceTileList.dataSource.enablePicking) {\n                return;\n            }\n\n            dataSourceTileList.renderedTiles.forEach(tile => {\n                tmpOBB.copy(tile.boundingBox);\n                tmpOBB.position.sub(this.mapView.worldCenter);\n                // This offset shifts the box by the given tile offset, see renderTileObjects in\n                // MapView\n                const worldOffsetX = tile.computeWorldOffsetX();\n                tmpOBB.position.x += worldOffsetX;\n                const distance = tmpOBB.intersectsRay(rayCaster.ray);\n                if (distance !== undefined) {\n                    tiles.push({ tile, distance });\n                }\n            });\n        });\n\n        tiles.sort(\n            (lhs: { tile: Tile; distance: number }, rhs: { tile: Tile; distance: number }) => {\n                return lhs.distance - rhs.distance;\n            }\n        );\n        return tiles;\n    }\n\n    private addObjInfo(\n        featureData: TileFeatureData,\n        intersect: THREE.Intersection,\n        pickResult: PickResult\n    ) {\n        if (featureData.objInfos === undefined) {\n            return;\n        }\n\n        if (pickResult.intersection!.object instanceof MapViewPoints) {\n            pickResult.userData = featureData.objInfos[intersect.index!];\n            return;\n        }\n\n        if (\n            featureData.starts === undefined ||\n            featureData.starts.length === 0 ||\n            (typeof intersect.faceIndex !== \"number\" && intersect.index === undefined)\n        ) {\n            if (featureData.objInfos.length === 1) {\n                pickResult.userData = featureData.objInfos[0];\n            }\n            return;\n        }\n\n        if (featureData.starts.length === 1) {\n            pickResult.userData = featureData.objInfos[0];\n            return;\n        }\n\n        const intersectIndex =\n            typeof intersect.faceIndex === \"number\" ? intersect.faceIndex * 3 : intersect.index!;\n\n        // TODO: Implement binary search.\n        let objInfosIndex = 0;\n        for (const featureStartIndex of featureData.starts) {\n            if (featureStartIndex > intersectIndex) {\n                break;\n            }\n            objInfosIndex++;\n        }\n        pickResult.userData = featureData.objInfos[objInfosIndex - 1];\n    }\n\n    private setupRaycaster(x: number, y: number): THREE.Raycaster {\n        const camera = this.mapView.camera;\n        const rayCaster = this.raycasterFromScreenPoint(x, y);\n\n        // A threshold must be set for picking of line and line segments, indicating the maximum\n        // distance in world units from the ray to a line to consider it as picked. Use the world\n        // units equivalent to one pixel at the furthest intersection (i.e. intersection with ground\n        // or far plane).\n        const furthestIntersection = this.mapView.getWorldPositionAt(x, y, true);\n        const furthestDistance =\n            camera.position.distanceTo(furthestIntersection) /\n            this.mapView.camera.getWorldDirection(tmpV3).dot(rayCaster.ray.direction);\n        rayCaster.params.Line!.threshold = MapViewUtils.calculateWorldSizeByFocalLength(\n            this.mapView.focalLength,\n            furthestDistance,\n            1\n        );\n        return rayCaster;\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\n\nimport { IntersectParams } from \"./IntersectParams\";\nimport { PickResult } from \"./PickHandler\";\n\n// Default sorting by:\n// 1. reversed data source order (higher first)\n// 2. distance to the camera (closer first)\n// 3. reversed render order (higher first)\n//\n// This criteria order is temporary, until HARP-16245 gets implemented.\n// Currently, rendering is configured in a way that makes 2D spatials occlude extruded buildings,\n// since spatials belong to a higher layer. Picking order reflects that, but comparison by distance should\n// happen first, once extruded buildings become rendered on top of spatials.\nfunction defaultSort(lhs: PickResult, rhs: PickResult) {\n    // HARP-14531: Compare by \"dataSourceOrder\" first,\n    // to ensure that picking results are sorted according to their layers.\n    // The bigger \"dataSourceOrder\" value is, the higher its stacked in the data model,\n    // meaning the higher it should be appear in the resulting picking collection.\n    // Defaulting \"dataSourceOrder\" to 0 (base layer) to not skip comparison when it's undefined - in that case\n    // sorting results would not be consistent, as some objects become compared by different criteria.\n    const lDataSourceOrder = lhs.dataSourceOrder ?? 0;\n    const rDataSourceOrder = rhs.dataSourceOrder ?? 0;\n    if (lDataSourceOrder !== rDataSourceOrder) {\n        return rDataSourceOrder - lDataSourceOrder;\n    }\n\n    // HARP-14553: Set a distance tolerance to ignore small distance differences between 2D objects\n    // that are supposed to lie on the same plane.\n    const eps = 1e-4;\n    const distanceDiff = lhs.distance - rhs.distance;\n    const haveRenderOrder = lhs.renderOrder !== undefined && rhs.renderOrder !== undefined;\n    if (Math.abs(distanceDiff) > eps || !haveRenderOrder) {\n        return distanceDiff;\n    }\n\n    return rhs.renderOrder! - lhs.renderOrder!;\n}\n\n/**\n * Collects results from a picking (intersection) test.\n *\n * @internal\n */\nexport class PickListener {\n    private m_results: PickResult[] = [];\n    private m_sorted: boolean = true;\n    private m_finished: boolean = true;\n\n    /**\n     * Constructs a new `PickListener`.\n     *\n     * @param m_parameters - Optional parameters to customize picking behaviour.\n     */\n    constructor(private readonly m_parameters?: IntersectParams) {}\n\n    /**\n     * Adds a pick result.\n     *\n     * @param result - The result to be added.\n     */\n    addResult(result: PickResult): void {\n        // Add the result only if it's a different feature from the ones already collected.\n        const foundFeatureIdx = this.m_results.findIndex(otherResult => {\n            const sameType = otherResult.type === result.type;\n            const dataSource = result.intersection?.object.userData?.dataSource;\n            const sameDataSource =\n                dataSource && otherResult.intersection?.object.userData?.dataSource === dataSource;\n            const sameId =\n                result.featureId !== undefined && otherResult.featureId === result.featureId;\n            const noId = result.featureId === undefined && otherResult.featureId === undefined;\n            const sameUserData = result.userData && otherResult.userData === result.userData;\n            return sameType && sameDataSource && (sameId || (noId && sameUserData));\n        });\n\n        if (foundFeatureIdx < 0) {\n            this.m_sorted = false;\n            this.m_finished = false;\n            this.m_results.push(result);\n            return;\n        }\n\n        // Replace the result for the same feature if it's sorted after the new result.\n        const oldResult = this.m_results[foundFeatureIdx];\n        if (defaultSort(result, oldResult) < 0) {\n            this.m_results[foundFeatureIdx] = result;\n            this.m_sorted = false;\n            this.m_finished = false;\n        }\n    }\n\n    /**\n     * Indicates whether the listener is satisfied with the results already provided.\n     * @returns `True` if the listener doesn't expect more results, `False` otherwise.\n     */\n    get done(): boolean {\n        return this.maxResults ? this.m_results.length >= this.maxResults : false;\n    }\n\n    /**\n     * Orders the collected results by distance first, then by reversed render order\n     * (topmost/highest render order first), and limits the number of results to the maximum\n     * accepted number, see {@link IntersectParams.maxResultCount}.\n     */\n    finish(): void {\n        // Keep only the closest max results.\n        this.sortResults();\n        if (this.maxResults && this.m_results.length > this.maxResults) {\n            this.m_results.length = this.maxResults;\n        }\n        this.m_finished = true;\n    }\n\n    /**\n     * Returns the collected results. {@link PickListener.finish} should be called first to ensure\n     * the proper sorting and result count.\n     * @returns The pick results.\n     */\n    get results(): PickResult[] {\n        assert(this.m_finished, \"finish() was not called before getting the results\");\n        return this.m_results;\n    }\n\n    /**\n     * Returns the closest result collected so far, following the order documented in\n     * {@link PickListener.finish}\n     * @returns The closest pick result, or `undefined` if no result was collected.\n     */\n    get closestResult(): PickResult | undefined {\n        this.sortResults();\n        return this.m_results.length > 0 ? this.m_results[0] : undefined;\n    }\n\n    /**\n     * Returns the furthest result collected so far, following the order documented in\n     * {@link PickListener.results}\n     * @returns The furthest pick result, or `undefined` if no result was collected.\n     */\n    get furthestResult(): PickResult | undefined {\n        this.sortResults();\n        return this.m_results.length > 0 ? this.m_results[this.m_results.length - 1] : undefined;\n    }\n\n    private get maxResults(): number | undefined {\n        const maxCount = this.m_parameters?.maxResultCount ?? 0;\n        return maxCount > 0 ? maxCount : undefined;\n    }\n\n    private sortResults(): void {\n        if (this.m_sorted) {\n            return;\n        }\n\n        // HARP-14531: group zero-distance results first,\n        // as screen-space objects (e.g. labels) are currently rendered on top.\n        const zeroDistanceGroup: PickResult[] = [];\n        const nonZeroDistanceGroup: PickResult[] = [];\n\n        this.m_results\n            .sort(defaultSort)\n            .forEach(result =>\n                (result.distance === 0 ? zeroDistanceGroup : nonZeroDistanceGroup).push(result)\n            );\n        // both groups are sorted because \"this.m_results\" are sorted\n        this.m_results = zeroDistanceGroup.concat(nonZeroDistanceGroup);\n        this.m_sorted = true;\n    }\n}\n","/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { MapObjectAdapter } from \"./MapObjectAdapter\";\n\nfunction intersectObject(\n    object: THREE.Object3D,\n    raycaster: PickingRaycaster,\n    intersects: THREE.Intersection[],\n    recursive?: boolean\n) {\n    if (object.layers.test(raycaster.layers) && object.visible) {\n        const mapObjectAdapter = MapObjectAdapter.get(object);\n        if (!mapObjectAdapter || mapObjectAdapter.isPickable()) {\n            object.raycast(raycaster, intersects);\n        }\n    }\n\n    if (recursive === true) {\n        for (const child of object.children) {\n            intersectObject(child, raycaster, intersects, true);\n        }\n    }\n}\n\n/**\n * Raycasting points is not supported as necessary in Three.js. This class extends a\n * [[THREE.Raycaster]] and adds the width / height of the canvas to allow picking of screen space\n * geometry.\n *\n * @internal\n */\nexport class PickingRaycaster extends THREE.Raycaster {\n    /**\n     * Constructor.\n     *\n     * @param canvasSize - the canvas width and height.\n     */\n    constructor(readonly canvasSize: THREE.Vector2) {\n        super();\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize overrides of\n    // three.js classes.\n    intersectObject(\n        object: THREE.Object3D,\n        recursive?: boolean,\n        optionalTarget?: THREE.Intersection[]\n    ): THREE.Intersection[] {\n        const intersects: THREE.Intersection[] = optionalTarget ?? [];\n\n        intersectObject(object, this, intersects, recursive);\n\n        return intersects;\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize overrides of\n    // three.js classes.\n    intersectObjects(\n        objects: THREE.Object3D[],\n        recursive?: boolean,\n        optionalTarget?: THREE.Intersection[]\n    ): THREE.Intersection[] {\n        const intersects: THREE.Intersection[] = optionalTarget ?? [];\n\n        for (const object of objects) {\n            intersectObject(object, this, intersects, recursive);\n        }\n\n        return intersects;\n    }\n}\n","/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    EarthConstants,\n    GeoCoordinates,\n    GeoPolygon,\n    GeoPolygonCoordinates,\n    Projection,\n    ProjectionType\n} from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport { Frustum, Line3, Matrix4, PerspectiveCamera, Plane, Ray, Vector3 } from \"three\";\n\nimport { TileCorners } from \"./geometry/ProjectTilePlaneCorners\";\nimport { MapViewUtils } from \"./Utils\";\nimport { ViewBounds } from \"./ViewBounds\";\n\n/**\n * Generates Bounds for a camera view and a planar projection.\n *\n * @internal\n */\nexport class PlaneViewBounds implements ViewBounds {\n    private readonly m_groundPlaneNormal = new Vector3(0, 0, 1);\n    private readonly m_groundPlane = new Plane(this.m_groundPlaneNormal.clone());\n\n    constructor(\n        readonly camera: PerspectiveCamera,\n        readonly projection: Projection,\n        private readonly m_options: { tileWrappingEnabled: boolean }\n    ) {\n        assert(projection.type === ProjectionType.Planar);\n    }\n\n    /**\n     * @override\n     */\n    generate(): GeoPolygon | undefined {\n        //!!!!!!!ALTITUDE IS NOT TAKEN INTO ACCOUNT!!!!!!!!!\n        const coordinates: GeoCoordinates[] = [];\n\n        // 1.) Raycast into all four corners of the canvas\n        //     => if an intersection is found, add it to the polygon\n        this.addCanvasCornerIntersection(coordinates);\n\n        // => All 4 corners found an intersection, therefore the screen is covered with the map\n        // and the polygon complete\n        if (coordinates.length === 4) {\n            return this.createPolygon(coordinates);\n        }\n\n        //2.) Raycast into the two corners of the horizon cutting the canvas sides\n        //    => if an intersection is found, add it to the polygon\n        this.addHorizonIntersection(coordinates);\n\n        //Setup the frustum for further checks\n        const frustum = new Frustum().setFromProjectionMatrix(\n            new Matrix4().multiplyMatrices(\n                this.camera.projectionMatrix,\n                this.camera.matrixWorldInverse\n            )\n        );\n\n        // Setup the world corners for further checks.\n        // Cast to TileCorners as it cannot be undefined here, due to the forced\n        // PlanarProjection above\n        const worldCorners: TileCorners = this.getWorldConers(this.projection) as TileCorners;\n\n        if (!this.m_options.tileWrappingEnabled) {\n            // 3.) If no wrapping, check if any corners of the world plane are inside the view\n            //     => if true, add it to the polygon\n            [worldCorners.ne, worldCorners.nw, worldCorners.se, worldCorners.sw].forEach(corner => {\n                this.addPointInFrustum(corner, frustum, coordinates);\n            });\n        }\n\n        //4.) Check for any edges of the world plane intersecting with the frustum?\n        //    => if true, add to polygon\n\n        if (!this.m_options.tileWrappingEnabled) {\n            // if no tile wrapping:\n            //       check with limited lines around the world edges\n            [\n                new Line3(worldCorners.sw, worldCorners.se), // south edge\n                new Line3(worldCorners.ne, worldCorners.nw), // north edge\n                new Line3(worldCorners.se, worldCorners.ne), // east edge\n                new Line3(worldCorners.nw, worldCorners.sw) //  west edge\n            ].forEach(edge => {\n                this.addFrustumIntersection(edge, frustum, coordinates);\n            });\n        } else {\n            // if tile wrapping:\n            //       check for intersections with rays along the south and north edges\n            const directionEast = new Vector3() //west -> east\n                .subVectors(worldCorners.sw, worldCorners.se)\n                .normalize();\n            const directionWest = new Vector3() //east -> west\n                .subVectors(worldCorners.se, worldCorners.sw)\n                .normalize();\n\n            [\n                new Ray(worldCorners.se, directionEast), // south east ray\n                new Ray(worldCorners.se, directionWest), // south west ray\n                new Ray(worldCorners.ne, directionEast), // north east ray\n                new Ray(worldCorners.ne, directionWest) //  north west ray\n            ].forEach(ray => {\n                this.addFrustumIntersection(ray, frustum, coordinates);\n            });\n        }\n\n        // 5.) Create the Polygon and set needsSort to `true`as we expect it to be convex and\n        //     sortable\n        return this.createPolygon(coordinates);\n    }\n\n    private createPolygon(coordinates: GeoCoordinates[]): GeoPolygon | undefined {\n        if (coordinates.length > 2) {\n            return new GeoPolygon(coordinates as GeoPolygonCoordinates, true);\n        }\n        return undefined;\n    }\n\n    private getWorldConers(projection: Projection): TileCorners | undefined {\n        const worldBox = projection.worldExtent(0, 0);\n        return {\n            sw: worldBox.min as Vector3,\n            se: new Vector3(worldBox.max.x, worldBox.min.y, 0),\n            nw: new Vector3(worldBox.min.x, worldBox.max.y, 0),\n            ne: worldBox.max as Vector3\n        };\n    }\n\n    private addNDCRayIntersection(\n        ndcPoints: Array<[number, number]>,\n        geoPolygon: GeoCoordinates[]\n    ) {\n        ndcPoints.forEach(corner => {\n            const intersection = MapViewUtils.rayCastWorldCoordinates(\n                { camera: this.camera, projection: this.projection },\n                corner[0],\n                corner[1]\n            );\n            if (intersection) {\n                this.validateAndAddToGeoPolygon(intersection, geoPolygon);\n            }\n        });\n    }\n\n    private addHorizonIntersection(geoPolygon: GeoCoordinates[]) {\n        const verticalHorizonPosition = this.getVerticalHorizonPositionInNDC();\n        if (!verticalHorizonPosition) {\n            return;\n        }\n        this.addNDCRayIntersection(\n            [\n                [-1, verticalHorizonPosition], //horizon left\n                [1, verticalHorizonPosition] //horizon right\n            ],\n            geoPolygon\n        );\n    }\n\n    private addCanvasCornerIntersection(geoPolygon: GeoCoordinates[]) {\n        this.addNDCRayIntersection(\n            [\n                [-1, -1], //lower left\n                [1, -1], //lower right\n                [1, 1], //upper right\n                [-1, 1] //upper left\n            ],\n            geoPolygon\n        );\n    }\n\n    private validateAndAddToGeoPolygon(point: Vector3, geoPolygon: GeoCoordinates[]) {\n        if (this.isInVisibleMap(point)) {\n            geoPolygon.push(this.projection.unprojectPoint(point));\n        }\n    }\n\n    private isInVisibleMap(point: Vector3): boolean {\n        if (point.y < 0 || point.y > EarthConstants.EQUATORIAL_CIRCUMFERENCE) {\n            return false;\n        }\n\n        if (\n            !this.m_options.tileWrappingEnabled &&\n            (point.x < 0 || point.x > EarthConstants.EQUATORIAL_CIRCUMFERENCE)\n        ) {\n            return false;\n        }\n        return true;\n    }\n\n    private addPointInFrustum(point: Vector3, frustum: Frustum, geoPolygon: GeoCoordinates[]) {\n        if (frustum.containsPoint(point)) {\n            const geoPoint = this.projection.unprojectPoint(point);\n            geoPoint.altitude = 0;\n            geoPolygon.push(geoPoint);\n        }\n    }\n\n    private addFrustumIntersection(\n        edge: Line3 | Ray,\n        frustum: Frustum,\n        geoPolygon: GeoCoordinates[]\n    ) {\n        frustum.planes.forEach(plane => {\n            let intersection: Vector3 | null | undefined = null;\n            const target: Vector3 = new Vector3();\n            if (edge instanceof Ray && edge.intersectsPlane(plane)) {\n                intersection = edge.intersectPlane(plane, target);\n            } else if (edge instanceof Line3 && plane.intersectsLine(edge)) {\n                intersection = plane.intersectLine(edge, target);\n            }\n\n            if (intersection) {\n                //uses this check to fix inaccuracies\n                if (MapViewUtils.closeToFrustum(intersection, this.camera)) {\n                    const geoIntersection = this.projection.unprojectPoint(intersection);\n\n                    //correct altitude caused by inaccuracies, due to large numbers to 0\n                    geoIntersection.altitude = 0;\n                    geoPolygon.push(geoIntersection);\n                }\n            }\n        });\n    }\n\n    private getVerticalHorizonPositionInNDC(): number | undefined {\n        const bottomMidFarPoint = new Vector3(-1, -1, 1)\n            .unproject(this.camera)\n            .add(new Vector3(1, -1, 1).unproject(this.camera))\n            .multiplyScalar(0.5);\n        const topMidFarPoint = new Vector3(-1, 1, 1)\n            .unproject(this.camera)\n            .add(new Vector3(1, 1, 1).unproject(this.camera))\n            .multiplyScalar(0.5);\n        const farPlaneVerticalCenterLine = new Line3(bottomMidFarPoint, topMidFarPoint);\n\n        const verticalHorizonPosition: Vector3 = new Vector3();\n        if (\n            !this.m_groundPlane.intersectLine(farPlaneVerticalCenterLine, verticalHorizonPosition)\n        ) {\n            return undefined;\n        }\n        return verticalHorizonPosition.project(this.camera).y;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    FlatTheme,\n    StandardGeometryKind,\n    StyleSet,\n    Technique,\n    Theme\n} from \"@here/harp-datasource-protocol\";\nimport { MapEnv, StyleSetEvaluator } from \"@here/harp-datasource-protocol/index-decoder\";\nimport {\n    GeoCoordinates,\n    MercatorConstants,\n    polarTilingScheme,\n    TileKey,\n    TilingScheme,\n    TransverseMercatorUtils\n} from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\nimport { DataSource, DataSourceOptions } from \"./DataSource\";\nimport { createMaterial } from \"./DecodedTileHelpers\";\nimport { MapObjectAdapter } from \"./MapObjectAdapter\";\nimport { ThemeLoader } from \"./ThemeLoader\";\nimport { Tile } from \"./Tile\";\n\nexport interface PolarTileDataSourceOptions extends DataSourceOptions {\n    /**\n     * Optional level offset of regular tiles from reference datasource to align tiles to.\n     * Default is -1.\n     */\n    geometryLevelOffset?: number;\n\n    /**\n     * Enable debug display for generated tiles.\n     * Default is false.\n     */\n    debugTiles?: boolean;\n}\n\ninterface TechniqueEntry {\n    technique: Technique;\n    material: THREE.Material;\n}\n\n/**\n * {@link DataSource} providing geometry for poles\n */\nexport class PolarTileDataSource extends DataSource {\n    private readonly m_tilingScheme: TilingScheme = polarTilingScheme;\n    private readonly m_maxLatitude = THREE.MathUtils.radToDeg(MercatorConstants.MAXIMUM_LATITUDE);\n    private m_geometryLevelOffset: number;\n    private readonly m_debugTiles: boolean;\n\n    private m_styleSetEvaluator?: StyleSetEvaluator;\n    private m_northPoleEntry?: TechniqueEntry;\n    private m_southPoleEntry?: TechniqueEntry;\n\n    constructor({\n        name = \"polar\",\n        styleSetName = \"polar\",\n        minDataLevel,\n        maxDataLevel,\n        minDisplayLevel,\n        maxDisplayLevel,\n        storageLevelOffset = -2,\n        geometryLevelOffset = 1,\n        debugTiles = false\n    }: PolarTileDataSourceOptions) {\n        super({\n            name,\n            styleSetName,\n            minDataLevel,\n            maxDataLevel,\n            minDisplayLevel,\n            maxDisplayLevel,\n            storageLevelOffset\n        });\n\n        this.m_geometryLevelOffset = geometryLevelOffset;\n        this.m_debugTiles = debugTiles;\n        this.cacheable = false;\n        this.enablePicking = false;\n    }\n\n    /** @override */\n    dispose() {\n        if (this.m_northPoleEntry) {\n            this.m_northPoleEntry.material.dispose();\n            delete this.m_northPoleEntry;\n        }\n        if (this.m_southPoleEntry) {\n            this.m_southPoleEntry.material.dispose();\n            delete this.m_southPoleEntry;\n        }\n        if (this.m_styleSetEvaluator) {\n            delete this.m_styleSetEvaluator;\n        }\n    }\n\n    createTechiqueEntry(kind: string): TechniqueEntry | undefined {\n        if (!this.m_styleSetEvaluator) {\n            return undefined;\n        }\n        const env = new MapEnv({\n            $geometryType: \"polygon\",\n            $layer: \"earth\",\n            kind\n        });\n        const techniques = this.m_styleSetEvaluator.getMatchingTechniques(env);\n\n        if (techniques.length === 0) {\n            return undefined;\n        }\n        const technique = techniques[0];\n        const material = createMaterial(this.mapView.renderer.capabilities, {\n            technique,\n            env: this.mapView.env\n        });\n        if (!material) {\n            return undefined;\n        }\n        return { material, technique };\n    }\n\n    /** @override */\n    async setTheme(theme: Theme | FlatTheme): Promise<void> {\n        // Seems superfluent, but the call to  ThemeLoader.load will resolve extends etc.\n        theme = await ThemeLoader.load(theme);\n        let styleSet: StyleSet | undefined;\n\n        if (this.styleSetName !== undefined && theme.styles !== undefined) {\n            styleSet = theme.styles[this.styleSetName];\n        }\n\n        this.m_styleSetEvaluator = new StyleSetEvaluator({\n            styleSet: styleSet ?? [],\n            definitions: theme.definitions,\n            priorities: theme.priorities,\n            labelPriorities: theme.labelPriorities\n        });\n\n        this.m_northPoleEntry = this.createTechiqueEntry(\"north_pole\");\n        this.m_southPoleEntry = this.createTechiqueEntry(\"south_pole\");\n\n        this.mapView.markTilesDirty(this);\n    }\n\n    /** @override */\n    canGetTile(zoomLevel: number, tileKey: TileKey): boolean {\n        if (zoomLevel !== tileKey.level || tileKey.level < 1) {\n            return false;\n        }\n\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n\n    /** @override */\n    shouldSubdivide(zoomLevel: number, tileKey: TileKey): boolean {\n        if (zoomLevel <= tileKey.level) {\n            return false;\n        }\n\n        const { north, south } = this.m_tilingScheme.getGeoBox(tileKey);\n\n        return north > this.m_maxLatitude || south < -this.m_maxLatitude;\n    }\n\n    /** @override */\n    getTilingScheme(): TilingScheme {\n        return this.m_tilingScheme;\n    }\n\n    /** @override */\n    getTile(tileKey: TileKey): Tile {\n        const tile = new Tile(this, tileKey);\n\n        this.createTileGeometry(tile);\n\n        return tile;\n    }\n\n    get geometryLevelOffset(): number {\n        return this.m_geometryLevelOffset;\n    }\n\n    set geometryLevelOffset(geometryLevelOffset: number) {\n        this.m_geometryLevelOffset = geometryLevelOffset;\n    }\n\n    private intersectEdge(latitude: number, a: GeoCoordinates, b: GeoCoordinates): GeoCoordinates {\n        const latA = a.latitude;\n        const latB = b.latitude;\n\n        let lonA = a.longitude;\n        let lonB = b.longitude;\n\n        if (Math.abs(latA) === 90) {\n            lonA = lonB;\n        }\n        if (Math.abs(latB) === 90) {\n            lonB = lonA;\n        }\n        const deltaLat = latB - latA;\n        const deltaLon = lonB - lonA;\n        const scale = (latitude - latA) / deltaLat;\n\n        return new GeoCoordinates(latitude, lonA + deltaLon * scale, 0);\n    }\n\n    private createTileGeometry(tile: Tile): void {\n        const { north, south } = tile.geoBox;\n\n        const isNorthPole = north > 0 && south >= 0;\n        const techniqueEntry = isNorthPole ? this.m_northPoleEntry : this.m_southPoleEntry;\n        if (techniqueEntry === undefined) {\n            tile.forceHasGeometry(true);\n            return;\n        }\n\n        const srcProjection = this.m_tilingScheme.projection;\n        const dstProjection = this.projection;\n\n        const maxLat = this.m_maxLatitude;\n        const poleLat = isNorthPole ? maxLat : -maxLat;\n\n        const box = this.m_tilingScheme.boundingBoxGenerator.getWorldBox(tile.tileKey);\n\n        const pBL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.min.y, 0));\n        const pBR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.min.y, 0));\n        const pTR = srcProjection.unprojectPoint(new THREE.Vector3(box.max.x, box.max.y, 0));\n        const pTL = srcProjection.unprojectPoint(new THREE.Vector3(box.min.x, box.max.y, 0));\n\n        let points: GeoCoordinates[];\n        let needsGeometryCut = false;\n\n        // special case where tile contains half of the hemisphere\n        if (tile.tileKey.level === 1) {\n            const isLeftHalf = box.min.x === 0;\n\n            const poleX = isLeftHalf ? box.max.x : box.min.x;\n            const poleY = (box.max.y + box.min.y) / 2;\n            const pPole = srcProjection.unprojectPoint(new THREE.Vector3(poleX, poleY, 0));\n\n            // coordinates are not used, needed for right position\n            const pXX = isLeftHalf ? pBL : pBR;\n\n            points = isNorthPole\n                ? isLeftHalf\n                    ? [pPole, pTR, pXX, pBR]\n                    : [pPole, pBL, pXX, pTL]\n                : isLeftHalf\n                ? [pPole, pBR, pXX, pTR]\n                : [pPole, pTL, pXX, pBL];\n\n            needsGeometryCut = true;\n        } else {\n            // ccw for north, cw for south\n            points = isNorthPole ? [pBL, pBR, pTR, pTL] : [pBL, pTL, pTR, pBR];\n\n            const lats = points.map(p => p.latitude);\n            const lmax = Math.max(...lats);\n            const lmin = Math.min(...lats);\n\n            const isAllPointsOut = isNorthPole ? lmax < poleLat : lmin > poleLat;\n            if (isAllPointsOut) {\n                return;\n            }\n\n            const isSomePointsOut = isNorthPole ? lmin < poleLat : lmax > poleLat;\n            needsGeometryCut = isSomePointsOut;\n\n            if (needsGeometryCut) {\n                const nearest = lats.indexOf(isNorthPole ? lmax : lmin);\n                if (nearest !== 0) {\n                    for (let i = 0; i < nearest; i++) {\n                        points.push(points.shift() as GeoCoordinates);\n                    }\n                }\n            }\n        }\n\n        if (needsGeometryCut) {\n            const centerX = (box.min.x + box.max.x) / 2;\n            const centerY = (box.min.y + box.max.y) / 2;\n            const center = srcProjection.unprojectPoint(new THREE.Vector3(centerX, centerY, 0));\n\n            TransverseMercatorUtils.alignLongitude(points, center);\n\n            // points aligned as follows:\n            // a - nearest to the pole, always in\n            // b - next to nearest\n            // c - farthes from the pole, always out\n            // d - prev from nearest\n            const a = points[0];\n            const b = points[1];\n            const c = points[2];\n            const d = points[3];\n\n            const inPointB = Math.abs(b.latitude) >= maxLat;\n            const inPointD = Math.abs(d.latitude) >= maxLat;\n\n            const cutStart = inPointB\n                ? this.intersectEdge(poleLat, b, c)\n                : this.intersectEdge(poleLat, a, b);\n\n            const cutEnd = inPointD\n                ? this.intersectEdge(poleLat, d, c)\n                : this.intersectEdge(poleLat, a, d);\n\n            points.splice(inPointB ? 2 : 1, 4, cutStart);\n\n            const level = tile.tileKey.level - this.storageLevelOffset + this.m_geometryLevelOffset;\n            const subdivisions = 1 << Math.max(0, level);\n            const step = 360 / subdivisions;\n\n            const cutIndexStart = Math.floor((cutStart.longitude + 180) / step);\n            const cutIndexEnd = Math.ceil((cutEnd.longitude + 180) / step);\n\n            for (let i = cutIndexStart + 1; i < cutIndexEnd; i++) {\n                points.push(new GeoCoordinates(poleLat, i * step - 180, 0));\n            }\n\n            points.push(cutEnd);\n            if (inPointD) {\n                points.push(d);\n            }\n        }\n\n        const geometry = new THREE.BufferGeometry();\n\n        const vertices: THREE.Vector3[] = points.map(point => {\n            const projected = dstProjection.projectPoint(point, new THREE.Vector3());\n            projected.sub(tile.center);\n            return projected;\n        });\n        geometry.setFromPoints(vertices);\n\n        const indices: number[] = [];\n        for (let i = 1; i < vertices.length - 1; i++) {\n            isNorthPole ? indices.push(0, i, i + 1) : indices.push(0, i + 1, i);\n        }\n        geometry.setIndex(indices);\n\n        const mesh = new THREE.Mesh(geometry, techniqueEntry.material);\n        mesh.userData = {\n            dataSource: this.name,\n            tileKey: tile.tileKey\n        };\n\n        if (this.m_debugTiles) {\n            const color = Math.round(Math.abs(Math.sin(11 * tile.tileKey.mortonCode())) * 0xffffff);\n            mesh.material = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.5 });\n\n            tile.objects.push(\n                new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color, wireframe: true }))\n            );\n        }\n\n        MapObjectAdapter.create(mesh, {\n            dataSource: this,\n            technique: techniqueEntry.technique,\n            kind: [isNorthPole ? StandardGeometryKind.Water : StandardGeometryKind.Background]\n        });\n\n        tile.objects.push(mesh);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager, Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { debugContext } from \"./DebugContext\";\n\ndeclare const require: any;\n\nconst RBush = require(\"rbush\");\n\nconst logger = LoggerManager.instance.create(\"ScreenCollissions\");\n\nexport interface IBox {\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nexport class CollisionBox extends Math2D.Box implements IBox {\n    constructor(box?: Math2D.Box | THREE.Box2 | IBox) {\n        super();\n        if (box !== undefined) {\n            this.copy(box);\n        }\n    }\n\n    copy(box: Math2D.Box | THREE.Box2 | IBox): CollisionBox {\n        if (box instanceof Math2D.Box) {\n            this.set(box.x, box.y, box.w, box.h);\n        } else if (box instanceof THREE.Box2) {\n            this.set(box.min.x, box.min.y, box.max.x - box.min.x, box.max.y - box.min.y);\n        } else {\n            this.set(box.minX, box.minY, box.maxX - box.minX, box.maxY - box.minY);\n        }\n        return this;\n    }\n\n    get minX(): number {\n        return this.x;\n    }\n\n    set minX(minX: number) {\n        this.x = minX;\n    }\n\n    get maxX(): number {\n        return this.x + this.w;\n    }\n\n    set maxX(maxX: number) {\n        this.w = maxX - this.x;\n    }\n\n    get minY(): number {\n        return this.y;\n    }\n\n    set minY(minY: number) {\n        this.y = minY;\n    }\n\n    get maxY(): number {\n        return this.y + this.h;\n    }\n\n    set maxY(maxY: number) {\n        this.h = maxY - this.y;\n    }\n}\n\n/**\n * Collision box with additional boxes defining tighter bounds for the enclosed feature\n * (e.g.glyph bounds for text).\n */\nexport class DetailedCollisionBox extends CollisionBox {\n    constructor(box: Math2D.Box | THREE.Box2 | IBox, readonly detailBoxes: CollisionBox[]) {\n        super(box);\n    }\n}\n\nexport interface LineWithBound extends IBox {\n    line: THREE.Line3;\n}\n\nexport function isLineWithBound(box: IBox): box is LineWithBound {\n    return (box as LineWithBound).line !== undefined;\n}\n\nconst tmpCollisionBox = new CollisionBox();\n\nexport class ScreenCollisions {\n    /** The screen bounding box. */\n    readonly screenBounds = new Math2D.Box();\n\n    /** Tree of allocated bounds. */\n\n    private readonly rtree = new RBush();\n\n    /**\n     * Constructs a new ScreenCollisions object.\n     */\n    constructor() {\n        //\n    }\n\n    /**\n     * Resets the list of allocated screen bounds.\n     */\n    reset() {\n        this.rtree.clear();\n    }\n\n    /**\n     * Updates the screen bounds that are used to check if bounding boxes are visible.\n     *\n     * @param width - The width of the container.\n     * @param height - The height of the container.\n     */\n    update(width: number, height: number) {\n        this.screenBounds.set(width / -2, height / -2, width, height);\n        this.reset();\n    }\n\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds - The bounding box in NDC scaled coordinates (i.e. top left is -width/2,\n     * -height/2)\n     */\n    allocate(bounds: Math2D.Box | CollisionBox | DetailedCollisionBox): void {\n        const bbox = !(bounds instanceof CollisionBox) ? new CollisionBox(bounds) : bounds;\n        this.rtree.insert(bbox);\n    }\n\n    /**\n     * Inserts the given bounds into the rtree.\n     *\n     * @param bounds - The bounding boxes (the bounding boxes must be in the space returned from the\n     * ScreenProjector.project method).\n     */\n    allocateIBoxes(bounds: IBox[]) {\n        this.rtree.load(bounds);\n    }\n\n    /**\n     * Search for all bounds in the tree intersecting with the given box.\n     * @param box - The box used for the search.\n     * @returns An array of all IBoxes intersecting with the given box.\n     */\n    search(box: CollisionBox): IBox[] {\n        return this.rtree.search(box);\n    }\n\n    /**\n     * Checks if the given bounding box is already allocated.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     */\n    isAllocated(bounds: Math2D.Box | CollisionBox): boolean {\n        const collisionBox = bounds instanceof CollisionBox ? bounds : tmpCollisionBox.copy(bounds);\n        const results = this.search(collisionBox);\n        return this.intersectsDetails(collisionBox, results);\n    }\n\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     */\n    isVisible(bounds: Math2D.Box): boolean {\n        return this.screenBounds.intersects(bounds);\n    }\n\n    /**\n     * Checks if the given screen bounds is contained within the frustum of the active camera.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     */\n    isFullyVisible(bounds: Math2D.Box): boolean {\n        return this.screenBounds.containsBox(bounds);\n    }\n\n    /**\n     * Test whether a given [[CollisionBox]] intersects with any of the details in the specified\n     * [[IBox]]es.\n     *\n     * @param testBox - The box to test for intersection.\n     * @param boxes - The candidate boxes the test box may intersect with. It's assumed that the\n     * global bounds of these boxes intersect with the given test box.\n     * @returns `true` if any intersection found.\n     */\n    intersectsDetails(testBox: CollisionBox, boxes: IBox[]): boolean {\n        for (const box of boxes) {\n            if (box instanceof DetailedCollisionBox) {\n                for (const detailBox of box.detailBoxes) {\n                    if (detailBox.intersects(testBox)) {\n                        return true;\n                    }\n                }\n            } else if (isLineWithBound(box)) {\n                const boundedLine = box as LineWithBound;\n                if (this.intersectsLine(testBox, boundedLine)) {\n                    return true;\n                }\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Computes the intersection between the supplied CollisionBox and the LineWithBound.\n     * @note The [[CollisionBox]] is in Screen Bounds space, whereas the line must be\n     * in Screen Coordinate space\n     */\n    private intersectsLine(bbox: CollisionBox, boundedLine: LineWithBound): boolean {\n        const line = boundedLine.line;\n\n        // Note, these aren't normalized, but it doesn't matter, we are just interested\n        // in the sign.\n        const lineXDiffTransformed = line.end.x - line.start.x;\n\n        // Sign of bottom left, bottom right, top left and top right corners.\n        let signBL: number;\n        let signBR: number;\n        let signTL: number;\n        let signTR: number;\n        if (lineXDiffTransformed !== 0) {\n            const lineYDiffTransformed = line.end.y - line.start.y;\n            const normalX = lineYDiffTransformed;\n            const normalY = -lineXDiffTransformed;\n            const D = line.start.y - (lineYDiffTransformed / lineXDiffTransformed) * line.start.x;\n\n            signBL = Math.sign(bbox.minX * normalX + (bbox.minY - D) * normalY);\n            signBR = Math.sign(bbox.maxX * normalX + (bbox.minY - D) * normalY);\n            signTL = Math.sign(bbox.minX * normalX + (bbox.maxY - D) * normalY);\n            signTR = Math.sign(bbox.maxX * normalX + (bbox.maxY - D) * normalY);\n        } else {\n            signBL = Math.sign(bbox.minX - line.start.x);\n            signBR = Math.sign(bbox.maxX - line.start.x);\n            signTL = Math.sign(bbox.minX - line.start.x);\n            signTR = Math.sign(bbox.maxX - line.start.x);\n        }\n        return signBL !== signBR || signBL !== signTL || signBL !== signTR;\n    }\n}\n\n/**\n * @hidden\n *\n * Shows requests for screen space during labelling in an HTML canvas, which should be sized like\n * the actual map canvas. It can be placed on top of the map canvas to show exactly which requests\n * for screen space were done.\n *\n * Also logs statistics.\n */\nexport class ScreenCollisionsDebug extends ScreenCollisions {\n    /** 2D rendering context. */\n    private m_renderContext: CanvasRenderingContext2D | null = null;\n    private m_renderingEnabled = false;\n    private m_numAllocations = 0;\n    private m_numSuccessfulTests = 0;\n    private m_numFailedTests = 0;\n    private m_numSuccessfulVisibilityTests = 0;\n    private m_numFailedVisibilityTests = 0;\n\n    /**\n     * Constructs a new ScreenCollisions object which renders its state to a 2D canvas.\n     */\n    constructor(debugCanvas: HTMLCanvasElement) {\n        super();\n\n        if (debugCanvas !== undefined && debugCanvas !== null) {\n            this.m_renderContext = debugCanvas.getContext(\"2d\");\n        }\n    }\n\n    /**\n     * Resets the list of allocated bounds and clears the debug canvas.\n     * @override\n     */\n    reset() {\n        super.reset();\n\n        this.m_numAllocations = 0;\n        this.m_numSuccessfulTests = 0;\n        this.m_numFailedTests = 0;\n        this.m_numSuccessfulVisibilityTests = 0;\n        this.m_numFailedVisibilityTests = 0;\n    }\n\n    /**\n     * Updates the screen bounds used to check if bounding boxes are visible.\n     *\n     * @param width - The width of the container.\n     * @param height - The height of the container.\n     * @override\n     */\n    update(width: number, height: number) {\n        if (this.m_renderingEnabled) {\n            logger.log(\n                `Allocations: ${this.m_numAllocations} Successful Tests: ${this.m_numSuccessfulTests} Failed Tests: ${this.m_numFailedTests}  Successful Visibility Tests: ${this.m_numSuccessfulVisibilityTests}  Failed Visibility Tests: ${this.m_numFailedVisibilityTests} `\n            );\n        }\n\n        super.update(width, height);\n\n        if (this.m_renderContext !== null) {\n            this.m_renderContext.canvas.width = width;\n            this.m_renderContext.canvas.height = height;\n        }\n\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_SCREEN_COLLISIONS\", true)\n        this.m_renderingEnabled = debugContext.getValue(\"DEBUG_SCREEN_COLLISIONS\");\n    }\n\n    /**\n     * Marks the region of the screen intersecting with the given bounding box as allocated.\n     *\n     * @param bounds - the bounding box in world coordinates.\n     * @override\n     */\n    allocate(bounds: Math2D.Box | CollisionBox): void {\n        super.allocate(bounds);\n\n        this.m_numAllocations++;\n\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            this.m_renderContext.strokeStyle = \"#6666ff\";\n            this.m_renderContext.strokeRect(\n                bounds.x - this.screenBounds.x,\n                this.screenBounds.y + this.screenBounds.h - bounds.y,\n                bounds.w,\n                -bounds.h\n            );\n        }\n    }\n\n    /** @override */\n    allocateIBoxes(boundsArray: IBox[]) {\n        for (const bounds of boundsArray) {\n            this.m_numAllocations++;\n\n            if (this.m_renderingEnabled && this.m_renderContext !== null) {\n                this.m_renderContext.strokeStyle = \"#aa2222\";\n                this.m_renderContext.strokeRect(\n                    bounds.minX - this.screenBounds.x,\n                    this.screenBounds.y + this.screenBounds.h - bounds.minY,\n                    bounds.maxX - bounds.minX,\n                    -(bounds.maxY - bounds.minY)\n                );\n            }\n        }\n        super.allocateIBoxes(boundsArray);\n    }\n\n    /** @override */\n    intersectsDetails(testBox: CollisionBox, boxes: IBox[]): boolean {\n        const collisionFound = super.intersectsDetails(testBox, boxes);\n        if (this.m_renderingEnabled && this.m_renderContext !== null) {\n            const padding = collisionFound ? 2 : 1;\n            this.m_renderContext.strokeStyle = collisionFound ? \"#FF0000\" : \"#00ff00\";\n            this.m_renderContext.strokeRect(\n                testBox.x - this.screenBounds.x - padding,\n                this.screenBounds.y + this.screenBounds.h - testBox.y + padding,\n                testBox.w + 2 * padding,\n                -testBox.h - 2 * padding\n            );\n        }\n\n        if (collisionFound) {\n            this.m_numFailedTests++;\n        } else {\n            this.m_numSuccessfulTests++;\n        }\n\n        return collisionFound;\n    }\n\n    /**\n     * Checks if the given screen bounds intersects with the frustum of the active camera.\n     *\n     * @param bounds - The bounding box in world coordinates.\n     * @override\n     */\n    isVisible(bounds: Math2D.Box): boolean {\n        const visible = super.isVisible(bounds);\n\n        if (visible) {\n            this.m_numSuccessfulVisibilityTests++;\n        } else {\n            this.m_numFailedVisibilityTests++;\n        }\n        return visible;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\n/**\n * Determines whether a position in NDC (Normalized Device Coordinates) is inside the screen.\n * @param ndc - The position to check.\n */\nfunction isOnScreen(ndc: THREE.Vector3) {\n    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;\n}\n\n/**\n * Determines whether a position in NDC (Normalized Device Coordinates) is between the near\n * and far plane.\n * @param ndc - The position to check.\n */\nfunction isInRange(ndc: THREE.Vector3) {\n    return ndc.z > -1 && ndc.z < 1;\n}\n\n/**\n * @hidden\n * Handles the projection of world coordinates to screen coordinates.\n */\nexport class ScreenProjector {\n    static tempV2 = new THREE.Vector2();\n    static tempV3 = new THREE.Vector3();\n\n    private m_width: number = 0;\n    private m_height: number = 0;\n\n    /**\n     * Constructs a new `ScreenProjector`.\n     *\n     * @param m_camera - Camera to project against.\n     */\n    constructor(private m_camera: THREE.Camera) {}\n\n    /**\n     * Height of the screen.\n     */\n    get width(): number {\n        return this.m_width;\n    }\n\n    /**\n     * Width of the screen.\n     */\n    get height(): number {\n        return this.m_height;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target')\n     */\n    project(\n        source: Vector3Like,\n        target: THREE.Vector2 = new THREE.Vector2()\n    ): THREE.Vector2 | undefined {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        return this.ndcToScreen(p, target);\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * outside of the near/far plane. The point may be outside the screen.\n     */\n    projectToScreen(\n        source: Vector3Like,\n        target: THREE.Vector2 = new THREE.Vector2()\n    ): THREE.Vector2 | undefined {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (isInRange(p)) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n\n    /**\n     * Test if the area around the specified point is visible on the screen.\n     *\n     * @param {(Vector3Like)} source The centered source vector to project.\n     * @param {(Number)} halfWidth Half of the width of the area in screen space [0..1].\n     * @param {(Number)} halfHeight Half of the height of the area in screen space [0..1].\n     * @param {THREE.Vector2} target The target vector.\n     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if\n     * the area is completely outside the screen.\n     */\n    projectAreaToScreen(\n        source: Vector3Like,\n        halfWidth: number,\n        halfHeight: number,\n        target: THREE.Vector2 = new THREE.Vector2()\n    ): THREE.Vector2 | undefined {\n        halfWidth *= 2;\n        halfHeight *= 2;\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (\n            isInRange(p) &&\n            p.x + halfWidth >= -1 &&\n            p.x - halfWidth <= 1 &&\n            p.y + halfHeight >= -1 &&\n            p.y - halfHeight <= 1\n        ) {\n            return this.ndcToScreen(p, target);\n        }\n        return undefined;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector into\n     * screen coordinates. The z component between -1 and 1 is also returned.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target') or undefined if\n     * outside the near / far plane.\n     */\n    project3(\n        source: Vector3Like,\n        target: THREE.Vector3 = new THREE.Vector3()\n    ): THREE.Vector3 | undefined {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        if (p.z > -1 && p.z < 1) {\n            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2, p.z);\n            return target;\n        }\n        return undefined;\n    }\n\n    /**\n     * Apply current projectionViewMatrix of the camera to project the source vector. Stores\n     * result in NDC in the target vector.\n     *\n     * @param {(Vector3Like)} source The source vector to project.\n     * @param {THREE.Vector3} target The target vector.\n     * @returns {THREE.Vector3} The projected vector (the parameter 'target').\n     */\n    projectVector(source: Vector3Like, target: THREE.Vector3): THREE.Vector3 {\n        target.set(source.x, source.y, source.z).project(this.m_camera);\n        return target;\n    }\n\n    /**\n     * Fast test to check if projected point is on screen.\n     *\n     * @returns {boolean} `true` if point is on screen, `false` otherwise.\n     */\n    onScreen(source: Vector3Like): boolean {\n        const p = this.projectVector(source, ScreenProjector.tempV3);\n        return isOnScreen(p);\n    }\n\n    /**\n     * Update the `ScreenProjector` with the latest values of the screen and the camera.\n     *\n     * @param {THREE.Camera} camera Camera to project against.\n     * @param {number} width Width of screen/canvas.\n     * @param {number} height Height of screen/canvas.\n     */\n    update(camera: THREE.Camera, width: number, height: number) {\n        this.m_camera = camera;\n        this.m_width = width;\n        this.m_height = height;\n    }\n\n    private ndcToScreen(ndc: THREE.Vector3, screenCoords: THREE.Vector2): THREE.Vector2 {\n        return screenCoords.set((ndc.x * this.m_width) / 2, (ndc.y * this.m_height) / 2);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CubemapSky, GradientSky } from \"@here/harp-datasource-protocol\";\nimport { ProjectionType } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\nimport { SkyCubemapTexture } from \"./SkyCubemapTexture\";\nimport { SkyGradientTexture } from \"./SkyGradientTexture\";\n\n/**\n * Class that handles {@link MapView}'s sky background.\n */\nexport class SkyBackground {\n    private m_skyTexture?: SkyGradientTexture | SkyCubemapTexture;\n\n    /**\n     * Constructs a new `SkyBackground`.\n     *\n     * @param m_sky - Sky configuration parameters.\n     * @param m_projectionType - {@link MapView}'s projection type.\n     * @param camera - {@link MapView}'s camera.\n     */\n    constructor(\n        private m_sky: GradientSky | CubemapSky,\n        private m_projectionType: ProjectionType,\n        camera: THREE.Camera\n    ) {\n        switch (this.m_sky.type) {\n            case \"gradient\":\n                this.m_skyTexture = new SkyGradientTexture(this.m_sky, this.m_projectionType);\n                this.updateCamera(camera);\n                break;\n            case \"cubemap\": {\n                this.m_skyTexture = new SkyCubemapTexture(this.m_sky);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skyTexture!.dispose();\n    }\n\n    /**\n     * Sky texture.\n     */\n    get texture(): THREE.Texture {\n        return this.m_skyTexture!.texture;\n    }\n\n    /**\n     * This method updates the skybox based on the camera position (needed for some types of sky).\n     *\n     * @param camera - The camera used in the map view.\n     */\n    updateCamera(camera: THREE.Camera) {\n        if (this.m_sky.type === \"gradient\") {\n            (this.m_skyTexture! as SkyGradientTexture).update(camera);\n        }\n    }\n\n    /**\n     * Updates the sky texture with new parameters.\n     *\n     * @param params - New sky configuration parameters.\n     * @param projectionType - Which projection is used, this may also change (in which case the\n     * textures should be recreated).\n     */\n    updateTexture(params: GradientSky | CubemapSky, projectionType: ProjectionType) {\n        const isSameSkyType =\n            this.m_sky.type === params.type && this.m_projectionType === projectionType;\n        switch (params.type) {\n            case \"gradient\":\n                if (isSameSkyType) {\n                    (this.m_skyTexture! as SkyGradientTexture).updateTexture(params);\n                } else {\n                    this.m_skyTexture = new SkyGradientTexture(params, projectionType);\n                }\n                break;\n            case \"cubemap\": {\n                if (isSameSkyType) {\n                    (this.m_skyTexture! as SkyCubemapTexture).updateTexture(params);\n                } else {\n                    this.m_skyTexture = new SkyCubemapTexture(params);\n                }\n                break;\n            }\n        }\n        this.m_projectionType = projectionType;\n        this.m_sky = params;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CubemapSky } from \"@here/harp-datasource-protocol\";\nimport { LoggerManager } from \"@here/harp-utils\";\nimport { CubeTexture, CubeTextureLoader, Texture } from \"three\";\n\nconst logger = LoggerManager.instance.create(\"SkyCubemapTexture\");\n\n/**\n * Number of faces that form a [[SkyCubemapTexture]].\n */\nexport const SKY_CUBEMAP_FACE_COUNT = 6;\n\n/**\n * Maps the faceId to the expected position in the threejs faces array.\n */\nexport enum SkyCubemapFaceId {\n    \"positiveX\",\n    \"negativeX\",\n    \"positiveY\",\n    \"negativeY\",\n    \"positiveZ\",\n    \"negativeZ\"\n}\n\n/**\n * Class that handles loading all 6 faces of a [[CubeTexture]], to be used with [[SkyBackground]].\n */\nexport class SkyCubemapTexture {\n    private m_skybox: CubeTexture;\n\n    /**\n     * Constructs a new `SkyCubemapTexture`.\n     *\n     * @param sky - Initial [[CubemapSky]] configuration.\n     */\n    constructor(sky: CubemapSky) {\n        const faces = this.createCubemapFaceArray(sky);\n        this.m_skybox =\n            faces !== undefined ? new CubeTextureLoader().load(faces) : new CubeTexture();\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        this.m_skybox.dispose();\n    }\n\n    /**\n     * `SkyCubemapTexture`'s texture resource.\n     */\n    get texture(): Texture {\n        return this.m_skybox;\n    }\n\n    /**\n     * Updates the `SkyCubemapTexture` with new parameters.\n     *\n     * @param params - New [[CubemapSky]] configuration.\n     */\n    updateTexture(sky: CubemapSky) {\n        const faces = this.createCubemapFaceArray(sky);\n        if (faces === undefined) {\n            return;\n        }\n        this.m_skybox = new CubeTextureLoader().load(faces);\n    }\n\n    private createCubemapFaceArray(sky: CubemapSky): string[] | undefined {\n        const faces: Array<string | undefined> = [\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined,\n            undefined\n        ];\n        for (let i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i) {\n            const face: string | undefined = (sky as any)[SkyCubemapFaceId[i]];\n            if (face === undefined) {\n                logger.error(`Face \"${SkyCubemapFaceId[i]}\" was not defined.`);\n                return;\n            }\n            faces[i] = face;\n        }\n\n        return faces as string[];\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GradientSky } from \"@here/harp-datasource-protocol\";\nimport { ProjectionType } from \"@here/harp-geoutils\";\nimport { getOptionValue } from \"@here/harp-utils\";\nimport { Color, CubeTexture, DataTexture, Line3, Plane, RGBFormat, Texture, Vector3 } from \"three\";\n\nexport const DEFAULT_TEXTURE_SIZE = 512;\nexport const DEFAULT_MONOMIAL_POWER = 1;\n\n// Vectors used for skybox bitmap computation.\nconst cameraDir = [\n    new Vector3(1, 0, 0),\n    new Vector3(-1, 0, 0),\n    new Vector3(0, -1, 0),\n    new Vector3(0, 1, 0),\n    new Vector3(0, 0, 1),\n    new Vector3(0, 0, -1)\n];\nconst cameraRight = [\n    new Vector3(0, 0, -1),\n    new Vector3(0, 0, 1),\n    new Vector3(1, 0, 0),\n    new Vector3(1, 0, 0),\n    new Vector3(1, 0, 0),\n    new Vector3(-1, 0, 0)\n];\nconst cameraUp = [\n    new Vector3(0, 1, 0),\n    new Vector3(0, 1, 0),\n    new Vector3(0, 0, 1),\n    new Vector3(0, 0, -1),\n    new Vector3(0, 1, 0),\n    new Vector3(0, 1, 0)\n];\n\n/**\n * Class tha generates a texture containing a linear gradient, to be used with [[SkyBackground]].\n *\n * The gradient is mapped onto a sphere, where `topColor` maps to the top of the upper hemisphere,\n * `bottomColor` to the bottom of the upper hemisphere, and `groundColor` fills the bottom\n *  hemisphere..\n */\nexport class SkyGradientTexture {\n    private readonly m_width: number;\n    private readonly m_faceCount: number;\n    private readonly m_faces: DataTexture[];\n    private readonly m_skybox?: CubeTexture;\n\n    // Used only in the planar case.\n    private readonly m_farClipPlaneDividedVertically?: THREE.Line3;\n    private readonly m_groundPlane?: THREE.Plane;\n    private readonly m_bottomMidFarPoint?: THREE.Vector3;\n    private readonly m_topMidFarPoint?: THREE.Vector3;\n    private readonly m_horizonPosition?: THREE.Vector3;\n    private readonly m_farClipPlaneCorners?: THREE.Vector3[];\n\n    /**\n     * Constructs a new `SkyGradientTexture`.\n     *\n     * @param sky - Initial [[GradientSky]] configuration.\n     * @param m_projectionType - {@link MapView}'s projection type.\n     * @param m_height - Optional height parameter.\n     */\n    constructor(\n        sky: GradientSky,\n        private readonly m_projectionType: ProjectionType,\n        private readonly m_height: number = DEFAULT_TEXTURE_SIZE\n    ) {\n        const topColor = new Color(sky.topColor);\n        const bottomColor = new Color(sky.bottomColor);\n        const groundColor = new Color(sky.groundColor);\n\n        this.m_width = this.m_projectionType === ProjectionType.Planar ? 1.0 : this.m_height;\n        this.m_faceCount = this.m_projectionType === ProjectionType.Planar ? 1.0 : 6.0;\n        this.m_faces = [];\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            const data = new Uint8Array(3 * this.m_width * this.m_height);\n            this.fillTextureData(data, i, topColor, bottomColor, groundColor, sky.monomialPower);\n\n            const texture = new DataTexture(data, this.m_width, this.m_height, RGBFormat);\n            texture.needsUpdate = true;\n            texture.unpackAlignment = 1;\n            this.m_faces.push(texture);\n        }\n\n        if (this.m_projectionType === ProjectionType.Spherical) {\n            this.m_skybox = new CubeTexture(this.m_faces);\n            this.m_skybox.needsUpdate = true;\n        } else {\n            this.m_farClipPlaneDividedVertically = new Line3();\n            this.m_groundPlane = new Plane(new Vector3(0, 0, 1));\n            this.m_bottomMidFarPoint = new Vector3();\n            this.m_topMidFarPoint = new Vector3();\n            this.m_horizonPosition = new Vector3();\n            this.m_farClipPlaneCorners = [\n                new Vector3(),\n                new Vector3(),\n                new Vector3(),\n                new Vector3()\n            ];\n        }\n    }\n\n    /**\n     * Disposes allocated resources.\n     */\n    dispose() {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.m_faces[i].dispose();\n        }\n        if (this.m_projectionType === ProjectionType.Spherical) {\n            this.m_skybox!.dispose();\n        }\n    }\n\n    /**\n     * `SkyGradientTexture`'s texture resource (simple texture or cubemap depending on\n     * {@link MapView}'s projection).\n     */\n    get texture(): Texture {\n        return this.m_projectionType === ProjectionType.Planar ? this.m_faces[0] : this.m_skybox!;\n    }\n\n    /**\n     * This method updates the position of the texture depending on the camera frustum.\n     *\n     * @param camera - The camera used in the map view.\n     */\n    update(camera: THREE.Camera) {\n        if (this.m_projectionType === ProjectionType.Planar) {\n            this.setHorizonPosition(camera);\n            this.updateTexturePosition();\n        }\n    }\n\n    /**\n     * Updates the `SkyGradientTexture` with new parameters.\n     *\n     * @param params - New [[GradientSky]] configuration.\n     */\n    updateTexture(sky: GradientSky) {\n        for (let i = 0; i < this.m_faceCount; ++i) {\n            this.fillTextureData(\n                this.m_faces[i].image.data,\n                i,\n                new Color(sky.topColor),\n                new Color(sky.bottomColor),\n                new Color(sky.groundColor),\n                sky.monomialPower\n            );\n            this.m_faces[i].needsUpdate = true;\n        }\n        if (this.m_projectionType === ProjectionType.Spherical) {\n            this.m_skybox!.needsUpdate = true;\n        }\n    }\n\n    // When creating the texture, a Uint8Array is required, because the resulting texture passed\n    // to the scene as a background, is a texImage2D object, that does not accept UintClampedArray\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n    // But, when updating the texture, a Uint8ClampedArray is passed as argument, because\n    // this.m_texture.image.data returns a Uint8ClampedArray. That's why this method accepts both.\n    private fillTextureData(\n        data: Uint8ClampedArray | Uint8Array,\n        faceIdx: number,\n        topColor: Color,\n        bottomColor: Color,\n        groundColor: Color,\n        monomialPower?: number\n    ) {\n        const color = new Color();\n        const dir = new Vector3();\n        const right = new Vector3();\n        const up = new Vector3();\n\n        const upDir = new Vector3(0, 0, 1);\n        for (let i = 0; i < this.m_height; ++i) {\n            for (let j = 0; j < this.m_width; ++j) {\n                if (this.m_projectionType === ProjectionType.Spherical) {\n                    const offsetX = right\n                        .copy(cameraRight[faceIdx])\n                        .multiplyScalar(((j + 0.5) / this.m_width) * 2.0 - 1.0);\n                    const offsetY = up\n                        .copy(cameraUp[faceIdx])\n                        .multiplyScalar(((i + 0.5) / this.m_height) * 2.0 - 1.0);\n                    dir.copy(cameraDir[faceIdx]).add(offsetX).add(offsetY).normalize();\n                    const t = Math.max(upDir.dot(dir), 0);\n\n                    color\n                        .copy(groundColor)\n                        .lerp(bottomColor, Math.min(t * 100, 1))\n                        .lerp(topColor, t ** getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER))\n                        .multiplyScalar(255);\n                } else {\n                    const t = i / this.m_height;\n                    if (i === 0) {\n                        color.copy(groundColor).multiplyScalar(255);\n                    } else {\n                        color\n                            .copy(bottomColor)\n                            .lerp(\n                                topColor,\n                                t ** getOptionValue(monomialPower, DEFAULT_MONOMIAL_POWER)\n                            )\n                            .multiplyScalar(255);\n                    }\n                }\n\n                data[i * this.m_width * 3 + j * 3] = color.r;\n                data[i * this.m_width * 3 + j * 3 + 1] = color.g;\n                data[i * this.m_width * 3 + j * 3 + 2] = color.b;\n            }\n        }\n    }\n\n    private setHorizonPosition(camera: THREE.Camera) {\n        this.m_farClipPlaneCorners![0].set(-1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners![1].set(1, -1, 1).unproject(camera);\n        this.m_farClipPlaneCorners![2].set(-1, 1, 1).unproject(camera);\n        this.m_farClipPlaneCorners![3].set(1, 1, 1).unproject(camera);\n\n        this.m_bottomMidFarPoint!.copy(this.m_farClipPlaneCorners![0])\n            .add(this.m_farClipPlaneCorners![1])\n            .multiplyScalar(0.5);\n        this.m_topMidFarPoint!.copy(this.m_farClipPlaneCorners![2])\n            .add(this.m_farClipPlaneCorners![3])\n            .multiplyScalar(0.5);\n        this.m_farClipPlaneDividedVertically!.set(this.m_bottomMidFarPoint, this.m_topMidFarPoint);\n\n        const hasIntersection = this.m_groundPlane!.intersectLine(\n            this.m_farClipPlaneDividedVertically!,\n            this.m_horizonPosition!\n        );\n\n        // When there is no intersection between the ground plane and the\n        // farClipPlaneDividedVertically, be sure that the horizon is reset. Otherwise a previous\n        // intersection point stored in the m_horizonPosition will be considered the valid one.\n        if (!hasIntersection) {\n            this.m_horizonPosition!.set(0.0, 0.0, 0.0);\n        }\n    }\n\n    private updateTexturePosition() {\n        const coveredBySky = this.m_bottomMidFarPoint!.distanceTo(this.m_horizonPosition!);\n        const frustumHeight = this.m_farClipPlaneDividedVertically!.distance();\n        const skyRatio = coveredBySky / frustumHeight;\n\n        // If there is no intersection between the ground plane and the line that defines the far\n        // clip plane divided vertically, it means that there is no sky visible and therefore the\n        // ground color should be displayed. When there is no intersection, the length of the\n        // this.m_horizonPosition is still equal to zero, as threejs initialize an empty vector with\n        // all the three components to zero.\n        // If there is an intersection, calculate the offset.\n        const ratio = this.m_horizonPosition!.length() === 0 ? 1 : skyRatio - 2 / this.m_height;\n\n        // If the bottom part of the far clipping plane is under the ground plane, scroll the\n        // texture down. Otherwise, the camera is looking at the sky, therefore, scroll the texture\n        // up.\n        this.m_faces[0].offset.set(0, this.m_bottomMidFarPoint!.z <= 0 ? -ratio : skyRatio);\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { EarthConstants, sphereProjection } from \"@here/harp-geoutils\";\nimport { Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { CameraUtils } from \"./CameraUtils\";\nimport { MapViewUtils } from \"./Utils\";\n\nconst twoPi = Math.PI * 2;\n\n// Keep counter clockwise order.\nexport enum CanvasSide {\n    Bottom,\n    Right,\n    Top,\n    Left\n}\n\nexport function nextCanvasSide(side: CanvasSide): CanvasSide {\n    return (side + 1) % 4;\n}\n\nexport function previousCanvasSide(side: CanvasSide): CanvasSide {\n    return (side + 3) % 4;\n}\n\n/**\n * Class computing horizon tangent points and intersections with canvas for spherical projection.\n *\n * @remarks\n *\n * The horizon for a sphere is a circle formed by all intersections of tangent lines passing through\n * the camera with said sphere. It lies on a plane perpendicular to the sphere normal at the camera\n * and it's center is at the line segment joining the sphere center and the camera.\n *\n * The further the camera is, the nearer the horizon center gets to the sphere center, only reaching\n * the sphere center when the camera is at infinity. In other words, the horizon observed from a\n * finite distance is always smaller than a great circle (a circle with the sphere radius, dividing\n * the sphere in two hemispheres, and therefore it's radius is smaller than the sphere's.\n *\n * @internal\n */\nexport class SphereHorizon {\n    private readonly m_matrix: THREE.Matrix4;\n    private readonly m_radius: number;\n    private readonly m_normalToTangentAngle: number;\n    private readonly m_distanceToHorizonCenter: number;\n    private readonly m_intersections: number[][] = [];\n    private m_isFullyVisible: boolean = true;\n    private readonly m_cameraPitch: number;\n\n    /**\n     * Constructs the SphereHorizon for the given camera.\n     *\n     * @param m_camera - The camera used as a reference to compute the horizon.\n     * @param m_cornerIntersects - Array with a boolean for each canvas corner telling whether it\n     * intersects with the world. Corners are in ccw-order starting with bottom left.\n     */\n    constructor(\n        private readonly m_camera: THREE.PerspectiveCamera,\n        private readonly m_cornerIntersects: boolean[]\n    ) {\n        //\n        //          TL :,,,,,,,,,,,,,,,,,,,,,,,,,,,,! TR canvas corner (proj. on horizon plane)\n        //             >                            +\n        //             >                            +\n        //             ::                           +\n        //              +                           >\n        //              >         `::::::'         !\"\n        //              >     `:::\"      ':::,     +\n        //              +   :!,              .!!`  +\n        //              ,,:;`                   :+`>\n        //              >T                        T# <-- Sphere radius to tangent angle (90 deg).\n        //             !!>                       `+!(`\n        //            =' +                      `.+  {:\n        //           /.  +                     `` >   |:`\n        //          /`   ::                   .`  >    |:.\n        //         /`     >         camZ     '`  `+     /`'`\n        //        ;,      +           *,`   '    !,      ( `'\n        //       ,^       +              `.~     +       ./  .`\n        //       )        +               ' ```  >        !~  `.\n        //      *`        '~             '    ``.>         (    .` tangentDistance\n        //     `\\          +           `'        ?``       '?    `'\n        //     /`          +          `.        :.  ```     )      `.\n        //    `\\           >         `.         >     ```   .=       .`\n        //    |`           +        ``          +        ``` (        `.\n        //    /            \"!      .`           +           `?!         '`\n        //   ,+             !,,,,,!:,,,,,,,,,,,,,             {.`        `.\n        //   /`            BL    '               BR           )  ```       .`\n        //   /                  '                             >`    ``      `'\n        //   /                 '                              `*      ```     .`\n        //  ,:                ' Sphere radius                  )     camZ```   `.\n        //  ?`              `.                                 )           ```   `.\n        //  /              `.                                  )              `.`  '`    camY\n        //  /             ``              horizon radius       /                 ````.   ^\n        //  /            .`          |<----------------------->/                   ``.'` '\n        //  /           .`           |                         /`                     `','  camX\n        //  /          O`````````````C`````````````````````````(,````````````````````````E-----*\n        //             |             |                distanceToHorizonCenter            |\n        //             |             |<------------------------------------------------->|\n        //             |                                                                 |\n        //             |<--------------------------------------------------------------->|\n        //                                      cameraHeight\n        // O -> Sphere center\n        // C -> Horizon center\n        // E -> Camera (eye)\n        // T -> Tangent points (also intersections with projected canvas)\n\n        const earthRadiusSq = EarthConstants.EQUATORIAL_RADIUS * EarthConstants.EQUATORIAL_RADIUS;\n        const xAxis = new THREE.Vector3().setFromMatrixColumn(m_camera.matrixWorld, 0).normalize();\n        const zAxis = m_camera.position.clone().normalize();\n        const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis);\n\n        const cameraHeight = m_camera.position.length();\n        this.m_normalToTangentAngle = Math.asin(EarthConstants.EQUATORIAL_RADIUS / cameraHeight);\n\n        const tangentDistance = Math.sqrt(cameraHeight * cameraHeight - earthRadiusSq);\n        this.m_distanceToHorizonCenter = tangentDistance * Math.cos(this.m_normalToTangentAngle);\n        const horizonCenterLength = cameraHeight - this.m_distanceToHorizonCenter;\n        this.m_radius = Math.sqrt(earthRadiusSq - horizonCenterLength * horizonCenterLength);\n        this.m_cameraPitch = MapViewUtils.extractAttitude(\n            { projection: sphereProjection },\n            this.m_camera\n        ).pitch;\n        const horizonCenter = new THREE.Vector3().copy(zAxis).setLength(horizonCenterLength);\n        this.m_matrix = new THREE.Matrix4()\n            .makeBasis(xAxis, yAxis, zAxis)\n            .setPosition(horizonCenter);\n        this.computeIntersections();\n    }\n\n    /**\n     * Gets the world coordinates of a point in the horizon corresponding to the given parameter.\n     *\n     * @param t - Parameter value in [0,1] corresponding to the point in the horizon circle at\n     * angle t*(arcEnd - arcStart)*2*pi counter clockwise.\n     * @param arcStart - Start of the arc covered by parameter t, corresponds to angle\n     * arcStart*2*pi.\n     * @param arcEnd - End of the arc covered by parameter t, corresponds to angle arcEnd*2*pi.\n     * @param target - Optional target where resulting world coordinates will be set.\n     * @returns the resulting point in world space.\n     */\n    getPoint(\n        t: number,\n        arcStart: number = 0,\n        arcEnd: number = 1,\n        target: THREE.Vector3 = new THREE.Vector3()\n    ): THREE.Vector3 {\n        const startAngle = arcStart * twoPi;\n        const endAngle = arcEnd >= arcStart ? arcEnd * twoPi : (arcEnd + 1) * twoPi;\n        const deltaAngle = endAngle - startAngle;\n        const angle = startAngle + t * deltaAngle;\n\n        target.set(this.m_radius * Math.cos(angle), this.m_radius * Math.sin(angle), 0);\n        target.applyMatrix4(this.m_matrix);\n        return target;\n    }\n\n    /**\n     * Subdivides and arc of the horizon circle, providing the world coordinates of the divisions.\n     *\n     * @param callback - Function called for every division point, getting the point world\n     * coordinates as parameter.\n     * @param tStart - Angular parameter of the arc's start point [0,1].\n     * @param tEnd - Angular parameter of the arc's end point [0,1].\n     * @param maxNumPoints - Number of division points for the whole horizon. Smaller arcs will\n     * be assigned a proportionally smaller number of points.\n     */\n    getDivisionPoints(\n        callback: (point: THREE.Vector3) => void,\n        tStart: number = 0,\n        tEnd: number = 1,\n        maxNumPoints: number = 10\n    ) {\n        const numPoints = Math.max(\n            Math.ceil(((tEnd < tStart ? 1 + tEnd : tEnd) - tStart) * maxNumPoints),\n            1\n        );\n        // Point corresponding to tEnd is omitted, hence the strict less condition in the loop.\n        for (let d = 0; d < numPoints; d++) {\n            callback(this.getPoint(d / numPoints, tStart, tEnd));\n        }\n    }\n\n    /**\n     * Indicates whether the horizon circle is fully visible.\n     * @returns 'True' if horizon is fully visible, false otherwise.\n     */\n    get isFullyVisible(): boolean {\n        return this.m_isFullyVisible;\n    }\n\n    /**\n     * Gets the horizon intersections with the specified canvas side, specified in angular\n     * parameters [0,1].\n     * @returns the intersections with the canvas.\n     */\n    getSideIntersections(side: CanvasSide): number[] {\n        return this.m_intersections[side];\n    }\n\n    private isTangentVisible(side: CanvasSide): boolean {\n        switch (side) {\n            case CanvasSide.Top: {\n                const eyeToTangentAngle = this.m_normalToTangentAngle - this.m_cameraPitch;\n                return CameraUtils.getTopFov(this.m_camera) >= Math.abs(eyeToTangentAngle);\n            }\n            case CanvasSide.Bottom: {\n                const eyeToTangentAngle = this.m_normalToTangentAngle + this.m_cameraPitch;\n                return CameraUtils.getBottomFov(this.m_camera) >= Math.abs(eyeToTangentAngle);\n            }\n            case CanvasSide.Left: {\n                const eyeToTangentAngle = this.m_normalToTangentAngle;\n                return (\n                    CameraUtils.getLeftFov(this.m_camera) >= Math.abs(eyeToTangentAngle) &&\n                    this.m_cameraPitch <= CameraUtils.getBottomFov(this.m_camera)\n                );\n            }\n            case CanvasSide.Right: {\n                const eyeToTangentAngle = this.m_normalToTangentAngle;\n                return (\n                    CameraUtils.getRightFov(this.m_camera) >= Math.abs(eyeToTangentAngle) &&\n                    this.m_cameraPitch <= CameraUtils.getBottomFov(this.m_camera)\n                );\n            }\n        }\n    }\n\n    private getTangentOnSide(side: CanvasSide): number {\n        switch (side) {\n            case CanvasSide.Bottom:\n                return 0.75;\n            case CanvasSide.Right:\n                return 0;\n            case CanvasSide.Top:\n                return 0.25;\n            case CanvasSide.Left:\n                return 0.5;\n        }\n    }\n\n    private computeIntersections() {\n        // Look for the intersections of the canvas sides projected in the horizon plane with the\n        // horizon circle.\n        // Top and bottom canvas sides are horizontal lines at plane coordinates yTop and yBottom\n        // respectively. Left and right sides are lines whose slope depends on the camera pitch.\n        //\n        // Front View (horizon plane):\n        //\n        //                        Top\n        //        TL '{~~~~~~~~~~~~~~~~~~~~~~~~~~}. TR\n        //            (                          (\n        //            ;\"   '!;!!!!!!!!!!!!;!'   ::\n        //             I>^^:                :^^|I <--------- Canvas-Horizon intersection\n        //          ~>+%.                      ,$+>,\n        //        !|~   (                      (   :|!\n        //      ~/'   L (----------C----------`) R   ,/\"\n        //     /;       `/         ^,         )`       ^|\n        //    }'         (         |`         (         '}\n        //   }`          ,^        |`        *.          .}\n        //  ('         BL !::::::::|:::::::::: BR         ,)\n        // ,{                      |`  Bottom              }`\n        // }                   camZ|`                      `}\n        // }                       |`                       }\n        // }                       E----> camX              }\n        // }                                                } Horizon circle\n        // }                                               `}\n        // ~{                                              }.\n        //  {.                                            '(\n        //   }`                                          `}\n        //   `}.                                        .}\n        //     )!                                      !/\n        //      :/.                                  '/:\n        //        ^|'                              ,|^\n        //          :>+.                        .+>:\n        //             !^^;'                ';^^!\n        //                 :;!!!!!!!!!!!!;!;:\n        //\n        // Top-down view (plane defined by camZ and camX):\n        //\n        //                        Top\n        //        TL_______________________________ TR\n        //          \\              |              /\n        //           \\   :;!!!!!!!!!!!!!!;!;:    /\n        //            I^;'         |        ';^^I\n        //         :>+.\\           |           /.+>:\n        //       ^|'    \\          |          /    ,|^ <--- Horizon\n        //     :/.       \\         |         /       '/:\n        //      }         L--------C--------R_________}_________\n        //     }           \\       ^camZ   /           }       ^\n        //      }           \\      |      /           }        |\n        //     :/.           \\     |     /           :/.       |\n        //       ^|'          BL----B----BR_______ !|'         |\n        //         :>+.        \\   |   /        ^              | eyeToHorizon\n        //            !^;'      \\  |  /      ';!|              |\n        //               :;!!!!!!\\ | /!!;!;:!   | eyeToBottom  |\n        //                        \\|/           |              |\n        //                         E----> camX__v______________v\n\n        const yBottom =\n            this.m_distanceToHorizonCenter *\n            Math.tan(this.m_cameraPitch - CameraUtils.getBottomFov(this.m_camera));\n        let tTopRight: number | undefined;\n        let tBottomRight: number | undefined;\n\n        // Collect all intersections in counter-clockwise order.\n        for (let side = CanvasSide.Bottom; side < 4; side++) {\n            if (this.isTangentVisible(side)) {\n                this.m_intersections.push([this.getTangentOnSide(side)]);\n                continue;\n            }\n\n            const sideIntersections = new Array<number | undefined>();\n            this.m_isFullyVisible = false;\n            switch (side) {\n                case CanvasSide.Bottom: {\n                    sideIntersections.push(...this.computeTBIntersections(yBottom));\n                    break;\n                }\n                case CanvasSide.Right: {\n                    const rightFov = CameraUtils.getRightFov(this.m_camera);\n                    const intersections = this.computeLRIntersections(yBottom, rightFov);\n                    if (intersections) {\n                        [tTopRight, tBottomRight] = intersections;\n                        sideIntersections.push(\n                            tBottomRight !== undefined ? 1 + tBottomRight : undefined,\n                            tTopRight\n                        );\n                    }\n                    break;\n                }\n                case CanvasSide.Top: {\n                    const yTop =\n                        this.m_distanceToHorizonCenter *\n                        Math.tan(this.m_cameraPitch + CameraUtils.getTopFov(this.m_camera));\n                    sideIntersections.push(...this.computeTBIntersections(yTop).reverse());\n                    break;\n                }\n                case CanvasSide.Left: {\n                    const leftFov = CameraUtils.getLeftFov(this.m_camera);\n                    if (leftFov === CameraUtils.getRightFov(this.m_camera)) {\n                        // Left side intersections are symmetrical to right ones.\n                        sideIntersections.push(\n                            tTopRight !== undefined ? 0.5 - tTopRight : undefined,\n                            tBottomRight !== undefined ? 0.5 - tBottomRight : undefined\n                        );\n                    } else {\n                        const isections = this.computeLRIntersections(yBottom, leftFov);\n                        if (isections) {\n                            sideIntersections.push(\n                                0.5 - isections[0], // top\n                                isections[1] !== undefined ? 0.5 - isections[1] : undefined // bottom\n                            );\n                        }\n                    }\n                    break;\n                }\n            }\n\n            // Filter out undefined values and horizon intersections that are not visible because\n            // the canvas corner intersects the world (this may happen with off-center projections).\n            const hasCorners = [\n                this.m_cornerIntersects[side],\n                this.m_cornerIntersects[nextCanvasSide(side)]\n            ];\n            this.m_intersections.push(\n                sideIntersections.filter(\n                    (val, i) => val !== undefined && !hasCorners[i]\n                ) as number[]\n            );\n        }\n    }\n\n    /**\n     * Computes horizon intersections with top or bottom canvas side.\n     *\n     * @returns positions of the intersections in the horizon circle, first left, then right\n     * Values are in range [0,1].\n     */\n    private computeTBIntersections(y: number): [number, number] {\n        const radiusSq = this.m_radius * this.m_radius;\n        const x = Math.sqrt(radiusSq - y * y);\n        const t = Math.atan2(y, x) / twoPi;\n        return [0.5 - t, t > 0 ? t : 1 + t];\n    }\n\n    /**\n     * Computes horizon intersections with left or right canvas side.\n     *\n     * @returns positions of the intersections in the horizon circle, first top, then bottom\n     * (or undefined if not visible). Values are in range [-0.5,0.5].\n     */\n    private computeLRIntersections(\n        yBottom: number,\n        sideFov: number\n    ): [number, number?] | undefined {\n        // Define vertical canvas side line by finding the middle and bottom points of\n        // its projection on the horizon plane.\n        const eyeToHorizon = this.m_distanceToHorizonCenter / Math.cos(this.m_cameraPitch);\n        const yMiddle = this.m_distanceToHorizonCenter * Math.tan(this.m_cameraPitch);\n        const xMiddle = eyeToHorizon * Math.tan(sideFov);\n        const bottomFov = CameraUtils.getBottomFov(this.m_camera);\n        const eyeToBottom =\n            (this.m_distanceToHorizonCenter * Math.cos(bottomFov)) /\n            Math.cos(this.m_cameraPitch - bottomFov);\n        const xBottom = (xMiddle * eyeToBottom) / eyeToHorizon;\n        const intersections = Math2D.intersectLineAndCircle(\n            xBottom,\n            yBottom,\n            xMiddle,\n            yMiddle,\n            this.m_radius\n        );\n\n        if (!intersections) {\n            return undefined;\n        }\n        const yTopRight = intersections.y1;\n        const tTop = Math.atan2(yTopRight, intersections.x1) / twoPi;\n\n        // If there's a bottom intersection check if it's visible (its above the y\n        // coordinate of the bottom canvas side).\n        const hasBottomIntersection = -yTopRight >= yBottom && intersections.x2 !== undefined;\n        const tBottom = hasBottomIntersection\n            ? Math.atan2(intersections.y2!, intersections.x2!) / twoPi\n            : undefined;\n        return [tTop, tBottom];\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    EarthConstants,\n    GeoCoordinates,\n    GeoPolygon,\n    GeoPolygonCoordinates,\n    isAntimeridianCrossing,\n    Projection,\n    ProjectionType\n} from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\nimport { PerspectiveCamera, Vector2, Vector3 } from \"three\";\n\nimport { CanvasSide, nextCanvasSide, previousCanvasSide, SphereHorizon } from \"./SphereHorizon\";\nimport { MapViewUtils } from \"./Utils\";\nimport { ViewBounds } from \"./ViewBounds\";\n\n// Rough, empirical rule to compute the number of divisions needed for a geopolygon edge to keep\n// the deviation from the view bound edge it must follow within acceptable values.\nexport function computeEdgeDivisions(geoStart: GeoCoordinates, geoEnd: GeoCoordinates): number {\n    const maxLatitudeSpan = 20;\n    const maxLongitudeSpan = 5;\n\n    const latitudeSpan = Math.abs(geoEnd.latitude - geoStart.latitude);\n    const longitudeSpan = geoStart.minLongitudeSpanTo(geoEnd);\n    return Math.ceil(Math.max(latitudeSpan / maxLatitudeSpan, longitudeSpan / maxLongitudeSpan));\n}\n\nconst ccwCanvasCornersNDC: Array<{ x: number; y: number }> = [\n    { x: -1, y: -1 }, // bottom left\n    { x: 1, y: -1 }, // bottom right\n    { x: 1, y: 1 }, // top right\n    { x: -1, y: 1 } // top left\n];\n\n/**\n * Generates Bounds for a camera view and a spherical projection\n *\n * @internal\n */\nexport class SphereViewBounds implements ViewBounds {\n    constructor(readonly camera: PerspectiveCamera, readonly projection: Projection) {\n        assert(projection.type === ProjectionType.Spherical);\n    }\n\n    /**\n     * @override\n     */\n    generate(): GeoPolygon | undefined {\n        const coordinates = this.findBoundsIntersections();\n\n        this.wrapAroundPoles(coordinates);\n\n        return coordinates.length > 2\n            ? new GeoPolygon(coordinates as GeoPolygonCoordinates, false, true)\n            : undefined;\n    }\n\n    private addSideSegmentSubdivisions(\n        coordinates: GeoCoordinates[],\n        NDCStart: { x: number; y: number },\n        NDCEnd: { x: number; y: number },\n        geoStart: GeoCoordinates,\n        geoEnd: GeoCoordinates\n    ) {\n        coordinates.push(geoStart);\n\n        const divisionCount = computeEdgeDivisions(geoStart, geoEnd);\n        if (divisionCount <= 1) {\n            return;\n        }\n\n        const NDCStep = new Vector2(NDCEnd.x - NDCStart.x, NDCEnd.y - NDCStart.y).multiplyScalar(\n            1 / divisionCount\n        );\n\n        const NDCDivision = new Vector2(NDCStart.x, NDCStart.y);\n        for (let i = 0; i < divisionCount - 1; i++) {\n            NDCDivision.add(NDCStep);\n            const intersection = MapViewUtils.rayCastWorldCoordinates(\n                { camera: this.camera, projection: this.projection },\n                NDCDivision.x,\n                NDCDivision.y\n            );\n            if (intersection) {\n                coordinates.push(this.projection.unprojectPoint(intersection));\n            }\n        }\n    }\n\n    private addSideIntersections(\n        coordinates: GeoCoordinates[],\n        side: CanvasSide,\n        geoStartCorner?: GeoCoordinates,\n        geoEndCorner?: GeoCoordinates,\n        horizon?: SphereHorizon\n    ) {\n        const startNDCCorner = ccwCanvasCornersNDC[side];\n        const endNDCCorner = ccwCanvasCornersNDC[nextCanvasSide(side)];\n\n        if (geoStartCorner && geoEndCorner) {\n            // No horizon visible on this side of the canvas, generate polygon vertices from\n            // intersections of the canvas side with the world.\n            this.addSideSegmentSubdivisions(\n                coordinates,\n                startNDCCorner,\n                endNDCCorner,\n                geoStartCorner,\n                geoEndCorner\n            );\n            return;\n        }\n\n        if (!horizon) {\n            return;\n        }\n\n        // Bounds on this side of the canvas need to be completed with the horizon.\n        const horizonIntersections = horizon.getSideIntersections(side);\n        if (horizonIntersections.length === 0) {\n            return;\n        }\n\n        if (geoStartCorner) {\n            // Generate polygon vertices from intersections of this canvas side with the world\n            // from its starting corner till the last intersection with the horizon.\n\n            const worldHorizonPoint = horizon.getPoint(\n                horizonIntersections[horizonIntersections.length - 1]\n            );\n            const geoHorizonPoint = this.projection.unprojectPoint(worldHorizonPoint);\n            this.addSideSegmentSubdivisions(\n                coordinates,\n                startNDCCorner,\n                worldHorizonPoint.project(this.camera),\n                geoStartCorner,\n                geoHorizonPoint\n            );\n        } else {\n            // Subdivide horizon from last horizon intersection on previous side to this side first.\n            const prevSide = previousCanvasSide(side);\n            let prevSideIntersections = horizon.getSideIntersections(prevSide);\n            if (prevSideIntersections.length === 0) {\n                // When bottom canvas side cuts the horizon above its center, right horizon\n                // tangent is not visible. Last horizon tangent is top one.\n                prevSideIntersections = horizon.getSideIntersections(previousCanvasSide(prevSide));\n            }\n            assert(prevSideIntersections.length > 0);\n\n            horizon.getDivisionPoints(\n                point => {\n                    coordinates.push(this.projection.unprojectPoint(point));\n                },\n                prevSideIntersections[prevSideIntersections.length - 1],\n                horizonIntersections[0]\n            );\n        }\n\n        if (horizonIntersections.length > 1) {\n            // Subdivide side segment between two horizon intersections.\n            const worldHorizonStart = horizon.getPoint(horizonIntersections[0]);\n            const worldHorizonEnd = horizon.getPoint(horizonIntersections[1]);\n            const geoHorizonStart = this.projection.unprojectPoint(worldHorizonStart);\n            const geoHorizonEnd = this.projection.unprojectPoint(worldHorizonEnd);\n\n            this.addSideSegmentSubdivisions(\n                coordinates,\n                worldHorizonStart.project(this.camera),\n                worldHorizonEnd.project(this.camera),\n                geoHorizonStart,\n                geoHorizonEnd\n            );\n        }\n\n        if (geoEndCorner) {\n            // Subdivice side segment from last horizon intersection to the ending corner of this\n            // canvas side.\n            const worldHorizonPoint = horizon.getPoint(horizonIntersections[0]);\n            const geoHorizonPoint = this.projection.unprojectPoint(worldHorizonPoint);\n            this.addSideSegmentSubdivisions(\n                coordinates,\n                worldHorizonPoint.project(this.camera),\n                endNDCCorner,\n                geoHorizonPoint,\n                geoEndCorner\n            );\n        }\n    }\n\n    private findBoundsIntersections(): GeoCoordinates[] {\n        const coordinates: GeoCoordinates[] = [];\n        const [cornerCoordinates, numCorners] = this.addCanvasCornerIntersection();\n\n        // Horizon points need to be added to complete the bounds if not all canvas corners\n        // intersect with the world.\n        const horizon =\n            numCorners < 4\n                ? new SphereHorizon(\n                      this.camera,\n                      cornerCoordinates.map(value => value !== undefined)\n                  )\n                : undefined;\n\n        if (numCorners === 0 && horizon!.isFullyVisible) {\n            // Bounds are generated entirely from equidistant points obtained from the horizon\n            // circle.\n            horizon!.getDivisionPoints(point => {\n                coordinates.push(this.projection.unprojectPoint(point));\n            });\n            return coordinates;\n        }\n\n        for (let side = CanvasSide.Bottom; side < 4; side++) {\n            const startCorner = cornerCoordinates[side];\n            const endCorner = cornerCoordinates[nextCanvasSide(side)];\n            this.addSideIntersections(coordinates, side, startCorner, endCorner, horizon);\n        }\n        return coordinates;\n    }\n\n    private wrapAroundPoles(coordinates: GeoCoordinates[]) {\n        // If one of the poles is inside the view bounds, the polygon would have to cover the pole,\n        // which is not possible in geo space. Instead, additional vertices (numbered in order from\n        // 1 to 6 in the diagram below) are added to the polygon so that it wraps around the pole,\n        // covering the same area(except for the pole circle that cannot be mapped to geospace).\n        // The globe is cut in two hemispheres by the meridians at the camera longitude (camLon) and\n        // its antimeridian (at camLon+180). Then, the polygon side crossing the camera antimeridian\n        // is found, and the new pole wrapping vertices are inserted between its start and end\n        // vertices.\n        //\n        //    (end) hem.crossing side (start)\n        //        \\|<-------------->|/\n        // x-------x------6!--------x--------x\n        // |         , - ~5!1 ~ -,           |\n        // |     , '       !       ' ,       |\n        // |   ,           !           ,     |\n        // |  ,            !            ,    |\n        // | ,             !             ,   |\n        // | 4           POLE            2   | <- Bounds polygon\n        // | ,             !             ,   |\n        // |  ,            !            ,    |\n        // |   ,           !           ,     |\n        // |     ,         !         ,'      |\n        // |       ' -_, _ ! _ ,_ -'         |\n        // |               3                 |\n        // x---------------!-----------------x\n        //                 ! <- hemisphere partition\n\n        const northPoleCenter = new Vector3(0, 0, EarthConstants.EQUATORIAL_RADIUS);\n        const southPoleCenter = new Vector3(0, 0, -EarthConstants.EQUATORIAL_RADIUS);\n        const northPoleInView = MapViewUtils.closeToFrustum(northPoleCenter, this.camera);\n        const southPoleInView = MapViewUtils.closeToFrustum(southPoleCenter, this.camera);\n\n        if (!northPoleInView && !southPoleInView) {\n            return;\n        }\n\n        // Create first wrapping vertex (number 1 in the diagram above).\n        const camLon = this.projection.unprojectPoint(this.camera.position).lng;\n        const wrapLat = northPoleInView ? 90 : -90;\n        const wrapLon = northPoleInView ? camLon + 180 : camLon - 180;\n        const geoWrapTopRight = new GeoCoordinates(wrapLat, wrapLon);\n        const geoWrapTopRightNorm = geoWrapTopRight.normalized();\n\n        // Find the polygon side crossing the camera antimeridian.\n        const crossLon = geoWrapTopRightNorm.lng;\n        let prevLon = coordinates[coordinates.length - 1].lng;\n        // Check whether the camera antimeridian crossing also crosses greenwich antimerdian.\n        let isGwAntimerCross = false;\n        const hSphereCrossEndIndex = coordinates.findIndex((value: GeoCoordinates) => {\n            const crossesAntimer = isAntimeridianCrossing(prevLon, value.lng);\n            const sameSign = Math.sign(crossLon - value.lng) === Math.sign(crossLon - prevLon);\n            if (sameSign === crossesAntimer) {\n                isGwAntimerCross = crossesAntimer;\n                return true;\n            }\n            prevLon = value.lng;\n            return false;\n        });\n\n        if (hSphereCrossEndIndex < 0) {\n            // No polygon side crosses the camera antimeridian, meaning that the polygon doesn't\n            // actually go above the pole to the other side of the world, no wrapping needed.\n            return;\n        }\n\n        // Create rest of wrapping vertices at pole's latitude (vertices 2-5 in diagram above).\n        const wrapSideOffset = northPoleInView ? 90 : -90;\n        const wrapCornerOffset = northPoleInView ? 0.00001 : -0.00001;\n\n        // Added to ensure antimeridian crossing detection when coordinates are wrapped around it by\n        // GeoPolygon (all polygon sides must have longitude spans smaller than 180 degrees).\n        const geoWrapRight = new GeoCoordinates(wrapLat, camLon + wrapSideOffset).normalized();\n        const geoWrapBottom = new GeoCoordinates(wrapLat, camLon).normalized();\n\n        // Added to ensure antimeridian crossing detection when coordinates are wrapped around it by\n        // GeoPolygon (all polygon sides must have longitude spans smaller than 180 degrees).\n        const geoWrapLeft = new GeoCoordinates(wrapLat, camLon - wrapSideOffset).normalized();\n        const geoWrapTopLeft = new GeoCoordinates(wrapLat, wrapLon + wrapCornerOffset).normalized();\n\n        const hSphereCrossStartIndex =\n            (hSphereCrossEndIndex + coordinates.length - 1) % coordinates.length;\n        const crossStart = coordinates[hSphereCrossStartIndex];\n        const crossEnd = coordinates[hSphereCrossEndIndex];\n\n        // Last wrapping vertex (number 6) is linearly interpolated at the polygon side crossing the\n        // camera antimeridian.\n        let crossLerp = GeoCoordinates.lerp(crossStart, crossEnd, 0.01, isGwAntimerCross);\n        if (isGwAntimerCross && northPoleInView) {\n            crossLerp.longitude -= 360;\n        } else {\n            crossLerp = crossLerp.normalized();\n        }\n\n        // Add the wrapping vertices to the array in the proper order (see diagram above).\n        coordinates.splice(\n            hSphereCrossEndIndex,\n            0,\n            wrapLon < -180 ? geoWrapTopRight : geoWrapTopRightNorm, // 1\n            geoWrapRight, // 2\n            geoWrapBottom, // 3\n            geoWrapLeft, // 4\n            geoWrapTopLeft, // 5\n            crossLerp // 6\n        );\n    }\n\n    // Returns a tuple with the array of canvas corner intersection geocoordinates in ccw order\n    // (undefined values for corners not intersecting the world) and the number of intersections.\n    private addCanvasCornerIntersection(): [Array<GeoCoordinates | undefined>, number] {\n        const geoCorners = new Array<GeoCoordinates | undefined>();\n        let numIntersections = 0;\n        ccwCanvasCornersNDC.forEach(corner => {\n            const intersection = MapViewUtils.rayCastWorldCoordinates(\n                { camera: this.camera, projection: this.projection },\n                corner.x,\n                corner.y\n            );\n            if (intersection) {\n                geoCorners.push(this.projection.unprojectPoint(intersection));\n                ++numIntersections;\n            } else {\n                geoCorners.push(undefined);\n            }\n        });\n        return [geoCorners, numIntersections];\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { LoggerManager, PerformanceTimer } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nconst logger = LoggerManager.instance.create(\"Statistics\");\n\n/**\n * A simple ring buffer to store the last `n` values of the timer. The buffer works on\n * a First-In-First-Out (FIFO) basis.\n */\nexport class RingBuffer<T> {\n    buffer: T[];\n    size: number;\n    head: number;\n    tail: number;\n\n    /**\n     * Sets up the ring buffer.\n     *\n     * @param capacity - The buffer's capacity.\n     */\n    constructor(readonly capacity: number) {\n        this.buffer = new Array(capacity);\n        this.capacity = capacity;\n        this.head = this.tail = this.size = 0;\n    }\n\n    /**\n     * Clears the contents, removes all elements.\n     */\n    clear(): void {\n        this.head = this.tail = this.size = 0;\n    }\n\n    /**\n     * Adds a single element to the ring buffer.\n     *\n     * @param data - Data element.\n     */\n    enqOne(data: T): void {\n        let next = this.head + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size < this.capacity) {\n            this.size++;\n        }\n\n        this.buffer[this.head] = data;\n        this.head = next;\n\n        if (this.size === this.capacity) {\n            this.tail = this.head;\n        }\n    }\n\n    /**\n     * Adds one or more elements.\n     *\n     * @param data - The elements to add.\n     */\n    enq(...data: T[]): void {\n        for (const v of data) {\n            this.enqOne(v);\n        }\n    }\n\n    /**\n     * Obtains the oldest element (FIFO). May throw an exception if a buffer underrun occurs.\n     * Before calling this method, make sure that `size > 0`.\n     */\n    deq(): T {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n\n        const data = this.buffer[this.tail];\n        let next = this.tail + 1;\n        if (next >= this.capacity) {\n            next = 0;\n        }\n        if (this.size > 0) {\n            this.size--;\n        }\n\n        this.tail = next;\n        return data;\n    }\n\n    /**\n     * Obtains the oldest element (FIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get top(): T {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n\n        return this.buffer[this.tail];\n    }\n\n    /**\n     * Obtains the latest element (LIFO) without removing it. Throws an exception if a buffer is\n     * empty. Before calling this method, make sure that `size > 0`.\n     */\n    get bottom(): T {\n        if (this.size === 0) {\n            throw new Error(\"Ringbuffer underrun\");\n        }\n\n        let previous = this.head - 1;\n        if (previous < 0) {\n            previous = this.capacity - 1;\n        }\n        return this.buffer[previous];\n    }\n\n    /**\n     * Creates an iterator for the buffer.\n     */\n    iterator(): RingBuffer.Iterator<T> {\n        return new RingBuffer.Iterator<T>(this);\n    }\n\n    /**\n     * Returns a copy of the buffer, where the elements are properly sorted from oldest to newest.\n     */\n    asArray(): T[] {\n        const array = new Array<T>();\n        for (let i = 0; i < this.size; i++) {\n            array.push(this.buffer[(this.tail + i) % this.capacity]);\n        }\n        return array;\n    }\n}\n\nexport namespace RingBuffer {\n    /**\n     * A local class for RingBuffer<T>\n     */\n    export class Iterator<T> {\n        /**\n         * Creates an iterator for the ring buffer.\n         *\n         * @param m_buffer - `Ringbuffer` to iterate over.\n         * @param m_index - Start index.\n         */\n        constructor(private readonly m_buffer: RingBuffer<T>, private m_index: number = 0) {}\n\n        /**\n         * Gets the iterator's current value. This function does not fail even if an overrun occurs.\n         * To detect an overrun, watch the result for [[next]].\n         */\n        get value(): T {\n            return this.m_buffer.buffer[\n                (this.m_buffer.tail + this.m_index) % this.m_buffer.capacity\n            ];\n        }\n\n        /**\n         * Advances the iterator to the next element.\n         *\n         * @returns `true` if the iterator is still valid; `false` if an overrun occurs.\n         */\n        next(): boolean {\n            this.m_index++;\n            return this.m_index < this.m_buffer.size;\n        }\n    }\n}\n\n/**\n * An interface for a Timer class, that abstracts the basic functions of a Timer.\n *\n * @remarks\n * Implemented by SimpleTimer, SampledTimer, and MultiStageTimer.\n *\n * @internal\n */\nexport interface Timer {\n    readonly name: string;\n    readonly value?: number;\n\n    /**\n     * Resets value to be able to start again.\n     */\n    reset(): void;\n\n    /**\n     * Starts the timer. Returns the current time, based on `Performance.now()`.\n     */\n    start(): number;\n\n    /**\n     * Stops the timer. Requires that the timer has started.\n     */\n    stop(): number;\n\n    /**\n     * Samples the timer. Requires that the timer has started. This function does not modify\n     * the timer's internal state.\n     *\n     * @returns Current timer value. `-1` if statistics are disabled.\n     */\n    now(): number;\n\n    /**\n     * Sets the measurement value for the amount of time that has elapsed from start() to stop().\n     * Use this function to override the timer's duration.\n     *\n     * @param val - The timer's duration.\n     */\n    setValue(val: number | undefined): void;\n}\n\n/**\n * A simple timer that stores only the latest measurement.\n *\n * @internal\n */\nexport class SimpleTimer implements Timer {\n    /** `true` if timer has been started. */\n    running = false;\n\n    private m_currentValue?: number;\n\n    constructor(public statistics: Statistics, readonly name: string) {}\n\n    /**\n     * Gets the latest measurement. This function may return `undefined` if no measurement\n     * was done.\n     */\n    get value(): number | undefined {\n        return this.m_currentValue;\n    }\n\n    /**\n     * Sets the measurement value for the amount of time that has elapsed from start() to stop().\n     * Use this function to override the timer's duration.\n     *\n     * @param val - The timer's duration.\n     */\n    setValue(val: number | undefined) {\n        this.m_currentValue = val;\n    }\n\n    /**\n     * Resets the value to be able to start again.\n     */\n    reset() {\n        this.m_currentValue = undefined;\n    }\n\n    /**\n     * Starts the timer. Returns the current time, based on `Performance.now()`.\n     */\n    start(): number {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' is already running\");\n        }\n        this.running = true;\n        return (this.m_currentValue = PerformanceTimer.now());\n    }\n\n    /**\n     * Stops the timer. Requires that the timer has started.\n     */\n    stop(): number {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        } else {\n            // this.currentValue is a number now!\n            const t = PerformanceTimer.now() - (this.m_currentValue ?? 0);\n            this.m_currentValue = t;\n            this.setValue(t);\n            this.running = false;\n            return t;\n        }\n    }\n\n    /**\n     * Samples the timer. Requires that the timer has started.\n     *\n     * @returns the current timer value; `-1` if statistics are disabled.\n     */\n    now(): number {\n        if (!this.statistics.enabled) {\n            return -1;\n        }\n        if (!this.running) {\n            throw new Error(\"Timer '\" + this.name + \"' has not been started\");\n        } else {\n            const t = PerformanceTimer.now() - (this.m_currentValue ?? 0);\n            return t;\n        }\n    }\n}\n\n/**\n * Simple statistics about the values in an array.\n *\n * @internal\n */\nexport interface Stats {\n    /**\n     * The lowest value in the array.\n     */\n    min: number;\n\n    /**\n     * The highest value in the array.\n     */\n    max: number;\n\n    /**\n     * The average duration of all values in the array.\n     */\n    avg: number;\n\n    /**\n     * The median duration of all values in the array.\n     */\n    median: number;\n\n    /**\n     * The 75th percentile median of all values in the array.\n     */\n    median75: number;\n\n    /**\n     * The 90th percentile median of all values in the array.\n     */\n    median90: number;\n\n    /**\n     * The 95th percentile median of all values in the array.\n     */\n    median95: number;\n\n    /**\n     * The 97th percentile median of all values in the array.\n     */\n    median97: number;\n\n    /**\n     * The 99th percentile median of all values in the array.\n     */\n    median99: number;\n\n    /**\n     * The 99.9th percentile median of all values in the array.\n     */\n    median999: number;\n\n    /**\n     * The number of values in the array.\n     */\n    numSamples: number;\n}\n\n/**\n * A timer that stores the last `n` samples in a ring buffer.\n *\n * @internal\n */\nexport class SampledTimer extends SimpleTimer {\n    /**\n     * The number of times the timer has reset.\n     */\n    numResets = 0;\n\n    /**\n     * Maximum samples until the statistics are reset and updated, which may destroy a median\n     * computation.\n     */\n    maxNumSamples = 1000;\n\n    /**\n     * The array of sampled values, its length cannot exceed `maxNumSamples`.\n     */\n    samples = new RingBuffer<number>(this.maxNumSamples);\n\n    /**\n     * Creates a `SampledTimer` instance. Must still be added to statistics if it should be logged!\n     *\n     * @param statistics - Statistics to use for management.\n     * @param name - Name of the timer. Use colons to build a hierarchy.\n     */\n    constructor(public statistics: Statistics, readonly name: string) {\n        super(statistics, name);\n    }\n\n    /**\n     * Resets the timer and clears all of its historical values.\n     * @override\n     */\n    reset() {\n        super.reset();\n        this.getStats();\n        this.samples.clear();\n        this.numResets++;\n    }\n\n    /**\n     * Add a single measurement to the sample.\n     *\n     * @param val - A measurement to add.\n     * @override\n     */\n    setValue(val: number | undefined) {\n        super.setValue(val);\n\n        if (val !== undefined) {\n            this.samples.enqOne(val);\n        }\n    }\n\n    /**\n     * Updates the `min`, `max`, `avg`, and `median` values. Currently, this function is expensive,\n     * as it requires a copy of the sampled values.\n     */\n    getStats(): Stats | undefined {\n        return computeArrayStats(this.samples.asArray());\n    }\n}\n\n/**\n * Only exported for testing\n * @ignore\n *\n * @remarks\n * Compute the [[ArrayStats]] for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values. Will be modified (!) by sorting the\n *      entries.\n * @returns {(Stats | undefined)}\n *\n * @internal\n */\nexport function computeArrayStats(samples: number[]): Stats | undefined {\n    if (samples.length === 0) {\n        return undefined;\n    }\n\n    samples.sort((a: number, b: number) => {\n        return a - b;\n    });\n\n    const min: number = samples[0];\n    const max: number = samples[samples.length - 1];\n    let median: number;\n    let median75: number;\n    let median90: number;\n    let median95: number;\n    let median97: number;\n    let median99: number;\n    let median999: number;\n\n    if (samples.length === 1) {\n        median75 = median90 = median95 = median97 = median99 = median999 = median = samples[0];\n    } else if (samples.length === 2) {\n        median = samples[0] * 0.5 + samples[1] * 0.5;\n        median75 = median90 = median95 = median97 = median99 = median999 = samples[1];\n    } else {\n        const mid = Math.floor(samples.length / 2);\n        median =\n            samples.length % 2 === 0 ? samples[mid - 1] * 0.5 + samples[mid] * 0.5 : samples[mid];\n\n        const mid75 = Math.round(samples.length * 0.75) - 1;\n        median75 = samples[mid75];\n        const mid90 = Math.round(samples.length * 0.9) - 1;\n        median90 = samples[mid90];\n        const mid95 = Math.round(samples.length * 0.95) - 1;\n        median95 = samples[mid95];\n        const mid97 = Math.round(samples.length * 0.97) - 1;\n        median97 = samples[mid97];\n        const mid99 = Math.round(samples.length * 0.99) - 1;\n        median99 = samples[mid99];\n        const mid999 = Math.round(samples.length * 0.999) - 1;\n        median999 = samples[mid999];\n    }\n\n    let sum = 0;\n\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n\n    const avg = sum / samples.length;\n\n    return {\n        min,\n        max,\n        avg,\n        median,\n        median75,\n        median90,\n        median95,\n        median97,\n        median99,\n        median999,\n        numSamples: samples.length\n    };\n}\n\n/**\n * Only exported for testing\n * @ignore\n *\n * @remarks\n * Compute the averages for the passed in array of numbers.\n *\n * @param {number[]} samples Array containing sampled values.\n * @returns {(Stats | undefined)}\n *\n * @internal\n */\nexport function computeArrayAverage(samples: number[]): number | undefined {\n    if (samples.length === 0) {\n        return undefined;\n    }\n\n    let sum = 0;\n\n    for (let i = 0, l = samples.length; i < l; i++) {\n        sum += samples[i];\n    }\n\n    const avg = sum / samples.length;\n\n    return avg;\n}\n\n/**\n * Measures a sequence of connected events, such as multiple processing stages in a function.\n *\n * @remarks\n * Each stage is identified with a timer name, that must be a valid timer in the statistics\n * object. Additionally, all timers within a `MultiStageTimer` must be unique.\n *\n * Internally, the `MultiStageTimer` manages a list of timers where at the end of each stage,\n * one timer stops and the next timer starts.\n *\n * @internal\n */\nexport class MultiStageTimer {\n    private currentStage: string | undefined;\n\n    /**\n     * Defines the `MultiStageTimer` with a list of timer names that represent its stages.\n     *\n     * @param statistics - The statistics object that manages the timers.\n     * @param name - Name of this `MultiStageTimer`.\n     * @param stages - List of timer names.\n     */\n    constructor(\n        private readonly statistics: Statistics,\n        readonly name: string,\n        public stages: string[]\n    ) {\n        if (stages.length < 1) {\n            throw new Error(\"MultiStageTimer needs stages\");\n        }\n\n        stages.forEach(stage => {\n            if (!statistics.hasTimer(stage)) {\n                throw new Error(\"Unknown timer: \" + stage);\n            }\n        });\n    }\n\n    /**\n     * Gets the timer value for the last stage. If the `MultiStageTimer` did not finish its\n     * last stage, the value is `undefined`.\n     */\n    get value(): number | undefined {\n        return this.statistics.getTimer(this.stages[this.stages.length - 1]).value;\n    }\n\n    /**\n     * Resets the timers across all stages.\n     */\n    reset(): void {\n        if (!this.statistics.enabled) {\n            return;\n        }\n        this.stages.forEach(stage => {\n            this.statistics.getTimer(stage).reset();\n        });\n    }\n\n    /**\n     * Starts the `MultiStageTimer` at its first stage.\n     */\n    start(): number {\n        this.stage = this.stages[0];\n\n        return this.statistics.getTimer(this.stages[0]).value ?? -1;\n    }\n\n    /**\n     * Stops the `MultiStageTimer`. Returns the measurement of the last stage, which may be\n     * `undefined` if not all stages started.\n     */\n    stop(): number {\n        this.stage = undefined;\n        return this.value !== undefined ? this.value : -1;\n    }\n\n    /**\n     * Gets the current stage.\n     */\n    get stage(): string | undefined {\n        return this.currentStage;\n    }\n\n    /**\n     * Sets the current stage. If a new stage is provided, the current timer (if available) is\n     * stopped, and the next timer is started. If the timer in the next stage is `undefined`,\n     * this is equivalent to calling `stop` on the `MultiStageTimer`.\n     *\n     * @param stage - The next stage to start.\n     */\n    set stage(stage: string | undefined) {\n        if (this.currentStage === stage) {\n            return;\n        }\n\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).stop();\n        }\n\n        this.currentStage = stage;\n\n        if (this.statistics.enabled && this.currentStage !== undefined) {\n            this.statistics.getTimer(this.currentStage).start();\n        }\n    }\n}\n\n/**\n * Manages a set of timers.\n *\n * @remarks\n * The main objective of `Statistics` is to log these timers. You can\n * disable statistics to minimize their impact on performance.\n *\n * @internal\n */\nexport class Statistics {\n    private readonly timers: Map<string, Timer>;\n\n    private readonly nullTimer: Timer;\n\n    /**\n     * Sets up a group of timers.\n     *\n     * @param name - The statistics name, for logging purposes.\n     * @param enabled - If `false`, the timers do not measure the performance.\n     */\n    constructor(public name?: string, public enabled = false) {\n        this.timers = new Map<string, Timer>();\n        this.nullTimer = new SimpleTimer(this, \"<null>\");\n    }\n\n    /**\n     * Adds a timer, based on the name specified.\n     *\n     * @param name - The timer's name; must be unique.\n     */\n    createTimer(name: string, keepSamples = true): Timer {\n        const timer = keepSamples ? new SampledTimer(this, name) : new SimpleTimer(this, name);\n\n        return this.addTimer(timer);\n    }\n\n    /**\n     * Adds the timer specified.\n     *\n     * @param timer - The timer's name, which must be unique within this statistics object.\n     */\n    addTimer(timer: Timer): Timer {\n        if (this.timers.get(timer.name) !== undefined) {\n            throw new Error(\"Duplicate timer name: '\" + timer.name + \"'\");\n        }\n\n        this.timers.set(timer.name, timer);\n\n        return timer;\n    }\n\n    /**\n     * Gets a timer by name.\n     *\n     * @param name - The timer's name.\n     */\n    getTimer(name: string): Timer {\n        if (!this.enabled) {\n            return this.nullTimer;\n        }\n\n        const t = this.timers.get(name);\n        return t === undefined ? this.nullTimer : t;\n    }\n\n    /**\n     * Checks if a timer with the specified name already exists.\n     *\n     * @param name - The timer's name.\n     * @returns `true` if a timer with `name` already exists; `false` otherwise.\n     */\n    hasTimer(name: string): boolean {\n        const t = this.timers.get(name);\n        return t !== undefined;\n    }\n\n    /**\n     * Resets all timers.\n     */\n    reset() {\n        this.timers.forEach((timer: Timer) => {\n            timer.reset();\n        });\n    }\n\n    /**\n     * Prints all values to the console.\n     *\n     * @param header - Optional header line.\n     * @param footer - Optional footer line.\n     */\n    log(header?: string, footer?: string) {\n        if (header !== undefined || this.name !== undefined) {\n            logger.log(header !== undefined ? header : this.name);\n        }\n\n        let maxNameLength = 0;\n\n        this.timers.forEach((timer: Timer) => {\n            maxNameLength = Math.max(maxNameLength, timer.name.length);\n        });\n\n        // simple printing function for number limits the number of decimal points.\n        const print = (v: number | undefined) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n\n        this.timers.forEach((timer: Timer) => {\n            let s = timer.name + \": \" + \" \".repeat(maxNameLength - timer.name.length);\n            s += print(timer.value);\n\n            // sampled timers also update their stats and log them\n            if (timer instanceof SampledTimer) {\n                const simpleStats = timer.getStats();\n                if (simpleStats !== undefined) {\n                    s +=\n                        `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                        `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                        `med95=${print(simpleStats.median95)}, med99=${print(\n                            simpleStats.median99\n                        )}, ` +\n                        `N=${print(simpleStats.numSamples)} ]`;\n                }\n            }\n            logger.log(s);\n        });\n\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n}\n\n/**\n * Class containing all counters, timers and events of the current frame.\n *\n * @internal\n */\nexport class FrameStats {\n    readonly entries: Map<string, number> = new Map();\n    messages?: string[] = undefined;\n\n    /**\n     * Retrieve the value of the performance number.\n     *\n     * @param name - Name of the performance number.\n     * @returns The value of the performance number or `undefined` if it has not been declared by\n     *      `setValue` before.\n     */\n    getValue(name: string): number | undefined {\n        return this.entries.get(name);\n    }\n\n    /**\n     * Set the value of the performance number.\n     *\n     * @param name - Name of the performance number.\n     * @param name - New value of the performance number.\n     */\n    setValue(name: string, value: number) {\n        this.entries.set(name, value);\n    }\n\n    /**\n     * Add a value to the current value of the performance number. If the performance is not known,\n     * it will be initialized with `value`.\n     *\n     * @param name - Name of the performance number.\n     * @param name - Value to be added to the performance number.\n     */\n    addValue(name: string, value: number) {\n        const oldValue = this.entries.get(name);\n        this.entries.set(name, value + (oldValue === undefined ? 0 : oldValue));\n    }\n\n    /**\n     * Add a text message to the frame, like \"Font XYZ has been loaded\"\n     *\n     * @param message - The message to add.\n     */\n    addMessage(message: string) {\n        if (this.messages === undefined) {\n            this.messages = [];\n        }\n        this.messages.push(message);\n    }\n\n    /**\n     * Reset all known performance values to `0` and the messages to `undefined`.\n     */\n    reset() {\n        this.entries.forEach((value: number, name: string) => {\n            this.entries.set(name, 0);\n        });\n\n        this.messages = undefined;\n    }\n}\n\n/**\n * @ignore\n * Only exported for testing.\n *\n * @remarks\n * Instead of passing around an array of objects, we store the frame statistics as an object of\n * arrays. This allows convenient computations from {@link RingBuffer},\n */\nexport class FrameStatsArray {\n    readonly frameEntries: Map<string, RingBuffer<number>> = new Map();\n    readonly messages: RingBuffer<string[] | undefined>;\n\n    constructor(readonly capacity: number = 0) {\n        this.messages = new RingBuffer<string[] | undefined>(capacity);\n    }\n\n    get length(): number {\n        return this.messages.size;\n    }\n\n    reset() {\n        this.frameEntries.forEach((buffer: RingBuffer<number>, name: string) => {\n            buffer.clear();\n        });\n        this.messages.clear();\n    }\n\n    addFrame(frameStats: FrameStats) {\n        const currentSize = this.length;\n        const frameEntries = this.frameEntries;\n\n        frameStats.entries.forEach((value: number, name: string) => {\n            let buffer = frameEntries.get(name);\n\n            if (buffer === undefined) {\n                // If there is a buffer that has not been known before, add it to the known buffers,\n                // fill it up with with 0 to the size of all the other buffers to make them of equal\n                // size to make PerfViz happy.\n                buffer = new RingBuffer<number>(this.capacity);\n                for (let i = 0; i < currentSize; i++) {\n                    buffer.enqOne(0);\n                }\n                this.frameEntries.set(name, buffer);\n            }\n            buffer.enqOne(value);\n        });\n\n        this.messages.enq(frameStats.messages);\n    }\n\n    /**\n     * Prints all values to the console.\n     */\n    log() {\n        let maxNameLength = 0;\n        this.frameEntries.forEach((buffer: RingBuffer<number>, name: string) => {\n            maxNameLength = Math.max(maxNameLength, name.length);\n        });\n\n        // simple printing function for number limits the number of decimal points.\n        const print = (v: number | undefined) => {\n            return v !== undefined ? v.toFixed(5) : \"?\";\n        };\n\n        this.frameEntries.forEach((buffer: RingBuffer<number>, name: string) => {\n            let s = name + \": \" + \" \".repeat(maxNameLength - name.length);\n\n            const simpleStats = computeArrayStats(buffer.asArray());\n            if (simpleStats !== undefined) {\n                s +=\n                    `  [ min=${print(simpleStats.min)}, max=${print(simpleStats.max)}, ` +\n                    `avg=${print(simpleStats.avg)}, med=${print(simpleStats.median)}, ` +\n                    `med95=${print(simpleStats.median95)}, med99=${print(simpleStats.median99)}, ` +\n                    `N=${print(simpleStats.numSamples)} ]`;\n            }\n            logger.log(s);\n        });\n    }\n}\n\n/**\n * Chrome's MemoryInfo interface.\n */\ninterface ChromeMemoryInfo {\n    totalJSHeapSize: number;\n    usedJSHeapSize: number;\n    jsHeapSizeLimit: number;\n}\n\n/**\n * @internal\n */\nexport interface SimpleFrameStatistics {\n    configs: Map<string, string>;\n    appResults: Map<string, number>;\n    frames: Map<string, number | number[]>;\n    messages: Array<string[] | undefined>;\n    frameStats?: Map<string, Stats | undefined>;\n    zoomLevelLabels?: string[];\n    zoomLevelData?: Map<string, number | number[]>;\n}\n\n/**\n * Performance measurement central.\n *\n * @remarks\n * Maintains the current. Implemented as an instance for easy access.\n *\n * {@link FrameStats}, which holds all individual performance numbers.\n *\n * @internal\n */\nexport class PerformanceStatistics {\n    /**\n     * Returns `true` when the maximum number of storable frames is reached.\n     *\n     * @readonly\n     * @type {boolean}\n     * @memberof PerformanceStatistics\n     */\n    get isFull(): boolean {\n        return this.m_frameEvents.length >= this.maxNumFrames;\n    }\n\n    /**\n     * Global instance to the instance. The current instance can be overridden by creating a new\n     * `PerformanceStatistics`.\n     */\n    static get instance(): PerformanceStatistics {\n        if (PerformanceStatistics.m_instance === undefined) {\n            PerformanceStatistics.m_instance = new PerformanceStatistics(false, 0);\n        }\n        return PerformanceStatistics.m_instance;\n    }\n\n    private static m_instance?: PerformanceStatistics = undefined;\n\n    /**\n     * Current frame statistics. Contains all values for the current frame. Will be cleared when\n     * [[PerformanceStatistics#storeFrameInfo]] is called.\n     *\n     * @type {FrameStats}\n     * @memberof PerformanceStatistics\n     */\n    readonly currentFrame: FrameStats = new FrameStats();\n\n    /**\n     * @ignore\n     * Only exported for testing.\n     *\n     * Return the array of frame events.\n     */\n    get frameEvents(): FrameStatsArray {\n        return this.m_frameEvents;\n    }\n\n    /**\n     * Additional results stored for the current application run, not per frame. Only the last value\n     * is stored.\n     *\n     * @type {(Map<string, number>)}\n     */\n    readonly appResults: Map<string, number> = new Map();\n\n    /**\n     * Additional configuration values stored for the current application run, not per frame. Only\n     * the last value is stored.\n     *\n     * @type {(Map<string, string>)}\n     * @memberof PerformanceStatistics\n     */\n    readonly configs: Map<string, string> = new Map();\n\n    // Current array of frame events.\n    private readonly m_frameEvents: FrameStatsArray;\n\n    /**\n     * Creates an instance of PerformanceStatistics. Overrides the current `instance`.\n     *\n     * @param {boolean} [enabled=true] If `false` the performance values will not be stored.\n     * @param {number} [maxNumFrames=1000] The maximum number of frames that are to be stored.\n     * @memberof PerformanceStatistics\n     */\n    constructor(public enabled = true, public maxNumFrames = 1000) {\n        PerformanceStatistics.m_instance = this;\n        this.m_frameEvents = new FrameStatsArray(maxNumFrames);\n    }\n\n    /**\n     * Clears all settings, all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clear() {\n        this.clearFrames();\n        this.configs.clear();\n        this.appResults.clear();\n    }\n\n    /**\n     * Clears only all stored frame events as well as the current frame values.\n     *\n     * @memberof PerformanceStatistics\n     */\n    clearFrames() {\n        this.m_frameEvents.reset();\n        this.currentFrame.reset();\n    }\n\n    /**\n     * Add the render state information from [[THREE.WebGLInfo]] to the current frame.\n     * @param {THREE.WebGLInfo} webGlInfo\n     */\n    addWebGLInfo(webGlInfo: THREE.WebGLInfo) {\n        if (webGlInfo.render !== undefined) {\n            this.currentFrame.setValue(\n                \"gl.numCalls\",\n                webGlInfo.render.calls === null ? 0 : webGlInfo.render.calls\n            );\n            this.currentFrame.setValue(\n                \"gl.numPoints\",\n                webGlInfo.render.points === null ? 0 : webGlInfo.render.points\n            );\n            this.currentFrame.setValue(\n                \"gl.numLines\",\n                webGlInfo.render.lines === null ? 0 : webGlInfo.render.lines\n            );\n            this.currentFrame.setValue(\n                \"gl.numTriangles\",\n                webGlInfo.render.triangles === null ? 0 : webGlInfo.render.triangles\n            );\n        }\n        if (webGlInfo.memory !== undefined) {\n            this.currentFrame.setValue(\n                \"gl.numGeometries\",\n                webGlInfo.memory.geometries === null ? 0 : webGlInfo.memory.geometries\n            );\n            this.currentFrame.setValue(\n                \"gl.numTextures\",\n                webGlInfo.memory.textures === null ? 0 : webGlInfo.memory.textures\n            );\n        }\n        if (webGlInfo.programs !== undefined) {\n            this.currentFrame.setValue(\n                \"gl.numPrograms\",\n                webGlInfo.programs === null ? 0 : webGlInfo.programs.length\n            );\n        }\n    }\n\n    /**\n     * Add memory statistics to the current frame if available.\n     * @note Currently only supported on Chrome\n     */\n    addMemoryInfo() {\n        if (window !== undefined && window.performance !== undefined) {\n            const memory = (window.performance as any).memory as ChromeMemoryInfo;\n            if (memory !== undefined) {\n                this.currentFrame.setValue(\"memory.totalJSHeapSize\", memory.totalJSHeapSize);\n                this.currentFrame.setValue(\"memory.usedJSHeapSize\", memory.usedJSHeapSize);\n                this.currentFrame.setValue(\"memory.jsHeapSizeLimit\", memory.jsHeapSizeLimit);\n            }\n        }\n    }\n\n    /**\n     * Stores the current frame events into the array of events and clears all values.\n     *\n     * @returns {boolean} Returns `false` if the maximum number of storable frames has been reached.\n     * @memberof PerformanceStatistics\n     */\n    storeAndClearFrameInfo(): boolean {\n        if (this.m_frameEvents.length >= this.maxNumFrames) {\n            return false;\n        }\n\n        this.m_frameEvents.addFrame(this.currentFrame);\n\n        this.currentFrame.reset();\n        return true;\n    }\n\n    /**\n     * Logs all values to the logger.\n     *\n     * @param header - Optional header line.\n     * @param footer - Optional footer line.\n     */\n    log(header?: string, footer?: string) {\n        logger.log(header !== undefined ? header : \"PerformanceStatistics\");\n\n        const appResults = this.appResults;\n        appResults.forEach((value: number, name: string) => {\n            logger.log(name, value);\n        });\n        const configs = this.configs;\n        configs.forEach((value: string, name: string) => {\n            logger.log(name, value);\n        });\n        this.m_frameEvents.log();\n\n        if (footer !== undefined) {\n            logger.log(footer);\n        }\n    }\n\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsPlainObject(onlyLastFrame: boolean = false): any {\n        const appResults: any = {};\n        const configs: any = {};\n        const frames: any = {};\n        const plainObject: any = {\n            configs,\n            appResults,\n            frames\n        };\n\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value: number, name: string) => {\n            appResults[name] = value;\n        });\n\n        const configValues = this.configs;\n        configValues.forEach((value: string, name: string) => {\n            configs[name] = value;\n        });\n\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.bottom;\n            }\n        } else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames[name] = buffer.asArray();\n            }\n        }\n        plainObject.messages = this.m_frameEvents.messages.asArray();\n        return plainObject;\n    }\n\n    /**\n     * Convert the last frame values to a plain object that can be serialized. Required to copy the\n     * test results over to nightwatch.\n     */\n    getLastFrameStatistics(): any {\n        return this.getAsPlainObject(true);\n    }\n\n    /**\n     * Convert to a plain object that can be serialized. Required to copy the test results over to\n     * nightwatch.\n     */\n    getAsSimpleFrameStatistics(onlyLastFrame: boolean = false): SimpleFrameStatistics {\n        const configs: Map<string, string> = new Map();\n        const appResults: Map<string, number> = new Map();\n        const frames: Map<string, number | number[]> = new Map();\n\n        const simpleStatistics: SimpleFrameStatistics = {\n            configs,\n            appResults,\n            frames,\n            messages: this.m_frameEvents.messages.asArray()\n        };\n\n        const appResultValues = this.appResults;\n        appResultValues.forEach((value: number, name: string) => {\n            appResults.set(name, value);\n        });\n\n        const configValues = this.configs;\n        configValues.forEach((value: string, name: string) => {\n            configs.set(name, value);\n        });\n\n        if (onlyLastFrame) {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.bottom);\n            }\n        } else {\n            for (const [name, buffer] of this.m_frameEvents.frameEntries) {\n                frames.set(name, buffer.asArray());\n            }\n        }\n        return simpleStatistics;\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nexport interface RequestHeaders {\n    [field: string]: string;\n}\n\n/**\n * A texture loader that supports request headers(e.g. for Authorization)\n */\nexport class TextureLoader {\n    private readonly m_textureLoader = new THREE.TextureLoader();\n\n    /**\n     * Load an image from url and create a texture\n     * @param url - URL to the image\n     * @param requestHeaders - Optional request headers to load image(e.g. Authorization)\n     * @param abortSignal - Optional AbortSignal to cancel the load.\n     * @param crossOrigin - Enable/disable CORS\n     */\n    async load(\n        url: string,\n        requestHeaders?: RequestHeaders | undefined,\n        abortSignal?: AbortSignal,\n        crossOrigin: boolean = true\n    ): Promise<THREE.Texture> {\n        // Use THREE.js texture loader directly if no request header is set\n        if (requestHeaders === undefined) {\n            return await this.loadWithThreeLoader(url);\n        }\n\n        // Load image with fetch API if request header is set\n        const response = await fetch(url, {\n            headers: requestHeaders,\n            signal: abortSignal,\n            mode: crossOrigin ? \"cors\" : \"no-cors\"\n        });\n        const blob = await response.blob();\n\n        // Load image from blob using THREE.js loader\n        const texture = await this.loadWithThreeLoader(URL.createObjectURL(blob));\n\n        // Set correct image format from original URL or blob mime type\n        // (object URL does not contain file format)\n        const isJPEG =\n            blob.type === \"image/jpeg/\" ||\n            url.search(/\\.jpe?g($|\\?)/i) > 0 ||\n            url.search(/^data\\:image\\/jpeg/) === 0;\n        texture.format = isJPEG ? THREE.RGBFormat : THREE.RGBAFormat;\n\n        return texture;\n    }\n\n    private loadWithThreeLoader(url: string): Promise<THREE.Texture> {\n        return new Promise<THREE.Texture>((resolve, reject) => {\n            this.m_textureLoader.setCrossOrigin(\"\");\n            this.m_textureLoader.load(\n                url,\n                texture => resolve(texture),\n                undefined,\n                () => reject(new Error(\"failed to load texture\"))\n            );\n        });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    Light,\n    MagFilter,\n    MinFilter,\n    PixelFormat,\n    TextureDataType,\n    WrappingMode\n} from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\n\n/**\n * Returns `three.js` pixel format object basing on a [[PixelFormat]] specified.\n */\nexport function toPixelFormat(format: PixelFormat): THREE.PixelFormat {\n    switch (format) {\n        case \"Alpha\":\n            return THREE.AlphaFormat;\n        case \"RGB\":\n            return THREE.RGBFormat;\n        case \"RGBA\":\n            return THREE.RGBAFormat;\n        case \"Luminance\":\n            return THREE.LuminanceFormat;\n        case \"LuminanceAlpha\":\n            return THREE.LuminanceAlphaFormat;\n        case \"RGBE\":\n            return THREE.RGBEFormat;\n        case \"Depth\":\n            return THREE.DepthFormat;\n        case \"DepthStencil\":\n            return THREE.DepthStencilFormat;\n        case \"Red\":\n            return THREE.RedFormat;\n        default:\n            throw new Error(`invalid pixel format: ${format}`);\n    }\n}\n\n/**\n * Returns `three.js` texture data types based on a [[TextureDataType]] specified.\n */\nexport function toTextureDataType(dataType: TextureDataType): THREE.TextureDataType {\n    switch (dataType) {\n        case \"UnsignedByte\":\n            return THREE.UnsignedByteType;\n        case \"Byte\":\n            return THREE.ByteType;\n        case \"Short\":\n            return THREE.ShortType;\n        case \"UnsignedShort\":\n            return THREE.UnsignedShortType;\n        case \"Int\":\n            return THREE.IntType;\n        case \"UnsignedInt\":\n            return THREE.UnsignedIntType;\n        case \"Float\":\n            return THREE.FloatType;\n        case \"HalfFloat\":\n            return THREE.HalfFloatType;\n        default:\n            throw new Error(`invalid texture data type: ${dataType}`);\n    }\n}\n\n/**\n * Returns `three.js` wrapping mode object based on a [[WrappingMode]] specified.\n */\nexport function toWrappingMode(mode: WrappingMode): THREE.Wrapping {\n    switch (mode) {\n        case \"clamp\":\n            return THREE.ClampToEdgeWrapping;\n        case \"repeat\":\n            return THREE.RepeatWrapping;\n        case \"mirror\":\n            return THREE.MirroredRepeatWrapping;\n        default:\n            throw new Error(`invalid wrapping mode: ${mode}`);\n    }\n}\n\n/**\n * Returns `three.js` texture filter object based on a [[MagFilter]] or [[MinFilter]] specified.\n */\nexport function toTextureFilter(filter: MagFilter | MinFilter): THREE.TextureFilter {\n    switch (filter) {\n        case \"nearest\":\n            return THREE.NearestFilter;\n        case \"nearestMipMapNearest\":\n            return THREE.NearestMipMapNearestFilter;\n        case \"nearestMipMapLinear\":\n            return THREE.NearestMipMapLinearFilter;\n        case \"linear\":\n            return THREE.LinearFilter;\n        case \"linearMipMapNearest\":\n            return THREE.LinearMipMapNearestFilter;\n        case \"linearMipMapLinear\":\n            return THREE.LinearMipMapLinearFilter;\n        default:\n            throw new Error(`invalid texture filter: ${filter}`);\n    }\n}\n\n/**\n * Create a specific light for lighting the map.\n */\nexport function createLight(lightDescription: Light): THREE.Light {\n    switch (lightDescription.type) {\n        case \"ambient\": {\n            const light = new THREE.AmbientLight(\n                lightDescription.color,\n                lightDescription.intensity\n            );\n            light.name = lightDescription.name;\n            return light;\n        }\n        case \"directional\": {\n            const light = new THREE.DirectionalLight(\n                lightDescription.color,\n                lightDescription.intensity\n            );\n            light.name = lightDescription.name;\n            if (lightDescription.castShadow !== undefined) {\n                light.castShadow = lightDescription.castShadow;\n            }\n            if (light.castShadow) {\n                light.shadow.bias = 0.00001;\n                light.shadow.mapSize.width = 1024;\n                light.shadow.mapSize.height = 1024;\n            }\n            light.position.set(\n                lightDescription.direction.x,\n                lightDescription.direction.y,\n                lightDescription.direction.z\n            );\n            light.position.normalize();\n            return light;\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport \"@here/harp-fetch\";\n\nimport { isJsonExpr } from \"@here/harp-datasource-protocol\";\nimport {\n    Definitions,\n    FlatTheme,\n    getDefinitionValue,\n    ImageTexture,\n    isJsonExprReference,\n    Style,\n    Styles,\n    StyleSet,\n    Theme\n} from \"@here/harp-datasource-protocol/lib/Theme\";\nimport {\n    composeUriResolvers,\n    ContextLogger,\n    getAppBaseUrl,\n    getOptionValue,\n    IContextLogger,\n    ISimpleChannel,\n    RelativeUriResolver,\n    UriResolver\n} from \"@here/harp-utils\";\n\nimport { SKY_CUBEMAP_FACE_COUNT, SkyCubemapFaceId } from \"./SkyCubemapTexture\";\n\n/**\n * @internal\n */\nexport const DEFAULT_MAX_THEME_INTHERITANCE_DEPTH = 4;\n\n/**\n * Options to customize {@link @here/harp-datasource-protocol#Theme} loading process.\n *\n * @see {@link ThemeLoader.load}\n */\nexport interface ThemeLoadOptions {\n    /**\n     * Whether to resolve `ref` expressions in `definition` and `styles` elements.\n     *\n     * @default `false`, as datasources resolve definitions in [[StyleSetEvaluator]].\n     */\n    resolveDefinitions?: boolean;\n\n    /**\n     * Resolve the URIs to resources like fonts, icons, ...\n     * If true, [[uriResolver]] will be used to resolve the URI\n     * @default true\n     */\n    resolveResourceUris?: boolean;\n\n    /**\n     * Resolve the URIs of inherited themes (using `extends` feature).\n     * If true, [[uriResolver]] will be used to resolve the URI\n     * @default true\n     */\n    resolveIncludeUris?: boolean;\n\n    /**\n     * An `AbortSignal` object instance; allows you to communicate with a loading process\n     * (including fetch requests) request and abort it if desired via an `AbortController`.\n     *\n     * Modeled after Web APIs `fetch`s `init.signal`.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortController\n     */\n    signal?: AbortSignal;\n\n    /**\n     * Maximum recursion depth when resolving base themes\n     * through [{@link @here/harp-datasource-protocol#Theme}s `extends` property.\n     *\n     * @default [[DEFAULT_MAX_THEME_INTHERITANCE_DEPTH]]\n     */\n    maxInheritanceDepth?: number;\n\n    /**\n     * Custom logging channel on which diagnostics and warnings will be reported.\n     *\n     * If not specified, {@link ThemeLoader.load} will log to `console`.\n     */\n    logger?: ISimpleChannel;\n\n    /**\n     * Resolve asset `URI`s referenced in `Theme` assets using this resolver.\n     */\n    uriResolver?: UriResolver;\n}\n\n/**\n * Loads and validates a theme from URL objects.\n */\nexport class ThemeLoader {\n    /**\n     * Loads a {@link @here/harp-datasource-protocol#Theme} from a\n     * remote resource, provided as a URL that points to a\n     * JSON-encoded theme.\n     *\n     * By default, resolves following features of theme:\n     *\n     *  -  `extends` - loads and merges all inherited themes (see [[resolveBaseTheme]])\n     *  -  `ref` - resolves all `ref` instances to their values defined in `definitions` section\n     *     of theme (see [[resolveThemeReferences]])\n     *\n     * Relative URIs of reference resources are resolved to full URL using the document's base URL\n     * (see [[resolveUrls]]).\n     *\n     * Custom URIs (of theme itself and of resources referenced by theme) may be resolved with by\n     * providing {@link @here/harp-utils#UriResolver} using {@link ThemeLoadOptions.uriResolver}\n     * option.\n     *\n     * @param theme - {@link @here/harp-datasource-protocol#Theme} instance or theme URL\n     *                to the theme.\n     * @param options - Optional, a {@link ThemeLoadOptions} objects\n     *                  containing any custom settings for\n     *                  this load request.\n     */\n    static async load(\n        theme: string | Theme | FlatTheme,\n        options?: ThemeLoadOptions\n    ): Promise<Theme> {\n        options = options ?? {};\n        if (typeof theme === \"string\") {\n            const uriResolver = options.uriResolver;\n            const themeUrl = uriResolver !== undefined ? uriResolver.resolveUri(theme) : theme;\n            const response = await fetch(themeUrl, { signal: options.signal });\n            if (!response.ok) {\n                throw new Error(`ThemeLoader#load: cannot load theme: ${response.statusText}`);\n            }\n            theme = (await response.json()) as Theme;\n            theme.url = themeUrl;\n            theme = this.resolveUrls(theme, options);\n        } else if (theme.url === undefined) {\n            // assume that theme url is same as baseUrl\n            theme.url = getAppBaseUrl();\n            theme = this.resolveUrls(theme, options);\n        } else {\n            theme = this.convertFlatTheme(theme);\n        }\n\n        if (theme === null || theme === undefined) {\n            throw new Error(\"ThemeLoader#load: loaded resource is not valid JSON\");\n        }\n\n        ThemeLoader.checkTechniqueSupport(theme);\n\n        const resolveDefinitions = getOptionValue<boolean>(options.resolveDefinitions, false);\n        theme = await ThemeLoader.resolveBaseThemes(theme, options);\n        if (resolveDefinitions) {\n            const contextLoader = new ContextLogger(\n                options.logger ?? console,\n                `when processing Theme ${theme.url}:`\n            );\n            ThemeLoader.resolveThemeReferences(theme, contextLoader);\n        }\n        return theme;\n    }\n\n    /**\n     * Checks if `theme` instance is completely loaded, meaning that `extends` property is resolved.\n     *\n     * @param theme -\n     */\n    static isThemeLoaded(theme: Theme | FlatTheme): boolean {\n        // TODO: Remove array check, when FlatTheme is fully supported\n        return theme.extends === undefined && !Array.isArray(theme.styles);\n    }\n\n    /**\n     * @deprecated Please use `ThemeLoader.load`\n     *\n     * Loads a {@link @here/harp-datasource-protocol#Theme} from a remote resource,\n     * provided as a URL that points to a JSON-encoded\n     * theme.\n     *\n     * @param themeUrl - The URL to the theme.\n     *\n     */\n    static async loadAsync(themeUrl: string): Promise<Theme> {\n        return await ThemeLoader.load(themeUrl);\n    }\n\n    /**\n     * Resolves all {@link @here/harp-datasource-protocol#Theme}'s relatives URLs\n     * to full URL using the {@link @here/harp-datasource-protocol#Theme}'s URL\n     * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n     *\n     * This method mutates original `theme` instance.\n     *\n     * @param theme - The {@link @here/harp-datasource-protocol#Theme} to resolve.\n     */\n    private static resolveUrls(theme: Theme | FlatTheme, options?: ThemeLoadOptions): Theme {\n        // Ensure that all resources referenced in theme by relative URIs are in fact relative to\n        // theme.\n        theme = ThemeLoader.convertFlatTheme(theme);\n        if (theme.url === undefined) {\n            return theme;\n        }\n\n        const childUrlResolver = composeUriResolvers(\n            options?.uriResolver,\n            new RelativeUriResolver(theme.url)\n        );\n\n        const resolveIncludes = options === undefined || !(options.resolveIncludeUris === false);\n        if (theme.extends && resolveIncludes) {\n            theme.extends = (Array.isArray(theme.extends) ? theme.extends : [theme.extends]).map(\n                baseTheme => {\n                    if (typeof baseTheme === \"string\") {\n                        return childUrlResolver.resolveUri(baseTheme);\n                    } else {\n                        if (baseTheme.url !== undefined) {\n                            return baseTheme;\n                        } else {\n                            baseTheme.url = theme.url;\n                            return this.resolveUrls(baseTheme, options);\n                        }\n                    }\n                }\n            );\n        }\n\n        if (!ThemeLoader.convertFlatTheme(theme)) {\n            return theme;\n        }\n\n        const resolveResources = options === undefined || !(options.resolveResourceUris === false);\n        if (resolveResources) {\n            ThemeLoader.resolveResources(theme, childUrlResolver);\n        }\n\n        return theme;\n    }\n\n    private static checkTechniqueSupport(theme: Theme) {\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                for (const style of theme.styles[styleSetName]) {\n                    switch ((style as any).technique) {\n                        // TODO: Re-enable this once \"dashed-line\" is deprecated.\n                        /* case \"dashed-line\":\n                            console.warn(\n                                `Using deprecated \"dashed-line\" technique.\n                                Use \"solid-line\" technique instead`\n                            ); */\n                        default:\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Expand all `ref` expressions in {@link @here/harp-datasource-protocol#Theme}\n     * basing on `definitions`.\n     *\n     * @remarks\n     * This method mutates original `theme` instance.\n     */\n    private static resolveThemeReferences(theme: Theme, contextLogger: IContextLogger): Theme {\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                contextLogger.pushAttr(\"styles\");\n                contextLogger.pushAttr(styleSetName);\n\n                theme.styles[styleSetName] = ThemeLoader.resolveStyleSet(\n                    theme.styles[styleSetName],\n                    theme.definitions,\n                    contextLogger\n                );\n                contextLogger.pop();\n                contextLogger.pop();\n            }\n        }\n        return theme;\n    }\n\n    /**\n     * Expand all `ref` in [[StyleSet]] basing on `definitions`.\n     */\n    private static resolveStyleSet(\n        styleSet: StyleSet,\n        definitions: Definitions | undefined,\n        contextLogger: IContextLogger\n    ): StyleSet {\n        const result: StyleSet = [];\n\n        for (let index = 0; index < styleSet.length; ++index) {\n            const currentStyle = styleSet[index];\n            contextLogger.pushIndex(index);\n            const resolvedStyle = ThemeLoader.resolveStyle(\n                currentStyle,\n                definitions,\n                contextLogger\n            );\n            if (resolvedStyle !== undefined) {\n                result.push(resolvedStyle);\n            } else {\n                contextLogger.warn(\"invalid style, ignored\");\n            }\n            contextLogger.pop();\n        }\n        return result;\n    }\n\n    /**\n     * Expand all `ref` in [[Style]] instance basing on `definitions`.\n     */\n    private static resolveStyle(\n        style: Style,\n        definitions: Definitions | undefined,\n        contextLogger: IContextLogger\n    ): Style | undefined {\n        if (Array.isArray(style.when)) {\n            contextLogger.pushAttr(\"when\");\n            const resolvedWhen = this.resolveExpressionReferences(\n                style.when,\n                definitions,\n                contextLogger\n            );\n            contextLogger.pop();\n            if (resolvedWhen === undefined) {\n                return undefined;\n            }\n            style.when = resolvedWhen;\n        }\n\n        if (style.attr !== undefined) {\n            const attr = style.attr as any;\n\n            contextLogger.pushAttr(\"attr\");\n            for (const prop in attr) {\n                if (!attr.hasOwnProperty(prop)) {\n                    continue;\n                }\n\n                const value = attr[prop];\n\n                if (!Array.isArray(value)) {\n                    continue; // nothing to do\n                }\n\n                contextLogger.pushAttr(prop);\n                const resolvedValue = this.resolveExpressionReferences(\n                    value,\n                    definitions,\n                    contextLogger\n                );\n                contextLogger.pop();\n\n                if (resolvedValue !== undefined) {\n                    attr[prop] = resolvedValue;\n                } else {\n                    delete attr[prop];\n                }\n            }\n            contextLogger.pop();\n        }\n        return style;\n    }\n\n    /**\n     * Resolve `[ref, ...]` in expressions.\n     *\n     * Returns `undefined` some reference was invalid (missing or wrong type).\n     */\n    private static resolveExpressionReferences<T>(\n        value: T,\n        definitions: Definitions | undefined,\n        contextLogger: IContextLogger\n    ): T | undefined {\n        let failed = false;\n        function resolveInternal(node: any) {\n            if (isJsonExprReference(node)) {\n                const defName = node[1];\n                const def = definitions && definitions[defName];\n                if (def === undefined) {\n                    contextLogger.warn(`invalid reference '${defName}' - not found`);\n                    failed = true;\n                    return undefined;\n                }\n                if (isJsonExpr(def)) {\n                    return def;\n                }\n                return getDefinitionValue(def);\n            } else if (Array.isArray(node)) {\n                const result = [...node];\n                for (let i = 1; i < result.length; ++i) {\n                    result[i] = resolveInternal(result[i]);\n                }\n                return result;\n            } else {\n                return node;\n            }\n        }\n        const r = resolveInternal(value);\n        if (failed) {\n            return undefined;\n        }\n        return r;\n    }\n\n    /**\n     * Realize `extends` clause by merging `theme` with\n     * its base {@link @here/harp-datasource-protocol#Theme}.\n     *\n     * @param theme - {@link @here/harp-datasource-protocol#Theme} object\n     * @param options - Optional, a {@link ThemeLoadOptions} objects\n     *                  containing any custom settings for\n     *                  this load request.\n     */\n    private static async resolveBaseThemes(\n        theme: Theme,\n        options?: ThemeLoadOptions\n    ): Promise<Theme> {\n        options = options ?? {};\n        if (theme.extends === undefined) {\n            return theme;\n        }\n\n        const maxInheritanceDepth = getOptionValue(\n            options.maxInheritanceDepth,\n            DEFAULT_MAX_THEME_INTHERITANCE_DEPTH\n        );\n        if (maxInheritanceDepth <= 0) {\n            throw new Error(`maxInheritanceDepth reached when attempting to load base theme`);\n        }\n\n        const baseThemes = !Array.isArray(theme.extends) ? [theme.extends] : theme.extends;\n        delete theme.extends;\n        let baseThemesMerged: Theme = {};\n        for (const baseTheme of baseThemes) {\n            const actualBaseTheme = await ThemeLoader.load(baseTheme, {\n                ...options,\n                resolveDefinitions: false,\n                maxInheritanceDepth: maxInheritanceDepth - 1\n            });\n\n            baseThemesMerged = ThemeLoader.mergeThemes(actualBaseTheme, baseThemesMerged);\n        }\n        return ThemeLoader.mergeThemes(theme, baseThemesMerged);\n    }\n\n    private static mergeThemes(theme: Theme, baseTheme: Theme): Theme {\n        const definitions = { ...baseTheme.definitions, ...theme.definitions };\n\n        let styles!: Styles;\n\n        if (baseTheme.styles && theme.styles) {\n            const currentStyleSets = Object.keys(baseTheme.styles);\n            const incomingStyleSets = Object.keys(theme.styles);\n\n            styles = {};\n\n            currentStyleSets.forEach(styleSetName => {\n                const index = incomingStyleSets.indexOf(styleSetName);\n\n                if (index !== -1) {\n                    // merge the current and incoming styleset\n                    // and add the result to `styles`.\n\n                    const baseStyleSet = baseTheme.styles![styleSetName];\n\n                    const newStyleSet: StyleSet = [];\n                    const styleIdMap = new Map<string, number>();\n                    baseStyleSet.forEach(style => {\n                        if (typeof style.id === \"string\") {\n                            styleIdMap.set(style.id, newStyleSet.length);\n                        }\n                        newStyleSet.push(style);\n                    });\n\n                    const incomingStyleSet = theme.styles![styleSetName];\n                    incomingStyleSet.forEach(style => {\n                        if (typeof style.extends === \"string\" && styleIdMap.has(style.extends)) {\n                            // extends the existing style referenced by `style.extends`.\n                            const baseStyleIndex = styleIdMap.get(style.extends)!;\n                            const baseStyle = newStyleSet[baseStyleIndex];\n                            newStyleSet[baseStyleIndex] = { ...baseStyle, ...style } as any;\n                            newStyleSet[baseStyleIndex].extends = undefined;\n                            return;\n                        }\n\n                        if (typeof style.id === \"string\" && styleIdMap.has(style.id)) {\n                            // overrides the existing style with `id` equals to `style.id`.\n                            const styleIndex = styleIdMap.get(style.id)!;\n                            newStyleSet[styleIndex] = style;\n                            return;\n                        }\n\n                        newStyleSet.push(style);\n                    });\n\n                    styles[styleSetName] = newStyleSet;\n\n                    // remove the styleset from the incoming list\n                    incomingStyleSets.splice(index, 1);\n                } else {\n                    // copy the existing style set to `styles`.\n                    styles[styleSetName] = baseTheme.styles![styleSetName];\n                }\n            });\n\n            // add the remaining stylesets to styles.\n            incomingStyleSets.forEach(p => {\n                styles[p] = theme.styles![p];\n            });\n        } else if (baseTheme.styles) {\n            styles = { ...baseTheme.styles };\n        } else if (theme.styles) {\n            styles = { ...theme.styles };\n        }\n\n        return {\n            ...baseTheme,\n            ...theme,\n            // Due to nested structure of the images/textures it needs a\n            // deep merge with a duplicate exclusion.\n            ...ThemeLoader.mergeImageTextures(theme, baseTheme),\n            definitions,\n            styles\n        };\n    }\n\n    private static mergeImageTextures(\n        theme: Theme,\n        baseTheme: Theme\n    ): Pick<FlatTheme, \"images\" | \"imageTextures\"> {\n        const images = { ...baseTheme.images, ...theme.images };\n        let imageTextures: ImageTexture[] = [];\n\n        if (!baseTheme.imageTextures && theme.imageTextures) {\n            imageTextures = theme.imageTextures;\n        } else if (baseTheme.imageTextures && !theme.imageTextures) {\n            imageTextures = baseTheme.imageTextures;\n        } else if (baseTheme.imageTextures && theme.imageTextures) {\n            imageTextures = theme.imageTextures.slice();\n            baseTheme.imageTextures.forEach(val => {\n                if (!imageTextures.find(({ name }) => name === val.name)) {\n                    imageTextures.push(val);\n                }\n            });\n        }\n\n        return {\n            images,\n            imageTextures\n        };\n    }\n\n    private static convertFlatTheme(theme: Theme | FlatTheme): Theme {\n        if (Array.isArray(theme.styles)) {\n            // Convert the flat theme to a standard theme.\n            const styles: Styles = {};\n            theme.styles.forEach(style => {\n                if (isJsonExpr(style)) {\n                    throw new Error(\"invalid usage of theme reference\");\n                }\n                const styleSetName = style.styleSet;\n                if (styleSetName === undefined) {\n                    throw new Error(\"missing reference to style set\");\n                }\n                if (!styles[styleSetName]) {\n                    styles[styleSetName] = [];\n                }\n                styles[styleSetName].push(style);\n            });\n            theme.styles = styles;\n        }\n        return theme as Theme;\n    }\n\n    private static resolveResources(theme: Theme, childUrlResolver: UriResolver) {\n        if (theme.sky && theme.sky.type === \"cubemap\") {\n            for (let i = 0; i < SKY_CUBEMAP_FACE_COUNT; ++i) {\n                const faceUrl: string | undefined = (theme.sky as any)[SkyCubemapFaceId[i]];\n                if (faceUrl !== undefined) {\n                    (theme.sky as any)[SkyCubemapFaceId[i]] = childUrlResolver.resolveUri(faceUrl);\n                }\n            }\n        }\n        if (theme.images) {\n            for (const name of Object.keys(theme.images)) {\n                const image = theme.images[name];\n                image.url = childUrlResolver.resolveUri(image.url);\n                if (image.atlas !== undefined) {\n                    image.atlas = childUrlResolver.resolveUri(image.atlas);\n                }\n            }\n        }\n        if (theme.fontCatalogs) {\n            for (const font of theme.fontCatalogs) {\n                font.url = childUrlResolver.resolveUri(font.url);\n            }\n        }\n        if (theme.poiTables) {\n            for (const poiTable of theme.poiTables) {\n                poiTable.url = childUrlResolver.resolveUri(poiTable.url);\n            }\n        }\n\n        if (theme.styles !== undefined) {\n            for (const styleSetName in theme.styles) {\n                if (!theme.styles.hasOwnProperty(styleSetName)) {\n                    continue;\n                }\n                const styleSet = theme.styles[styleSetName] as Style[];\n                for (const style of styleSet) {\n                    if (!style.attr) {\n                        continue;\n                    }\n                    [\"map\", \"normalMap\", \"displacementMap\", \"roughnessMap\"].forEach(\n                        texturePropertyName => {\n                            const textureProperty = (style.attr! as any)[texturePropertyName];\n                            if (textureProperty && typeof textureProperty === \"string\") {\n                                (style.attr! as any)[\n                                    texturePropertyName\n                                ] = childUrlResolver.resolveUri(textureProperty);\n                            }\n                        }\n                    );\n                }\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    GeometryKindSet,\n    GeometryType,\n    TextPathGeometry\n} from \"@here/harp-datasource-protocol\";\nimport { GeoBox, OrientedBox3, Projection, TileKey, TileKeyUtils } from \"@here/harp-geoutils\";\nimport { assert, CachedResource, chainCallbacks, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { CopyrightInfo } from \"./copyrights/CopyrightInfo\";\nimport { DataSource } from \"./DataSource\";\nimport { ElevationRange } from \"./ElevationRangeSource\";\nimport { LodMesh } from \"./geometry/LodMesh\";\nimport { Object3DUtils } from \"./geometry/Object3DUtils\";\nimport { TileGeometryLoader } from \"./geometry/TileGeometryLoader\";\nimport { ITileLoader, TileLoaderState } from \"./ITileLoader\";\nimport { MapView } from \"./MapView\";\nimport { PathBlockingElement } from \"./PathBlockingElement\";\nimport { PerformanceStatistics } from \"./Statistics\";\nimport { TextElement } from \"./text/TextElement\";\nimport { TextElementGroup } from \"./text/TextElementGroup\";\nimport { TextElementGroupPriorityList } from \"./text/TextElementGroupPriorityList\";\nimport { TileTextStyleCache } from \"./text/TileTextStyleCache\";\n\nconst logger = LoggerManager.instance.create(\"Tile\");\n\nexport type TileObject = THREE.Object3D & {\n    /**\n     * Distance of this object from the {@link Tile}'s center.\n     */\n    displacement?: THREE.Vector3;\n};\n\ninterface DisposableObject {\n    geometry?: THREE.BufferGeometry;\n    geometries?: THREE.BufferGeometry[];\n    material?: THREE.Material[] | THREE.Material;\n}\n\n/**\n * An interface for optional feature data that is saved in a `THREE.Object3D`'s `userData`\n * property.\n */\nexport interface TileFeatureData {\n    /**\n     * The original type of geometry.\n     */\n    geometryType?: GeometryType;\n\n    /**\n     * An optional array of sorted indices into geometry where the feature starts. The lists of IDs\n     * and starting indices (starts) must have the same size.\n     * Feature i starts at starts[i] and ends at starts[i+1]-1, except for the last feature, which\n     * ends at the last index in the object's geometry.\n     */\n    starts?: number[];\n\n    /**\n     * An optional object containing properties defined by the developer. It has the same size as\n     * the list of IDs and the starting indices (starts).\n     */\n    objInfos?: Array<{} | undefined>;\n}\n\n/**\n * Minimum estimated size of a JS object.\n */\nconst MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION = 16;\nconst MINIMUM_OBJECT_SIZE_ESTIMATION = 100;\n\n/**\n * Compute the memory footprint of `TileFeatureData`.\n *\n * @internal\n */\nexport function getFeatureDataSize(featureData: TileFeatureData): number {\n    let numBytes = MINIMUM_OBJECT_SIZE_ESTIMATION;\n\n    if (featureData.starts !== undefined) {\n        numBytes += featureData.starts.length * 8;\n    }\n    if (featureData.objInfos !== undefined) {\n        // 16 (estimated) bytes per objInfos\n        numBytes += featureData.objInfos.length * MINIMUM_SMALL_OBJECT_SIZE_ESTIMATION;\n    }\n\n    return numBytes;\n}\n\n/**\n * An object that contains information about resources used by a tile.\n */\nexport interface TileResourceUsage {\n    /**\n     * The estimated memory usage, in bytes.\n     */\n    estimatedMemoryUsage: number;\n    /**\n     * The amount of vertices used by a tile.\n     */\n    numVertices: number;\n    /**\n     * The amount of colors used by a tile.\n     */\n    numColors: number;\n    /**\n     * The amount of objects used by a tile.\n     */\n    numObjects: number;\n    /**\n     * The amount of geometries used by a tile.\n     */\n    numGeometries: number;\n    /**\n     * The amount of materials used by a tile.\n     */\n    numMaterials: number;\n}\n\n/**\n * Simple information about resource usage by the {@link Tile}.\n *\n * @remarks\n * Heap and GPU information are\n * estimations.\n */\nexport interface TileResourceInfo {\n    /**\n     * Estimated number of bytes used on the heap.\n     */\n    heapSize: number;\n    /**\n     * Estimated number of bytes used on the GPU.\n     */\n    gpuSize: number;\n    /**\n     * Number of [[THREE.Object3D]] in this tile.\n     */\n    num3dObjects: number;\n    /**\n     * Number of {@link TextElement}s in this tile.\n     */\n    numTextElements: number;\n    /**\n     * @deprecated This counter has been merged with numTextElements.\n     * Number of user {@link TextElement}s in this tile.\n     */\n    numUserTextElements: number;\n}\n\n/**\n * @internal\n */\nexport interface TextElementIndex {\n    groupIndex: number;\n    elementIndex: number;\n}\n\ntype TileCallback = (tile: Tile) => void;\n\n/**\n * The class that holds the tiled data for a {@link DataSource}.\n */\nexport class Tile implements CachedResource {\n    /**\n     * A list of the THREE.js objects stored in this `Tile`.\n     */\n    readonly objects: TileObject[] = [];\n\n    /**\n     * The optional list of HERE TileKeys of tiles with geometries that cross the boundaries of this\n     * `Tile`.\n     */\n    readonly dependencies: TileKey[] = [];\n\n    /**\n     * The bounding box of this `Tile` in geocoordinates.\n     */\n    readonly geoBox: GeoBox;\n\n    /**\n     * Copyright information of this `Tile`'s data.\n     */\n    copyrightInfo?: CopyrightInfo[];\n\n    /**\n     * Keeping some stats for the individual {@link Tile}s to analyze caching behavior.\n     *\n     * The frame the {@link Tile} was last requested. This is\n     * required to know when the given {@link Tile}\n     * can be removed from the cache.\n     */\n    frameNumLastRequested: number = -1;\n\n    /**\n     * The frame the `Tile` was first visible.\n     */\n    frameNumVisible: number = -1;\n\n    /**\n     * The last frame this `Tile` has been rendered (or was in the visible set). Used to determine\n     * visibility of `Tile` at the end of a frame, if the number is the current frame number, it is\n     * visible.\n     */\n    frameNumLastVisible: number = -1;\n\n    /**\n     * After removing from cache, this is the number of frames the `Tile` was visible.\n     */\n    numFramesVisible: number = 0;\n\n    /**\n     * Version stamp of the visibility set in the [[TileManager]]. If the counter is different, the\n     * visibility of the Tile's objects has to be calculated. Optimization to reduce overhead of\n     * computing visibility.\n     */\n    visibilityCounter: number = -1;\n\n    /**\n     * @hidden\n     *\n     * Used to tell if the Tile is used temporarily as a fallback tile.\n     *\n     * levelOffset is in in the range [-quadTreeSearchDistanceUp,\n     * quadTreeSearchDistanceDown], where these values come from the\n     * {@link VisibleTileSetOptions}\n     */\n    levelOffset: number = 0;\n\n    /**\n     * If the tile should not be rendered, this is used typically when the tile in question\n     * is completely covered by another tile and therefore can be skipped without any visual\n     * impact. Setting this value directly affects the [[willRender]] method, unless\n     * overriden by deriving classes.\n     */\n    skipRendering: boolean = false;\n\n    /**\n     * If the tile should not yet be rendered, this is used typically when the tile in question\n     * does not fit into the gpu upload limit of the current frame.\n     * Setting this value directly affects the [[willRender]] method, unless\n     * overriden by deriving classes.\n     */\n    delayRendering = false;\n\n    /**\n     * @hidden\n     *\n     * Prepared text geometries optimized for display.\n     */\n    protected preparedTextPaths: TextPathGeometry[] | undefined;\n    protected readonly m_tileGeometryLoader?: TileGeometryLoader;\n\n    /**\n     * The bounding box of this `Tile` in world coordinates.\n     */\n    private readonly m_boundingBox = new OrientedBox3();\n\n    private m_disposed: boolean = false;\n    private m_disposeCallback?: TileCallback;\n    private readonly m_localTangentSpace: boolean;\n\n    private m_forceHasGeometry: boolean | undefined = undefined;\n\n    private m_tileLoader?: ITileLoader;\n    private m_decodedTile?: DecodedTile;\n\n    // Used for {@link TextElement}s that are stored in the data, and that are placed explicitly,\n    // fading in and out.\n    private m_textElementGroups = new TextElementGroupPriorityList();\n\n    // Blocks other labels from showing.\n    private readonly m_pathBlockingElements: PathBlockingElement[] = [];\n\n    // If `true`, the text content of the {@link Tile} changed after the last time it was rendered.\n    // It's `Undefined` when no text content has been added yet.\n    private m_textElementsChanged: boolean | undefined;\n\n    // Center of the tile's un-elevated bounding box world coordinates.\n    private readonly m_worldCenter = new THREE.Vector3();\n    private m_visibleArea: number = 0;\n    // Tile elevation range in meters\n    private readonly m_elevationRange: ElevationRange = { minElevation: 0, maxElevation: 0 };\n    // Maximum height of geometry on this tile above ground level.\n    private m_maxGeometryHeight?: number;\n    // Minimum height of geometry on this tile below ground level. Should be negative for values\n    // below ground.\n    private m_minGeometryHeight?: number;\n\n    private m_resourceInfo: TileResourceInfo | undefined;\n\n    // List of owned textures for disposal\n    private readonly m_ownedTextures: WeakSet<THREE.Texture> = new WeakSet();\n\n    private readonly m_textStyleCache: TileTextStyleCache;\n    private m_uniqueKey: number;\n    private m_offset: number;\n    /**\n     * Creates a new {@link Tile}.\n     *\n     * @param dataSource - The {@link DataSource} that created this {@link Tile}.\n     * @param tileKey - The unique identifier for this {@link Tile}.\n     *                  Currently only up to level 24 is\n     *                  supported, because of the use of the upper bits for the offset.\n     * @param offset - The optional offset, this is an integer which represents what multiple of 360\n     *                 degrees to shift, only useful for flat projections, hence optional.\n     * @param localTangentSpace - Whether the tile geometry is in local tangent space or not.\n     */\n    constructor(\n        readonly dataSource: DataSource,\n        readonly tileKey: TileKey,\n        offset: number = 0,\n        localTangentSpace?: boolean\n    ) {\n        this.geoBox = this.dataSource.getTilingScheme().getGeoBox(this.tileKey);\n        this.updateBoundingBox();\n        this.m_worldCenter.copy(this.boundingBox.position);\n        this.m_localTangentSpace = localTangentSpace ?? false;\n        this.m_textStyleCache = new TileTextStyleCache(this);\n        this.m_offset = offset;\n        this.m_uniqueKey = TileKeyUtils.getKeyForTileKeyAndOffset(this.tileKey, this.offset);\n        if (dataSource.useGeometryLoader) {\n            this.m_tileGeometryLoader = new TileGeometryLoader(this, this.mapView.taskQueue);\n            this.attachGeometryLoadedCallback();\n        }\n    }\n\n    /**\n     * The visibility status of the {@link Tile}. It is actually\n     * visible or planned to become visible.\n     */\n    get isVisible(): boolean {\n        // Tiles are not evaluated as invisible until the second frame they aren't requested.\n        // This happens in order to prevent that, during VisibleTileSet visibility evaluation,\n        // visible tiles that haven't yet been evaluated for the current frame are preemptively\n        // removed from [[DataSourceCache]].\n        // There is cases when a tile was already removed from the MapView, i.e. the PolaCaps\n        // Datasource might get remove on a change of projection, in this case\n        // this.dataSource.mapView will throw an error\n        try {\n            return this.frameNumLastRequested >= this.dataSource.mapView.frameNumber - 1;\n        } catch (error) {\n            logger.debug(error);\n            return false;\n        }\n    }\n\n    /**\n     * Sets the tile visibility status.\n     * @param visible - `True` to mark the tile as visible, `False` otherwise.\n     */\n    set isVisible(visible: boolean) {\n        this.frameNumLastRequested = visible ? this.dataSource.mapView.frameNumber : -1;\n\n        if (!visible && this.m_tileGeometryLoader && !this.m_tileGeometryLoader.isSettled) {\n            this.m_tileGeometryLoader.cancel();\n        }\n    }\n\n    /**\n     * The {@link @here/harp-geoutils#Projection} currently used by the {@link MapView}.\n     */\n    get projection(): Projection {\n        return this.dataSource.projection;\n    }\n\n    /**\n     * The {@link MapView} this `Tile` belongs to.\n     */\n    get mapView(): MapView {\n        return this.dataSource.mapView;\n    }\n\n    /**\n     * Whether the data of this tile is in local tangent space or not.\n     *\n     * @remarks\n     * If the data is in local tangent space (i.e. up vector is (0,0,1) for high zoomlevels) then\n     * {@link MapView} will rotate the objects before rendering using the rotation matrix of the\n     * oriented [[boundingBox]].\n     */\n    get localTangentSpace(): boolean {\n        return this.m_localTangentSpace;\n    }\n\n    /*\n     * The size of this Tile in system memory.\n     */\n    get memoryUsage(): number {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo!.heapSize;\n    }\n\n    /**\n     * The center of this `Tile` in world coordinates.\n     */\n    get center(): THREE.Vector3 {\n        return this.m_worldCenter;\n    }\n\n    /**\n     * Gets the key to uniquely represent this tile (based on\n     * the {@link tileKey} and {@link offset}).\n     *\n     * @remarks\n     * This key is only unique within the given {@link DataSource},\n     * to get a key which is unique across\n     * {@link DataSource}s see [[DataSourceCache.getKeyForTile]].\n     */\n    get uniqueKey(): number {\n        return this.m_uniqueKey;\n    }\n\n    /**\n     * The optional offset, this is an integer which represents what multiple of 360 degrees to\n     * shift, only useful for flat projections, hence optional.\n     */\n    get offset(): number {\n        return this.m_offset;\n    }\n\n    /**\n     * The optional offset, this is an integer which represents what multiple of 360 degrees to\n     * shift, only useful for flat projections, hence optional.\n     * @param offset - Which multiple of 360 degrees to apply to the {@link Tile}.\n     */\n    set offset(offset: number) {\n        if (this.m_offset !== offset) {\n            this.m_uniqueKey = TileKeyUtils.getKeyForTileKeyAndOffset(this.tileKey, offset);\n        }\n        this.m_offset = offset;\n    }\n\n    /**\n     * Compute {@link TileResourceInfo} of this `Tile`.\n     *\n     * @remarks\n     * May be using a cached value. The method\n     * `invalidateResourceInfo` can be called beforehand to force a recalculation.\n     *\n     * @returns `TileResourceInfo` for this `Tile`.\n     */\n    getResourceInfo(): TileResourceInfo {\n        if (this.m_resourceInfo === undefined) {\n            this.computeResourceInfo();\n        }\n        return this.m_resourceInfo!;\n    }\n\n    /**\n     * Force invalidation of the cached {@link TileResourceInfo}.\n     *\n     * @remarks\n     * Useful after the `Tile` has been\n     * modified.\n     */\n    invalidateResourceInfo(): void {\n        this.m_resourceInfo = undefined;\n    }\n\n    /**\n     * Add ownership of a texture to this tile.\n     *\n     * @remarks\n     * The texture will be disposed if the `Tile` is disposed.\n     * @param texture - Texture to be owned by the `Tile`\n     */\n    addOwnedTexture(texture: THREE.Texture): void {\n        this.m_ownedTextures.add(texture);\n    }\n\n    /**\n     * @internal\n     * @deprecated User text elements are deprecated.\n     *\n     * Gets the list of developer-defined {@link TextElement} in this `Tile`.\n     *\n     * @remarks\n     * This list is always rendered first.\n     */\n    get userTextElements(): TextElementGroup {\n        let group = this.m_textElementGroups.groups.get(TextElement.HIGHEST_PRIORITY);\n        if (group === undefined) {\n            group = new TextElementGroup(TextElement.HIGHEST_PRIORITY);\n            this.m_textElementGroups.groups.set(group.priority, group);\n        }\n        return group;\n    }\n\n    /**\n     * Adds a developer-defined {@link TextElement} to this `Tile`.\n     *\n     * @remarks\n     * The {@link TextElement} is always\n     * visible, if it's in the map's currently visible area.\n     *\n     * @deprecated use [[addTextElement]].\n     *\n     * @param textElement - The Text element to add.\n     */\n    addUserTextElement(textElement: TextElement) {\n        textElement.priority = TextElement.HIGHEST_PRIORITY;\n        this.addTextElement(textElement);\n    }\n\n    /**\n     * Removes a developer-defined {@link TextElement} from this `Tile`.\n     *\n     * @deprecated use `removeTextElement`.\n     *\n     * @param textElement - A developer-defined TextElement to remove.\n     * @returns `true` if the element has been removed successfully; `false` otherwise.\n     */\n    removeUserTextElement(textElement: TextElement): boolean {\n        textElement.priority = TextElement.HIGHEST_PRIORITY;\n        return this.removeTextElement(textElement);\n    }\n\n    /**\n     * Adds a {@link TextElement} to this `Tile`, which is added to the visible set of\n     * {@link TextElement}s based on the capacity and visibility.\n     *\n     * @remarks\n     * The {@link TextElement}'s priority controls if or when it becomes visible.\n     *\n     * To ensure that a TextElement is visible, use a high value for its priority, such as\n     * `TextElement.HIGHEST_PRIORITY`. Since the number of visible TextElements is limited by the\n     * screen space, not all TextElements are visible at all times.\n     *\n     * @param textElement - The TextElement to add.\n     */\n    addTextElement(textElement: TextElement) {\n        this.textElementGroups.add(textElement);\n\n        if (this.m_textElementsChanged === false) {\n            // HARP-8733: Clone all groups so that they are handled as new element groups\n            // by TextElementsRenderer and it doesn't try to reuse the same state stored\n            // for the old groups.\n            this.m_textElementGroups = this.textElementGroups.clone();\n        }\n        this.textElementsChanged = true;\n    }\n\n    /**\n     * Adds a `PathBlockingElement` to this `Tile`.\n     *\n     * @remarks\n     * This path has the highest priority and blocks\n     * all other labels. There maybe in future a use case to give it a priority, but as that isn't\n     * yet required, it is left to be implemented later if required.\n     * @param blockingElement - Element which should block all other labels.\n     */\n    addBlockingElement(blockingElement: PathBlockingElement) {\n        this.m_pathBlockingElements.push(blockingElement);\n    }\n\n    /**\n     * Removes a {@link TextElement} from this `Tile`.\n     *\n     * @remarks\n     * For the element to be removed successfully, the\n     * priority of the {@link TextElement} has to be equal to its priority when it was added.\n     *\n     * @param textElement - The TextElement to remove.\n     * @returns `true` if the TextElement has been removed successfully; `false` otherwise.\n     */\n    removeTextElement(textElement: TextElement): boolean {\n        const groups = this.textElementGroups;\n        if (!groups.remove(textElement)) {\n            return false;\n        }\n        if (this.m_textElementsChanged === false) {\n            // HARP-8733: Clone all groups so that they are handled as new element groups\n            // by TextElementsRenderer and it doesn't try to reuse the same state stored\n            // for the old groups.\n            this.m_textElementGroups = groups.clone();\n        }\n        this.textElementsChanged = true;\n        return true;\n    }\n\n    /**\n     * @internal\n     *\n     * Gets the current `GroupedPriorityList` which\n     * contains a list of all {@link TextElement}s to be\n     * selected and placed for rendering.\n     */\n    get textElementGroups(): TextElementGroupPriorityList {\n        return this.m_textElementGroups;\n    }\n\n    /**\n     * Gets the current modification state for the list\n     * of {@link TextElement}s in the `Tile`.\n     *\n     * @remarks\n     * If the value is `true` the `TextElement` is placed for\n     * rendering during the next frame.\n     */\n    get textElementsChanged(): boolean {\n        return this.m_textElementsChanged ?? false;\n    }\n\n    set textElementsChanged(changed: boolean) {\n        this.m_textElementsChanged = changed;\n    }\n\n    /**\n     * Returns true if the `Tile` has any text elements to render.\n     */\n    hasTextElements(): boolean {\n        return this.m_textElementGroups.count() > 0;\n    }\n\n    /**\n     * Get the current blocking elements.\n     */\n    get blockingElements(): PathBlockingElement[] {\n        return this.m_pathBlockingElements;\n    }\n\n    /**\n     * Called before {@link MapView} starts rendering this `Tile`.\n     *\n     * @remarks\n     * @param zoomLevel - The current zoom level.\n     * @returns Returns `true` if this `Tile` should be rendered. Influenced directly by the\n     *      `skipRendering` property unless specifically overriden in deriving classes.\n     */\n    willRender(_zoomLevel: number): boolean {\n        return !this.skipRendering && !this.delayRendering;\n    }\n\n    /**\n     * Called after {@link MapView} has rendered this `Tile`.\n     */\n    didRender(): void {\n        // to be overridden by subclasses\n    }\n\n    /**\n     * Estimated visible area of tile used for sorting the priorities during loading.\n     */\n    get visibleArea(): number {\n        return this.m_visibleArea;\n    }\n\n    set visibleArea(area: number) {\n        this.m_visibleArea = area;\n        if (this.tileLoader !== undefined) {\n            this.tileLoader.priority = area;\n        }\n    }\n\n    /**\n     * @internal\n     * Gets the tile's ground elevation range in meters.\n     */\n    get elevationRange(): ElevationRange {\n        return this.m_elevationRange;\n    }\n\n    /**\n     * @internal\n     * Sets the tile's ground elevation range in meters.\n     *\n     * @param elevationRange - The elevation range.\n     */\n    set elevationRange(elevationRange: ElevationRange) {\n        if (\n            elevationRange.minElevation === this.m_elevationRange.minElevation &&\n            elevationRange.maxElevation === this.m_elevationRange.maxElevation &&\n            elevationRange.calculationStatus === this.m_elevationRange.calculationStatus\n        ) {\n            return;\n        }\n\n        this.m_elevationRange.minElevation = elevationRange.minElevation;\n        this.m_elevationRange.maxElevation = elevationRange.maxElevation;\n        this.m_elevationRange.calculationStatus = elevationRange.calculationStatus;\n        this.elevateGeoBox();\n\n        // Only update bounding box if tile has already been decoded and a maximum/minimum geometry\n        // height is provided by the data source.\n        if (this.m_maxGeometryHeight !== undefined || this.m_minGeometryHeight !== undefined) {\n            assert(this.decodedTile?.boundingBox === undefined);\n            this.updateBoundingBox();\n        }\n    }\n\n    /**\n     * Gets the decoded tile; it is removed after geometry handling.\n     */\n    get decodedTile(): DecodedTile | undefined {\n        return this.m_decodedTile;\n    }\n\n    /**\n     * Applies the decoded tile to the tile.\n     *\n     * @remarks\n     * If the geometry is empty, then the tile's forceHasGeometry flag is set.\n     * Map is updated.\n     * @param decodedTile - The decoded tile to set.\n     */\n    set decodedTile(decodedTile: DecodedTile | undefined) {\n        this.m_decodedTile = decodedTile;\n        this.invalidateResourceInfo();\n\n        if (decodedTile === undefined) {\n            return;\n        }\n\n        if (decodedTile.geometries.length === 0) {\n            this.forceHasGeometry(true);\n        }\n\n        // If the decoder provides a more accurate bounding box than the one we computed from\n        // the flat geo box we take it instead. Otherwise, if an elevation range was set, elevate\n        // bounding box to match the elevated geometry.\n        this.m_maxGeometryHeight = decodedTile.boundingBox\n            ? undefined\n            : decodedTile.maxGeometryHeight ?? 0;\n        this.m_minGeometryHeight = decodedTile.boundingBox\n            ? undefined\n            : decodedTile.minGeometryHeight ?? 0;\n        this.elevateGeoBox();\n        this.updateBoundingBox(decodedTile.boundingBox);\n\n        const stats = PerformanceStatistics.instance;\n        if (stats.enabled && decodedTile.decodeTime !== undefined) {\n            stats.currentFrame.addValue(\"decode.decodingTime\", decodedTile.decodeTime);\n            stats.currentFrame.addValue(\"decode.decodedTiles\", 1);\n        }\n\n        if (decodedTile.copyrightHolderIds !== undefined) {\n            this.copyrightInfo = decodedTile.copyrightHolderIds.map(id => ({ id }));\n        }\n\n        this.dataSource.requestUpdate();\n    }\n\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free the geometry of a `Tile` object.\n     *\n     * @param object - The object that references the geometry.\n     * @returns `true` if the geometry can be disposed.\n     */\n    shouldDisposeObjectGeometry(object: TileObject): boolean {\n        return true;\n    }\n\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a `Tile` object's material.\n     *\n     * @param object - The object referencing the geometry.\n     * @returns `true` if the material can be disposed.\n     */\n    shouldDisposeObjectMaterial(object: TileObject): boolean {\n        return true;\n    }\n\n    /**\n     * Called when the default implementation of `dispose()` needs\n     * to free a Texture that is part of a `Tile` object's material.\n     *\n     * @param texture - The texture about to be disposed.\n     * @returns `true` if the texture can be disposed.\n     */\n    shouldDisposeTexture(texture: THREE.Texture): boolean {\n        return this.m_ownedTextures.has(texture);\n    }\n\n    /**\n     * Returns `true` if this `Tile` has been disposed.\n     */\n    get disposed(): boolean {\n        return this.m_disposed;\n    }\n\n    /**\n     * `True` if all geometry of the `Tile` has been loaded.\n     */\n    get allGeometryLoaded(): boolean {\n        return this.m_tileGeometryLoader?.isFinished ?? this.hasGeometry;\n    }\n\n    /**\n     * MapView checks if this `Tile` is ready to be rendered while culling.\n     *\n     * By default, MapView checks if the [[objects]] list is not empty. However, you can override\n     * this check by manually setting this property.\n     */\n    get hasGeometry(): boolean {\n        if (this.m_forceHasGeometry === undefined) {\n            return this.objects.length !== 0;\n        } else {\n            return this.m_forceHasGeometry;\n        }\n    }\n\n    /**\n     * Overrides the default value for [[hasGeometry]] if value is not `undefined`.\n     *\n     * @param value - A new value for the [[hasGeometry]] flag.\n     */\n    forceHasGeometry(value: boolean | undefined) {\n        this.m_forceHasGeometry = value;\n    }\n\n    /**\n     * Reset the visibility counter. This will force the visibility check to be rerun on all objects\n     * in this `Tile`.\n     */\n    resetVisibilityCounter(): void {\n        this.visibilityCounter = -1;\n    }\n\n    /**\n     * Gets the {@link ITileLoader} that manages this tile.\n     */\n    get tileLoader(): ITileLoader | undefined {\n        return this.m_tileLoader;\n    }\n\n    /**\n     * Sets the {@link ITileLoader} to manage this tile.\n     *\n     * @param tileLoader - A {@link ITileLoader} instance to manage\n     *                     the loading process for this tile.\n     */\n    set tileLoader(tileLoader: ITileLoader | undefined) {\n        this.m_tileLoader = tileLoader;\n    }\n\n    /**\n     * Loads this `Tile` geometry.\n     *\n     * @returns Promise which can be used to wait for the loading to be finished.\n     */\n    async load(): Promise<void> {\n        const tileLoader = this.tileLoader;\n        if (tileLoader === undefined) {\n            return await Promise.resolve();\n        }\n\n        if (this.m_tileGeometryLoader) {\n            const wasSettled = this.m_tileGeometryLoader.isSettled;\n            this.m_tileGeometryLoader.reset();\n            if (wasSettled) {\n                this.attachGeometryLoadedCallback();\n            }\n        }\n\n        return await tileLoader\n            .loadAndDecode()\n            .then(tileLoaderState => {\n                assert(tileLoaderState === TileLoaderState.Ready);\n                const decodedTile = tileLoader.decodedTile;\n                this.decodedTile = decodedTile;\n                decodedTile?.dependencies?.forEach(mortonCode => {\n                    this.dependencies.push(TileKey.fromMortonCode(mortonCode));\n                });\n            })\n            .catch(tileLoaderState => {\n                if (tileLoaderState === TileLoaderState.Failed) {\n                    this.dispose();\n                } else if (tileLoaderState !== TileLoaderState.Canceled) {\n                    logger.error(\"Unknown error\" + tileLoaderState);\n                }\n            });\n    }\n\n    /**\n     * Text style cache for this tile.\n     * @hidden\n     */\n    get textStyleCache(): TileTextStyleCache {\n        return this.m_textStyleCache;\n    }\n\n    /**\n     * Frees the rendering resources allocated by this `Tile`.\n     *\n     * @remarks\n     * The default implementation of this method frees the geometries and the materials for all the\n     * reachable objects.\n     * Textures are freed if they are owned by this `Tile` (i.e. if they where created by this\n     * `Tile`or if the ownership was explicitely set to this `Tile` by [[addOwnedTexture]]).\n     */\n    clear() {\n        const disposeMaterial = (material: THREE.Material) => {\n            Object.getOwnPropertyNames(material).forEach((property: string) => {\n                const materialProperty = (material as any)[property];\n                if (materialProperty !== undefined && materialProperty instanceof THREE.Texture) {\n                    const texture = materialProperty;\n                    if (this.shouldDisposeTexture(texture)) {\n                        texture.dispose();\n                    }\n                }\n            });\n            material.dispose();\n        };\n\n        const disposeObject = (object: TileObject & DisposableObject) => {\n            if (this.shouldDisposeObjectGeometry(object)) {\n                if (object.geometry !== undefined) {\n                    object.geometry.dispose();\n                }\n\n                if (object.geometries !== undefined) {\n                    for (const geometry of object.geometries) {\n                        geometry.dispose();\n                    }\n                }\n            }\n\n            if (object.material !== undefined && this.shouldDisposeObjectMaterial(object)) {\n                if (object.material instanceof Array) {\n                    object.material.forEach((material: THREE.Material | undefined) => {\n                        if (material !== undefined) {\n                            disposeMaterial(material);\n                        }\n                    });\n                } else {\n                    disposeMaterial(object.material);\n                }\n            }\n        };\n\n        this.objects.forEach((rootObject: TileObject & DisposableObject) => {\n            rootObject.traverse((object: TileObject & DisposableObject) => {\n                disposeObject(object);\n            });\n\n            disposeObject(rootObject);\n        });\n        this.objects.length = 0;\n\n        if (this.preparedTextPaths) {\n            this.preparedTextPaths = [];\n        }\n\n        this.m_textStyleCache.clear();\n        this.clearTextElements();\n        this.invalidateResourceInfo();\n    }\n\n    /**\n     * Removes all {@link TextElement} from the tile.\n     */\n    clearTextElements() {\n        if (!this.hasTextElements()) {\n            return;\n        }\n        this.textElementsChanged = true;\n        this.m_pathBlockingElements.splice(0);\n        this.textElementGroups.forEach((element: TextElement) => {\n            element.dispose();\n        });\n        this.textElementGroups.clear();\n    }\n\n    /**\n     * Adds a callback that will be called whenever the tile is disposed.\n     *\n     * @remarks\n     * Multiple callbacks may be added.\n     * @internal\n     * @param callback - The callback to be called when the tile is disposed.\n     */\n    addDisposeCallback(callback: TileCallback) {\n        this.m_disposeCallback = chainCallbacks(this.m_disposeCallback, callback);\n    }\n\n    /**\n     * Disposes this `Tile`, freeing all geometries and materials for the reachable objects.\n     */\n    dispose() {\n        if (this.m_disposed) {\n            return;\n        }\n        if (this.m_tileLoader) {\n            this.m_tileLoader.cancel();\n            this.m_tileLoader = undefined;\n        }\n        this.clear();\n        // Ensure that tile is removable from tile cache.\n        this.frameNumLastRequested = 0;\n        this.m_disposed = true;\n        this.m_tileGeometryLoader?.dispose();\n\n        if (this.m_disposeCallback) {\n            this.m_disposeCallback(this);\n        }\n    }\n\n    /**\n     * Computes the offset in the x world coordinates corresponding to this tile, based on\n     * its {@link offset}.\n     *\n     * @returns The x offset.\n     */\n    computeWorldOffsetX(): number {\n        return this.projection.worldExtent(0, 0).max.x * this.offset;\n    }\n\n    /**\n     * Update tile for current map view zoom level\n     * @param zoomLevel - Zoom level of the map view\n     * @internal\n     */\n    update(zoomLevel: number): void {\n        for (const object of this.objects) {\n            if (object instanceof LodMesh) {\n                object.setLevelOfDetail(zoomLevel - this.tileKey.level);\n            }\n        }\n    }\n\n    /**\n     * Gets the tile's bounding box.\n     */\n    get boundingBox(): OrientedBox3 {\n        return this.m_boundingBox;\n    }\n\n    /**\n     * Start with or continue with loading geometry for tiles requiring this step. Called\n     * repeatedly until loading is finished.\n     * @param priority - Priority assigned to asynchronous tasks doing the geometry update.\n     * @param enabledKinds - {@link GeometryKind}s that will be created.\n     * @param disabledKinds - {@link GeometryKind}s that will not be created.\n     * @return `true` if tile uses a geometry loader, `false` otherwise.\n     * @internal\n     */\n    updateGeometry(\n        priority?: number,\n        enabledKinds?: GeometryKindSet,\n        disabledKinds?: GeometryKindSet\n    ): boolean {\n        if (!this.m_tileGeometryLoader) {\n            return false;\n        }\n\n        if (this.m_tileGeometryLoader.isSettled) {\n            return true;\n        }\n\n        if (this.dataSource.isDetached()) {\n            this.m_tileGeometryLoader.cancel();\n            return true;\n        }\n\n        if (this.tileLoader) {\n            if (!this.tileLoader.isFinished) {\n                return true;\n            } else if (!this.decodedTile) {\n                // Finish loading if tile has no data.\n                this.m_tileGeometryLoader.finish();\n                return true;\n            }\n        }\n\n        if (priority !== undefined) {\n            this.m_tileGeometryLoader.priority = priority;\n        }\n        this.m_tileGeometryLoader.update(enabledKinds, disabledKinds);\n        return true;\n    }\n\n    /**\n     * Gets a set of the {@link GeometryKind}s that were loaded (if any).\n     * @internal\n     */\n    get loadedGeometryKinds(): GeometryKindSet | undefined {\n        return this.m_tileGeometryLoader?.availableGeometryKinds;\n    }\n\n    /**\n     * Called when {@link TileGeometryLoader} is finished.\n     *\n     * @remarks\n     * It may be used to add content to the `Tile`.\n     * The {@link @here/harp-datasource-protocol#DecodedTile} is still available.\n     */\n    protected loadingFinished() {\n        // To be used in subclasses.\n    }\n\n    private attachGeometryLoadedCallback() {\n        assert(this.m_tileGeometryLoader !== undefined);\n        this.m_tileGeometryLoader!.waitFinished()\n            .then(() => {\n                this.loadingFinished();\n                this.removeDecodedTile();\n            })\n            .catch(() => {\n                if (this.disposed) {\n                    return;\n                }\n                // Loader was canceled, dispose tile.\n                if (!this.dataSource.isDetached()) {\n                    this.mapView.visibleTileSet.disposeTile(this);\n                }\n            });\n    }\n\n    /**\n     * Remove the decodedTile when no longer needed.\n     */\n    private removeDecodedTile() {\n        this.m_decodedTile = undefined;\n        this.invalidateResourceInfo();\n    }\n\n    /**\n     * Updates the tile's world bounding box.\n     * @param newBoundingBox - The new bounding box to set. If undefined, the bounding box will be\n     *                         computed by projecting the tile's geoBox.\n     */\n    private updateBoundingBox(newBoundingBox?: OrientedBox3) {\n        if (newBoundingBox) {\n            this.m_boundingBox.copy(newBoundingBox);\n            this.m_worldCenter.copy(this.boundingBox.position);\n        } else {\n            this.projection.projectBox(this.geoBox, this.boundingBox);\n        }\n    }\n\n    /**\n     * Elevates the tile's geo box using the elevation range and maximum geometry height.\n     */\n    private elevateGeoBox() {\n        this.geoBox.southWest.altitude =\n            this.m_elevationRange.minElevation + (this.m_minGeometryHeight ?? 0);\n        this.geoBox.northEast.altitude =\n            this.m_elevationRange.maxElevation + (this.m_maxGeometryHeight ?? 0);\n    }\n\n    private computeResourceInfo(): void {\n        let heapSize = 0;\n        let num3dObjects = 0;\n        let numTextElements = 0;\n\n        const aggregatedObjSize = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n\n        // Keep a map of the uuids of the larger objects, like Geometries, Materials and Attributes.\n        // They should be counted only once even if they are shared.\n        const visitedObjects: Map<string, boolean> = new Map();\n\n        for (const object of this.objects) {\n            if (object.visible) {\n                num3dObjects++;\n            }\n            Object3DUtils.estimateSize(object, aggregatedObjSize, visitedObjects);\n        }\n\n        for (const group of this.textElementGroups.groups) {\n            numTextElements += group[1].elements.length;\n        }\n        // 216 was the shallow size of a single TextElement last time it has been checked, 312 bytes\n        // was the minimum retained size of a TextElement that was not being rendered. If a\n        // TextElement is actually rendered, the size may be _much_ bigger.\n        heapSize += numTextElements * 312;\n\n        if (this.m_decodedTile !== undefined && this.m_decodedTile.tileInfo !== undefined) {\n            aggregatedObjSize.heapSize += this.m_decodedTile.tileInfo.numBytes;\n        }\n\n        this.m_resourceInfo = {\n            heapSize: aggregatedObjSize.heapSize + heapSize,\n            gpuSize: aggregatedObjSize.gpuSize,\n            num3dObjects,\n            numTextElements,\n            numUserTextElements: 0\n        };\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    Expr,\n    getFeatureId,\n    getPropertyValue,\n    IndexedTechnique,\n    MapEnv,\n    Pickability\n} from \"@here/harp-datasource-protocol\";\n\nimport { BackgroundDataSource } from \"./BackgroundDataSource\";\nimport { SolidLineMesh } from \"./geometry/SolidLineMesh\";\nimport { MapObjectAdapter } from \"./MapObjectAdapter\";\nimport { Tile, TileFeatureData, TileObject } from \"./Tile\";\n\nconst DEFAULT_STENCIL_VALUE = 1;\n\n/*\n * Interface to represent the items of three.js render lists.\n */\ninterface RenderItem {\n    groupOrder: number;\n    renderOrder: number;\n    program: { id: number };\n    material: { id: number };\n    z: number;\n    id: number;\n    object: THREE.Object3D;\n}\n\nexport class TileObjectRenderer {\n    private readonly m_renderOrderStencilValues = new Map<number, number>();\n    // Valid values start at 1, because the screen is cleared to zero\n    private m_stencilValue: number = DEFAULT_STENCIL_VALUE;\n\n    constructor(private readonly m_env: MapEnv, private readonly m_renderer: THREE.WebGLRenderer) {}\n\n    render(\n        tile: Tile,\n        storageLevel: number,\n        zoomLevel: number,\n        cameraPosition: THREE.Vector3,\n        rootNode: THREE.Object3D\n    ) {\n        const worldOffsetX = tile.computeWorldOffsetX();\n        if (tile.willRender(storageLevel)) {\n            for (const object of tile.objects) {\n                const mapObjectAdapter = MapObjectAdapter.get(object);\n                if (\n                    !this.processTileObject(tile, storageLevel, zoomLevel, object, mapObjectAdapter)\n                ) {\n                    continue;\n                }\n\n                this.updateStencilRef(object);\n\n                object.position.copy(tile.center);\n                if (object.displacement !== undefined) {\n                    object.position.add(object.displacement);\n                }\n                object.position.x += worldOffsetX;\n                object.position.sub(cameraPosition);\n                if (tile.localTangentSpace) {\n                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());\n                }\n                object.frustumCulled = false;\n\n                rootNode.add(object);\n            }\n            tile.didRender();\n        }\n    }\n\n    prepareRender() {\n        this.m_stencilValue = DEFAULT_STENCIL_VALUE;\n        this.m_renderOrderStencilValues.clear();\n    }\n\n    /**\n     * Prepares the sorting of tile objects.\n     */\n    setupRenderer() {\n        /**\n         * Custom sorting function to avoid non-deterministic IBCT testcases. It's basically a copy\n         * of the three.js internal sorting, see:\n         * https://github.com/mrdoob/three.js/blob/r118/src/renderers/webgl/WebGLRenderLists.js#L5\n         * but additionally checking tile-id before checking object.id, material.id and program.id\n         * b/c these ids are generated by incrementing a counter. This means if for two test\n         * executions the tiles are processed in a different order the ids hence draw call order\n         * will also be different.\n         */\n        const stableSort = (a: RenderItem, b: RenderItem): number => {\n            if (a.groupOrder !== b.groupOrder) {\n                return a.groupOrder - b.groupOrder;\n            } else if (a.renderOrder !== b.renderOrder) {\n                return a.renderOrder - b.renderOrder;\n            } else if (\n                a.object.userData.tileKey &&\n                b.object.userData.tileKey &&\n                a.object.userData.tileKey.mortonCode() !== b.object.userData.tileKey.mortonCode()\n            ) {\n                return (\n                    a.object.userData.tileKey.mortonCode() - b.object.userData.tileKey.mortonCode()\n                );\n            } else if (a.program !== b.program) {\n                return a.program.id - b.program.id;\n            } else if (a.material.id !== b.material.id) {\n                return a.material.id - b.material.id;\n            } else if (a.z !== b.z) {\n                return a.z - b.z;\n            } else {\n                return a.id - b.id;\n            }\n        };\n\n        // Custom sorting function which first sorts by the data source order, then by the level,\n        // then by the function `stableSort` above.\n        const painterSortStable = (a: RenderItem, b: RenderItem): number => {\n            const mapObjectAdapterA = MapObjectAdapter.get(a.object);\n            const mapObjectAdapterB = MapObjectAdapter.get(b.object);\n\n            const dataSourceOrder = mapObjectAdapterA?.dataSource?.dataSourceOrder;\n            const otherDataSourceOrder = mapObjectAdapterB?.dataSource?.dataSourceOrder;\n            if (\n                // We need to check against undefined because if either is 0, it will evaluate false\n                dataSourceOrder !== undefined &&\n                otherDataSourceOrder !== undefined &&\n                dataSourceOrder !== otherDataSourceOrder\n            ) {\n                return dataSourceOrder - otherDataSourceOrder;\n            }\n            // Background data source must be sorted by rendorOrder and not level, otherwise\n            // fallback tiles are useless, because they will be covered by this datasource\n            if (\n                a.renderOrder === BackgroundDataSource.GROUND_RENDER_ORDER ||\n                b.renderOrder === BackgroundDataSource.GROUND_RENDER_ORDER\n            ) {\n                return stableSort(a, b);\n            }\n            if (mapObjectAdapterA?.level !== undefined && mapObjectAdapterB?.level !== undefined) {\n                // Extruded buildings may interfere with landmarks, so we need to sort by\n                // renderOrder, see LandmarkDataSource.computeRenderOrder\n                const eitherIsBuilding =\n                    mapObjectAdapterA.kind?.find(s => s === \"building\") !== undefined ||\n                    mapObjectAdapterB.kind?.find(s => s === \"building\") !== undefined;\n                const sameLevel = mapObjectAdapterA.level === mapObjectAdapterB.level;\n                if (sameLevel || eitherIsBuilding) {\n                    return stableSort(a, b);\n                }\n                return mapObjectAdapterA.level - mapObjectAdapterB.level;\n            }\n            return stableSort(a, b);\n        };\n\n        // Temporary workaround due to incorrect comparator type definition:\n        // https://github.com/three-types/three-ts-types/issues/41\n        this.m_renderer.setOpaqueSort(painterSortStable);\n    }\n\n    private updateStencilRef(object: TileObject) {\n        // TODO: acquire a new style value of if transparent\n        if (object.renderOrder !== undefined && object instanceof SolidLineMesh) {\n            const material = object.material;\n            if (Array.isArray(material)) {\n                material.forEach(\n                    mat => (mat.stencilRef = this.getStencilValue(object.renderOrder))\n                );\n            } else {\n                material.stencilRef = this.getStencilValue(object.renderOrder);\n            }\n        }\n    }\n\n    private allocateStencilValue(renderOrder: number) {\n        const stencilValue = this.m_stencilValue++;\n        this.m_renderOrderStencilValues.set(renderOrder, stencilValue);\n        return stencilValue;\n    }\n\n    private getStencilValue(renderOrder: number) {\n        return (\n            this.m_renderOrderStencilValues.get(renderOrder) ??\n            this.allocateStencilValue(renderOrder)\n        );\n    }\n\n    /**\n     * Process dynamic updates of [[TileObject]]'s style.\n     *\n     * @returns `true` if object shall be used in scene, `false` otherwise\n     */\n    private processTileObject(\n        tile: Tile,\n        storageLevel: number,\n        zoomLevel: number,\n        object: TileObject,\n        mapObjectAdapter?: MapObjectAdapter\n    ) {\n        if (!object.visible) {\n            return false;\n        }\n        if (!this.processTileObjectFeatures(tile, storageLevel, zoomLevel, object)) {\n            return false;\n        }\n\n        if (mapObjectAdapter) {\n            mapObjectAdapter.ensureUpdated(tile.mapView);\n            if (\n                !mapObjectAdapter.isVisible() &&\n                !(mapObjectAdapter.pickability === Pickability.all)\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Process the features owned by the given `TileObject`.\n     *\n     * @param tile - The {@link Tile} owning the `TileObject`'s features.\n     * @param storageLevel - The storage level of the `Tile` containing the object,\n     * @param zoomLevel - The current zoom level of `MapView`.\n     * @param object - The `TileObject` to process.\n     * @returns `false` if the given `TileObject` should not be added to the scene.\n     */\n    private processTileObjectFeatures(\n        tile: Tile,\n        storageLevel: number,\n        zoomLevel: number,\n        object: TileObject\n    ): boolean {\n        const technique: IndexedTechnique | undefined = object.userData.technique;\n\n        const minZoomLevel = getPropertyValue(technique?.minZoomLevel, this.m_env);\n        const maxZoomLevel = getPropertyValue(technique?.maxZoomLevel, this.m_env);\n\n        if (typeof minZoomLevel === \"number\" && zoomLevel < minZoomLevel) {\n            return false;\n        }\n\n        if (typeof maxZoomLevel === \"number\" && zoomLevel >= maxZoomLevel) {\n            return false;\n        }\n\n        if (technique?.enabled === undefined) {\n            // Nothing to do, there's no technique.\n            return true;\n        }\n\n        const feature: TileFeatureData = object.userData.feature;\n\n        if (!feature || !Expr.isExpr(technique.enabled)) {\n            return Boolean(getPropertyValue(technique.enabled, this.m_env));\n        }\n\n        const { starts, objInfos } = feature;\n\n        if (!Array.isArray(objInfos) || !Array.isArray(starts)) {\n            // Nothing to do, the object is missing feature ids and their position\n            // in the index buffer.\n            return true;\n        }\n\n        const geometry: THREE.BufferGeometry | undefined = (object as any).geometry;\n\n        if (!geometry || !geometry.isBufferGeometry) {\n            // Nothing to do, the geometry is not a [[THREE.BufferGeometry]]\n            // and we can't generate groups.\n            return true;\n        }\n\n        // ExtrudeBufferGeometry for example doesn't have an index, hence we get the final index\n        // from the number of vertices.\n        const finalIndex = geometry.getIndex()?.count ?? geometry.attributes.position.count;\n\n        // clear the groups.\n        geometry.clearGroups();\n\n        // The offset in the index buffer of the end of the last\n        // pushed group.\n        let endOfLastGroup: number | undefined;\n\n        objInfos.forEach((properties, featureIndex) => {\n            // the id of the current feature.\n            const featureId = getFeatureId(properties);\n\n            let enabled = true;\n\n            if (Expr.isExpr(technique.enabled)) {\n                // the state of current feature.\n                const featureState = tile.dataSource.getFeatureState(featureId);\n\n                // create a new {@link @here/harp-datasource-protocol#Env} that can be used\n                // to evaluate expressions that access the feature state.\n                const $state = featureState ? new MapEnv(featureState) : null;\n\n                const parentEnv =\n                    typeof properties === \"object\"\n                        ? new MapEnv(properties, this.m_env)\n                        : this.m_env;\n\n                const env = new MapEnv({ $state }, parentEnv);\n\n                enabled = Boolean(getPropertyValue(technique.enabled, env));\n            }\n\n            if (!enabled) {\n                // skip this feature, it was disabled.\n                return;\n            }\n\n            // HARP-12247, geometry with no featureStarts would set start to `undefined`, in this\n            // case, `endOfLastGroup` is also undefined (first execution in this loop), so it would\n            // try to change the count of a group which hasn't yet been added, `addGroup` wasn't yet\n            // called, hence we use the `??` operator and fall back to 0. Because featureStarts are\n            // optional, we need to have a fallback.\n            const start = starts[featureIndex] ?? 0;\n            const end = starts[featureIndex + 1] ?? finalIndex;\n            const count = end - start;\n\n            if (start === endOfLastGroup) {\n                // extend the last group\n                geometry.groups[geometry.groups.length - 1].count += count;\n            } else {\n                geometry.addGroup(start, count);\n            }\n\n            endOfLastGroup = start + count;\n        });\n\n        return geometry.groups.length > 0;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    GeoBox,\n    GeoCoordinates,\n    GeoCoordinatesLike,\n    MathUtils,\n    OrientedBox3,\n    Projection,\n    ProjectionType,\n    sphereProjection,\n    TileKeyUtils,\n    Vector2Like,\n    Vector3Like\n} from \"@here/harp-geoutils\";\nimport { GeoCoordLike } from \"@here/harp-geoutils/lib/coordinates/GeoCoordLike\";\nimport { EarthConstants } from \"@here/harp-geoutils/lib/projection/EarthConstants\";\nimport { assert, DOMUtils, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { CameraUtils } from \"./CameraUtils\";\nimport { ElevationProvider } from \"./ElevationProvider\";\nimport { Object3DUtils } from \"./geometry/Object3DUtils\";\nimport { MapView } from \"./MapView\";\n\nconst logger = LoggerManager.instance.create(\"MapViewUtils\");\n\n/**\n * Zoom level to request terrain tiles for getting the height of the camera above terrain.\n */\nconst TERRAIN_ZOOM_LEVEL = 4;\n\n// Caching those for performance reasons.\nconst groundNormalPlanarProj = new THREE.Vector3(0, 0, 1);\nconst groundPlane = new THREE.Plane(groundNormalPlanarProj.clone());\nconst groundSphere = new THREE.Sphere(undefined, EarthConstants.EQUATORIAL_RADIUS);\nconst rayCaster = new THREE.Raycaster();\nconst epsilon = 1e-5;\n\n/**\n * Cached ThreeJS instances for realtime maths.\n */\nconst space = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst tangentSpace = {\n    x: new THREE.Vector3(),\n    y: new THREE.Vector3(),\n    z: new THREE.Vector3()\n};\nconst cache = {\n    box3: [new THREE.Box3()],\n    obox3: [new OrientedBox3()],\n    quaternions: [new THREE.Quaternion(), new THREE.Quaternion()],\n    vector2: [new THREE.Vector2(), new THREE.Vector2()],\n    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],\n    matrix4: [new THREE.Matrix4(), new THREE.Matrix4()],\n    transforms: [\n        {\n            xAxis: new THREE.Vector3(),\n            yAxis: new THREE.Vector3(),\n            zAxis: new THREE.Vector3(),\n            position: new THREE.Vector3()\n        }\n    ]\n};\n\nconst tmpCamera = new THREE.PerspectiveCamera();\n\n/**\n * Rounds a given zoom level up to the nearest integer value if it's close enough.\n *\n * The zoom level set in {@link MapView} after a zoom level\n * target is given to {@link (MapView.lookAt:WITH_PARAMS)} or\n * {@link @here/harp-map-controls#MapControls} never matches\n * exactly the target due to the precision loss caused by the\n * conversion from zoom level to camera distance (done in\n * {@link (MapView.lookAt:WITH_PARAMS)} and {@link @here/harp-map-controls#MapControls})\n * and from distance back to zoom level (done at every frame on camera update).\n * As a result, given a fixed integer zoom level input, the final zoom level computed at every frame\n * may fall sometimes below the integer value and others above. This causes flickering since each\n * frame will use different tile levels and different style evaluations for object visibility.\n * See HARP-9673 and HARP-8523.\n * @param zoomLevel - Input zoom level\n * @return The ceiling zoom level if input zoom level is close enough, otherwise the unmodified\n * input zoom level.\n */\nfunction snapToCeilingZoomLevel(zoomLevel: number) {\n    const eps = 1e-6;\n    const ceiling = Math.ceil(zoomLevel);\n    return ceiling - zoomLevel < eps ? ceiling : zoomLevel;\n}\n\n/**\n * MapView utilities: View transformations, camera setup, view bounds computation...\n */\nexport namespace MapViewUtils {\n    export const MAX_TILT_DEG = 89;\n    export const MAX_TILT_RAD = MAX_TILT_DEG * THREE.MathUtils.DEG2RAD;\n\n    /**\n     * The anti clockwise rotation of an object along the axes of its tangent space, with itself\n     * as origin.\n     */\n    export interface Attitude {\n        /**\n         * Rotation of the object along its vertical axis.\n         */\n        yaw: number;\n\n        /**\n         * Rotation of the object along its horizontal axis.\n         */\n        pitch: number;\n\n        /**\n         * Rotation of the object along its forward axis.\n         */\n        roll: number;\n    }\n\n    /**\n     * @deprecated\n     */\n    export interface MemoryUsage extends Object3DUtils.MemoryUsage {}\n\n    /**\n     * Zooms and moves the map in such a way that the given target position remains at the same\n     * position after the zoom.\n     *\n     * @param mapView - Instance of MapView.\n     * @param targetNDCx - Target x position in NDC space.\n     * @param targetNDCy - Target y position in NDC space.\n     * @param zoomLevel - The desired zoom level.\n     * @param maxTiltAngle - The maximum tilt angle to comply by, in globe projection, in radian.\n     * @returns `false` if requested zoom cannot be achieved due to the map view's maximum bounds\n     * {@link MapView.geoMaxBounds},`true` otherwise.\n     */\n    export function zoomOnTargetPosition(\n        mapView: MapView,\n        targetNDCx: number,\n        targetNDCy: number,\n        zoomLevel: number,\n        maxTiltAngle: number = MAX_TILT_RAD\n    ): boolean {\n        const { elevationProvider, camera, projection } = mapView;\n\n        // Use for now elevation at camera position. See getTargetAndDistance.\n        const elevation = elevationProvider\n            ? elevationProvider.getHeight(\n                  projection.unprojectPoint(camera.position),\n                  TERRAIN_ZOOM_LEVEL\n              )\n            : undefined;\n\n        // Get current target position in world space before we zoom.\n        const zoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);\n\n        // Compute current camera target, it may not be the one set in MapView, e.g. when this\n        // function is called multiple times between frames.\n        const cameraTarget = MapViewUtils.getTargetAndDistance(\n            projection,\n            camera,\n            elevationProvider\n        ).target;\n        const newCameraDistance = calculateDistanceFromZoomLevel(mapView, zoomLevel);\n\n        if (mapView.geoMaxBounds) {\n            // If map view has maximum bounds set, constrain camera target and distance to ensure\n            // they remain within bounds.\n            const constrained = constrainTargetAndDistanceToViewBounds(\n                cameraTarget,\n                newCameraDistance,\n                mapView\n            );\n            if (constrained.distance !== newCameraDistance) {\n                // Only indicate failure when zooming out. This avoids zoom in cancellations when\n                // camera is already at the maximum distance allowed by the view bounds.\n                return zoomLevel >= mapView.zoomLevel;\n            }\n        }\n        // Set the camera distance according to the given zoom level.\n        camera\n            .getWorldDirection(camera.position)\n            .multiplyScalar(-newCameraDistance)\n            .add(cameraTarget);\n\n        // In sphere, we may have to also orbit the camera around the target, in order to limit the\n        // the tilt to `maxTiltAngle`, as we change this tilt by changing the camera's height above.\n        if (projection.type === ProjectionType.Spherical) {\n            // FIXME: We cannot use mapView.tilt here b/c it does not reflect the latest camera\n            // changes.\n            const tilt = extractCameraTilt(camera, projection);\n            const deltaTilt = tilt - maxTiltAngle;\n            if (deltaTilt > 0) {\n                orbitAroundScreenPoint(mapView, { deltaTilt, maxTiltAngle });\n            }\n        }\n\n        // Get new target position after the zoom\n        const newZoomTarget = rayCastWorldCoordinates(mapView, targetNDCx, targetNDCy, elevation);\n        if (!zoomTarget || !newZoomTarget) {\n            return true;\n        }\n\n        if (projection.type === ProjectionType.Planar) {\n            // Calculate the difference and pan the map to maintain the map relative to the target\n            // position.\n            zoomTarget.sub(newZoomTarget);\n            panCameraAboveFlatMap(mapView, zoomTarget.x, zoomTarget.y);\n        } else if (projection.type === ProjectionType.Spherical) {\n            panCameraAroundGlobe(mapView, zoomTarget, newZoomTarget);\n        }\n        return true;\n    }\n\n    /**\n     * Parameters for {@link orbitAroundScreenPoint}.\n     */\n    export interface OrbitParams {\n        /**\n         * Delta azimuth in radians (default 0).\n         */\n        deltaAzimuth?: number;\n        /**\n         * Delta tilt in radians (default 0);\n         */\n        deltaTilt?: number;\n        /**\n         * Maximum tilt between the camera and its target in radians.\n         */\n        maxTiltAngle: number;\n        /**\n         * Orbiting center in NDC coordinates, defaults to camera's principal point.\n         * @see {@link CameraUtils.getPrincipalPoint}.\n         */\n        center?: Vector2Like;\n    }\n\n    /**\n     * Orbits the camera around a given point on the screen.\n     *\n     * @param mapView - The {@link MapView} instance to manipulate.\n     * @param offsetX - Orbit point in NDC space.\n     * @param offsetY - Orbit point in NDC space.\n     * @param deltaAzimuth - Delta azimuth in radians.\n     * @param deltaTilt - Delta tilt in radians.\n     * @param maxTiltAngle - The maximum tilt between the camera and its target in radian.\n     * @deprecated Use overload with {@link OrbitParams} object parameter.\n     */\n    export function orbitAroundScreenPoint(\n        mapView: MapView,\n        offsetX: number,\n        offsetY: number,\n        deltaAzimuth: number,\n        deltaTilt: number,\n        maxTiltAngle: number\n    ): void;\n\n    /**\n     * Orbits the camera around a given point on the screen.\n     *\n     * @param mapView - The {@link MapView} instance to manipulate.\n     * @param orbitParams - {@link OrbitParams}.\n     */\n    export function orbitAroundScreenPoint(mapView: MapView, orbitParams: OrbitParams): void;\n\n    export function orbitAroundScreenPoint(\n        mapView: MapView,\n        offsetXOrOrbitParams: number | OrbitParams,\n        offsetY?: number,\n        deltaAzimuth?: number,\n        deltaTilt?: number,\n        maxTiltAngle?: number\n    ): void {\n        const ppalPoint = CameraUtils.getPrincipalPoint(mapView.camera, cache.vector2[0]);\n        const mapTargetWorld = MapViewUtils.rayCastWorldCoordinates(\n            mapView,\n            ppalPoint.x,\n            ppalPoint.y\n        );\n        if (mapTargetWorld === null) {\n            return;\n        }\n\n        let orbitCenter: Vector2Like | undefined;\n        if (typeof offsetXOrOrbitParams === \"number\") {\n            orbitCenter = cache.vector2[1].set(offsetXOrOrbitParams, offsetY!);\n        } else {\n            const params = offsetXOrOrbitParams;\n            orbitCenter = params.center ?? ppalPoint;\n            deltaAzimuth = params.deltaAzimuth ?? 0;\n            deltaTilt = params.deltaTilt ?? 0;\n            maxTiltAngle = params.maxTiltAngle;\n        }\n        const orbitAroundPpalPoint = orbitCenter.x === ppalPoint.x && orbitCenter.y === ppalPoint.y;\n        const rotationTargetWorld = orbitAroundPpalPoint\n            ? mapTargetWorld\n            : MapViewUtils.rayCastWorldCoordinates(mapView, orbitCenter.x, orbitCenter.y);\n        if (rotationTargetWorld === null) {\n            return;\n        }\n\n        applyAzimuthAroundTarget(mapView, rotationTargetWorld, -deltaAzimuth!);\n\n        const tiltAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(mapView.camera.quaternion);\n        const clampedDeltaTilt = computeClampedDeltaTilt(\n            mapView,\n            orbitCenter.y - ppalPoint.y,\n            deltaTilt!,\n            maxTiltAngle!,\n            mapTargetWorld,\n            rotationTargetWorld,\n            tiltAxis\n        );\n\n        applyTiltAroundTarget(mapView, rotationTargetWorld, clampedDeltaTilt, tiltAxis);\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Applies the given Azimith to the camera around the supplied target.\n     */\n    function applyAzimuthAroundTarget(\n        mapView: MapView,\n        rotationTargetWorld: THREE.Vector3,\n        deltaAzimuth: number\n    ) {\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n\n        const headingAxis = projection.surfaceNormal(rotationTargetWorld, cache.vector3[0]);\n        const headingQuat = cache.quaternions[0].setFromAxisAngle(headingAxis, deltaAzimuth);\n        camera.quaternion.premultiply(headingQuat);\n        camera.position.sub(rotationTargetWorld);\n        camera.position.applyQuaternion(headingQuat);\n        camera.position.add(rotationTargetWorld);\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Clamps the supplied `deltaTilt` to the `maxTiltAngle` supplied. Note, when a non-zero offset\n     * is applied, we apply another max angle of 89 degrees to the rotation center to prevent some\n     * corner cases where the angle at the rotation center is 90 degrees and therefore intersects\n     * the geometry with the near plane.\n     */\n    function computeClampedDeltaTilt(\n        mapView: MapView,\n        offsetY: number,\n        deltaTilt: number,\n        maxTiltAngle: number,\n        mapTargetWorld: THREE.Vector3,\n        rotationTargetWorld: THREE.Vector3,\n        tiltAxis: THREE.Vector3\n    ): number {\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n\n        const tilt = extractTiltAngleFromLocation(projection, camera, mapTargetWorld, tiltAxis);\n        if (tilt + deltaTilt < 0) {\n            // Clamp the final tilt to 0\n            return -tilt;\n        } else if (deltaTilt <= 0) {\n            // Reducing the tilt isn't clamped (apart from above).\n            return deltaTilt;\n        } else if (mapTargetWorld.equals(rotationTargetWorld) || offsetY < 0) {\n            // When the rotation target is the center, or the offsetY is < 0, i.e. the angle at the\n            // `mapTargetWorld` is always bigger, then we have a simple formula\n            return MathUtils.clamp(deltaTilt + tilt, 0, maxTiltAngle) - tilt;\n        }\n\n        const rotationCenterTilt = extractTiltAngleFromLocation(\n            projection,\n            camera,\n            rotationTargetWorld!,\n            tiltAxis\n        );\n\n        const maxRotationTiltAngle = THREE.MathUtils.degToRad(89);\n\n        // The rotationCenterTilt may exceed 89 degrees when for example the user has tilted to 89\n        // at the mapTargetWorld, then choose a rotation center target above the mapTargetWorld,\n        // i.e. offsetY > 0. In such case, we just return 0, i.e. we don't let the user increase\n        // the tilt (but it can decrease, see check above for \"deltaTilt <= 0\").\n        if (rotationCenterTilt > maxRotationTiltAngle) {\n            return 0;\n        }\n\n        // This is used to find the max tilt angle, because the difference in normals is needed\n        // to correct the triangle used to find the max tilt angle at the rotation center.\n        let angleBetweenNormals = 0;\n        if (projection === sphereProjection) {\n            const projectedRotationTargetNormal = projection\n                .surfaceNormal(rotationTargetWorld, cache.vector3[0])\n                .projectOnPlane(tiltAxis)\n                .normalize();\n            const mapTargetNormal = projection.surfaceNormal(mapTargetWorld, cache.vector3[1]);\n            angleBetweenNormals = projectedRotationTargetNormal.angleTo(mapTargetNormal);\n        }\n\n        const ninetyRad = THREE.MathUtils.degToRad(90);\n\n        // The following terminology will be used:\n        // Ta = Tilt axis, tilting is achieved by rotating the camera around this direction.\n        // R = rotation target, i.e. the point about which we are rotating: `rotationTargetWorld`\n        // Rp = rotation target projected on to Ta\n        // C = camera position\n        // M = map target, i.e. the point which the camera is looking at at the NDC coordinates 0,0\n\n        // Note, the points Rp, C, and M create a plane that is perpendicular to the earths surface,\n        // because the tilt axis is perpendicular to the up vector. The following variable `RpCM` is\n        // the angle between the two rays C->Rp and C->M. This angle remains constant when tilting\n        // with a fixed `offsetX` and `offsetY`. It is calculated by using the intersection of the\n        // two rays with the earth.\n\n        // Note the use of `angleBetweenNormals` to ensure this works for spherical projections.\n        // Note, this calculation only works when the tilt at M is less than the tilt\n        // at Rp, otherwise the above formula won't work. We however don't need to worry about this\n        // case because this happens only when offsetY is less than zero, and this is handled above.\n        const MRpC = ninetyRad + angleBetweenNormals - rotationCenterTilt;\n        const CMRp = ninetyRad + tilt;\n        const RpCM = ninetyRad * 2 - (MRpC + CMRp);\n\n        // We want to find the greatest angle at the rotation target that gives us the max\n        // angle at the map center target.\n        const CMRpMaxTilt = ninetyRad * 2 - RpCM - ninetyRad - maxTiltAngle;\n\n        // Converting the `MRpC` back to a tilt is as easy as subtracting it from 90 and the\n        // `angleBetweenNormals`, i.e. this gives us the maximum allowed tilt at R that satisfies\n        // the `maxTiltAngle` constraint. Note, for globe projection, this is just an approximation,\n        // because once we move the camera by delta, the map target changes, and therefore the\n        // normal also changes, this would need to be applied iteratively until the difference in\n        // normals is reduced to some epsilon. I don't apply this because it is computationally\n        // expensive and the user would never notice this in practice.\n        const maxTilt = ninetyRad + angleBetweenNormals - CMRpMaxTilt;\n\n        // Here we clamp to the min of `maxTilt` and 89 degrees. The check for 89 is to prevent it\n        // intersecting with the world at 90. This is possible for example when the R position is\n        // near the horizon. If the angle RCM is say 5 degrees, then an angle of say 89 degrees at\n        // R, plus 5 degrees means the tilt at M would be 84 degrees, so the camera can reach 90\n        // from the point R whilst the tilt to M never reaches the `maxTiltAngle`\n        const clampedDeltaTilt =\n            MathUtils.clamp(\n                deltaTilt + rotationCenterTilt,\n                0,\n                Math.min(maxTilt, maxRotationTiltAngle)\n            ) - rotationCenterTilt;\n\n        return clampedDeltaTilt;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Applies the given tilt to the camera around the supplied target.\n     */\n    function applyTiltAroundTarget(\n        mapView: MapView,\n        rotationTargetWorld: THREE.Vector3,\n        deltaTilt: number,\n        tiltAxis: THREE.Vector3\n    ) {\n        const camera = mapView.camera;\n        // Consider to use the cache if necessary, but beware, because the `rayCastWorldCoordinates`\n        // also uses this cache.\n        const posBackup = camera.position.clone();\n        const quatBackup = camera.quaternion.clone();\n\n        const tiltQuat = cache.quaternions[0].setFromAxisAngle(tiltAxis, deltaTilt);\n        camera.quaternion.premultiply(tiltQuat);\n        camera.position.sub(rotationTargetWorld);\n        camera.position.applyQuaternion(tiltQuat);\n        camera.position.add(rotationTargetWorld);\n\n        if (MapViewUtils.rayCastWorldCoordinates(mapView, 0, 0) === null) {\n            logger.warn(\"Target got invalidated during rotation.\");\n            camera.position.copy(posBackup);\n            camera.quaternion.copy(quatBackup);\n        }\n    }\n\n    /**\n     * Calculate target (focus) point geo-coordinates for given camera.\n     * @see getTargetPositionFromCamera\n     *\n     * @param camera - The camera looking on target point.\n     * @param projection - The geo-projection used.\n     * @param elevation - Optional elevation above (or below) sea level measured in world units.\n     *\n     * @deprecated This function is for internal use only and will be removed in the future. Use\n     * MapView.worldTarget instead.\n     */\n    export function getGeoTargetFromCamera(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevation?: number\n    ): GeoCoordinates | null {\n        // This function does almost the same as:\n        // rayCastGeoCoordinates(mapView, 0, 0)\n        // but in more gentle and performance wise manner\n        const targetWorldPos = getWorldTargetFromCamera(camera, projection, elevation);\n        if (targetWorldPos !== null) {\n            return projection.unprojectPoint(targetWorldPos);\n        }\n        return null;\n    }\n\n    /**\n     * Calculate target (focus) point world coordinates for given camera position and orientation.\n     * @param camera - The camera looking on target point.\n     * @param projection - The geo-projection used.\n     * @param elevation - Optional elevation above (or below) sea level in world units.\n     *\n     * @deprecated This function is for internal use only and will be removed in the future.\n     */\n    export function getWorldTargetFromCamera(\n        camera: THREE.Camera,\n        projection: Projection,\n        elevation?: number\n    ): THREE.Vector3 | null {\n        const cameraPos = cache.vector3[0].copy(camera.position);\n        const cameraLookAt = camera.getWorldDirection(cache.vector3[1]);\n        rayCaster.set(cameraPos, cameraLookAt);\n        if (elevation !== undefined) {\n            groundPlane.constant -= elevation;\n            groundSphere.radius += elevation;\n        }\n        const targetWorldPos = new THREE.Vector3();\n        const result =\n            projection.type === ProjectionType.Planar\n                ? rayCaster.ray.intersectPlane(groundPlane, targetWorldPos)\n                : rayCaster.ray.intersectSphere(groundSphere, targetWorldPos);\n        if (elevation !== undefined) {\n            groundPlane.constant = 0;\n            groundSphere.radius = EarthConstants.EQUATORIAL_RADIUS;\n        }\n        return result;\n    }\n\n    /**\n     * Constrains given camera target and distance to {@link MapView.maxBounds}.\n     *\n     * @remarks\n     * The resulting\n     * target and distance will keep the view within the maximum bounds for a camera with tilt and\n     * yaw set to 0.\n     * @param target - The camera target.\n     * @param distance - The camera distance.\n     * @param mapView - The map view whose maximum bounds will be used as constraints.\n     * @returns constrained target and distance, or the unchanged input arguments if the view\n     * does not have maximum bounds set.\n     */\n    export function constrainTargetAndDistanceToViewBounds(\n        target: THREE.Vector3,\n        distance: number,\n        mapView: MapView\n    ): { target: THREE.Vector3; distance: number } {\n        const unconstrained = { target, distance };\n        const worldMaxBounds = mapView.worldMaxBounds;\n        const camera = mapView.camera;\n        const projection = mapView.projection;\n\n        if (!worldMaxBounds) {\n            return unconstrained;\n        }\n\n        /**\n         * Constraints are checked similarly for planar and sphere. The extents of a top down view\n         * (even if camera isn't top down) using the given camera distance are compared with those\n         * of the maximum bounds to compute a scale. There are two options:\n         * a) scale > 1. The view covers a larger area than the maximum bounds. The distance is\n         * is reduced to match the bounds extents and the target is set at the bounds center.\n         * b) scale <= 1. The view may fit within the bounds without changing the distance, only the\n         * target is moved to fit the whole view within the bounds.\n         **/\n\n        const boundsSize = worldMaxBounds.getSize(cache.vector3[1]);\n        const screenSize = mapView.renderer.getSize(cache.vector2[0]);\n        const viewHeight = CameraUtils.convertScreenToWorldSize(\n            mapView.focalLength,\n            unconstrained.distance,\n            screenSize.height\n        );\n        const viewWidth = viewHeight * camera.aspect;\n        const scale = Math.max(viewWidth / boundsSize.x, viewHeight / boundsSize.y);\n        const viewHalfSize = new THREE.Vector3(viewWidth / 2, viewHeight / 2, 0);\n\n        const constrained = {\n            target: unconstrained.target.clone(),\n            distance: unconstrained.distance\n        };\n\n        if (projection.type === ProjectionType.Planar) {\n            if (scale > 1) {\n                constrained.distance /= scale;\n                camera\n                    .getWorldDirection(camera.position)\n                    .multiplyScalar(-constrained.distance)\n                    .add(worldMaxBounds.getCenter(constrained.target));\n            } else {\n                const targetBounds = cache.box3[0]\n                    .copy(worldMaxBounds as THREE.Box3)\n                    .expandByVector(viewHalfSize.multiplyScalar(-1));\n                targetBounds\n                    .clampPoint(unconstrained.target, constrained.target)\n                    .setZ(unconstrained.target.z);\n                if (constrained.target.equals(unconstrained.target)) {\n                    return unconstrained;\n                }\n\n                camera.position.x += constrained.target.x - unconstrained.target.x;\n                camera.position.y += constrained.target.y - unconstrained.target.y;\n            }\n            return constrained;\n        }\n\n        // Spherical projection\n        if (scale > 1) {\n            // Set target to center of max bounds but keeping same height as unconstrained target.\n            worldMaxBounds.getCenter(constrained.target);\n            constrained.target.setLength(unconstrained.target.length());\n            constrained.distance /= scale;\n        } else {\n            // Compute the bounds where the target must be to ensure a top down view remains within\n            // the maximum bounds.\n            const targetMaxBounds = cache.obox3[0];\n            targetMaxBounds.copy(worldMaxBounds as OrientedBox3);\n            targetMaxBounds.position.setLength(unconstrained.target.length());\n            targetMaxBounds.extents.sub(viewHalfSize);\n\n            // Project unconstrained target to local tangent plane at the max bounds center.\n            const rotMatrix = targetMaxBounds.getRotationMatrix(cache.matrix4[0]);\n            const localTarget = cache.vector3[1]\n                .copy(constrained.target)\n                .sub(targetMaxBounds.position)\n                .applyMatrix4(cache.matrix4[1].copy(rotMatrix).transpose())\n                .setZ(0);\n\n            // Clamp the projected target with the target bounds and check if it changes.\n            const constrainedLocalTarget = cache.vector3[2]\n                .copy(localTarget)\n                .clamp(\n                    cache.vector3[3].copy(targetMaxBounds.extents).multiplyScalar(-1),\n                    targetMaxBounds.extents\n                );\n            if (constrainedLocalTarget.equals(localTarget)) {\n                return unconstrained;\n            }\n\n            // Project the local constrained target back into the sphere.\n            constrained.target\n                .copy(constrainedLocalTarget)\n                .applyMatrix4(rotMatrix)\n                .add(targetMaxBounds.position);\n            const targetHeightSq = targetMaxBounds.position.lengthSq();\n            const constTargetDistSq = constrained.target.distanceToSquared(\n                targetMaxBounds.position\n            );\n            const constTargetDistToGround =\n                Math.sqrt(targetHeightSq) - Math.sqrt(targetHeightSq - constTargetDistSq);\n            constrained.target.addScaledVector(targetMaxBounds.zAxis, -constTargetDistToGround);\n\n            // Set the constrained target to the same height as the unconstrained one.\n            constrained.target.setLength(unconstrained.target.length());\n        }\n\n        // Pan camera to constrained target and set constrained distance.\n        MapViewUtils.panCameraAroundGlobe(\n            mapView,\n            cache.vector3[1].copy(constrained.target),\n            cache.vector3[2].copy(unconstrained.target)\n        );\n        camera\n            .getWorldDirection(camera.position)\n            .multiplyScalar(-constrained.distance)\n            .add(constrained.target);\n        return constrained;\n    }\n    /**\n     * @internal\n     * Computes the target for a given camera and the distance between them.\n     * @param projection - The world space projection.\n     * @param camera - The camera whose target will be computed.\n     * @param elevationProvider - If provided, elevation at the camera position will be used.\n     * @returns The target, the distance to it and a boolean flag set to false in case an elevation\n     * provider was passed but the elevation was not available yet.\n     */\n    export function getTargetAndDistance(\n        projection: Projection,\n        camera: THREE.Camera,\n        elevationProvider?: ElevationProvider\n    ): { target: THREE.Vector3; distance: number; final: boolean } {\n        const cameraPitch = extractAttitude({ projection }, camera).pitch;\n\n        //FIXME: For now we keep the old behaviour when terrain is enabled (i.e. use the camera\n        //       height above terrain to deduce the target distance).\n        //       This leads to zoomlevel changes while panning. We have to find a proper solution\n        //       for terrain (e.g. raycast with the ground surfcae that is elevated by the average\n        //       elevation in the scene)\n        const elevation = elevationProvider\n            ? elevationProvider.getHeight(\n                  projection.unprojectPoint(camera.position),\n                  TERRAIN_ZOOM_LEVEL\n              )\n            : undefined;\n        const final = !elevationProvider || elevation !== undefined;\n\n        // Even for a tilt of 90 raycastTargetFromCamera is returning some point almost at\n        // infinity.\n        const target =\n            cameraPitch < MAX_TILT_RAD\n                ? getWorldTargetFromCamera(camera, projection, elevation)\n                : null;\n        if (target !== null) {\n            const distance = camera.position.distanceTo(target);\n            return { target, distance, final };\n        } else {\n            // We either reached the [[PITCH_LIMIT]] or we did not hit the ground surface.\n            // In this case we do the reverse, i.e. compute some fallback distance and\n            // use it to compute the tagret point by using the camera direction.\n            const groundDistance = projection.groundDistance(camera.position);\n            const heightAboveTerrain = Math.max(groundDistance - (elevation ?? 0), 0);\n\n            //For flat projection we fallback to the target distance at 89 degree pitch.\n            //For spherical projection we fallback to the tangent line distance\n            const distance =\n                projection.type === ProjectionType.Planar\n                    ? heightAboveTerrain / Math.cos(Math.min(cameraPitch, MAX_TILT_RAD))\n                    : Math.sqrt(\n                          Math.pow(heightAboveTerrain + EarthConstants.EQUATORIAL_RADIUS, 2) -\n                              Math.pow(EarthConstants.EQUATORIAL_RADIUS, 2)\n                      );\n            const cameraDir = camera.getWorldDirection(cache.vector3[0]);\n            cameraDir.multiplyScalar(distance);\n            const fallbackTarget = cache.vector3[1];\n            fallbackTarget.copy(camera.position).add(cameraDir);\n            return { target: fallbackTarget, distance, final };\n        }\n    }\n\n    /**\n     * Returns the {@link @here/harp-geoutils#GeoCoordinates} of the camera,\n     * given its target coordinates on the map and its\n     * zoom, yaw and pitch.\n     *\n     * @param targetCoordinates - Coordinates of the center of the view.\n     * @param distance - Distance to the target in meters.\n     * @param yawDeg - Camera yaw in degrees.\n     * @param pitchDeg - Camera pitch in degrees.\n     * @param projection - Active MapView, needed to get the camera fov and map projection.\n     * @param result - Optional output vector.\n     * @returns Camera position in world space.\n     */\n    export function getCameraPositionFromTargetCoordinates(\n        targetCoordinates: GeoCoordinates,\n        distance: number,\n        yawDeg: number,\n        pitchDeg: number,\n        projection: Projection,\n        result: THREE.Vector3 = new THREE.Vector3()\n    ): THREE.Vector3 {\n        const pitchRad = THREE.MathUtils.degToRad(pitchDeg);\n        const altitude = Math.cos(pitchRad) * distance;\n        const yawRad = THREE.MathUtils.degToRad(yawDeg);\n        projection.projectPoint(targetCoordinates, result);\n        const groundDistance = distance * Math.sin(pitchRad);\n        if (projection.type === ProjectionType.Planar) {\n            result.x = result.x + Math.sin(yawRad) * groundDistance;\n            result.y = result.y - Math.cos(yawRad) * groundDistance;\n            result.z = result.z + altitude;\n        } else if (projection.type === ProjectionType.Spherical) {\n            // In globe yaw and pitch are understood to be in tangent space. The approach below is\n            // to find the Z and Y tangent space axes, then rotate Y around Z by the given yaw, and\n            // set its new length (groundDistance). Finally the up vector's length is set to the\n            // camera height and added to the transformed Y above.\n\n            // Get the Z axis in tangent space: it is the normalized position vector of the target.\n            tangentSpace.z.copy(result).normalize();\n\n            // Get the Y axis (north axis in tangent space):\n            tangentSpace.y.set(0, 0, 1).projectOnPlane(tangentSpace.z).normalize();\n\n            // Rotate this north axis by the given yaw, giving the camera direction relative to\n            // the target.\n            cache.quaternions[0].setFromAxisAngle(tangentSpace.z, yawRad - Math.PI);\n            tangentSpace.y.applyQuaternion(cache.quaternions[0]);\n\n            // Push the camera to the specified distance.\n            tangentSpace.y.setLength(groundDistance);\n\n            // Now get the actual camera position vector: from the target position, add the\n            // previous computation to get the projection of the camera on the ground, then add\n            // the height of the camera in the tangent space.\n            const height = distance * Math.cos(pitchRad);\n            result.add(tangentSpace.y).add(tangentSpace.z.setLength(height));\n\n            const a = EarthConstants.EQUATORIAL_RADIUS + altitude;\n            const b = Math.sin(pitchRad) * distance;\n            const cameraHeight = Math.sqrt(a * a + b * b);\n            result.setLength(cameraHeight);\n        }\n\n        return result;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Add offset to geo points for minimal view box in flat projection with tile wrapping.\n     *\n     * @remarks\n     * In flat projection, with wrap around enabled, we should detect clusters of points around that\n     * wrap antimeridian.\n     *\n     * Here, we fit points into minimal geo box taking world wrapping into account.\n     */\n    export function wrapGeoPointsToScreen(\n        points: GeoCoordLike[],\n        startPosition?: GeoCoordinates\n    ): GeoCoordinates[] {\n        let startIndex = 0;\n        if (startPosition === undefined) {\n            startPosition = GeoCoordinates.fromObject(points[0]);\n            startIndex = 1;\n        }\n        let north = startPosition.latitude;\n        let south = startPosition.latitude;\n        let lonCenter = MathUtils.normalizeLongitudeDeg(startPosition.longitude);\n        let lonSpan = 0;\n        let east = startPosition.longitude;\n        let west = startPosition.longitude;\n\n        const result: GeoCoordinates[] = [];\n        result.push(new GeoCoordinates(north, lonCenter));\n        for (let i = startIndex; i < points.length; i++) {\n            const p = GeoCoordinates.fromObject(points[i]);\n            if (p.latitude > north) {\n                north = p.latitude;\n            } else if (p.latitude < south) {\n                south = p.latitude;\n            }\n\n            let longitude = MathUtils.normalizeLongitudeDeg(p.longitude);\n\n            const relToCenter = MathUtils.angleDistanceDeg(lonCenter, longitude);\n            longitude = lonCenter - relToCenter;\n            if (relToCenter < 0 && -relToCenter > lonSpan / 2) {\n                east = Math.max(east, lonCenter - relToCenter);\n                lonSpan = east - west;\n                lonCenter = (east + west) / 2;\n            } else if (relToCenter > 0 && relToCenter > lonSpan / 2) {\n                west = Math.min(west, longitude);\n                lonSpan = east - west;\n                lonCenter = (east + west) / 2;\n            }\n            result.push(new GeoCoordinates(p.latitude, longitude));\n        }\n        return result;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Given `cameraPos`, force all points that lie on non-visible sphere half to be \"near\" max\n     * possible viewable circle from given camera position.\n     *\n     * @remarks\n     * Assumes that shpere projection with world center is in `(0, 0, 0)`.\n     */\n    export function wrapWorldPointsToView(points: THREE.Vector3[], cameraPos: THREE.Vector3) {\n        const cameraPosNormalized = cameraPos.clone().normalize();\n        for (const point of points) {\n            if (point.angleTo(cameraPos) > Math.PI / 2) {\n                // Point is on other side of sphere, we \"clamp it to\" max possible viewable circle\n                // from given camera position\n\n                const pointLen = point.length();\n\n                point.projectOnPlane(cameraPosNormalized).setLength(pointLen);\n            }\n        }\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Return `GeoPoints` bounding {@link @here/harp-geoutils#GeoBox}\n     * applicable for {@link getFitBoundsDistance}.\n     *\n     * @returns {@link @here/harp-geoutils#GeoCoordinates} set that covers `box`\n     */\n    export function geoBoxToGeoPoints(box: GeoBox): GeoCoordinates[] {\n        const center = box.center;\n        return [\n            new GeoCoordinates(box.north, box.west),\n            new GeoCoordinates(box.north, box.east),\n            new GeoCoordinates(center.latitude, box.west),\n            new GeoCoordinates(center.latitude, box.east),\n            new GeoCoordinates(box.south, box.west),\n            new GeoCoordinates(box.south, box.east),\n            new GeoCoordinates(box.north, center.longitude),\n            new GeoCoordinates(box.south, center.longitude)\n        ];\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Get minimal distance required for `camera` looking at `worldTarget` to cover `points`.\n     *\n     * All dimensions belong to world space.\n     *\n     * @param points - points which must be in view.\n     * @param worldTarget - readonly, world target of {@link MapView}\n     * @param camera - readonly, camera with proper `position` and rotation set\n     * @returns new distance to camera to be used with {@link (MapView.lookAt:WITH_PARAMS)}\n     */\n    export function getFitBoundsDistance(\n        points: THREE.Vector3[],\n        worldTarget: THREE.Vector3,\n        camera: THREE.PerspectiveCamera\n    ): number {\n        // Diagram of the camera space YZ plane with the initial situation. Camera is at C0 and may\n        // need to be moved to make point P visible.\n        //\n        //                camY\n        //       targetDist^\n        //      |<-------->|     Ps\n        //     constD pEyeZ|    /|  ^\n        //      |<-->|<--->|   / |  |\n        //      |    |     |  /  |  | |ndcY-O.y|*h/2\n        //      |    |     | /   |  |\n        //  <---T----P'----C0----O  v\n        // camZ      |_|  /|     |                              C0  - Initial camera position\n        //           |   / |<--->|                              T   - Camera target\n        //      PcamY|  /     f                                 P   - Bounds point (world space)\n        //           | / (focal length)                         O   - Principal point.\n        //           |/                                         h   - viewport height.\n        //           P\n        //\n        // Diagram of camera space YZ plane with the final camera position C1 that leaves P at the\n        // edge of the viewport. The new camera distance is the sum of a constant term (constD) and\n        // the new distance to P (newPEyeZ), which is the initial distance (pEyeZ) multiplied by a\n        // factor that needs to be found.\n        //\n        //                            camY\n        //     constD      newPEyeZ    ^          Ps\n        //      |<-->|<--------------->|       _-`|  ^\n        //      |    |                 |    _-`   |  | |sign(ndcY)-O.y|h/2\n        //      |    |                 | _-`      |  |\n        //  <---T----P'----C0----------C1---------O  v\n        // camZ      |_|            _-`|          |              C0  - Initial camera position\n        //           |           _-`   |<-------->|              C1  - New camera position\n        //      PcamY|        _-`           f                    T   - Camera target\n        //           |     _-`        (focal length)             P   - Bounds point (world space)\n        //           |  _-`                                      Ps  - P projected on screen.\n        //           P-`                                         O   - Principal point.\n        //                                                       h   - viewport height.\n        //\n        // P is between target and initial camera position, but calculations are equivalent for\n        // points beyond the target (pEyeZ negative) or behind the camera (constD negative).\n        // Right triangles PP'C0 and PsOC0 are equivalent, as well as PP'C1 and Ps0C1, that means:\n        // |ndcY-O.y|*h/(2*f) = PcamY / |pEyeZ| (1) (ndcY-O.y,pEyeZ may be negative, take abs vals).\n        // |sign(ndcY)-O.y|h/(2*f) = PcamY / newPEyeZ (2)\n        // Dividing (1) by (2) and solving for newPEyeZ we get:\n        // newPEyeZ = | pEyeZ || ndcY - O.y | / |sign(ndcY)-O.y|\n        // The target distance to project P at the top/bottom border of the viewport is then:\n        // constD + newPEyeZ = targetDist - pEyeZ + |pEyeZ||ndcY-O.y| / |sign(ndcY)-O.y|\n        // The target distance to project P at the left/right border of the viewport is similarly:\n        // targetDist - pEyeZ + |pEyeZ||ndcX-O.x| / |sign(ndcX)-O.x|\n        // Take the largest of both distances to ensure the point is inside the viewport:\n        // newDistance = targetDist - pEyeZ +\n        // max(| ndcX - O.x | /|sign(ndcX)-O.x|, |ndcY-O.y|/sign(ndcY) - O.y |) *| pEyeZ |\n\n        const targetDist = cache.vector3[0].copy(worldTarget).sub(camera.position).length();\n        const ppalPoint = CameraUtils.getPrincipalPoint(camera);\n        let newDistance = targetDist;\n\n        const getDistanceFactor = (pointNDC: number, ppNDC: number) => {\n            // Use as maximum NDC a value slightly smaller than 1 to ensure the point is visible\n            // with the final camera distance. Otherwise any precision loss might leave it just\n            // outside of the viewport.\n            const maxNDC = 0.99;\n            return Math.abs(pointNDC) > 1\n                ? Math.abs((pointNDC - ppNDC) / (maxNDC * Math.sign(pointNDC) - ppNDC))\n                : 1;\n        };\n        for (const point of points) {\n            const pEyeZ = -cache.vector3[0].copy(point).applyMatrix4(camera.matrixWorldInverse).z;\n            const pointNDC = cache.vector3[0].applyMatrix4(camera.projectionMatrix);\n            const maxFactor = Math.max(\n                getDistanceFactor(pointNDC.x, ppalPoint.x),\n                getDistanceFactor(pointNDC.y, ppalPoint.y)\n            );\n            if (maxFactor > 1) {\n                const constDist = targetDist - pEyeZ;\n                const newPEyeZ = Math.abs(pEyeZ) * maxFactor + constDist;\n                newDistance = Math.max(newDistance, newPEyeZ);\n            }\n        }\n        return newDistance;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Paremeters for [[getFitBoundsLookAtParams]] function.\n     */\n    export interface FitPointParams {\n        tilt: number;\n        heading: number;\n        projection: Projection;\n        minDistance: number;\n        camera: THREE.PerspectiveCamera;\n    }\n\n    /**\n     * @hidden\n     * @internal\n     *\n     * Get {@link LookAtParams} that fit all `worldPoints`\n     * giving that {@link MapView} will target at\n     * `geoTarget`.\n     *\n     * @param geoTarget - desired target (see {@link MapView.target}) as geo point\n     * @param worldTarget - same as `geoTarget` but in world space\n     * @param worldPoints - points we want to see\n     * @param params - other params derived from {@link MapView}.\n     */\n    export function getFitBoundsLookAtParams(\n        geoTarget: GeoCoordinates,\n        worldTarget: THREE.Vector3,\n        worldPoints: THREE.Vector3[],\n        params: FitPointParams\n    ) {\n        const { tilt, heading, projection } = params;\n        const startDistance = params.minDistance;\n        const tmpCamera = params.camera.clone() as THREE.PerspectiveCamera;\n\n        getCameraRotationAtTarget(projection, geoTarget, -heading, tilt, tmpCamera.quaternion);\n        getCameraPositionFromTargetCoordinates(\n            geoTarget,\n            startDistance,\n            -heading,\n            tilt,\n            projection,\n            tmpCamera.position\n        );\n        tmpCamera.updateMatrixWorld(true);\n\n        if (projection.type === ProjectionType.Spherical) {\n            wrapWorldPointsToView(worldPoints, tmpCamera.position);\n        }\n        const distance = getFitBoundsDistance(worldPoints, worldTarget, tmpCamera);\n        return {\n            target: geoTarget,\n            distance,\n            heading,\n            tilt\n        };\n    }\n\n    /**\n     * @deprecated use getCameraPositionFromTargetCoordinates instead\n     */\n    export function getCameraCoordinatesFromTargetCoordinates(\n        targetCoordinates: GeoCoordinates,\n        distance: number,\n        yawDeg: number,\n        pitchDeg: number,\n        mapView: MapView\n    ): GeoCoordinates {\n        return mapView.projection.unprojectPoint(\n            getCameraPositionFromTargetCoordinates(\n                targetCoordinates,\n                distance,\n                yawDeg,\n                pitchDeg,\n                mapView.projection,\n                cache.vector3[1]\n            )\n        );\n    }\n\n    /**\n     * Casts a ray in NDC space from the current map view and returns the intersection point of that\n     * ray wih the map in world space.\n     *\n     * @param mapView - Instance of MapView.\n     * @param pointOnScreenXinNDC - X coordinate in NDC space.\n     * @param pointOnScreenYinNDC - Y coordinate in NDC space.\n     * @param elevation - Optional param used to offset the ground plane. Used when wanting to pan\n     * based on a plane at some altitude. Necessary for example when panning with terrain.\n     *\n     * @returns Intersection coordinates, or `null` if raycast failed.\n     */\n    export function rayCastWorldCoordinates(\n        mapView: MapView | { camera: THREE.Camera; projection: Projection },\n        pointOnScreenXinNDC: number,\n        pointOnScreenYinNDC: number,\n        elevation?: number\n    ): THREE.Vector3 | null {\n        const pointInNDCPosition = cache.vector3[0].set(\n            pointOnScreenXinNDC,\n            pointOnScreenYinNDC,\n            0\n        );\n\n        mapView.camera.updateMatrixWorld();\n        const cameraPos = cache.vector3[1].copy(mapView.camera.position);\n\n        cache.matrix4[0].extractRotation(mapView.camera.matrixWorld);\n\n        // Prepare the unprojection matrix which projects from NDC space to camera space\n        // and takes the current rotation of the camera into account.\n        cache.matrix4[1].multiplyMatrices(\n            cache.matrix4[0],\n            cache.matrix4[1].copy(mapView.camera.projectionMatrix).invert()\n        );\n        // Unproject the point via the unprojection matrix.\n        const pointInCameraSpace = pointInNDCPosition.applyMatrix4(cache.matrix4[1]);\n        // Use the point in camera space as the vector towards this point.\n        rayCaster.set(cameraPos, pointInCameraSpace.normalize());\n        if (elevation !== undefined) {\n            groundPlane.constant -= elevation;\n            groundSphere.radius += elevation;\n        }\n\n        const worldPosition = new THREE.Vector3();\n        const result =\n            mapView.projection.type === ProjectionType.Planar\n                ? rayCaster.ray.intersectPlane(groundPlane, worldPosition)\n                : rayCaster.ray.intersectSphere(groundSphere, worldPosition);\n\n        if (elevation !== undefined) {\n            groundPlane.constant = 0;\n            groundSphere.radius = EarthConstants.EQUATORIAL_RADIUS;\n        }\n        return result;\n    }\n\n    /**\n     * Pans the camera according to the projection.\n     *\n     * @param mapView - Instance of MapView.\n     * @param xOffset - In world space. Value > 0 will pan the map to the right, value < 0 will pan\n     *                  the map to the left in default camera orientation.\n     * @param yOffset - In world space. Value > 0 will pan the map upwards, value < 0 will pan the\n     *                  map downwards in default camera orientation.\n     */\n    export function panCameraAboveFlatMap(\n        mapView: MapView,\n        offsetX: number,\n        offsetY: number\n    ): void {\n        mapView.camera.position.x += offsetX;\n        mapView.camera.position.y += offsetY;\n    }\n\n    /**\n     * The function doing a pan in the spherical space\n     * when {@link MapView}'s active [[ProjectionType]]\n     * is spherical. In other words, the function that rotates the camera around the globe.\n     *\n     * @param mapView - MapView instance.\n     * @param fromWorld - Start vector representing the scene position of a geolocation.\n     * @param toWorld - End vector representing the scene position of a geolocation.\n     */\n    export function panCameraAroundGlobe(\n        mapView: MapView,\n        fromWorld: THREE.Vector3,\n        toWorld: THREE.Vector3\n    ) {\n        cache.quaternions[0]\n            .setFromUnitVectors(fromWorld.normalize(), toWorld.normalize())\n            .invert();\n        cache.matrix4[0].makeRotationFromQuaternion(cache.quaternions[0]);\n        mapView.camera.applyMatrix4(cache.matrix4[0]);\n        mapView.camera.updateMatrixWorld();\n    }\n\n    /**\n     * Rotates the camera by the given delta yaw and delta pitch. The pitch will be clamped to the\n     * maximum possible tilt to the new target, and under the horizon in sphere projection.\n     *\n     * @param mapView - The {@link MapView} instance in use.\n     * @param deltaYawDeg - Delta yaw in degrees.\n     * @param deltaPitchDeg - Delta pitch in degrees.\n     * @param maxTiltAngleRad - Max tilt angle in radians.\n     */\n    export function rotate(\n        mapView: { projection: Projection; camera: THREE.PerspectiveCamera },\n        deltaYawDeg: number,\n        deltaPitchDeg: number = 0,\n        maxTiltAngleRad = Math.PI / 4\n    ) {\n        // 1. Apply yaw: rotate around the vertical axis.\n        mapView.camera.rotateOnWorldAxis(\n            mapView.projection.type === ProjectionType.Spherical\n                ? cache.vector3[0].copy(mapView.camera.position).normalize()\n                : cache.vector3[0].set(0, 0, 1),\n            THREE.MathUtils.degToRad(-deltaYawDeg)\n        );\n        mapView.camera.updateMatrixWorld();\n\n        // 2. Apply pitch: rotate around the camera's local X axis.\n        if (deltaPitchDeg === 0) {\n            return;\n        }\n        const pitch = MapViewUtils.extractAttitude(mapView, mapView.camera).pitch;\n        // `maxTiltAngle` is equivalent to a `maxPitchAngle` in flat projections.\n        let newPitch = THREE.MathUtils.clamp(\n            pitch + THREE.MathUtils.degToRad(deltaPitchDeg),\n            0,\n            maxTiltAngleRad\n        );\n        // In sphere projection, the value of a maximum pitch is smaller than the value of the\n        // maximum tilt, as the curvature of the surface adds up to it.\n        if (mapView.projection.type === ProjectionType.Spherical) {\n            // Deduce max pitch from max tilt. To this end the sine law of triangles is used below.\n            const maxPitch = Math.asin(\n                (EarthConstants.EQUATORIAL_RADIUS * Math.sin(Math.PI - maxTiltAngleRad)) /\n                    mapView.camera.position.length()\n            );\n            newPitch = Math.min(newPitch, maxPitch);\n        }\n        mapView.camera.rotateX(newPitch - pitch);\n    }\n\n    /**\n     * Computes the rotation of the camera according to yaw and pitch in degrees. The computations\n     * hinge on the current `projection` and `target`, because yaw and pitch are defined in\n     * tangent space of the target point.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param projection - Current projection.\n     * @param target - The camera target.\n     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg - Pitch in degrees.\n     */\n    export function getCameraRotationAtTarget(\n        projection: Projection,\n        target: GeoCoordinates,\n        yawDeg: number,\n        pitchDeg: number,\n        result: THREE.Quaternion = new THREE.Quaternion()\n    ): THREE.Quaternion {\n        const transform = cache.transforms[0];\n        projection.localTangentSpace(target, transform);\n\n        cache.matrix4[0].makeBasis(transform.xAxis, transform.yAxis, transform.zAxis);\n        result.setFromRotationMatrix(cache.matrix4[0]);\n\n        cache.quaternions[0].setFromAxisAngle(\n            cache.vector3[1].set(0, 0, 1),\n            THREE.MathUtils.degToRad(yawDeg)\n        );\n        cache.quaternions[1].setFromAxisAngle(\n            cache.vector3[1].set(1, 0, 0),\n            THREE.MathUtils.degToRad(pitchDeg)\n        );\n\n        result.multiply(cache.quaternions[0]);\n        result.multiply(cache.quaternions[1]);\n        return result;\n    }\n\n    /**\n     * Sets the rotation of the camera according to yaw and pitch in degrees. The computations hinge\n     * on the current projection and `geoCenter`, because yaw and pitch are defined in tangent\n     * space. In particular, `MapView#geoCenter` needs to be set before calling `setRotation`.\n     *\n     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the\n     * map.\n     *\n     * @param mapView - Instance of MapView.\n     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.\n     * @param pitchDeg - Pitch in degrees.\n     */\n    export function setRotation(mapView: MapView, yawDeg: number, pitchDeg: number) {\n        getCameraRotationAtTarget(\n            mapView.projection,\n            mapView.geoCenter,\n            yawDeg,\n            pitchDeg,\n            mapView.camera.quaternion\n        );\n    }\n\n    /**\n     * Extracts current camera tilt angle in radians.\n     *\n     * @param camera - The [[Camera]] in use.\n     * @param projection - The {@link @here/harp-geoutils#Projection} used to\n     *                     convert between geo and world coordinates.\n     *\n     * @deprecated Use MapView.tilt\n     */\n    export function extractCameraTilt(camera: THREE.Camera, projection: Projection): number {\n        // For planar projections the camera target point local tangent is the same\n        // at every point on the ground (ignoring terrain fluctuations), so we may\n        // simply use inverted ground normal for tilt calculation. This simplifies\n        // the more generic calculus used for spherical projections.\n        if (projection.type === ProjectionType.Planar) {\n            const lookAt: THREE.Vector3 = camera.getWorldDirection(cache.vector3[0]).normalize();\n            const normal: THREE.Vector3 = projection\n                .surfaceNormal(camera.position, cache.vector3[1])\n                .negate();\n            const cosTheta = lookAt.dot(normal);\n            return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));\n        } else {\n            // Sanity check if new projection type is introduced.\n            assert(projection.type === ProjectionType.Spherical);\n            const targetGeoCoords = MapViewUtils.getGeoTargetFromCamera(camera, projection);\n            // If focus point is lost we then expose maximum allowable tilt value.\n            if (targetGeoCoords !== null) {\n                return MapViewUtils.extractTiltAngleFromLocation(\n                    projection,\n                    camera,\n                    targetGeoCoords\n                );\n            } else {\n                logger.warn(\n                    \"MapView camera is pointing in the void, using maxTilt: \",\n                    MAX_TILT_RAD\n                );\n                return MAX_TILT_RAD;\n            }\n        }\n    }\n\n    /**\n     * Extracts yaw, pitch, and roll rotation in radians.\n     * - Yaw : Rotation around the vertical axis, counter-clockwise (as opposed to azimuth),\n     * starting north.\n     * - Pitch :Rotation around the horizontal axis.\n     * - Roll : Rotation around the view axis.\n     *\n     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles\n     *\n     * @param options - Subset of necessary {@link MapView} properties.\n     * @param object - The [[THREE.Object3D]] instance to extract the rotations from.\n     */\n    export function extractAttitude(\n        mapView: { projection: Projection },\n        object: THREE.Object3D\n    ): Attitude {\n        // 1. Build the matrix of the tangent space of the object.\n        cache.vector3[1].setFromMatrixPosition(object.matrixWorld); // Ensure using world position.\n        mapView.projection.localTangentSpace(cache.vector3[1], {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n        cache.matrix4[1].makeBasis(tangentSpace.x, tangentSpace.y, tangentSpace.z);\n\n        // 2. Change the basis of matrixWorld to the tangent space to get the new base axes.\n        cache.matrix4[0].copy(cache.matrix4[1]).invert().multiply(object.matrixWorld);\n        space.x.setFromMatrixColumn(cache.matrix4[0], 0);\n        space.y.setFromMatrixColumn(cache.matrix4[0], 1);\n        space.z.setFromMatrixColumn(cache.matrix4[0], 2);\n\n        // 3. Deduce orientation from the base axes.\n        let yaw = 0;\n        let pitch = 0;\n        let roll = 0;\n\n        // Decompose rotation matrix into Z0 X Z1 Euler angles.\n        const d = space.z.dot(cache.vector3[1].set(0, 0, 1));\n        if (d < 1.0 - Number.EPSILON) {\n            if (d > -1.0 + Number.EPSILON) {\n                yaw = Math.atan2(space.z.x, -space.z.y);\n                pitch = Math.acos(space.z.z);\n                roll = Math.atan2(space.x.z, space.y.z);\n            } else {\n                // Looking bottom-up with space.z.z == -1.0\n                yaw = -Math.atan2(-space.y.x, space.x.x);\n                pitch = 180;\n                roll = 0;\n            }\n        } else {\n            // Looking top-down with space.z.z == 1.0\n            yaw = Math.atan2(-space.y.x, space.x.x);\n            pitch = 0.0;\n            roll = 0.0;\n        }\n\n        return {\n            yaw,\n            pitch,\n            roll\n        };\n    }\n\n    /**\n     * Gets the spherical coordinates in radian of the object to the coordinates of `point`.\n     *\n     * Note: this method can be used to get the direction that an object points to, when `location`\n     * is the target of that object, by adding PI to it. Otherwise it only returns the spherical\n     * coordinates of `object` in the tangent space of `location`.\n     *\n     * @param mapView - The {@link MapView} instance to consider.\n     * @param object - The object to get the coordinates from.\n     * @param location - The reference point.\n     */\n    export function extractSphericalCoordinatesFromLocation(\n        mapView: { projection: Projection },\n        object: THREE.Object3D,\n        location: GeoCoordinatesLike | Vector3Like\n    ): { azimuth: number; tilt: number } {\n        // if (projection instanceof MapView) {\n        //     logger.warn(\"Passing MapView to extractSphericalCoordinatesFromLocation is deprecated\");\n        //     projection = projection.projection;\n        // }\n        mapView.projection.localTangentSpace(location, {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n\n        let tilt = 0;\n        let azimuth = 0;\n\n        // Get point to object vector in `cache.vector3[1]` and deduce `tilt` from the angle with\n        // tangent Z.\n        cache.vector3[1].copy(object.position).sub(cache.vector3[0]).normalize();\n        if (cache.vector3[1].dot(tangentSpace.z) > 1 - Number.EPSILON) {\n            // Top down view: the azimuth of the object would be opposite the yaw, and clockwise.\n            azimuth = Math.PI - extractAttitude(mapView, object).yaw;\n            // Wrap between -PI and PI.\n            azimuth = Math.atan2(Math.sin(azimuth), Math.cos(azimuth));\n            tilt = 0;\n            return { tilt, azimuth };\n        }\n        tilt = cache.vector3[1].angleTo(tangentSpace.z);\n        // Tilted view: the azimuth is the direction of the object from the origin.\n        cache.vector3[1]\n            .copy(object.position)\n            .sub(cache.vector3[0])\n            .projectOnPlane(tangentSpace.z)\n            .normalize();\n        azimuth = cache.vector3[1].angleTo(tangentSpace.y);\n        if (cache.vector3[1].cross(tangentSpace.y).dot(tangentSpace.z) < 0) {\n            azimuth = -azimuth;\n        }\n        return { tilt, azimuth };\n    }\n\n    /**\n     * Gets the tilt angle (in radians) of the object relative to the coordinates of `location`.\n     *\n     * Note: this method can be used to get the direction that an object points to, when `location`\n     * is the target of that object, by adding PI to it. Otherwise it only returns the tilt angle\n     * (in radians) of `object` in the tangent space of `location`.\n     *\n     * @param projection - The {@link @here/harp-geoutils#Projection} used when\n     *                     converting from geo to world coordinates.\n     * @param object - The object to get the coordinates from.\n     * @param location - The reference point.\n     * @param tiltAxis - Optional axis used to define the rotation about which the object's tilt\n     * occurs, the direction vector to the location from the camera is projected on the plane with\n     * the given angle.\n     */\n    export function extractTiltAngleFromLocation(\n        projection: Projection,\n        object: THREE.Object3D,\n        location: GeoCoordinates | Vector3Like,\n        tiltAxis?: THREE.Vector3\n    ): number {\n        projection.localTangentSpace(location, {\n            xAxis: tangentSpace.x,\n            yAxis: tangentSpace.y,\n            zAxis: tangentSpace.z,\n            position: cache.vector3[0]\n        });\n        // Get point to object vector (dirVec) and compute the `tilt` as the angle with tangent Z.\n        const dirVec = cache.vector3[2].copy(object.position).sub(cache.vector3[0]);\n        if (tiltAxis) {\n            dirVec.projectOnPlane(tiltAxis);\n            tangentSpace.z.projectOnPlane(tiltAxis).normalize();\n        }\n        const dirLen = dirVec.length();\n        if (dirLen < epsilon) {\n            logger.error(\"Can not calculate tilt for the zero length vector!\");\n            return 0;\n        }\n        dirVec.divideScalar(dirLen);\n\n        const cosTheta = dirVec.dot(tangentSpace.z);\n        if (cosTheta >= 1 - Number.EPSILON) {\n            // Top down view.\n            return 0;\n        }\n        return Math.acos(THREE.MathUtils.clamp(cosTheta, -1, 1));\n    }\n\n    /**\n     * Get perspective camera frustum planes distances.\n     * @deprecated\n     * @return all plane distances in helper object.\n     */\n    export function getCameraFrustumPlanes(\n        camera: THREE.PerspectiveCamera\n    ): { left: number; right: number; top: number; bottom: number; near: number; far: number } {\n        const near = camera.near;\n        const far = camera.far;\n        let top = (near * Math.tan(THREE.MathUtils.degToRad(0.5 * camera.fov))) / camera.zoom;\n        let height = 2 * top;\n        let width = camera.aspect * height;\n        let left = -0.5 * width;\n\n        const view = camera.view;\n        if (view !== null && view.enabled) {\n            const fullWidth = view.fullWidth;\n            const fullHeight = view.fullHeight;\n\n            left += (view.offsetX * width) / fullWidth;\n            top -= (view.offsetY * height) / fullHeight;\n            width *= view.width / fullWidth;\n            height *= view.height / fullHeight;\n        }\n\n        // Correct by skew factor\n        left += camera.filmOffset !== 0 ? (near * camera.filmOffset) / camera.getFilmWidth() : 0;\n\n        return {\n            left,\n            right: left + width,\n            top,\n            bottom: top - height,\n            near,\n            far\n        };\n    }\n\n    /**\n     * Casts a ray in NDC space from the current view of the camera and returns the intersection\n     * point of that ray against the map in geo coordinates. The return value can be `null` when\n     * the raycast is above the horizon.\n     *\n     * @param mapView - Instance of MapView.\n     * @param pointOnScreenXNDC -  Abscissa in NDC space.\n     * @param pointOnScreenYNDC -  Ordinate in NDC space.\n     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.\n     */\n    export function rayCastGeoCoordinates(\n        mapView: MapView,\n        pointOnScreenXinNDC: number,\n        pointOnScreenYinNDC: number\n    ): GeoCoordinates | null {\n        const worldCoordinates = rayCastWorldCoordinates(\n            mapView,\n            pointOnScreenXinNDC,\n            pointOnScreenYinNDC\n        );\n\n        if (!worldCoordinates) {\n            return null;\n        }\n\n        return mapView.projection.unprojectPoint(worldCoordinates);\n    }\n\n    /**\n     * Calculates and returns the distance from the ground, which is needed to put the camera to\n     * this height, to see the size of the area that would be covered by one tile for the given zoom\n     * level.\n     *\n     * @param mapView - Instance of MapView.\n     * @param options - Subset of necessary {@link MapView} properties.\n     */\n    export function calculateDistanceToGroundFromZoomLevel(\n        mapView: { projection: Projection; focalLength: number; camera: THREE.PerspectiveCamera },\n        zoomLevel: number\n    ): number {\n        const cameraPitch = extractAttitude(mapView, mapView.camera).pitch;\n        const tileSize = EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);\n        return ((mapView.focalLength * tileSize) / 256) * Math.cos(cameraPitch);\n    }\n\n    /**\n     * Calculates and returns the distance to the target point.\n     *\n     * @param options - Necessary subset of MapView properties to compute the distance.\n     * @param zoomLevel - The zoom level to get the equivalent height to.\n     */\n    export function calculateDistanceFromZoomLevel(\n        options: { focalLength: number },\n        zoomLevel: number\n    ): number {\n        const tileSize = EarthConstants.EQUATORIAL_CIRCUMFERENCE / Math.pow(2, zoomLevel);\n        return (options.focalLength * tileSize) / 256;\n    }\n\n    /**\n     * Calculates the zoom level, which corresponds to the current distance from\n     * camera to lookAt point.\n     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in\n     * between zoom levels. By setting the zoom level, you change the height position of the camera\n     * in away that the field of view of the camera should be able to cover one tile for the given\n     * zoom level.\n     *\n     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you\n     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of\n     * you.\n     *\n     * @param options - Subset of necessary {@link MapView} properties.\n     * @param distance - The distance in meters, which are scene units in {@link MapView}.\n     */\n    export function calculateZoomLevelFromDistance(\n        options: { focalLength: number; minZoomLevel: number; maxZoomLevel: number },\n        distance: number\n    ): number {\n        const tileSize = (256 * distance) / options.focalLength;\n        const zoomLevel = THREE.MathUtils.clamp(\n            Math.log2(EarthConstants.EQUATORIAL_CIRCUMFERENCE / tileSize),\n            options.minZoomLevel,\n            options.maxZoomLevel\n        );\n        return snapToCeilingZoomLevel(zoomLevel);\n    }\n\n    /**\n     * @deprecated\n     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.\n     * This is useful as the depth values are not stored in the depth buffer linearly, and this can\n     * lead into confusing behavior when not taken into account.\n     *\n     * @param clipDistance - Distance from the camera in clip space (range: [0, 1]).\n     * @param camera - Camera applying the perspective projection.\n     */\n    export function calculateDepthFromClipDistance(\n        clipDistance: number,\n        camera: THREE.Camera\n    ): number {\n        const perspCam = camera as THREE.PerspectiveCamera;\n        const cameraRange = perspCam.far - perspCam.near;\n        const viewSpaceDistance = clipDistance * perspCam.far;\n\n        return (1.0 - perspCam.near / viewSpaceDistance) * (perspCam.far / cameraRange);\n    }\n\n    /**\n     * @deprecated\n     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n     * [0..cameraFar].\n     *\n     * @param distance - Distance from the camera (range: [0, 1]).\n     * @param camera - Camera applying the perspective projection.\n     */\n    export function cameraToWorldDistance(distance: number, camera: THREE.Camera): number {\n        const perspCam = camera as THREE.PerspectiveCamera;\n        return distance * perspCam.far;\n    }\n\n    /**\n     * @deprecated\n     */\n    export function calculateVerticalFovByHorizontalFov(hFov: number, aspect: number): number {\n        return 2 * Math.atan(Math.tan(hFov / 2) / aspect);\n    }\n\n    /**\n     * @deprecated Use {@link CameraUtils.getHorizontalFov}.\n     */\n    export function calculateHorizontalFovByVerticalFov(vFov: number, aspect: number): number {\n        tmpCamera.fov = THREE.MathUtils.radToDeg(vFov);\n        tmpCamera.aspect = aspect;\n        return CameraUtils.getHorizontalFov(tmpCamera);\n    }\n\n    /**\n     * @deprecated Use {@link CameraUtils.setVerticalFov}.\n     */\n    export function calculateFocalLengthByVerticalFov(vFov: number, height: number): number {\n        // setVerticalFov takes into account the principal point position to support\n        // off-center projections. Keep previous behaviour by passing a camera with centered\n        // principal point.\n        CameraUtils.setPrincipalPoint(tmpCamera, new THREE.Vector2());\n        CameraUtils.setVerticalFov(tmpCamera, vFov, height);\n        return CameraUtils.getFocalLength(tmpCamera)!;\n    }\n\n    /**\n     * @deprecated Use {@link CameraUtils.setFocalLength}.\n     */\n    export function calculateFovByFocalLength(focalLength: number, height: number): number {\n        // setFocalLength takes into account the principal point position to support\n        // off-center projections. Keep previous behaviour by passing a camera with centered\n        // principal point.\n        CameraUtils.setPrincipalPoint(tmpCamera, new THREE.Vector2());\n        CameraUtils.setFocalLength(tmpCamera, focalLength, height);\n        return tmpCamera.fov;\n    }\n\n    /**\n     * @deprecated Use {@link CameraUtils.convertWorldToScreenSize}.\n     */\n    export const calculateScreenSizeByFocalLength = CameraUtils.convertWorldToScreenSize;\n\n    /**\n     * @deprecated Use {@link CameraUtils.convertScreenToWorldSize}.\n     */\n    export const calculateWorldSizeByFocalLength = CameraUtils.convertScreenToWorldSize;\n\n    /**\n     * @deprecated\n     */\n    export const estimateObject3dSize = Object3DUtils.estimateSize;\n\n    /**\n     * Check if tiles or other content is currently being loaded.\n     *\n     * This method can be removed once HARP-7932 is implemented.\n     *\n     * @returns `true` if MapView has visible tiles or other content that is being loaded.\n     */\n    export function mapViewIsLoading(mapView: MapView) {\n        let numTilesLoading = 0;\n\n        for (const tileList of mapView.visibleTileSet.dataSourceTileList) {\n            numTilesLoading += tileList.numTilesLoading;\n\n            for (const tile of tileList.visibleTiles) {\n                if (!tile.allGeometryLoaded) {\n                    numTilesLoading++;\n                }\n            }\n        }\n        let isLoading = numTilesLoading > 0;\n\n        if (mapView.textElementsRenderer !== undefined) {\n            isLoading = isLoading || mapView.textElementsRenderer.loading;\n        }\n\n        isLoading =\n            isLoading ||\n            !mapView.poiTableManager.finishedLoading ||\n            !mapView.visibleTileSet.allVisibleTilesLoaded;\n\n        return isLoading;\n    }\n\n    export function closeToFrustum(\n        point: THREE.Vector3,\n        camera: THREE.Camera,\n        eps: number = 1e-13\n    ): boolean {\n        const ndcPoint = new THREE.Vector3().copy(point).project(camera);\n        if (\n            Math.abs(ndcPoint.x) - eps < 1 &&\n            Math.abs(ndcPoint.y) - eps < 1 &&\n            Math.abs(ndcPoint.z) - eps < 1\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @deprecated Use {@link @here/harp-utils#DOMUtils.getBrowserLanguages}\n     */\n    export const getBrowserLanguages = DOMUtils.getBrowserLanguages;\n}\n\nexport namespace TileOffsetUtils {\n    /**\n     * @deprecated Use {@link @here/harp-geoutils#TileKeyUtils.getKeyForTileKeyAndOffset}.\n     */\n    export const getKeyForTileKeyAndOffset = TileKeyUtils.getKeyForTileKeyAndOffset;\n\n    /**\n     * @deprecated Use {@link @here/harp-geoutils#TileKeyUtils.getKeyForTileKeyAndOffset}.\n     */\n    export const extractOffsetAndMortonKeyFromKey = TileKeyUtils.extractOffsetAndMortonKeyFromKey;\n\n    /**\n     * @deprecated Use {@link @here/harp-geoutils#TileKeyUtils.getParentKeyFromKey}.\n     */\n    export const getParentKeyFromKey = TileKeyUtils.getParentKeyFromKey;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport {\n    GeoCoordinates,\n    Projection,\n    ProjectionType,\n    TileKey,\n    TileKeyUtils,\n    TilingScheme\n} from \"@here/harp-geoutils\";\nimport { LRUCache } from \"@here/harp-lrucache\";\nimport { assert, MathUtils, TaskQueue } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { BackgroundDataSource } from \"./BackgroundDataSource\";\nimport { ClipPlanesEvaluator } from \"./ClipPlanesEvaluator\";\nimport { DataSource } from \"./DataSource\";\nimport { ElevationRangeSource } from \"./ElevationRangeSource\";\nimport { FrustumIntersection, TileKeyEntry } from \"./FrustumIntersection\";\nimport { TileGeometryManager } from \"./geometry/TileGeometryManager\";\nimport { TileTaskGroups } from \"./MapView\";\nimport { Tile } from \"./Tile\";\n\n/**\n * Way the memory consumption of a tile is computed. Either in number of tiles, or in MegaBytes. If\n * it is in MB, an estimation is used.\n */\nexport enum ResourceComputationType {\n    EstimationInMb = 0,\n    NumberOfTiles\n}\n\n// Direction in quad tree to search: up -> shallower levels, down -> deeper levels.\nenum SearchDirection {\n    NONE,\n    UP,\n    DOWN,\n    BOTH\n}\n\n/**\n * Limited set of {@link MapViewOptions} used for {@link VisibleTileSet}.\n */\nexport interface VisibleTileSetOptions {\n    /**\n     * The projection of the view.\n     */\n    projection: Projection;\n\n    /**\n     * User-defined camera clipping planes evaluator.\n     */\n    clipPlanesEvaluator: ClipPlanesEvaluator;\n\n    /**\n     * Limit of tiles that can be visible per datasource.\n     */\n    maxVisibleDataSourceTiles: number;\n\n    /**\n     * In addition to the simple frustum culling also do additional checks with [[MapTileCuller]].\n     */\n    extendedFrustumCulling: boolean;\n\n    /**\n     * Missing Typedoc\n     */\n    tileCacheSize: number;\n\n    /**\n     * Missing Typedoc\n     */\n    resourceComputationType: ResourceComputationType;\n\n    /**\n     * Number of levels to go up when searching for fallback tiles.\n     */\n    quadTreeSearchDistanceUp: number;\n\n    /**\n     * Number of levels to go down when searching for fallback tiles.\n     */\n    quadTreeSearchDistanceDown: number;\n\n    /**\n     * Maximal number of new tiles, that can be added to the scene per frame.\n     * if set to `0`the limit will be ignored and all available tiles be uploaded.\n     * @beta\n     * @internal\n     * @defaultValue 0\n     */\n    maxTilesPerFrame: number;\n}\n\nconst MB_FACTOR = 1.0 / (1024.0 * 1024.0);\n\ntype TileCacheId = string;\n\n/**\n * Wrapper for LRU cache that encapsulates tiles caching for any {@link DataSource} used.\n *\n * Provides LRU based caching mechanism where each tile is identified by its tile key\n * (morton code) and data source name.\n * Tiles are kept in the cache based on last recently used policy, cached tile may be evicted\n * only when cache reaches full saturation and tile is no longer visible.\n * @note Currently cached entries (tiles) are identified by unique tile code (morton code) and\n * data source name, thus it is required that each {@link DataSource} used should have unique\n * name, but implementation could be improved to omit this limitation.\n */\nclass DataSourceCache {\n    /**\n     * Creates unique tile key for caching based on morton code, tile offset and its data source.\n     *\n     * @param mortonCode - The tile morton code.\n     * @param offset - The tile offset.\n     * @param dataSource - The {@link DataSource} from which tile was loaded.\n     */\n    static getKey(mortonCode: number, offset: number, dataSource: DataSource): TileCacheId {\n        return `${dataSource.name}_${mortonCode}_${offset}`;\n    }\n\n    /**\n     * Create unique tile identifier for caching, based on tile object passed in.\n     *\n     * @param tile - The tile for which key is generated.\n     */\n    static getKeyForTile(tile: Tile): TileCacheId {\n        return DataSourceCache.getKey(tile.tileKey.mortonCode(), tile.offset, tile.dataSource);\n    }\n\n    private readonly m_tileCache: LRUCache<TileCacheId, Tile>;\n    private readonly m_disposedTiles: Tile[] = [];\n    private m_resourceComputationType: ResourceComputationType;\n\n    constructor(\n        cacheSize: number,\n        rct: ResourceComputationType = ResourceComputationType.EstimationInMb\n    ) {\n        this.m_resourceComputationType = rct;\n        this.m_tileCache = new LRUCache<string, Tile>(cacheSize, (tile: Tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            } else {\n                return 1;\n            }\n        });\n        this.m_tileCache.evictionCallback = (_, tile) => {\n            if (tile.tileLoader !== undefined) {\n                // Cancel downloads as early as possible.\n                tile.tileLoader.cancel();\n            }\n            this.m_disposedTiles.push(tile);\n        };\n        this.m_tileCache.canEvict = (_, tile) => {\n            // Tiles can be evicted that weren't requested in the last frame.\n            return !tile.isVisible;\n        };\n    }\n\n    /**\n     * Get information how cached tiles affects cache space available.\n     *\n     * The way how cache evaluates the __resources size__ have a big influence on entire\n     * caching mechanism, if [[resourceComputationType]] is set to:\n     * [[ResourceComputationType.EstimationInMb]] then each tiles contributes to cache size\n     * differently depending on the memory consumed, on other side\n     * [[ResourceComputationType.NumberOfTiles]] says each tile occupies single slot in cache,\n     * so its real memory consumed does not matter affect caching behavior. Of course in\n     * the second scenario cache may grow significantly in terms of memory usage and thus it\n     * is out of control.\n     *\n     * @return [[ResourceComputationType]] enum that describes if resources are counted by\n     * space occupied in memory or just by number of them.\n     */\n    get resourceComputationType(): ResourceComputationType {\n        return this.m_resourceComputationType;\n    }\n\n    /**\n     * Get the cache capacity measured as number if megabytes or number of entries.\n     *\n     * The total cached tiles size determines cache saturation, if it reaches the capacity value\n     * then the resources becomes evicted (released) starting from the oldest (the latest used).\n     *\n     * @see size.\n     * @see resourceComputationType.\n     */\n    get capacity(): number {\n        return this.m_tileCache.capacity;\n    }\n\n    /**\n     * Get total cache size described as number of megabytes consumed or number of tiles stored.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     */\n    get size(): number {\n        return this.m_tileCache.size;\n    }\n\n    /**\n     * Set cache capacity and the algorithm used for cache size calculation.\n     *\n     * @see capacity.\n     * @see resourceComputationType.\n     * @param size - The new capacity declared in megabytes or number of entires.\n     * @param rct - The enum value that determines how size and capacity are evaluated.\n     */\n    setCapacity(size: number, rct: ResourceComputationType) {\n        this.m_resourceComputationType = rct;\n        this.m_tileCache.setCapacityAndMeasure(size, (tile: Tile) => {\n            if (this.m_resourceComputationType === ResourceComputationType.EstimationInMb) {\n                // Default is size in MB.\n                return tile.memoryUsage * MB_FACTOR;\n            } else {\n                return 1;\n            }\n        });\n    }\n\n    /**\n     * Get tile cached or __undefined__ if tile is not yet in cache.\n     *\n     * @param mortonCode - An unique tile morton code.\n     * @param offset - Tile offset.\n     * @param dataSource - A {@link DataSource} the tile comes from.\n     */\n    get(mortonCode: number, offset: number, dataSource: DataSource): Tile | undefined {\n        return this.m_tileCache.get(DataSourceCache.getKey(mortonCode, offset, dataSource));\n    }\n\n    /**\n     * Add new tile to the cache.\n     *\n     * @param mortonCode - En unique tile code (morton code).\n     * @param offset - The tile offset.\n     * @param dataSource - A {@link DataSource} the tile comes from.\n     * @param tile - The tile reference.\n     */\n    set(mortonCode: number, offset: number, dataSource: DataSource, tile: Tile) {\n        this.m_tileCache.set(DataSourceCache.getKey(mortonCode, offset, dataSource), tile);\n    }\n\n    /**\n     * Delete tile from cache.\n     *\n     * @note This method will not call eviction callback.\n     * @param tile - The tile reference to be removed from cache.\n     */\n    delete(tile: Tile) {\n        const tileKey = DataSourceCache.getKeyForTile(tile);\n        this.deleteByKey(tileKey);\n    }\n\n    /**\n     * Delete tile using its unique identifier.\n     *\n     * @note Tile identifier its constructed using information about tile code (morton code) and its\n     * {@link DataSource}.\n     * @note This is explicit removal thus eviction callback will not be processed.\n     * @see DataSourceCache.getKey.\n     * @param tileKey - The unique tile identifier.\n     */\n    deleteByKey(tileKey: TileCacheId) {\n        this.m_tileCache.delete(tileKey);\n    }\n\n    /**\n     * Dispose all tiles releasing their internal data.\n     */\n    disposeTiles() {\n        this.m_disposedTiles.forEach(tile => {\n            tile.dispose();\n        });\n\n        this.m_disposedTiles.length = 0;\n    }\n\n    /**\n     * Shrink cache to its allowed capacity.\n     *\n     * This method should be called each time after operations are performed on the cache entries,\n     * in order to keep cache size consistent. It informs caching mechanism to invalidate memory\n     * consumed by its entries and check if cache is overgrown, is such case some tiles will be\n     * evicted.\n     */\n    shrinkToCapacity() {\n        this.m_tileCache.shrinkToCapacity();\n    }\n\n    /**\n     * Evict all cached tiles implicitly even without checking if still in use.\n     */\n    evictAll() {\n        this.m_tileCache.evictAll();\n    }\n\n    /**\n     * Evict selected tiles implicitly.\n     *\n     * @param selector - The callback used to determine if tile should be evicted.\n     */\n    evictSelected(selector: (tile: Tile, key: TileCacheId) => boolean) {\n        this.m_tileCache.evictSelected(selector);\n    }\n\n    /**\n     * Call functor (callback) on each tile store in cache.\n     *\n     * Optionally you may specify from which {@link DataSource} tiles should be processed.\n     * This limits the tiles visited to a sub-set originating from single {@link DataSource}.\n     * @param callback - The function to be called for each visited tile.\n     * @param inDataSource - The optional {@link DataSource} to which tiles should belong.\n     */\n    forEach(callback: (tile: Tile, key: TileCacheId) => void, inDataSource?: DataSource): void {\n        this.m_tileCache.forEach((entry: Tile, key: TileCacheId) => {\n            if (inDataSource === undefined || entry.dataSource === inDataSource) {\n                callback(entry, key);\n            }\n        });\n    }\n}\n\n/**\n * List of visible tiles for a {@link DataSource}.\n */\nexport interface DataSourceTileList {\n    /**\n     * The datasource that was producing the tiles.\n     */\n    dataSource: DataSource;\n\n    /**\n     * The current {@link MapView} zoom level.\n     */\n    zoomLevel: number;\n\n    /**\n     * The storage level of the visibleTiles.\n     * Note: renderedTiles might contain tiles from different levels.\n     */\n    storageLevel: number;\n\n    /**\n     * True if all [[visibleTiles]] are loaded.\n     */\n    allVisibleTileLoaded: boolean;\n\n    /**\n     * The number of tiles which are still loading.\n     */\n    numTilesLoading: number;\n\n    /**\n     * List of tiles we want to render (i.e. the tiles computed from the zoom level and view\n     * frustum). However some might not be renderable yet (e.g. loading). See [[renderedTiles]] for\n     * the actual list of tiles that the user will see.\n     */\n    visibleTiles: Tile[];\n\n    /**\n     * Map of tiles that will be rendered, key is the the combination of tile key and offset, see\n     * [[getKeyForTileKeyAndOffset]]. This includes tiles that are not in the [[visibleTiles]]\n     * list but that are used as fallbacks b/c they are still in the cache.\n     */\n    renderedTiles: Map<number, Tile>;\n}\n\n// Sort by distance to camera, now the tiles that are further away are at the end\n// of the list.\n//\n// Sort is unstable if distance is equal, which happens a lot when looking top-down.\n// Unstable sorting makes label placement unstable at tile borders, leading to\n// flickering.\nconst compareDistances = (a: TileKeyEntry, b: TileKeyEntry) => {\n    const distanceDiff = a.distance - b.distance;\n\n    // Take care or numerical precision issues\n    const minDiff = (a.distance + b.distance) * 0.000001;\n\n    return Math.abs(distanceDiff) < minDiff\n        ? a.tileKey.mortonCode() - b.tileKey.mortonCode()\n        : distanceDiff;\n};\n\n/**\n * Manages visible {@link Tile}s for {@link MapView}.\n *\n * Responsible for election of rendered tiles:\n *  - quad-tree traversal\n *  - frustum culling\n *  - sorting tiles by relevance (visible area) to prioritize load\n *  - limiting number of visible tiles\n *  - caching tiles\n *  - searching cache to replace visible but yet empty tiles with already loaded siblings in nearby\n *    zoom levels\n */\nexport class VisibleTileSet {\n    dataSourceTileList: DataSourceTileList[] = [];\n    allVisibleTilesLoaded: boolean = false;\n\n    private readonly m_cameraOverride = new THREE.PerspectiveCamera();\n    private readonly m_dataSourceCache: DataSourceCache;\n    private m_viewRange: ViewRanges = {\n        near: 0.1,\n        far: Infinity,\n        minimum: 0.1,\n        maximum: Infinity\n    };\n\n    // Maps morton codes to a given Tile, used to find overlapping Tiles. We only need to have this\n    // for a single TilingScheme, i.e. that of the BackgroundDataSource.\n    private readonly m_coveringMap = new Map<number, Tile>();\n\n    private m_resourceComputationType: ResourceComputationType =\n        ResourceComputationType.EstimationInMb;\n\n    constructor(\n        private readonly m_frustumIntersection: FrustumIntersection,\n        private readonly m_tileGeometryManager: TileGeometryManager,\n        public options: VisibleTileSetOptions,\n        private readonly m_taskQueue: TaskQueue\n    ) {\n        this.options = options;\n        this.options.maxTilesPerFrame = Math.floor(this.options.maxTilesPerFrame ?? 0);\n        this.m_resourceComputationType =\n            options.resourceComputationType === undefined\n                ? ResourceComputationType.EstimationInMb\n                : options.resourceComputationType;\n        this.m_dataSourceCache = new DataSourceCache(\n            this.options.tileCacheSize,\n            this.m_resourceComputationType\n        );\n    }\n\n    /**\n     * Returns cache size.\n     */\n    getDataSourceCacheSize(): number {\n        return this.options.tileCacheSize;\n    }\n\n    /**\n     * Sets cache size.\n     *\n     * @param size - cache size\n     * @param computationType - Optional value specifying the way a {@link Tile}s cache usage is\n     *      computed, either based on size in MB (mega bytes) or in number of tiles. Defaults to\n     *      `ResourceComputationType.EstimationInMb`.\n     */\n    setDataSourceCacheSize(\n        size: number,\n        computationType: ResourceComputationType = ResourceComputationType.EstimationInMb\n    ): void {\n        this.options.tileCacheSize = size;\n        // This effectively invalidates DataSourceCache\n        this.resourceComputationType = computationType;\n    }\n\n    /**\n     * Retrieves maximum number of visible tiles.\n     */\n    getNumberOfVisibleTiles() {\n        return this.options.maxVisibleDataSourceTiles;\n    }\n\n    /**\n     * Sets maximum number of visible tiles.\n     *\n     * @param size - size of visible tiles array\n     */\n    setNumberOfVisibleTiles(size: number) {\n        this.options.maxVisibleDataSourceTiles = size;\n    }\n\n    /**\n     * Gets the maximum number of tiles that can be added to the scene per frame\n     * @beta\n     * @internal\n     */\n    get maxTilesPerFrame(): number {\n        return this.options.maxTilesPerFrame;\n    }\n\n    /**\n     * Gets the maximum number of tiles that can be added to the scene per frame\n     * @beta\n     * @internal\n     * @param value\n     */\n    set maxTilesPerFrame(value: number) {\n        if (value < 0) {\n            throw new Error(\"Invalid value, this will result in no tiles ever showing\");\n        }\n        this.options.maxTilesPerFrame = Math.floor(value);\n    }\n\n    /**\n     * The way the cache usage is computed, either based on size in MB (mega bytes) or in number of\n     * tiles.\n     */\n    get resourceComputationType(): ResourceComputationType {\n        return this.m_resourceComputationType;\n    }\n\n    /**\n     * Sets the way tile cache is managing its elements.\n     *\n     * Cache may be either keeping number of elements stored or the memory consumed by them.\n     *\n     * @param computationType - Type of algorith used in cache for checking full saturation,\n     * may be counting number of elements or memory consumed by them.\n     */\n    set resourceComputationType(computationType: ResourceComputationType) {\n        this.m_resourceComputationType = computationType;\n        this.m_dataSourceCache.setCapacity(this.options.tileCacheSize, computationType);\n    }\n\n    /**\n     * Evaluate frustum near/far clip planes and visibility ranges.\n     */\n    updateClipPlanes(maxElevation?: number, minElevation?: number): ViewRanges {\n        if (maxElevation !== undefined) {\n            this.options.clipPlanesEvaluator.maxElevation = maxElevation;\n        }\n        if (minElevation !== undefined) {\n            this.options.clipPlanesEvaluator.minElevation = minElevation;\n        }\n        const { camera, projection, elevationProvider } = this.m_frustumIntersection.mapView;\n        this.m_viewRange = this.options.clipPlanesEvaluator.evaluateClipPlanes(\n            camera,\n            projection,\n            elevationProvider\n        );\n        return this.m_viewRange;\n    }\n\n    /**\n     * Calculates a new set of visible tiles.\n     * @param storageLevel - The camera storage level, see {@link MapView.storageLevel}.\n     * @param zoomLevel - The camera zoom level.\n     * @param dataSources - The data sources for which the visible tiles will be calculated.\n     * @param elevationRangeSource - Source of elevation range data if any.\n     * @returns view ranges and their status since last update (changed or not).\n     */\n    updateRenderList(\n        storageLevel: number,\n        zoomLevel: number,\n        dataSources: DataSource[],\n        frameNumber: number,\n        elevationRangeSource?: ElevationRangeSource\n    ): { viewRanges: ViewRanges; viewRangesChanged: boolean } {\n        let allVisibleTilesLoaded: boolean = true;\n        // This isn't really const, because we pass by ref to the methods below.\n        const newTilesPerFrame = 0;\n\n        const visibleTileKeysResult = this.getVisibleTileKeysForDataSources(\n            zoomLevel,\n            dataSources,\n            elevationRangeSource\n        );\n        this.dataSourceTileList = [];\n        this.m_coveringMap.clear();\n        for (const { dataSource, visibleTileKeys } of visibleTileKeysResult.tileKeys) {\n            visibleTileKeys.sort(compareDistances);\n\n            // Create actual tiles only for the allowed number of visible tiles\n            const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);\n\n            const visibleResult = this.processVisibleTiles(\n                visibleTileKeys,\n                dataSource,\n                frameNumber,\n                {\n                    newTilesPerFrame\n                },\n                true\n            );\n            const dependentResult = this.processVisibleTiles(\n                visibleResult.dependentTiles,\n                dataSource,\n                frameNumber,\n                {\n                    newTilesPerFrame\n                },\n                false\n            );\n            // creates geometry if not yet available\n            this.m_tileGeometryManager.updateTiles(visibleResult.visibleTiles);\n            this.m_tileGeometryManager.updateTiles(dependentResult.visibleTiles);\n            // used to actually render the tiles or find alternatives for incomplete tiles\n            this.dataSourceTileList.push({\n                dataSource,\n                storageLevel,\n                zoomLevel: dataZoomLevel,\n                allVisibleTileLoaded:\n                    visibleResult.allDataSourceTilesLoaded &&\n                    dependentResult.allDataSourceTilesLoaded,\n                numTilesLoading: visibleResult.numTilesLoading + dependentResult.numTilesLoading,\n                visibleTiles: [...visibleResult.visibleTiles, ...dependentResult.visibleTiles],\n                renderedTiles: new Map<number, Tile>()\n            });\n            allVisibleTilesLoaded = allVisibleTilesLoaded && visibleResult.allDataSourceTilesLoaded;\n        }\n\n        this.allVisibleTilesLoaded =\n            allVisibleTilesLoaded && visibleTileKeysResult.allBoundingBoxesFinal;\n\n        this.populateRenderedTiles();\n\n        this.forEachCachedTile(tile => {\n            // Remove all tiles that are still being loaded, but are no longer visible. They have to\n            // be reloaded when they become visible again. Hopefully, they are still in the browser\n            // cache by then.\n            if (!tile.isVisible && !tile.allGeometryLoaded) {\n                // The internal TileLoader is cancelled automatically when the Tile is disposed.\n                this.disposeTile(tile);\n            }\n        });\n\n        this.m_dataSourceCache.shrinkToCapacity();\n\n        let minElevation: number | undefined;\n        let maxElevation: number | undefined;\n        this.dataSourceTileList.forEach(renderListEntry => {\n            // Calculate min/max elevation from every data source tiles,\n            // data sources without elevationRangeSource will contribute to\n            // values with zero levels for both elevations.\n            const tiles = renderListEntry.renderedTiles;\n            tiles.forEach(tile => {\n                tile.update(renderListEntry.zoomLevel);\n                minElevation = MathUtils.min2(minElevation, tile.geoBox.minAltitude);\n                maxElevation = MathUtils.max2(maxElevation, tile.geoBox.maxAltitude);\n            });\n        });\n\n        if (minElevation === undefined) {\n            minElevation = 0;\n        }\n        if (maxElevation === undefined) {\n            maxElevation = 0;\n        }\n        // If clip planes evaluator depends on the tiles elevation re-calculate\n        // frustum planes and update the camera near/far plane distances.\n        let viewRangesChanged: boolean = false;\n        const oldViewRanges = this.m_viewRange;\n        const newViewRanges = this.updateClipPlanes(maxElevation, minElevation);\n        viewRangesChanged = viewRangesEqual(newViewRanges, oldViewRanges) === false;\n\n        return {\n            viewRanges: newViewRanges,\n            viewRangesChanged\n        };\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source, key and offset, creating it if\n     * necessary.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param tileKey - The key identifying the tile.\n     * @param offset - Tile offset.\n     * @param frameNumber - Frame in which the tile was requested\n     * @return The tile if it was found or created, undefined otherwise.\n     */\n    getTile(\n        dataSource: DataSource,\n        tileKey: TileKey,\n        offset: number,\n        frameNumber: number\n    ): Tile | undefined {\n        const cacheOnly = false;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the cache.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param tileKey - The key identifying the tile.\n     * @param offset - Tile offset.\n     * @param frameNumber - Frame in which the tile was requested\n     * @return The tile if found in cache, undefined otherwise.\n     */\n    getCachedTile(\n        dataSource: DataSource,\n        tileKey: TileKey,\n        offset: number,\n        frameNumber: number\n    ): Tile | undefined {\n        assert(dataSource.cacheable);\n        const cacheOnly = true;\n        return this.getTileImpl(dataSource, tileKey, offset, cacheOnly, frameNumber);\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source, key and offset from the rendered tiles.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param tileKey - The key identifying the tile.\n     * @param offset - Tile offset.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTile(\n        dataSource: DataSource,\n        tileKey: TileKey,\n        offset: number = 0\n    ): Tile | undefined {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n\n        return dataSourceVisibleTileList.renderedTiles.get(\n            TileKeyUtils.getKeyForTileKeyAndOffset(tileKey, offset)\n        );\n    }\n\n    /**\n     * Gets the tile corresponding to the given data source and location from the rendered tiles.\n     *\n     * @param dataSource - The data source the tile belongs to.\n     * @param geoPoint - The geolocation included within the tile.\n     * @return The tile if found among the rendered tiles, undefined otherwise.\n     */\n    getRenderedTileAtLocation(\n        dataSource: DataSource,\n        geoPoint: GeoCoordinates,\n        offset: number = 0\n    ): Tile | undefined {\n        const dataSourceVisibleTileList = this.dataSourceTileList.find(list => {\n            return list.dataSource === dataSource;\n        });\n\n        if (dataSourceVisibleTileList === undefined) {\n            return undefined;\n        }\n\n        const tilingScheme = dataSource.getTilingScheme();\n        const visibleLevel = dataSourceVisibleTileList.zoomLevel;\n        const visibleTileKey = tilingScheme.getTileKey(geoPoint, visibleLevel);\n\n        if (!visibleTileKey) {\n            return undefined;\n        }\n\n        let tile = dataSourceVisibleTileList.renderedTiles.get(\n            TileKeyUtils.getKeyForTileKeyAndOffset(visibleTileKey, offset)\n        );\n\n        if (tile !== undefined) {\n            return tile;\n        }\n\n        const { searchLevelsUp, searchLevelsDown } = this.getSearchDirection(\n            dataSource,\n            visibleLevel\n        );\n\n        let parentTileKey = visibleTileKey;\n        for (let levelOffset = 1; levelOffset <= searchLevelsUp; ++levelOffset) {\n            parentTileKey = parentTileKey.parent();\n\n            tile = dataSourceVisibleTileList.renderedTiles.get(\n                TileKeyUtils.getKeyForTileKeyAndOffset(parentTileKey, offset)\n            );\n            if (tile !== undefined) {\n                return tile;\n            }\n        }\n\n        const worldPoint = tilingScheme.projection.projectPoint(geoPoint);\n\n        for (let levelOffset = 1; levelOffset <= searchLevelsDown; ++levelOffset) {\n            const childLevel = visibleLevel + levelOffset;\n            const childTileKey = TileKeyUtils.worldCoordinatesToTileKey(\n                tilingScheme,\n                worldPoint,\n                childLevel\n            );\n            if (childTileKey) {\n                tile = dataSourceVisibleTileList.renderedTiles.get(\n                    TileKeyUtils.getKeyForTileKeyAndOffset(childTileKey, offset)\n                );\n\n                if (tile !== undefined) {\n                    return tile;\n                }\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Removes all internal bookkeeping entries and cache related to specified datasource.\n     *\n     * Called by {@link MapView} when {@link DataSource} has been removed from {@link MapView}.\n     */\n    removeDataSource(dataSource: DataSource) {\n        this.clearTileCache(dataSource);\n        this.dataSourceTileList = this.dataSourceTileList.filter(\n            tileList => tileList.dataSource !== dataSource\n        );\n    }\n\n    /**\n     * Clear the tile cache.\n     *\n     * Remove the {@link Tile} objects created by cacheable {@link DataSource}.\n     * If a {@link DataSource} name is\n     * provided, this method restricts the eviction\n     * the {@link DataSource} with the given name.\n     *\n     * @param dataSourceName - The name of the {@link DataSource}.\n     * @param filter Optional tile filter\n     */\n    clearTileCache(dataSource?: DataSource, filter?: (tile: Tile) => boolean) {\n        if (dataSource !== undefined) {\n            this.m_dataSourceCache.evictSelected((tile: Tile, _) => {\n                return (\n                    tile.dataSource === dataSource && (filter !== undefined ? filter(tile) : true)\n                );\n            });\n        } else if (filter !== undefined) {\n            this.m_dataSourceCache.evictSelected(filter);\n        } else {\n            this.m_dataSourceCache.evictAll();\n        }\n    }\n\n    /**\n     * Visit each tile in visible, rendered, and cached sets.\n     *\n     *  * Visible and temporarily rendered tiles will be marked for update and retained.\n     *  * Cached but not rendered/visible will be evicted.\n     *\n     * @param dataSource - If passed, only the tiles from this {@link DataSource} instance\n     *      are processed. If `undefined`, tiles from all {@link DataSource}s are processed.\n     * @param filter Optional tile filter\n     */\n    markTilesDirty(dataSource?: DataSource, filter?: (tile: Tile) => boolean) {\n        if (dataSource === undefined) {\n            this.dataSourceTileList.forEach(renderListEntry => {\n                this.markDataSourceTilesDirty(renderListEntry, filter);\n            });\n        } else {\n            const renderListEntry = this.dataSourceTileList.find(e => e.dataSource === dataSource);\n            if (renderListEntry === undefined) {\n                return;\n            }\n            this.markDataSourceTilesDirty(renderListEntry, filter);\n        }\n    }\n\n    /**\n     * Dispose tiles that are marked for removal by {@link @here/harp-lrucache#LRUCache} algorithm.\n     */\n    disposePendingTiles() {\n        this.m_dataSourceCache.disposeTiles();\n    }\n\n    /**\n     * Process callback function [[fun]] with each visible tile in set.\n     *\n     * @param fun - The callback function to be called.\n     */\n    forEachVisibleTile(fun: (tile: Tile) => void): void {\n        for (const listEntry of this.dataSourceTileList) {\n            listEntry.renderedTiles.forEach(fun);\n        }\n    }\n\n    /**\n     * Process callback function [[fun]] with each tile in the cache.\n     *\n     * Optional [[dataSource]] parameter limits processing to the tiles that belongs to\n     * DataSource passed in.\n     *\n     * @param fun - The callback function to be called.\n     * @param dataSource - The optional DataSource reference for tiles selection.\n     */\n    forEachCachedTile(fun: (tile: Tile) => void, dataSource?: DataSource): void {\n        this.m_dataSourceCache.forEach((tile, _) => fun(tile), dataSource);\n    }\n\n    /**\n     * Dispose a `Tile` from cache, 'dispose()' is also called on the tile to free its resources.\n     */\n    disposeTile(tile: Tile): void {\n        // TODO: Consider using evict here!\n        this.m_dataSourceCache.delete(tile);\n        tile.dispose();\n    }\n\n    // Requests the tiles using the tilekeys from the DataSource and returns them, including whether\n    // all tiles were loaded and how many are loading.\n    private processVisibleTiles(\n        visibleTileKeys: TileKeyEntry[],\n        dataSource: DataSource,\n        frameNumber: number,\n        // Must be passed by reference\n        refs: {\n            newTilesPerFrame: number;\n        },\n        processDependentTiles: boolean\n    ): {\n        allDataSourceTilesLoaded: boolean;\n        numTilesLoading: number;\n        visibleTiles: Tile[];\n        dependentTiles: TileKeyEntry[];\n    } {\n        let allDataSourceTilesLoaded = true;\n        let numTilesLoading = 0;\n        const visibleTiles: Tile[] = [];\n        const dependentTiles: TileKeyEntry[] = [];\n        for (\n            let i = 0;\n            i < visibleTileKeys.length &&\n            visibleTiles.length < this.options.maxVisibleDataSourceTiles;\n            i++\n        ) {\n            const tileEntry = visibleTileKeys[i];\n            const tile = this.getTile(dataSource, tileEntry.tileKey, tileEntry.offset, frameNumber);\n            if (tile === undefined) {\n                continue;\n            }\n            visibleTiles.push(tile);\n\n            allDataSourceTilesLoaded = allDataSourceTilesLoaded && tile.allGeometryLoaded;\n            if (!tile.allGeometryLoaded) {\n                numTilesLoading++;\n            } else {\n                // If this tile's data source is \"covering\" then other tiles beneath it have\n                // their rendering skipped, see [[Tile.willRender]].\n                this.skipOverlappedTiles(dataSource, tile);\n                if (this.processDelayTileRendering(tile, refs.newTilesPerFrame, frameNumber)) {\n                    refs.newTilesPerFrame++;\n                }\n            }\n            // Update the visible area of the tile. This is used for those tiles that are\n            // currently loaded and are waiting to be decoded to sort the jobs by area.\n            tile.visibleArea = tileEntry.area;\n            tile.elevationRange = tileEntry.elevationRange ?? { minElevation: 0, maxElevation: 0 };\n\n            if (processDependentTiles) {\n                // Add any dependent tileKeys if not already visible. Consider to optimize with a\n                // Set if this proves to be a bottleneck (because of O(n^2) search). Given the fact\n                // that dependencies are rare and used for non tiled data, this shouldn't be a\n                // problem.\n                for (const tileKey of tile.dependencies) {\n                    if (\n                        visibleTileKeys.find(\n                            tileKeyEntry =>\n                                tileKeyEntry.tileKey.mortonCode() === tileKey.mortonCode()\n                        ) === undefined &&\n                        // Check that we haven't already added this TileKey\n                        dependentTiles.find(\n                            tileKeyEntry =>\n                                tileKeyEntry.tileKey.mortonCode() === tileKey.mortonCode()\n                        ) === undefined\n                    ) {\n                        dependentTiles.push(new TileKeyEntry(tileKey, 0));\n                    }\n                }\n            }\n        }\n\n        return {\n            allDataSourceTilesLoaded,\n            numTilesLoading,\n            visibleTiles,\n            dependentTiles\n        };\n    }\n\n    // Processes if the tile should delay its rendering, returns if the tile is new, which is needed\n    // to count how many tiles are generated per frame.\n    private processDelayTileRendering(\n        tile: Tile,\n        newTilesPerFrame: number,\n        frameNumber: number\n    ): boolean {\n        let isNewTile: boolean = false;\n        if (\n            // if set to 0, it will ignore the limit and upload all available\n            this.options.maxTilesPerFrame !== 0 &&\n            newTilesPerFrame > this.options.maxTilesPerFrame &&\n            //if the tile was already visible last frame dont delay it\n            !(tile.frameNumLastVisible === frameNumber - 1)\n        ) {\n            tile.delayRendering = true;\n            tile.mapView.update();\n        } else {\n            if (tile.frameNumVisible < 0) {\n                // Store the fist frame the tile became visible.\n                tile.frameNumVisible = frameNumber;\n                isNewTile = true;\n            }\n            tile.numFramesVisible++;\n            tile.delayRendering = false;\n        }\n        return isNewTile;\n    }\n\n    /**\n     * Skips rendering of tiles that are overlapped. The overlapping {@link Tile} comes from a\n     * {@link DataSource} which is fully covering, i.e. there it is fully opaque.\n     **/\n    private skipOverlappedTiles(dataSource: DataSource, tile: Tile) {\n        if (this.options.projection.type === ProjectionType.Spherical) {\n            // HARP-7899, currently the globe has no background planes in the tiles (it relies on\n            // the BackgroundDataSource), because the LOD mismatches, hence disabling for globe.\n            return;\n        }\n        if (dataSource.isFullyCovering()) {\n            const key = tile.uniqueKey;\n            const entry = this.m_coveringMap.get(key);\n            if (entry === undefined) {\n                // We need to reset the flag so that if the covering datasource is disabled, that\n                // the tiles beneath then start to render.\n                tile.skipRendering = false;\n                this.m_coveringMap.set(key, tile);\n            } else {\n                // Skip the Tile if either the stored entry or the tile to consider is from the\n                // [[BackgroundDataSource]]\n                if (entry.dataSource instanceof BackgroundDataSource) {\n                    entry.skipRendering = true;\n                } else if (dataSource instanceof BackgroundDataSource) {\n                    tile.skipRendering = true;\n                }\n            }\n        }\n    }\n\n    // Returns the search direction and the number of levels up / down that can be searched.\n    private getSearchDirection(\n        dataSource: DataSource,\n        visibleLevel: number\n    ): {\n        searchDirection: SearchDirection;\n        searchLevelsUp: number;\n        searchLevelsDown: number;\n    } {\n        const searchLevelsUp = Math.min(\n            this.options.quadTreeSearchDistanceUp,\n            Math.max(0, visibleLevel - dataSource.minDataLevel)\n        );\n        const searchLevelsDown = Math.min(\n            this.options.quadTreeSearchDistanceDown,\n            Math.max(0, dataSource.maxDataLevel - visibleLevel)\n        );\n        const searchDirection =\n            searchLevelsDown > 0 && searchLevelsUp > 0\n                ? SearchDirection.BOTH\n                : searchLevelsDown > 0\n                ? SearchDirection.DOWN\n                : searchLevelsUp > 0\n                ? SearchDirection.UP\n                : SearchDirection.NONE;\n        return { searchDirection, searchLevelsUp, searchLevelsDown };\n    }\n\n    /**\n     * Populates the list of tiles to render, see \"renderedTiles\". Tiles that are loaded and which\n     * are an exact match are added straight to the list, tiles that are still loading are replaced\n     * with tiles in the cache that are either a parent or child of the requested tile. This helps\n     * to prevent flickering when zooming in / out. The distance to search is based on the options\n     * [[quadTreeSearchDistanceDown]] and [[quadTreeSearchDistanceUp]].\n     *\n     * Each {@link DataSource} can also switch this behaviour on / off using the\n     * [[allowOverlappingTiles]] flag.\n     *\n     */\n    private populateRenderedTiles() {\n        this.dataSourceTileList.forEach(renderListEntry => {\n            const renderedTiles = renderListEntry.renderedTiles;\n\n            // Tiles for which we need to fall(back/forward) to.\n            const incompleteTiles: number[] = [];\n\n            // Populate the list of tiles which can be shown (\"renderedTiles\"), and the list of\n            // tiles that are incomplete, and for which we search for an alternative\n            // (\"incompleteTiles\").\n            renderListEntry.visibleTiles.forEach(tile => {\n                tile.levelOffset = 0;\n                if (tile.hasGeometry && !tile.delayRendering) {\n                    renderedTiles.set(tile.uniqueKey, tile);\n                } else {\n                    // if dataSource supports cache and it was existing before this render\n                    // then enable searching for loaded tiles in cache\n                    incompleteTiles.push(tile.uniqueKey);\n                }\n            });\n\n            const dataSource = renderListEntry.dataSource;\n            if (incompleteTiles.length === 0 || dataSource.allowOverlappingTiles === false) {\n                // Either all tiles are loaded or the datasource doesn't support using cached tiles\n                // from other levels.\n                return;\n            }\n\n            const dataZoomLevel = renderListEntry.zoomLevel;\n            const { searchDirection } = this.getSearchDirection(dataSource, dataZoomLevel);\n\n            // Minor optimization for the fallback search, only check parent tiles once, otherwise\n            // the recursive algorithm checks all parent tiles multiple times, the key is the code\n            // of the tile that is checked and the value is whether a parent was found or not.\n            const checkedTiles = new Map<number, boolean>();\n            // Iterate over incomplete (not loaded tiles) and find their parents or children that\n            // are in cache that can be rendered temporarily until tile is loaded. Note, we favour\n            // falling back to parent tiles rather than children.\n            for (const tileKeyCode of incompleteTiles) {\n                if (\n                    searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.UP\n                ) {\n                    if (\n                        this.findUp(\n                            tileKeyCode,\n                            dataZoomLevel,\n                            renderedTiles,\n                            checkedTiles,\n                            dataSource\n                        )\n                    ) {\n                        // Continue to next entry so we don't search down.\n                        continue;\n                    }\n                }\n\n                if (\n                    searchDirection === SearchDirection.BOTH ||\n                    searchDirection === SearchDirection.DOWN\n                ) {\n                    this.findDown(tileKeyCode, dataZoomLevel, renderedTiles, dataSource);\n                }\n            }\n        });\n    }\n\n    private findDown(\n        tileKeyCode: number,\n        dataZoomLevel: number,\n        renderedTiles: Map<number, Tile>,\n        dataSource: DataSource\n    ) {\n        const { offset, mortonCode } = TileKeyUtils.extractOffsetAndMortonKeyFromKey(tileKeyCode);\n        const tileKey = TileKey.fromMortonCode(mortonCode);\n\n        const tilingScheme = dataSource.getTilingScheme();\n        for (const childTileKey of tilingScheme.getSubTileKeys(tileKey)) {\n            const childTileCode = TileKeyUtils.getKeyForTileKeyAndOffset(childTileKey, offset);\n            const childTile = this.m_dataSourceCache.get(\n                childTileKey.mortonCode(),\n                offset,\n                dataSource\n            );\n\n            const nextLevelDiff = Math.abs(childTileKey.level - dataZoomLevel);\n            if (childTile !== undefined && childTile.hasGeometry && !childTile.delayRendering) {\n                //childTile has geometry and was/can be uploaded to the GPU,\n                //so we can use it as fallback\n                renderedTiles.set(childTileCode, childTile);\n                childTile.levelOffset = nextLevelDiff;\n                continue;\n            }\n\n            // Recurse down until the max distance is reached.\n            if (nextLevelDiff < this.options.quadTreeSearchDistanceDown) {\n                this.findDown(childTileCode, dataZoomLevel, renderedTiles, dataSource);\n            }\n        }\n    }\n\n    /**\n     * Returns true if a tile was found in the cache which is a parent\n     * @param tileKeyCode - Morton code of the current tile that should be searched for.\n     * @param dataZoomLevel - The current data zoom level of tiles that are to be displayed.\n     * @param renderedTiles - The list of tiles that are shown to the user.\n     * @param checkedTiles - Used to map a given code to a boolean which tells us if an ancestor is\n     * displayed or not.\n     * @param dataSource - The provider of tiles.\n     * @returns Whether a parent tile exists.\n     */\n    private findUp(\n        tileKeyCode: number,\n        dataZoomLevel: number,\n        renderedTiles: Map<number, Tile>,\n        checkedTiles: Map<number, boolean>,\n        dataSource: DataSource\n    ): boolean {\n        const parentCode = TileKeyUtils.getParentKeyFromKey(tileKeyCode);\n        // Check if another sibling has already added the parent.\n        if (renderedTiles.get(parentCode) !== undefined) {\n            return true;\n        }\n        const exists = checkedTiles.get(parentCode)!;\n        if (exists !== undefined) {\n            return exists;\n        }\n\n        const { offset, mortonCode } = TileKeyUtils.extractOffsetAndMortonKeyFromKey(parentCode);\n        const parentTile = this.m_dataSourceCache.get(mortonCode, offset, dataSource);\n        const parentTileKey = parentTile ? parentTile.tileKey : TileKey.fromMortonCode(mortonCode);\n        const nextLevelDiff = Math.abs(dataZoomLevel - parentTileKey.level);\n        if (parentTile !== undefined && parentTile.hasGeometry && !parentTile.delayRendering) {\n            checkedTiles.set(parentCode, true);\n            // parentTile has geometry, so can be reused as fallback\n            renderedTiles.set(parentCode, parentTile);\n\n            // We want to have parent tiles as -ve, hence the minus.\n            parentTile.levelOffset = -nextLevelDiff;\n\n            return true;\n        } else {\n            checkedTiles.set(parentCode, false);\n        }\n\n        // Recurse up until the max distance is reached or we go to the parent of all parents.\n        if (nextLevelDiff < this.options.quadTreeSearchDistanceUp && parentTileKey.level !== 0) {\n            const foundUp = this.findUp(\n                parentCode,\n                dataZoomLevel,\n                renderedTiles,\n                checkedTiles,\n                dataSource\n            );\n            // If there was a tile upstream found, then add it to the list, so we can\n            // early skip checkedTiles.\n            checkedTiles.set(parentCode, foundUp);\n            if (foundUp) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private getTileImpl(\n        dataSource: DataSource,\n        tileKey: TileKey,\n        offset: number,\n        cacheOnly: boolean,\n        frameNumber: number\n    ): Tile | undefined {\n        function touchTile(tileToUpdate: Tile) {\n            // Keep the tile from being removed from the cache.\n            tileToUpdate.frameNumLastRequested = frameNumber;\n        }\n\n        if (!dataSource.cacheable && !cacheOnly) {\n            const resultTile = dataSource.getTile(tileKey, true);\n            if (resultTile !== undefined) {\n                this.addToTaskQueue(resultTile);\n                touchTile(resultTile);\n            }\n            return resultTile;\n        }\n\n        const tileCache = this.m_dataSourceCache;\n        let tile = tileCache.get(tileKey.mortonCode(), offset, dataSource);\n\n        if (tile !== undefined && tile.offset === offset) {\n            touchTile(tile);\n            return tile;\n        }\n\n        if (cacheOnly) {\n            return undefined;\n        }\n\n        tile = dataSource.getTile(tileKey, true);\n        // TODO: Update all tile information including area, min/max elevation from TileKeyEntry\n        if (tile !== undefined) {\n            this.addToTaskQueue(tile);\n            tile.offset = offset;\n            touchTile(tile);\n            tileCache.set(tileKey.mortonCode(), offset, dataSource, tile);\n        }\n        return tile;\n    }\n\n    private addToTaskQueue(tile: Tile) {\n        this.m_taskQueue.add({\n            execute: tile.load.bind(tile),\n            group: TileTaskGroups.FETCH_AND_DECODE,\n            getPriority: () => {\n                return tile?.tileLoader?.priority ?? 0;\n            },\n            isExpired: () => {\n                return !tile?.isVisible;\n            },\n            estimatedProcessTime: () => {\n                return 1;\n            }\n        });\n    }\n\n    private markDataSourceTilesDirty(\n        renderListEntry: DataSourceTileList,\n        filter?: (tile: Tile) => boolean\n    ) {\n        const dataSourceCache = this.m_dataSourceCache;\n        const retainedTiles: Set<TileCacheId> = new Set();\n\n        const markTileDirty = (tile: Tile) => {\n            const tileKey = DataSourceCache.getKeyForTile(tile);\n            if (!retainedTiles.has(tileKey)) {\n                retainedTiles.add(tileKey);\n                // We need to cancel the loader first because if we don't then the call to\n                // tileLoader.loadAndDecode() inside Tile::load will return the existing promise (if\n                // the tile is still loading) and not re-request the tile data from the provider as\n                // required.\n                tile.tileLoader?.cancel();\n                this.addToTaskQueue(tile);\n            }\n        };\n\n        renderListEntry.visibleTiles.forEach(tile => {\n            if (filter === undefined || filter(tile)) {\n                markTileDirty(tile);\n            }\n        });\n        renderListEntry.renderedTiles.forEach(tile => {\n            if (filter === undefined || filter(tile)) {\n                markTileDirty(tile);\n            }\n        });\n\n        dataSourceCache.forEach((tile, key) => {\n            if ((filter === undefined || filter(tile)) && !retainedTiles.has(key)) {\n                dataSourceCache.deleteByKey(key);\n                tile.dispose();\n            }\n        }, renderListEntry.dataSource);\n    }\n\n    // Computes the visible tile keys for each supplied data source.\n    private getVisibleTileKeysForDataSources(\n        zoomLevel: number,\n        dataSources: DataSource[],\n        elevationRangeSource: ElevationRangeSource | undefined\n    ): {\n        tileKeys: Array<{ dataSource: DataSource; visibleTileKeys: TileKeyEntry[] }>;\n        allBoundingBoxesFinal: boolean;\n    } {\n        const tileKeys = Array<{\n            dataSource: DataSource;\n            visibleTileKeys: TileKeyEntry[];\n        }>();\n        let allBoundingBoxesFinal: boolean = true;\n\n        if (dataSources.length === 0) {\n            return { tileKeys, allBoundingBoxesFinal };\n        }\n\n        const dataSourceBuckets = new Map<TilingScheme, DataSource[]>();\n        dataSources.forEach(dataSource => {\n            const tilingScheme = dataSource.getTilingScheme();\n            const bucket = dataSourceBuckets.get(tilingScheme);\n            if (bucket === undefined) {\n                dataSourceBuckets.set(tilingScheme, [dataSource]);\n            } else {\n                bucket.push(dataSource);\n            }\n        });\n\n        // If elevation is to be taken into account extend view frustum:\n        // (near ~0, far: maxVisibilityRange) that allows to consider tiles that\n        // are far below ground plane and high enough to intersect the frustum.\n        if (elevationRangeSource !== undefined) {\n            this.m_cameraOverride.copy(this.m_frustumIntersection.camera);\n            this.m_cameraOverride.near = Math.min(\n                this.m_cameraOverride.near,\n                this.m_viewRange.minimum\n            );\n            this.m_cameraOverride.far = Math.max(\n                this.m_cameraOverride.far,\n                this.m_viewRange.maximum\n            );\n            this.m_cameraOverride.updateProjectionMatrix();\n            this.m_frustumIntersection.updateFrustum(this.m_cameraOverride.projectionMatrix);\n        } else {\n            this.m_frustumIntersection.updateFrustum();\n        }\n\n        // For each bucket of data sources with same tiling scheme, calculate frustum intersection\n        // once using the maximum display level.\n        for (const [tilingScheme, bucket] of dataSourceBuckets) {\n            const zoomLevels = bucket.map(dataSource => dataSource.getDataZoomLevel(zoomLevel));\n            const result = this.m_frustumIntersection.compute(\n                tilingScheme,\n                elevationRangeSource,\n                zoomLevels,\n                bucket\n            );\n\n            allBoundingBoxesFinal = allBoundingBoxesFinal && result.calculationFinal;\n\n            for (const dataSource of bucket) {\n                // For each data source check what tiles from the intersection should be rendered\n                // at this zoom level.\n                const visibleTileKeys: TileKeyEntry[] = [];\n                const dataZoomLevel = dataSource.getDataZoomLevel(zoomLevel);\n                for (const tileKeyEntry of result.tileKeyEntries.get(dataZoomLevel)!.values()) {\n                    if (dataSource.canGetTile(dataZoomLevel, tileKeyEntry.tileKey)) {\n                        visibleTileKeys.push(tileKeyEntry);\n                    }\n                }\n                tileKeys.push({ dataSource, visibleTileKeys });\n            }\n        }\n\n        return { tileKeys, allBoundingBoxesFinal };\n    }\n}\n\nfunction viewRangesEqual(a: ViewRanges, b: ViewRanges) {\n    return (\n        a.far === b.far && a.maximum === b.maximum && a.minimum === b.minimum && a.near === b.near\n    );\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    DecoderOptions,\n    getProjectionName,\n    ITileDecoder,\n    OptionsMap,\n    RequestController,\n    TileInfo,\n    WorkerDecoderProtocol,\n    WorkerServiceProtocol\n} from \"@here/harp-datasource-protocol\";\nimport { Projection, TileKey } from \"@here/harp-geoutils\";\n\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\n\n/**\n * Identifier of next decoder worker-service. Used to ensure uniqueness of service ids of decoders\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n\n/**\n * Decoder based on [[ConcurrentWorkerSet]].\n *\n * Decodes tiles using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends decode requests,\n * - configuration.\n */\nexport class WorkerBasedDecoder implements ITileDecoder {\n    private readonly serviceId: string;\n    private m_serviceCreated: boolean = false;\n\n    /**\n     * Creates a new `WorkerBasedDecoder`.\n     *\n     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param decoderServiceType - Service type identifier.\n     */\n    constructor(\n        private readonly workerSet: ConcurrentWorkerSet,\n        private readonly decoderServiceType: string\n    ) {\n        this.workerSet.addReference();\n        this.serviceId = `${this.decoderServiceType}-${nextUniqueServiceId++}`;\n    }\n\n    /**\n     * Dispose of dedicated tile decoder services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                    type: WorkerServiceProtocol.Requests.DestroyService,\n                    targetServiceId: this.serviceId\n                })\n                .catch(() => {\n                    /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n                });\n        }\n\n        this.workerSet.removeReference();\n    }\n\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TileDecoderService]]s in all workers to serve decode requests.\n     */\n    async connect(): Promise<void> {\n        await this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(\n                WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID,\n                {\n                    type: WorkerServiceProtocol.Requests.CreateService,\n                    targetServiceType: this.decoderServiceType,\n                    targetServiceId: this.serviceId\n                }\n            );\n            this.m_serviceCreated = true;\n        }\n    }\n\n    /**\n     * Get {@link Tile} from tile decoder service in worker.\n     *\n     * @remarks\n     * Invokes {@link @here/harp-datasource-protocol#DecodeTileRequest} on\n     * [[TileDecoderService]] running in worker pool.\n     */\n    decodeTile(\n        data: ArrayBufferLike,\n        tileKey: TileKey,\n        projection: Projection,\n        requestController?: RequestController\n    ): Promise<DecodedTile> {\n        const tileKeyCode = tileKey.mortonCode();\n\n        const message: WorkerDecoderProtocol.DecodeTileRequest = {\n            type: WorkerDecoderProtocol.Requests.DecodeTileRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: getProjectionName(projection)\n        };\n\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n\n        return this.workerSet.invokeRequest(\n            this.serviceId,\n            message,\n            transferList,\n            requestController\n        );\n    }\n\n    /**\n     * Get {@link @here/harp-datasource-protocol#TileInfo} from tile decoder service in worker.\n     *\n     * @remarks\n     * Invokes {@link @here/harp-datasource-protocol#TileInfoRequest}\n     * on [[TileDecoderService]] running in worker pool.\n     */\n    getTileInfo(\n        data: ArrayBufferLike,\n        tileKey: TileKey,\n        projection: Projection,\n        requestController?: RequestController\n    ): Promise<TileInfo | undefined> {\n        const tileKeyCode = tileKey.mortonCode();\n\n        const message: WorkerDecoderProtocol.TileInfoRequest = {\n            type: WorkerDecoderProtocol.Requests.TileInfoRequest,\n            tileKey: tileKeyCode,\n            data,\n            projection: getProjectionName(projection)\n        };\n\n        const transferList = data instanceof ArrayBuffer ? [data] : undefined;\n        return this.workerSet.invokeRequest(\n            this.serviceId,\n            message,\n            transferList,\n            requestController\n        );\n    }\n\n    /**\n     * Configure tile decoder service in workers.\n     *\n     * @remarks\n     * Broadcasts {@link @here/harp-datasource-protocol#ConfigurationMessage}\n     * to all [[TileDecoderService]]s running in worker pool.\n     *\n     * @param options - Options that will be applied to the styles\n     * @param customOptions -   new options, undefined options are not changed\n     */\n    configure(options?: DecoderOptions, customOptions?: OptionsMap): void {\n        const message: WorkerDecoderProtocol.ConfigurationMessage = {\n            service: this.serviceId,\n            type: WorkerDecoderProtocol.DecoderMessageName.Configuration,\n            ...options,\n            options: customOptions\n        };\n\n        this.workerSet.broadcastMessage(message);\n    }\n\n    /**\n     * The number of workers started for this decoder. The value is `undefined` until the workers\n     * have been created.\n     */\n    get workerCount(): number | undefined {\n        return this.workerSet.workerCount;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    GeoJson,\n    ITiler,\n    WorkerServiceProtocol,\n    WorkerTilerProtocol\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\n\nimport { ConcurrentWorkerSet } from \"./ConcurrentWorkerSet\";\n\n/**\n * Identifier of next tiler worker-service. Used to ensure uniqueness of service ids of tilers\n * dedicated to different datasources.\n */\nlet nextUniqueServiceId = 0;\n\n/**\n * Tiler based on [[ConcurrentWorkerSet]].\n *\n * Tiles payloads using workers running in separate contexts (also known as `WebWorkers`):\n * - connection establishment,\n * - sends tile requests,\n * - configuration.\n */\nexport class WorkerBasedTiler implements ITiler {\n    private readonly serviceId: string;\n    private m_serviceCreated: boolean = false;\n\n    /**\n     * Creates a new `WorkerBasedTiler`.\n     *\n     * @param workerSet - [[ConcurrentWorkerSet]] this tiler will live in.\n     * @param tilerServiceType - Service type identifier.\n     */\n    constructor(\n        private readonly workerSet: ConcurrentWorkerSet,\n        private readonly tilerServiceType: string\n    ) {\n        this.workerSet.addReference();\n        this.serviceId = `${this.tilerServiceType}-${nextUniqueServiceId++}`;\n    }\n\n    /**\n     * Dispose of dedicated tiler services in workers and remove reference to underlying\n     * [[ConcurrentWorkerSet]].\n     */\n    dispose() {\n        if (this.m_serviceCreated) {\n            this.workerSet\n                .broadcastRequest(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID, {\n                    type: WorkerServiceProtocol.Requests.DestroyService,\n                    targetServiceId: this.serviceId\n                })\n                .catch(() => {\n                    /* Ignoring these errors as underlying workers possibly do not exist anymore. */\n                });\n        }\n\n        this.workerSet.removeReference();\n    }\n\n    /**\n     * Connects to [[WorkerServiceManager]]s in underlying [[ConcurrentWorkerSet]] and creates\n     * dedicated [[TilerService]]s in all workers to serve tiling requests.\n     */\n    async connect(): Promise<void> {\n        await this.workerSet.connect(WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);\n        if (!this.m_serviceCreated) {\n            await this.workerSet.broadcastRequest(\n                WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID,\n                {\n                    type: WorkerServiceProtocol.Requests.CreateService,\n                    targetServiceType: this.tilerServiceType,\n                    targetServiceId: this.serviceId\n                }\n            );\n\n            this.m_serviceCreated = true;\n        }\n    }\n\n    /**\n     * Register index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId - Index identifier.\n     * @param input - Url to the index payload, or direct GeoJSON.\n     */\n    registerIndex(indexId: string, input: URL | GeoJson): Promise<void> {\n        const message: WorkerTilerProtocol.RegisterIndexRequest = {\n            type: WorkerTilerProtocol.Requests.RegisterIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : (input as GeoJson)\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n\n    /**\n     * Update index in the tiler. Indexes registered in the tiler can be later used to retrieved\n     * tiled payloads using `getTile`.\n     *\n     * @param indexId - Index identifier.\n     * @param input - Url to the index payload, or direct GeoJSON.\n     */\n    updateIndex(indexId: string, input: URL | GeoJson): Promise<void> {\n        const message: WorkerTilerProtocol.UpdateIndexRequest = {\n            type: WorkerTilerProtocol.Requests.UpdateIndex,\n            id: indexId,\n            input: input instanceof URL ? input.href : (input as GeoJson)\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n\n    /**\n     * Retrieves a tile for a previously registered index.\n     *\n     * @param indexId - Index identifier.\n     * @param tileKey - The {@link @here/harp-geoutils#TileKey} that identifies the tile.\n     */\n    getTile(indexId: string, tileKey: TileKey): Promise<{}> {\n        const tileKeyCode = tileKey.mortonCode();\n        const message: WorkerTilerProtocol.TileRequest = {\n            type: WorkerTilerProtocol.Requests.TileRequest,\n            index: indexId,\n            tileKey: tileKeyCode\n        };\n        return this.workerSet.invokeRequest(this.serviceId, message);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CopyMaterial, CopyShader } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { Pass } from \"./Pass\";\n\n/**\n * The `LowResRenderPass` renders the scene at a lower resolution into an internal\n * `WebGLRenderTarget`, and then copies the result into the frame buffer. The size of the internal\n * buffer is determined by the current frame buffer size multiplied by `pixelRatio`.\n *\n * @note Since no anti-aliasing is applied during dynamic rendering, visual artifacts may be\n * visible.\n */\nexport class LowResRenderPass extends Pass {\n    private m_renderTarget: THREE.WebGLRenderTarget | null = null;\n    private readonly m_localCamera: THREE.OrthographicCamera = new THREE.OrthographicCamera(\n        -1,\n        1,\n        1,\n        -1,\n        0,\n        1\n    );\n\n    private readonly m_quadScene: THREE.Scene = new THREE.Scene();\n    private readonly m_quadUniforms: { [uniformName: string]: THREE.IUniform } =\n        CopyShader.uniforms;\n\n    private readonly m_quadMaterial: THREE.ShaderMaterial = new CopyMaterial(this.m_quadUniforms);\n    private readonly m_quad: THREE.Mesh = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry(2, 2),\n        this.m_quadMaterial\n    );\n\n    private m_pixelRatio: number | undefined;\n    private m_savedWidth = 0;\n    private m_savedHeight = 0;\n\n    /**\n     * The constructor for `LowResRenderPass`. It builds an internal scene with a camera looking at\n     * a quad.\n     *\n     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     */\n    constructor(public lowResPixelRatio?: number) {\n        super();\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n        this.m_pixelRatio = lowResPixelRatio;\n    }\n\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        this.m_quadMaterial.dispose();\n        this.m_quad.geometry.dispose();\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n\n    /**\n     * If a value is specified, a low resolution render pass is used to render the scene into a\n     * low resolution render target, before it is copied to the screen.\n     *\n     * A value of `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     *\n     * @default `undefined`\n     */\n    set pixelRatio(ratio: number | undefined) {\n        this.m_pixelRatio = ratio;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(\n                Math.floor(this.m_savedWidth * this.pixelRatio),\n                Math.floor(this.m_savedHeight * this.pixelRatio)\n            );\n        }\n    }\n\n    get pixelRatio(): number | undefined {\n        return this.m_pixelRatio;\n    }\n\n    /**\n     * The render function of `LowResRenderPass`. It renders the whole scene into an internal\n     * `WebGLRenderTarget` instance with a lower resolution, using the passed in `WebGLRenderer`.\n     * The low resolution image is then copied to the `writeBuffer`, which is `undefined` in case it\n     * is the screen.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene - The ThreeJS Scene instance to render the scene with.\n     * @param camera - The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.\n     * @override\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget\n    ) {\n        if (!this.enabled || this.pixelRatio === undefined) {\n            return;\n        }\n\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_savedWidth = readBuffer.width;\n            this.m_savedHeight = readBuffer.height;\n            this.m_renderTarget = new THREE.WebGLRenderTarget(\n                Math.floor(this.m_savedWidth * this.pixelRatio),\n                Math.floor(this.m_savedHeight * this.pixelRatio),\n                {\n                    minFilter: THREE.LinearFilter,\n                    magFilter: THREE.LinearFilter,\n                    format: THREE.RGBAFormat,\n                    depthBuffer: true,\n                    stencilBuffer: true\n                }\n            );\n            this.m_renderTarget.texture.name = \"LowResRenderPass.sample\";\n        }\n\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n        this.m_quadUniforms.opacity.value = 1.0;\n\n        const oldRenderTarget = renderer.getRenderTarget();\n        renderer.setRenderTarget(this.m_renderTarget);\n        renderer.clear();\n        // Render into the low resolution internal render target.\n        renderer.render(scene, camera);\n\n        // Render the low resolution target into the screen.\n        // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.clear();\n        renderer.render(this.m_quadScene, this.m_localCamera);\n        renderer.setRenderTarget(oldRenderTarget);\n    }\n\n    /**\n     * Resize the internal render target to match the new size specified. The size of internal\n     * buffer depends on the `pixelRatio`.\n     *\n     * @param width - New width to apply to the render target.\n     * @param height - New height to apply to the render target.\n     * @override\n     */\n    setSize(width: number, height: number) {\n        this.m_savedWidth = width;\n        this.m_savedHeight = height;\n        if (this.m_renderTarget && this.pixelRatio !== undefined) {\n            this.m_renderTarget.setSize(\n                Math.floor(width * this.pixelRatio),\n                Math.floor(height * this.pixelRatio)\n            );\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { CopyShader, MSAAMaterial } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { Pass } from \"./Pass\";\n\n/**\n * This enum represents the sampling level to apply to\n * a {@link MSAARenderPass} instance. At level 0,\n * only one sample is performed, which is like\n * disabling the MSAA pass.\n */\nexport enum MSAASampling {\n    \"Level_0\",\n    \"Level_1\",\n    \"Level_2\",\n    \"Level_3\",\n    \"Level_4\",\n    \"Level_5\"\n}\n\n/**\n * {@link MapView}'s MSAA implementation.\n *\n * @remarks\n * MSAA stands for Multi Sampling Anti-Aliasing, and its concept\n * is to provide a rendering engine with additional color values for each pixel, so they can include\n * the missing bits between them on a screen. WebGL already comes with a native MSAA implementation\n * with four samples. Because of its native nature, it is more efficient and one may not want to use\n * MapView's MSAA implementation when these four samples are satisfying. However in some situations\n * they are not: on low devices, MSAA can impact the framerate and we may desire to reduce the\n * number of samples at runtime. On the other hand, when the interaction stops, the engine also\n * stops rendering the map, and because a map relies on many line-like patterns, aliasing can then\n * turn very noticeable. In such static renders, the number of samples could be dramatically\n * increased on a last frame to render.\n */\nexport class MSAARenderPass extends Pass {\n    /**\n     * The sampling level determines the number of samples that will be performed per frame.\n     * Renders will happen `2 ^ samplingLevel` time(s). `samplingLevel` stands between `0` and `5`.\n     * Therefore there can be between 1 and 32 samples.\n     *\n     * @default `SamplingLevel.Level_1`\n     */\n    samplingLevel: MSAASampling = MSAASampling.Level_1;\n\n    private m_renderTarget: THREE.WebGLRenderTarget | null = null;\n    private readonly m_localCamera: THREE.OrthographicCamera = new THREE.OrthographicCamera(\n        -1,\n        1,\n        1,\n        -1,\n        0,\n        1\n    );\n\n    private readonly m_quadScene: THREE.Scene = new THREE.Scene();\n    private readonly m_quadUniforms: { [uniformName: string]: THREE.IUniform } =\n        CopyShader.uniforms;\n\n    private readonly m_quadMaterial: THREE.ShaderMaterial = new MSAAMaterial(this.m_quadUniforms);\n    private readonly m_quad: THREE.Mesh = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry(2, 2),\n        this.m_quadMaterial\n    );\n\n    private readonly m_tmpColor = new THREE.Color();\n\n    /**\n     * The constructor for `MSAARenderPass`. It builds an internal scene with a camera looking at a\n     * quad.\n     *\n     * @param m_scene - The scene to render.\n     * @param m_camera - The camera to render the scene through.\n     */\n    constructor() {\n        super();\n        this.m_quad.frustumCulled = false;\n        this.m_quadScene.add(this.m_quad);\n    }\n\n    /**\n     * Releases all used resources.\n     */\n    dispose() {\n        if (this.m_renderTarget !== null) {\n            this.m_renderTarget.dispose();\n            this.m_renderTarget = null;\n        }\n    }\n\n    /**\n     * The render function of `MSAARenderPass`.\n     *\n     * @remarks\n     * At each call of this method, and for each sample the {@link MapView}\n     * camera provided in the `render method is offset within the dimension of a\n     * pixel on screen. It then renders the whole scene with this offset to a local\n     * `WebGLRenderTarget` instance, via a `WebGLRenderer` instance. Finally the local camera\n     * created in the constructor shoots the quad and renders to the write buffer or to the frame\n     * buffer. The quad material's opacity is modified so the renders can accumulate in the\n     * targetted buffer.\n     *\n     * The number of samples can be modified at runtime through the enum [[SamplingLevel]].\n     *\n     * If there is no further pass, the {@link Pass.renderToScreen} flag can be set to `true` to\n     * output directly to the framebuffer.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the scene with.\n     * @param scene - The ThreeJS Scene instance to render the scene with.\n     * @param camera - The ThreeJS Camera instance to render the scene with.\n     * @param writeBuffer - A ThreeJS WebGLRenderTarget instance to render the scene to.\n     * @param readBuffer - A ThreeJS WebGLRenderTarget instance to render the scene.\n     * @override\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget\n    ) {\n        if (!this.enabled) {\n            return;\n        }\n\n        // Initiates the local render target with the read buffer's dimensions, if not available.\n        if (this.m_renderTarget === null) {\n            this.m_renderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, {\n                minFilter: THREE.LinearFilter,\n                magFilter: THREE.LinearFilter,\n                format: THREE.RGBAFormat\n            });\n            this.m_renderTarget.texture.name = \"MSAARenderPass.sample\";\n        }\n        this.m_quadUniforms.tDiffuse.value = this.m_renderTarget.texture;\n\n        const offsets = MSAARenderPass.OffsetVectors[this.samplingLevel];\n\n        const rendererClearColor = renderer.getClearColor(this.m_tmpColor);\n        const oldClearColor = rendererClearColor !== undefined ? rendererClearColor.getHex() : 0;\n\n        // The method `camera.setViewOffset` will be called in the next loop. In order to maintain\n        // its usability externally (like for the triple view in mosaic demo) we must cache the\n        // previous values stored in `camera.view` and re-assign them at the end of the pass.\n\n        // 1. Create a default cache object, with default dimensions the size of our read buffer.\n        const oldView = {\n            enabled: camera.view !== null && camera.view.enabled,\n            fullWidth: readBuffer.width,\n            fullHeight: readBuffer.height,\n            x: 0,\n            y: 0,\n            width: readBuffer.width,\n            height: readBuffer.height\n        };\n\n        // 2. If `camera.view` has been enabled previously, then `setViewOffset` has been called\n        // externally: copy the existing `camera.view` values in the cache. Override the cache\n        // object with the values provided externally.\n        if (oldView.enabled && camera.view !== null) {\n            oldView.fullWidth = camera.view.fullWidth;\n            oldView.fullHeight = camera.view.fullHeight;\n            oldView.x = camera.view.offsetX;\n            oldView.y = camera.view.offsetY;\n            oldView.width = camera.view.width;\n            oldView.height = camera.view.height;\n        }\n\n        const oldRenderTarget = renderer.getRenderTarget();\n        for (let i = 0; i < offsets.length; i++) {\n            // 4. Then for each sample, call `setViewOffset` with our object. This also updates the\n            // `camera.view` object in Three.js.\n            const offset = offsets[i];\n            camera.setViewOffset(\n                oldView.fullWidth,\n                oldView.fullHeight,\n                oldView.x + offset[0] / 16,\n                oldView.y + offset[1] / 16,\n                oldView.width,\n                oldView.height\n            );\n\n            // 5. Divide the opacity of the quad by the number of samples to accumulate on the\n            // target buffer, and reduce the impact of the offset on color to reduce banding. Then\n            // render.\n            const uniformCenteredDistribution = -0.5 + (i + 0.5) / offsets.length;\n            const sampleWeight = 1.0 / offsets.length + uniformCenteredDistribution / 32;\n\n            this.m_quadUniforms.opacity.value = sampleWeight;\n\n            renderer.setRenderTarget(this.m_renderTarget);\n            renderer.clear();\n            renderer.render(scene, camera);\n\n            // 6. Render the quad on top of the previous renders.\n\n            // NOTE: three.js doesn't like undefined as renderTarget, but works with `null`\n            renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n            if (i === 0) {\n                renderer.setClearColor(0x000000);\n                renderer.clear();\n            }\n            renderer.render(this.m_quadScene, this.m_localCamera);\n            if (i === 0 && rendererClearColor !== undefined) {\n                renderer.setClearColor(oldClearColor);\n            }\n        }\n        renderer.setRenderTarget(oldRenderTarget);\n\n        // 7. Restore `camera.view` as set externally (or not).\n        if (camera.view !== null) {\n            camera.view.enabled = oldView.enabled;\n            camera.view.offsetX = oldView.x;\n            camera.view.offsetY = oldView.y;\n        }\n    }\n\n    /**\n     * Resize the internal render target to match the new size specified.\n     *\n     * @param width - New width to apply to the render target.\n     * @param height - New height to apply to the render target.\n     * @override\n     */\n    setSize(width: number, height: number) {\n        if (this.m_renderTarget) {\n            this.m_renderTarget.setSize(width, height);\n        }\n    }\n\n    /**\n     * The list of offsets to apply to the camera, per sampling level, adapted from :\n     *\n     * @see https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\n     */\n    static readonly OffsetVectors: number[][][] = [\n        [[0, 0]],\n        [\n            [4, 4],\n            [-4, -4]\n        ],\n        [\n            [-2, -6],\n            [6, -2],\n            [-6, 2],\n            [2, 6]\n        ],\n        [\n            [1, -3],\n            [-1, 3],\n            [5, 1],\n            [-3, -5],\n            [-5, 5],\n            [-7, -1],\n            [3, 7],\n            [7, -7]\n        ],\n        [\n            [1, 1],\n            [-1, -3],\n            [-3, 2],\n            [4, -1],\n            [-5, -2],\n            [2, 5],\n            [5, 3],\n            [3, -5],\n            [-2, 6],\n            [0, -7],\n            [-4, -6],\n            [-6, 4],\n            [-8, 0],\n            [7, -4],\n            [6, 7],\n            [-7, -8]\n        ],\n        [\n            [-4, -7],\n            [-7, -5],\n            [-3, -5],\n            [-5, -4],\n            [-1, -4],\n            [-2, -2],\n            [-6, -1],\n            [-4, 0],\n            [-7, 1],\n            [-1, 2],\n            [-6, 3],\n            [-3, 3],\n            [-7, 6],\n            [-3, 6],\n            [-5, 7],\n            [-1, 7],\n            [5, -7],\n            [1, -6],\n            [6, -5],\n            [4, -4],\n            [2, -3],\n            [7, -2],\n            [1, -1],\n            [4, -1],\n            [2, 1],\n            [6, 2],\n            [0, 4],\n            [4, 4],\n            [2, 5],\n            [7, 5],\n            [5, 6],\n            [3, 7]\n        ]\n    ];\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    IBloomEffect,\n    IOutlineEffect,\n    ISepiaEffect,\n    IVignetteEffect\n} from \"@here/harp-datasource-protocol\";\nimport { SepiaShader, VignetteShader } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { IPassManager } from \"./IPassManager\";\nimport { LowResRenderPass } from \"./LowResRenderPass\";\nimport { MSAARenderPass, MSAASampling } from \"./MSAARenderPass\";\nimport { OutlineEffect } from \"./Outline\";\nimport { RenderPass, ShaderPass } from \"./Pass\";\nimport { BloomPass } from \"./UnrealBloomPass\";\n\nconst DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL = MSAASampling.Level_1;\nconst DEFAULT_STATIC_MSAA_SAMPLING_LEVEL = MSAASampling.Level_4;\n\n/**\n * Interface for the antialias settings passed when instantiating\n * a {@link MapView}, and transferred to\n * the {@link MapRenderingManager} instance.\n *\n * @remarks\n * These parameters can be changed at runtime as opposed to\n * the native WebGL antialiasing.\n */\nexport interface IMapAntialiasSettings {\n    /**\n     * Whether the MSAA is enabled or not.\n     *\n     * @default `false`\n     */\n    msaaEnabled: boolean;\n\n    /**\n     * The sampling level to use for MSAA during continuous rendering.\n     *\n     * @default `MSAASampling.Level_1`\n     */\n    dynamicMsaaSamplingLevel?: MSAASampling;\n\n    /**\n     * The sampling level to use for MSAA when the rendering stops.\n     *\n     * @default `MSAASampling.Level_4`\n     */\n    staticMsaaSamplingLevel?: MSAASampling;\n}\n\n/**\n * The `MapRenderingManager` class manages the map rendering (as opposed to text) by dispatching the\n * {@link MapRenderingManager.render} call to a set of internal {@link Pass} instances.\n *\n * @remarks It provides an API to modify some of the rendering\n * processes like the antialiasing behaviour at runtime.\n */\nexport interface IMapRenderingManager extends IPassManager {\n    /**\n     * Bloom effect parameters.\n     */\n    bloom: IBloomEffect;\n\n    /**\n     * Outline effect parameters.\n     */\n    outline: IOutlineEffect;\n\n    /**\n     * Vignette effect parameters.\n     */\n    vignette: IVignetteEffect;\n\n    /**\n     * Sepia effect parameters.\n     */\n    sepia: ISepiaEffect;\n\n    /**\n     * Set a `pixelRatio` for dynamic rendering (i.e. during animations). If a value is specified,\n     * the `LowResRenderPass` will be employed to used to render the scene into a lower resolution\n     * render target, which will then be rendered to the screen.\n     */\n    lowResPixelRatio?: number;\n\n    /**\n     * The level of MSAA sampling while the user interacts. It should be a low level so that the\n     * MSAA does not impact the framerate.\n     */\n    dynamicMsaaSamplingLevel: MSAASampling;\n\n    /**\n     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided\n     * in the {@link MapRenderingManager.render} method to render the scene.\n     */\n    msaaEnabled: boolean;\n\n    /**\n     * The higher level of MSAA sampling for a last frame to render, when the camera is static. It\n     * can be a high level, providing high quality renders requiring few tens of seconds, since no\n     * frame is expected to immediately follow in the requestAnimationFrame. It is still limited by\n     * zooming, since zooming is not requestAnimationFrame-based and can lead to stuttering if the\n     * render time is too long, except on desktop Mac, where mouse interaction already implements\n     * some damping. Higher levels of sampling may lead to noticeable color banding, visible in\n     * areas with a slight color gradient, like large areas or the sky background.\n     */\n    staticMsaaSamplingLevel: MSAASampling;\n\n    /**\n     * The method to call to render the map. This method depends on an `isStaticFrame` boolean that\n     * notifies the pass manager to switch to a higher level render quality for the last frame.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the map with.\n     * @param isStaticFrame - Whether the frame to render is static or dynamic. Selects level of\n     * antialiasing.\n     * @param time - Optional time argument provided by the requestAnimationFrame, to pass to\n     * sub-passes.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        isStaticFrame: boolean,\n        time?: number\n    ): void;\n\n    /**\n     * Updating the outline rebuilds the outline materials of every outlined mesh.\n     *\n     * @param options - outline options from the {@link @here/harp-datasource-protocol#Theme}.\n     */\n    updateOutline(options: {\n        thickness: number;\n        color: string;\n        ghostExtrudedPolygons: boolean;\n    }): void;\n}\n\n/**\n * The implementation of {@link IMapRenderingManager} to\n * instantiate in {@link MapView} and manage the map\n * rendering.\n */\nexport class MapRenderingManager implements IMapRenderingManager {\n    bloom = {\n        enabled: false,\n        strength: 1.5,\n        radius: 0.4,\n        threshold: 0.85\n    };\n\n    outline = {\n        enabled: false,\n        thickness: 0.005,\n        color: \"#000000\",\n        ghostExtrudedPolygons: false,\n        needsUpdate: false\n    };\n\n    vignette = {\n        enabled: false,\n        offset: 1.0,\n        darkness: 1.0\n    };\n\n    sepia = {\n        enabled: false,\n        amount: 0.5\n    };\n\n    private m_width: number = 1;\n    private m_height: number = 1;\n\n    private m_outlineEffect?: OutlineEffect;\n    private m_msaaPass: MSAARenderPass;\n    private readonly m_renderPass: RenderPass = new RenderPass();\n    private readonly m_target1: THREE.WebGLRenderTarget = new THREE.WebGLRenderTarget(1, 1);\n    private readonly m_target2: THREE.WebGLRenderTarget = new THREE.WebGLRenderTarget(1, 1);\n    private m_bloomPass?: BloomPass;\n    private m_sepiaPass: ShaderPass = new ShaderPass(SepiaShader);\n    private m_vignettePass: ShaderPass = new ShaderPass(VignetteShader);\n    private readonly m_readBuffer: THREE.WebGLRenderTarget;\n    private m_dynamicMsaaSamplingLevel: MSAASampling;\n    private m_staticMsaaSamplingLevel: MSAASampling;\n    private m_lowResPass: LowResRenderPass;\n\n    /**\n     * The constructor of `MapRenderingManager`.\n     *\n     * @param width - Width of the frame buffer.\n     * @param height - Height of the frame buffer.\n     * @param lowResPixelRatio - The `pixelRatio` determines the resolution of the internal\n     *  `WebGLRenderTarget`. Values between 0.5 and `window.devicePixelRatio` can be tried to give\n     * good results. A value of `undefined` disables the low res render pass. The value should not\n     * be larger than`window.devicePixelRatio`.\n     * @param antialiasSetting - The object defining the demeanor of MSAA.\n     */\n    constructor(\n        width: number,\n        height: number,\n        lowResPixelRatio: number | undefined,\n        antialiasSettings: IMapAntialiasSettings | undefined = { msaaEnabled: false }\n    ) {\n        this.m_readBuffer = new THREE.WebGLRenderTarget(width, height);\n        this.m_msaaPass = new MSAARenderPass();\n        this.m_msaaPass.enabled =\n            antialiasSettings !== undefined ? antialiasSettings.msaaEnabled === true : false;\n        this.m_dynamicMsaaSamplingLevel =\n            antialiasSettings.dynamicMsaaSamplingLevel === undefined\n                ? DEFAULT_DYNAMIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.dynamicMsaaSamplingLevel;\n        this.m_staticMsaaSamplingLevel =\n            antialiasSettings.staticMsaaSamplingLevel === undefined\n                ? DEFAULT_STATIC_MSAA_SAMPLING_LEVEL\n                : antialiasSettings.staticMsaaSamplingLevel;\n        this.m_lowResPass = new LowResRenderPass(lowResPixelRatio);\n        this.m_lowResPass.enabled = lowResPixelRatio !== undefined;\n    }\n\n    updateOutline(options: { thickness: number; color: string; ghostExtrudedPolygons: boolean }) {\n        this.outline.color = options.color;\n        this.outline.thickness = options.thickness;\n        this.outline.ghostExtrudedPolygons = options.ghostExtrudedPolygons;\n        this.outline.needsUpdate = true;\n    }\n\n    /**\n     * The method to call to render the map with the `MapRenderingManager` instance. It contains the\n     * chain of sub-passes that can transfer the write and read buffers, and other sheer rendering\n     * conditions as disabling AA when a high DPI device is in use.\n     *\n     * @param renderer - The ThreeJS WebGLRenderer instance to render the map with.\n     * @param scene - The ThreeJS Scene instance containing the map objects to render.\n     * @param camera - The ThreeJS Camera instance to render the scene through.\n     * @param isStaticFrame - Whether the frame to render is static or dynamic. Selects level of\n     * antialiasing.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,\n        isStaticFrame: boolean\n    ) {\n        const target = null;\n        if (!isStaticFrame && this.m_lowResPass.pixelRatio !== undefined) {\n            // Not designed to be combined with our own MSAA\n            this.m_lowResPass.renderToScreen = true;\n            this.m_lowResPass.render(renderer, scene, camera, target, this.m_readBuffer);\n            return;\n        }\n\n        const usePostEffects =\n            this.bloom.enabled ||\n            this.outline.enabled ||\n            this.vignette.enabled ||\n            this.sepia.enabled;\n\n        let activeTarget: null | THREE.WebGLRenderTarget = null;\n\n        // 1. If the bloom is enabled, clear the depth.\n        if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n            renderer.setRenderTarget(this.m_target1);\n            renderer.clearDepth();\n        }\n\n        // 2. Render the map.\n\n        if (this.m_msaaPass.enabled) {\n            // Use a higher MSAA sampling level for static rendering.\n            this.m_msaaPass.samplingLevel = isStaticFrame\n                ? this.m_staticMsaaSamplingLevel\n                : this.m_dynamicMsaaSamplingLevel;\n            // MSAA is the only effect for the moment.\n            this.m_msaaPass.renderToScreen = !usePostEffects;\n            // Render to the specified target with the MSAA pass.\n            this.m_msaaPass.render(renderer, scene, camera, target, this.m_readBuffer);\n        } else {\n            if (this.bloom.enabled || this.vignette.enabled || this.sepia.enabled) {\n                activeTarget = this.m_target1;\n                this.m_renderPass.render(renderer, scene, camera, this.m_target1, null!);\n            } else if (!this.outline.enabled || (this.outline.enabled && !this.bloom.enabled)) {\n                renderer.render(scene, camera);\n            }\n        }\n\n        // 3. Apply effects\n        if (this.outline.enabled) {\n            if (this.m_outlineEffect === undefined) {\n                this.m_outlineEffect = new OutlineEffect(renderer);\n            }\n            if (this.outline.needsUpdate) {\n                this.m_outlineEffect.color = this.outline.color;\n                this.m_outlineEffect.thickness = this.outline.thickness;\n                this.m_outlineEffect.ghostExtrudedPolygons = this.outline.ghostExtrudedPolygons;\n                this.outline.needsUpdate = false;\n            }\n            const nextEffectEnabled =\n                this.bloom.enabled || this.vignette.enabled || this.sepia.enabled;\n            if (nextEffectEnabled) {\n                activeTarget = this.m_target1;\n            }\n            renderer.setRenderTarget(nextEffectEnabled ? activeTarget : null!);\n            this.m_outlineEffect.render(scene, camera);\n        }\n\n        if (this.bloom.enabled) {\n            if (this.m_bloomPass === undefined) {\n                this.m_bloomPass = new BloomPass(\n                    new THREE.Vector2(this.m_width, this.m_height),\n                    this.bloom.strength,\n                    this.bloom.radius,\n                    this.bloom.threshold\n                );\n            }\n            const nextEffectEnabled = this.vignette.enabled || this.sepia.enabled;\n            this.m_bloomPass.renderToScreen = !nextEffectEnabled;\n            this.m_bloomPass.radius = this.bloom.radius;\n            this.m_bloomPass.strength = this.bloom.strength;\n            this.m_bloomPass.threshold = this.bloom.threshold;\n            this.m_bloomPass.render(renderer, scene, camera, null!, activeTarget!);\n        } else if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.dispose();\n            this.m_bloomPass = undefined;\n        }\n\n        if (this.vignette.enabled) {\n            const oldTarget = activeTarget!;\n            const nextEffectEnabled = this.sepia.enabled;\n            this.m_vignettePass.uniforms.offset.value = this.vignette.offset;\n            this.m_vignettePass.uniforms.darkness.value = this.vignette.darkness;\n            this.m_vignettePass.renderToScreen = !nextEffectEnabled;\n            if (nextEffectEnabled) {\n                activeTarget = activeTarget === this.m_target1 ? this.m_target2 : this.m_target1;\n            }\n            this.m_vignettePass.render(renderer, scene, camera, activeTarget!, oldTarget);\n        }\n\n        if (this.sepia.enabled) {\n            this.m_sepiaPass.renderToScreen = true;\n            this.m_sepiaPass.uniforms.amount.value = this.sepia.amount;\n            this.m_sepiaPass.render(renderer, scene, camera, null!, activeTarget!);\n        }\n    }\n\n    /**\n     * The resize function to call on resize events to resize the render targets. It shall include\n     * the resize methods of all the sub-passes used in `MapRenderingManager`.\n     *\n     * @param width - New width to use.\n     * @param height - New height to use.\n     */\n    setSize(width: number, height: number) {\n        this.m_readBuffer.setSize(width, height);\n        this.m_msaaPass.setSize(width, height);\n        if (this.m_bloomPass !== undefined) {\n            this.m_bloomPass.setSize(width, height);\n        }\n        this.m_lowResPass.setSize(width, height);\n        this.m_target1.setSize(width, height);\n        this.m_target2.setSize(width, height);\n        this.m_width = width;\n        this.m_height = height;\n    }\n\n    /**\n     * The `lowResPixelRatio` determines the resolution of the internal `WebGLRenderTarget`. Values\n     * between 0.5 and `window.devicePixelRatio` can be tried to give  good results. A value of\n     * `undefined` disables the low res render pass. The value should not be larger than\n     * `window.devicePixelRatio`.\n     */\n    get lowResPixelRatio(): number | undefined {\n        return this.m_lowResPass.pixelRatio;\n    }\n\n    set lowResPixelRatio(pixelRatio: number | undefined) {\n        this.m_lowResPass.pixelRatio = pixelRatio;\n        this.m_lowResPass.enabled = pixelRatio !== undefined;\n    }\n\n    /**\n     * Set the level of sampling while the user interacts.\n     *\n     * @param samplingLevel - The sampling level.\n     */\n    set dynamicMsaaSamplingLevel(samplingLevel: MSAASampling) {\n        this.m_dynamicMsaaSamplingLevel = samplingLevel;\n    }\n\n    /**\n     * Return the sampling level defined during continuous rendering.\n     */\n    get dynamicMsaaSamplingLevel(): MSAASampling {\n        return this.m_dynamicMsaaSamplingLevel;\n    }\n\n    /**\n     * Enable or disable the MSAA. If disabled, `MapRenderingManager` will use the renderer provided\n     * in the {@link MapRenderingManager.render} method to render the scene.\n     *\n     * @param value - If `true`, MSAA is enabled, disabled otherwise.\n     */\n    set msaaEnabled(value: boolean) {\n        this.m_msaaPass.enabled = value;\n    }\n\n    /**\n     * Return whether the MSAA is enabled.\n     */\n    get msaaEnabled(): boolean {\n        return this.m_msaaPass.enabled;\n    }\n\n    /**\n     * Set the sampling level for rendering static frames.\n     *\n     * @param samplingLevel - The sampling level.\n     */\n    set staticMsaaSamplingLevel(samplingLevel: MSAASampling) {\n        this.m_staticMsaaSamplingLevel = samplingLevel;\n    }\n\n    /**\n     * Return the sampling level defined for rendering static frames.\n     */\n\n    get staticMsaaSamplingLevel(): MSAASampling {\n        return this.m_staticMsaaSamplingLevel;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    EdgeMaterial,\n    ExtrusionFeatureDefs,\n    FadingFeature,\n    MixinShaderProperties,\n    UniformsType\n} from \"@here/harp-materials\";\nimport { chainCallbacks } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { DepthPrePassProperties } from \"../DepthPrePass\";\n\nconst vertexShaderChunk = `\n#ifdef USE_EXTRUSION\n  #ifndef HAS_EXTRUSION_PARS_VERTEX\n    #include <extrusion_pars_vertex>\n  #endif\n#endif\n\n#ifdef USE_FADING\n  #include <fading_pars_vertex>\n#endif\n\nuniform float outlineThickness;\n\nvec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {\n    float thickness = outlineThickness;\n    const float ratio = 1.0;\n    vec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );\n    vec4 norm = normalize( pos - pos2 );\n    return pos + norm * thickness * pos.w * ratio;\n}`;\n\nconst vertexShaderChunk2 = `\n#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( STANDARD )\n    #ifndef USE_ENVMAP\n        vec3 objectNormal = normalize( normal );\n    #endif\n#endif\n\n#ifdef FLIP_SIDED\n    objectNormal = -objectNormal;\n#endif\n\n#ifdef DECLARE_TRANSFORMED\n    vec3 transformed = vec3( position );\n#endif\n\n#ifdef USE_EXTRUSION\n #ifndef HAS_EXTRUSION_VERTEX\n  #include <extrusion_vertex>\n #endif\n#endif\n\n#ifdef USE_FADING\n  #include <fading_vertex>\n#endif\n\n#ifdef USE_EXTRUSION\n  gl_Position = calculateOutline( projectionMatrix * modelViewMatrix * vec4( transformed, 1.0 ),\n      objectNormal, vec4( transformed, 1.0 ) );\n#else\n  gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );\n#endif\n\n#include <fog_vertex>`;\n\nconst fragmentShader = `\n#include <common>\n#include <fog_pars_fragment>\n\n#ifdef USE_EXTRUSION\n  #include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n  #include <fading_pars_fragment>\n#endif\n\nuniform vec3 outlineColor;\nuniform float outlineAlpha;\n\nvoid main() {\n\n    gl_FragColor = vec4( outlineColor, outlineAlpha );\n\n    #include <fog_fragment>\n\n    #ifdef USE_EXTRUSION\n      #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n      #include <fading_fragment>\n    #endif\n}`;\n\n/**\n * Effect to render bold lines around extruded polygons.\n *\n * Implemented by rendering the mesh geometries with an outline material before rendering them\n * again with their original.\n */\nexport class OutlineEffect {\n    enabled: boolean = true;\n\n    autoClear: boolean;\n    domElement: HTMLCanvasElement;\n    shadowMap: THREE.WebGLShadowMap;\n\n    private m_defaultThickness: number = 0.02;\n    private readonly m_defaultColor: THREE.Color = new THREE.Color(0, 0, 0);\n    private readonly m_defaultAlpha: number = 1;\n    private readonly m_defaultKeepAlive: boolean = false;\n    private m_ghostExtrudedPolygons: boolean = false;\n\n    private m_cache: any = {};\n    private readonly m_removeThresholdCount: number = 60;\n    private m_originalMaterials: any = {};\n    private m_originalOnBeforeRenders: any = {};\n\n    private readonly m_shaderIDs: { [key: string]: string } = {\n        MeshBasicMaterial: \"basic\",\n        MeshLambertMaterial: \"lambert\",\n        MeshPhongMaterial: \"phong\",\n        MeshToonMaterial: \"phong\",\n        MeshStandardMaterial: \"physical\",\n        MeshPhysicalMaterial: \"physical\"\n    };\n\n    private readonly m_uniformsChunk = {\n        outlineThickness: { value: this.m_defaultThickness },\n        outlineColor: { value: this.m_defaultColor },\n        outlineAlpha: { value: this.m_defaultAlpha }\n    };\n\n    constructor(private m_renderer: THREE.WebGLRenderer) {\n        this.autoClear = m_renderer.autoClear;\n        this.domElement = m_renderer.domElement;\n        this.shadowMap = m_renderer.shadowMap;\n    }\n\n    set thickness(thickness: number) {\n        this.m_defaultThickness = thickness;\n        this.m_uniformsChunk.outlineThickness.value = thickness;\n        this.m_cache = {};\n    }\n\n    set color(color: string) {\n        this.m_defaultColor.set(color);\n        this.m_cache = {};\n    }\n\n    set ghostExtrudedPolygons(ghost: boolean) {\n        this.m_ghostExtrudedPolygons = ghost;\n    }\n\n    clear(color: boolean, depth: boolean, stencil: boolean) {\n        this.m_renderer.clear(color, depth, stencil);\n    }\n\n    getPixelRatio() {\n        return this.m_renderer.getPixelRatio();\n    }\n\n    setPixelRatio(value: number) {\n        this.m_renderer.setPixelRatio(value);\n    }\n\n    getSize(target: THREE.Vector2) {\n        return this.m_renderer.getSize(target);\n    }\n\n    setSize(width: number, height: number, updateStyle: boolean) {\n        this.m_renderer.setSize(width, height, updateStyle);\n    }\n\n    setViewport(x: number, y: number, width: number, height: number) {\n        this.m_renderer.setViewport(x, y, width, height);\n    }\n\n    setScissor(x: number, y: number, width: number, height: number) {\n        this.m_renderer.setScissor(x, y, width, height);\n    }\n\n    setScissorTest(boolean: boolean) {\n        this.m_renderer.setScissorTest(boolean);\n    }\n\n    setRenderTarget(renderTarget: THREE.WebGLRenderTarget) {\n        this.m_renderer.setRenderTarget(renderTarget);\n    }\n\n    render(scene: THREE.Scene, camera: THREE.Camera) {\n        // Re-rendering the scene with the outline effect enables to hide the\n        // extruded polygons and show only the outlines (it is a hack and should be\n        // implemented another way!).\n        if (this.m_ghostExtrudedPolygons) {\n            if (!this.enabled) {\n                this.m_renderer.render(scene, camera);\n                return;\n            }\n\n            const currentAutoClear = this.m_renderer.autoClear;\n            this.m_renderer.autoClear = this.autoClear;\n\n            this.m_renderer.render(scene, camera);\n\n            this.m_renderer.autoClear = currentAutoClear;\n        }\n\n        this.renderOutline(scene, camera);\n    }\n\n    renderOutline(scene: THREE.Scene, camera: THREE.Camera) {\n        const currentAutoClear = this.m_renderer.autoClear;\n        const currentSceneAutoUpdate = scene.autoUpdate;\n        const currentSceneBackground = scene.background;\n        const currentShadowMapEnabled = this.m_renderer.shadowMap.enabled;\n\n        scene.autoUpdate = false;\n        scene.background = null;\n        this.m_renderer.autoClear = false;\n        this.m_renderer.shadowMap.enabled = false;\n\n        scene.traverse(this.setOutlineMaterial.bind(this));\n\n        this.m_renderer.render(scene, camera);\n\n        scene.traverse(this.restoreOriginalMaterial.bind(this));\n\n        this.cleanupCache();\n\n        scene.autoUpdate = currentSceneAutoUpdate;\n        scene.background = currentSceneBackground;\n        this.m_renderer.autoClear = currentAutoClear;\n        this.m_renderer.shadowMap.enabled = currentShadowMapEnabled;\n    }\n\n    private createInvisibleMaterial() {\n        return new THREE.ShaderMaterial({ name: \"invisible\", visible: false });\n    }\n\n    private createMaterial(originalMaterial: THREE.Material) {\n        // EdgeMaterial or depth prepass material should not be used for outlines.\n        if (\n            originalMaterial instanceof EdgeMaterial ||\n            (originalMaterial as DepthPrePassProperties).isDepthPrepassMaterial === true\n        ) {\n            return this.createInvisibleMaterial();\n        }\n\n        const shaderID = this.m_shaderIDs[originalMaterial.type];\n        let originalVertexShader;\n\n        let originalUniforms: UniformsType | undefined =\n            (originalMaterial as MixinShaderProperties).shaderUniforms !== undefined\n                ? (originalMaterial as MixinShaderProperties).shaderUniforms\n                : (originalMaterial as THREE.ShaderMaterial).uniforms;\n\n        if (shaderID !== undefined) {\n            const shader = THREE.ShaderLib[shaderID];\n            originalUniforms = shader.uniforms;\n            originalVertexShader = shader.vertexShader;\n        } else if ((originalMaterial as any).isRawShaderMaterial === true) {\n            originalVertexShader = (originalMaterial as any).vertexShader;\n\n            if (\n                !/attribute\\s+vec3\\s+position\\s*;/.test(originalVertexShader) ||\n                !/attribute\\s+vec3\\s+normal\\s*;/.test(originalVertexShader)\n            ) {\n                return this.createInvisibleMaterial();\n            }\n        } else if ((originalMaterial as any).isShaderMaterial === true) {\n            originalVertexShader = (originalMaterial as any).vertexShader;\n        } else {\n            return this.createInvisibleMaterial();\n        }\n\n        const isExtrusionMaterial =\n            (originalMaterial as MixinShaderProperties).shaderUniforms !== undefined &&\n            (originalMaterial as any).shaderUniforms.extrusionRatio !== undefined;\n\n        const isFadingMaterial = FadingFeature.isDefined(originalMaterial as FadingFeature);\n\n        const uniforms: UniformsType = { ...originalUniforms, ...this.m_uniformsChunk };\n\n        const vertexShader = originalVertexShader\n            // put vertexShaderChunk right before \"void main() {...}\"\n            .replace(/void\\s+main\\s*\\(\\s*\\)/, vertexShaderChunk + \"\\nvoid main()\")\n            // put vertexShaderChunk2 the end of \"void main() {...}\"\n            // Note: here assums originalVertexShader ends with \"}\" of \"void main() {...}\"\n            .replace(/\\}\\s*$/, vertexShaderChunk2 + \"\\n}\")\n            // remove any light related lines\n            // Note: here is very sensitive to originalVertexShader\n            // TODO: consider safer way\n            .replace(/#include\\s+<[\\w_]*light[\\w_]*>/g, \"\");\n\n        const defines: any = {};\n\n        if (\n            !/vec3\\s+transformed\\s*=/.test(originalVertexShader) &&\n            !/#include\\s+<begin_vertex>/.test(originalVertexShader)\n        ) {\n            (defines as any).DECLARE_TRANSFORMED = true;\n        }\n\n        if (isExtrusionMaterial) {\n            // If the original material is setup for animated extrusion (like buildings), add the\n            // uniform describing the extrusion to the outline material.\n            uniforms.extrusionRatio = { value: ExtrusionFeatureDefs.DEFAULT_RATIO_MIN };\n            defines.USE_EXTRUSION = 1;\n        }\n\n        if (isFadingMaterial) {\n            uniforms.fadeNear = {\n                value:\n                    originalUniforms!.fadeNear !== undefined\n                        ? originalUniforms!.fadeNear.value\n                        : FadingFeature.DEFAULT_FADE_NEAR\n            };\n            uniforms.fadeFar = {\n                value:\n                    originalUniforms!.fadeFar !== undefined\n                        ? originalUniforms!.fadeFar.value\n                        : FadingFeature.DEFAULT_FADE_FAR\n            };\n            defines.USE_FADING = 1;\n        }\n\n        const outlineMaterial = new THREE.ShaderMaterial({\n            defines,\n            uniforms,\n            vertexShader,\n            fragmentShader,\n            side: THREE.BackSide,\n            morphTargets: false,\n            morphNormals: false,\n            fog: false,\n            blending: THREE.CustomBlending,\n            blendSrc: THREE.SrcAlphaFactor,\n            blendDst: THREE.OneMinusSrcAlphaFactor,\n            blendSrcAlpha: THREE.OneFactor,\n            blendDstAlpha: THREE.OneMinusSrcAlphaFactor,\n            transparent: true,\n            polygonOffset: true,\n            // Extreme values used here to reduce artifacts, especially at tile borders.\n            polygonOffsetFactor: 10.0,\n            polygonOffsetUnits: 30.0\n        });\n\n        return outlineMaterial;\n    }\n\n    private getOutlineMaterialFromCache(originalMaterial: THREE.Material) {\n        let data = this.m_cache[originalMaterial.uuid];\n\n        if (data === undefined) {\n            data = {\n                material: this.createMaterial(originalMaterial),\n                used: true,\n                keepAlive: this.m_defaultKeepAlive,\n                count: 0\n            };\n\n            this.m_cache[originalMaterial.uuid] = data;\n        }\n\n        data.used = true;\n\n        return data.material;\n    }\n\n    private getOutlineMaterial(originalMaterial: THREE.Material) {\n        const outlineMaterial = this.getOutlineMaterialFromCache(originalMaterial);\n\n        this.m_originalMaterials[outlineMaterial.uuid] = originalMaterial;\n\n        this.updateOutlineMaterial(outlineMaterial, originalMaterial);\n\n        return outlineMaterial;\n    }\n\n    private setOutlineMaterial(object: THREE.Object3D) {\n        if ((object as THREE.Mesh).material === undefined) {\n            return;\n        }\n\n        if (Array.isArray((object as THREE.Mesh).material)) {\n            for (\n                let i = 0, il = ((object as THREE.Mesh).material as THREE.Material[]).length;\n                i < il;\n                i++\n            ) {\n                ((object as THREE.Mesh).material as THREE.Material[])[i] = this.getOutlineMaterial(\n                    ((object as THREE.Mesh).material as THREE.Material[])[i]\n                );\n            }\n        } else {\n            (object as THREE.Mesh).material = this.getOutlineMaterial(\n                (object as THREE.Mesh).material as THREE.Material\n            );\n        }\n\n        this.m_originalOnBeforeRenders[object.uuid] = object.onBeforeRender;\n        object.onBeforeRender = chainCallbacks(\n            object.onBeforeRender,\n            this.onBeforeRender.bind(this)\n        );\n    }\n\n    private restoreOriginalMaterial(object: THREE.Object3D) {\n        if ((object as THREE.Mesh).material === undefined) {\n            return;\n        }\n\n        if (Array.isArray((object as THREE.Mesh).material)) {\n            for (\n                let i = 0, il = ((object as THREE.Mesh).material as THREE.Material[]).length;\n                i < il;\n                i++\n            ) {\n                ((object as THREE.Mesh).material as THREE.Material[])[i] = this.m_originalMaterials[\n                    ((object as THREE.Mesh).material as THREE.Material[])[i].uuid\n                ];\n            }\n        } else {\n            (object as THREE.Mesh).material = this.m_originalMaterials[\n                ((object as THREE.Mesh).material as THREE.Material).uuid\n            ];\n        }\n\n        object.onBeforeRender = this.m_originalOnBeforeRenders[object.uuid];\n    }\n\n    private onBeforeRender(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        geometry: THREE.BufferGeometry,\n        material: THREE.Material,\n        group: THREE.Group\n    ) {\n        const originalMaterial = this.m_originalMaterials[material.uuid];\n\n        // just in case\n        if (originalMaterial === undefined) {\n            return;\n        }\n\n        this.updateUniforms(material, originalMaterial);\n    }\n\n    private updateUniforms(material: THREE.Material, originalMaterial: THREE.Material) {\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n\n        const outlineUniforms = (material as THREE.ShaderMaterial).uniforms;\n        outlineUniforms.outlineAlpha.value = originalMaterial.opacity;\n\n        const originalUniforms =\n            (originalMaterial as any).shaderUniforms !== undefined\n                ? (originalMaterial as any).shaderUniforms\n                : (originalMaterial as any).uniforms;\n\n        if (outlineParameters !== undefined) {\n            if (outlineParameters.thickness !== undefined) {\n                outlineUniforms.outlineThickness.value = outlineParameters.thickness;\n            }\n            if (outlineParameters.color !== undefined) {\n                outlineUniforms.outlineColor.value.fromArray(outlineParameters.color);\n            }\n            if (outlineParameters.alpha !== undefined) {\n                outlineUniforms.outlineAlpha.value = outlineParameters.alpha;\n            }\n        }\n\n        // If the original material is setup for animated extrusion (like buildings), update the\n        // uniforms in the outline material.\n        if (originalUniforms !== undefined && originalUniforms.extrusionRatio !== undefined) {\n            const value = (originalMaterial as any).shaderUniforms.extrusionRatio.value;\n            (material as any).extrusionRatio = value;\n            (material as any).uniforms.extrusionRatio.value =\n                value !== undefined ? value : ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;\n        }\n\n        // Copy available fading params to the outline material.\n        if (\n            material.defines?.USE_FADING !== undefined &&\n            originalUniforms.fadeNear !== undefined &&\n            originalUniforms.fadeFar !== undefined &&\n            originalUniforms.fadeFar.value >= 0.0\n        ) {\n            outlineUniforms.fadeNear.value = originalUniforms.fadeNear.value;\n            outlineUniforms.fadeFar.value = originalUniforms.fadeFar.value;\n        }\n    }\n\n    private updateOutlineMaterial(material: THREE.Material, originalMaterial: THREE.Material) {\n        if (material.name === \"invisible\") {\n            return;\n        }\n\n        const outlineParameters = originalMaterial.userData.outlineParameters;\n\n        (material as any).skinning = (originalMaterial as any).skinning;\n        (material as any).morphTargets = (originalMaterial as any).morphTargets;\n        (material as any).morphNormals = (originalMaterial as any).morphNormals;\n        material.fog = originalMaterial.fog;\n\n        if (outlineParameters !== undefined) {\n            material.visible =\n                originalMaterial.visible === false\n                    ? false\n                    : outlineParameters.visible !== undefined\n                    ? outlineParameters.visible\n                    : true;\n\n            if (outlineParameters.keepAlive !== undefined) {\n                this.m_cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;\n            }\n        } else {\n            material.visible = originalMaterial.visible;\n        }\n\n        if ((originalMaterial as any).wireframe === true || originalMaterial.depthTest === false) {\n            material.visible = false;\n        }\n    }\n\n    private cleanupCache() {\n        let keys;\n\n        // clear originialMaterials\n        keys = Object.keys(this.m_originalMaterials);\n\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalMaterials[keys[i]] = undefined;\n        }\n\n        // clear originalOnBeforeRenders\n        keys = Object.keys(this.m_originalOnBeforeRenders);\n\n        for (let i = 0, il = keys.length; i < il; i++) {\n            this.m_originalOnBeforeRenders[keys[i]] = undefined;\n        }\n\n        // remove unused outlineMaterial from cache\n        keys = Object.keys(this.m_cache);\n\n        for (const key of keys) {\n            if (this.m_cache[key].used === false) {\n                this.m_cache[key].count++;\n\n                if (\n                    this.m_cache[key].keepAlive === false &&\n                    this.m_cache[key].count > this.m_removeThresholdCount\n                ) {\n                    delete this.m_cache[key];\n                }\n            } else {\n                this.m_cache[key].used = false;\n                this.m_cache[key].count = 0;\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * The interface for the {@link Pass} class.\n */\nexport interface IPass {\n    /**\n     * Whether the {@link Pass} instance is active or not.\n     * @default `true`.\n     */\n    enabled: boolean;\n\n    /**\n     * Whether the render method should target a WebGLRenderTarget instance, or the frame buffer.\n     * @default `false`.\n     */\n    renderToScreen: boolean;\n\n    /**\n     * The resize method to extend in {@link Pass} implementations.\n     *\n     * @remarks\n     * It resizes the render targets. Call on resize events.\n     *\n     * @param width - Width to resize to.\n     * @param height - Height to resize to.\n     */\n    setSize(width: number, height: number): void;\n\n    /**\n     * The render method to extend in {@link Pass} implementations.\n     *\n     * @remarks\n     * This is the place where the desired\n     * effects or render operations are executed.\n     *\n     * @param renderer - The WebGLRenderer instance in use.\n     * @param scene - The scene to render.\n     * @param camera - The camera to render the scene through.\n     * @param writeBuffer - The optional WebGLRenderTarget instance to write to.\n     * @param readBuffer - The optional WebGLRenderTarget instance of a previous pass to write onto.\n     * @param delta - The time argument from the requestAnimationFrame.\n     */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget | null,\n        delta?: number\n    ): void;\n}\n\n/**\n * The base class to extend for further passes in {@link MapView},\n * like the {@link MSAARenderPass},\n *\n * @remarks\n * `Pass` provides the core logic for both :\n * - render passes (proper scene renders),\n * - and shader passes (quad renders, i.e. effects added on top of the render output as a\n * postprocess).\n *\n * Even some shader passes still actually fall within the render pass category as they need to\n * re-render the scene to then deduce an effect, such as masking, AO, DoF etc. Others just need the\n * previous input image to apply a shader on top of it, as for bloom or NVIDIA's FXAA for example.\n * These only are proper shader passes.\n */\nexport class Pass implements IPass {\n    enabled: boolean = false;\n    renderToScreen: boolean = false;\n    setSize(width: number, height: number) {\n        // Implemented in sub-classes.\n    }\n\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget | null,\n        delta?: number\n    ) {\n        // Implemented in sub-classes.\n    }\n}\n\n/**\n * The pass that does a default normal scene rendering for further post-effects.\n */\nexport class RenderPass extends Pass {\n    constructor() {\n        super();\n    }\n\n    /** @override */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget | null\n    ) {\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        renderer.render(scene, camera);\n    }\n}\n\n/**\n * The base class to extend for post-effects on the final render (like Vignette, Sepia, color\n * correction...)\n */\nexport class ShaderPass extends Pass {\n    uniforms: { [uniform: string]: THREE.IUniform };\n    material: THREE.Material;\n    fsQuad: FullScreenQuad;\n    constructor(shader: THREE.Shader, private readonly textureID: string = \"tDiffuse\") {\n        super();\n        if (shader instanceof THREE.ShaderMaterial) {\n            this.uniforms = shader.uniforms;\n            this.material = shader;\n        } else {\n            this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n            this.material = new THREE.ShaderMaterial({\n                defines: { ...(shader as any).defines },\n                uniforms: this.uniforms,\n                vertexShader: shader.vertexShader,\n                fragmentShader: shader.fragmentShader\n            });\n        }\n        this.fsQuad = new FullScreenQuad(this.material);\n    }\n\n    /** @override */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget,\n        readBuffer: THREE.WebGLRenderTarget,\n        delta?: number\n    ) {\n        if (this.uniforms[this.textureID]) {\n            this.uniforms[this.textureID].value = readBuffer.texture;\n        }\n        this.fsQuad.material = this.material;\n        renderer.setRenderTarget(this.renderToScreen ? null : writeBuffer);\n        this.fsQuad.render(renderer);\n    }\n}\n\nclass FullScreenQuad {\n    private m_mesh: THREE.Mesh;\n    private readonly m_camera: THREE.Camera;\n    constructor(material: THREE.Material) {\n        this.m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        const geometry = new THREE.PlaneBufferGeometry(2, 2);\n        this.m_mesh = new THREE.Mesh(geometry, material);\n    }\n\n    get material(): THREE.Material {\n        return this.m_mesh.material as THREE.Material;\n    }\n\n    set material(value: THREE.Material) {\n        this.m_mesh.material = value;\n    }\n\n    render(renderer: THREE.WebGLRenderer) {\n        renderer.render((this.m_mesh as any) as THREE.Scene, this.m_camera);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { CopyShader, LuminosityHighPassShader } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { Pass } from \"./Pass\";\n\nconst BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nconst BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\n/**\n * The TS version of ThreeJS's UnrealBloomPass.\n */\nexport class BloomPass extends Pass {\n    strength: number;\n    radius: number;\n    threshold: number;\n    resolution: THREE.Vector2 = new THREE.Vector2(256, 256);\n    private readonly m_renderTargetsHorizontal: THREE.WebGLRenderTarget[] = [];\n    private readonly m_renderTargetsVertical: THREE.WebGLRenderTarget[] = [];\n    private readonly m_nMips: number = 5;\n    private readonly m_highPassUniforms: any;\n    private readonly m_materialHighPassFilter: THREE.ShaderMaterial;\n    private readonly m_separableBlurMaterials: THREE.ShaderMaterial[] = [];\n    private readonly m_materialCopy: THREE.ShaderMaterial;\n    private readonly m_copyUniforms: any;\n    private readonly m_compositeMaterial: THREE.ShaderMaterial;\n\n    private readonly m_camera: THREE.OrthographicCamera = new THREE.OrthographicCamera(\n        -1,\n        1,\n        1,\n        -1,\n        0,\n        1\n    );\n\n    private readonly m_scene: THREE.Scene = new THREE.Scene();\n    private m_basic = new THREE.MeshBasicMaterial();\n    private m_quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2));\n\n    private readonly m_bloomTintColors: THREE.Vector3[] = [\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1),\n        new THREE.Vector3(1, 1, 1)\n    ];\n\n    private readonly m_renderTargetBright: THREE.WebGLRenderTarget;\n\n    constructor(resolution: THREE.Vector2, strength: number, radius: number, threshold: number) {\n        super();\n\n        this.strength = strength;\n        this.radius = radius;\n        this.threshold = threshold;\n        this.resolution = resolution;\n\n        this.m_quad.frustumCulled = false;\n        this.m_scene.add(this.m_quad);\n\n        const pars = {\n            minFilter: THREE.LinearFilter,\n            magFilter: THREE.LinearFilter,\n            format: THREE.RGBAFormat\n        };\n\n        let resx = Math.round(this.resolution.x / 2);\n        let resy = Math.round(this.resolution.y / 2);\n\n        this.m_renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n        this.m_renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n        this.m_renderTargetBright.texture.generateMipmaps = false;\n\n        for (let i = 0; i < this.m_nMips; i++) {\n            const renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n            renderTargetHorizonal.texture.generateMipmaps = false;\n            this.m_renderTargetsHorizontal.push(renderTargetHorizonal);\n\n            const renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);\n            renderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n            renderTargetVertical.texture.generateMipmaps = false;\n            this.m_renderTargetsVertical.push(renderTargetVertical);\n\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n\n        this.m_highPassUniforms = THREE.UniformsUtils.clone(LuminosityHighPassShader.uniforms);\n\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = threshold;\n        this.m_highPassUniforms[\"smoothWidth\"].value = 0.01;\n\n        this.m_materialHighPassFilter = new THREE.ShaderMaterial({\n            uniforms: this.m_highPassUniforms,\n            vertexShader: LuminosityHighPassShader.vertexShader,\n            fragmentShader: LuminosityHighPassShader.fragmentShader,\n            defines: {}\n        });\n\n        // Gaussian Blur Materials\n        const kernelSizeArray = [3, 5, 7, 9, 11];\n        resx = Math.round(this.resolution.x / 2);\n        resy = Math.round(this.resolution.y / 2);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(\n                resx,\n                resy\n            );\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n\n        // Composite material\n        this.m_compositeMaterial = this.getCompositeMaterial(this.m_nMips);\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture1\"\n        ].value = this.m_renderTargetsVertical[0].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture2\"\n        ].value = this.m_renderTargetsVertical[1].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture3\"\n        ].value = this.m_renderTargetsVertical[2].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture4\"\n        ].value = this.m_renderTargetsVertical[3].texture;\n        this.m_compositeMaterial.uniforms[\n            \"blurTexture5\"\n        ].value = this.m_renderTargetsVertical[4].texture;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n        this.m_compositeMaterial.needsUpdate = true;\n\n        const bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n        this.m_compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n\n        this.m_copyUniforms = THREE.UniformsUtils.clone(CopyShader.uniforms);\n        this.m_copyUniforms[\"opacity\"].value = 1.0;\n\n        this.m_materialCopy = new THREE.ShaderMaterial({\n            uniforms: this.m_copyUniforms,\n            vertexShader: CopyShader.vertexShader,\n            fragmentShader: CopyShader.fragmentShader,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false,\n            transparent: true\n        });\n    }\n\n    dispose() {\n        for (const rt of this.m_renderTargetsHorizontal) {\n            rt.dispose();\n        }\n        for (const rt of this.m_renderTargetsVertical) {\n            rt.dispose();\n        }\n        this.m_renderTargetBright.dispose();\n    }\n\n    /** @override */\n    setSize(width: number, height: number) {\n        let resx = Math.round(width / 2);\n        let resy = Math.round(height / 2);\n        this.m_renderTargetBright.setSize(resx, resy);\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_renderTargetsHorizontal[i].setSize(resx, resy);\n            this.m_renderTargetsVertical[i].setSize(resx, resy);\n            this.m_separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(\n                resx,\n                resy\n            );\n            resx = Math.round(resx / 2);\n            resy = Math.round(resy / 2);\n        }\n    }\n\n    /** @override */\n    render(\n        renderer: THREE.WebGLRenderer,\n        scene: THREE.Scene,\n        camera: THREE.Camera,\n        writeBuffer: THREE.WebGLRenderTarget | null,\n        readBuffer: THREE.WebGLRenderTarget\n    ) {\n        // Render input to screen\n        if (this.renderToScreen) {\n            this.m_quad.material = this.m_basic;\n            this.m_basic.map = readBuffer.texture;\n            renderer.setRenderTarget(null!);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n        }\n\n        // 1. Extract bright areas\n        this.m_highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n        this.m_highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n        this.m_quad.material = this.m_materialHighPassFilter;\n\n        renderer.setRenderTarget(this.m_renderTargetBright);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n\n        // 2. Blur all the mips progressively\n        let inputRenderTarget = this.m_renderTargetBright;\n\n        for (let i = 0; i < this.m_nMips; i++) {\n            this.m_quad.material = this.m_separableBlurMaterials[i];\n\n            this.m_separableBlurMaterials[i].uniforms[\"colorTexture\"].value =\n                inputRenderTarget.texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionX;\n            renderer.setRenderTarget(this.m_renderTargetsHorizontal[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n\n            this.m_separableBlurMaterials[i].uniforms[\n                \"colorTexture\"\n            ].value = this.m_renderTargetsHorizontal[i].texture;\n            this.m_separableBlurMaterials[i].uniforms[\"direction\"].value = BlurDirectionY;\n            renderer.setRenderTarget(this.m_renderTargetsVertical[i]);\n            renderer.clear();\n            renderer.render(this.m_scene, this.m_camera);\n\n            inputRenderTarget = this.m_renderTargetsVertical[i];\n        }\n\n        // Composite all the mips\n        this.m_quad.material = this.m_compositeMaterial;\n        this.m_compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n        this.m_compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n        this.m_compositeMaterial.uniforms[\"bloomTintColors\"].value = this.m_bloomTintColors;\n\n        renderer.setRenderTarget(this.m_renderTargetsHorizontal[0]);\n        renderer.clear();\n        renderer.render(this.m_scene, this.m_camera);\n\n        // Blend it additively over the input texture\n        this.m_quad.material = this.m_materialCopy;\n        this.m_copyUniforms[\"tDiffuse\"].value = this.m_renderTargetsHorizontal[0].texture;\n\n        if (this.renderToScreen) {\n            renderer.setRenderTarget(null!);\n            renderer.render(this.m_scene, this.m_camera);\n        } else {\n            renderer.setRenderTarget(readBuffer);\n            renderer.render(this.m_scene, this.m_camera);\n        }\n    }\n\n    getSeperableBlurMaterial(kernelRadius: number): THREE.ShaderMaterial {\n        return new THREE.ShaderMaterial({\n            defines: {\n                KERNEL_RADIUS: kernelRadius,\n                SIGMA: kernelRadius\n            },\n\n            uniforms: {\n                colorTexture: { value: null },\n                texSize: { value: new THREE.Vector2(0.5, 0.5) },\n                direction: { value: new THREE.Vector2(0.5, 0.5) }\n            },\n\n            vertexShader: `varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }`,\n\n            fragmentShader: `#include <common>\n            varying vec2 vUv;\n            uniform sampler2D colorTexture;\n            uniform vec2 texSize;\n            uniform vec2 direction;\n\n            float gaussianPdf(in float x, in float sigma) {\n                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n            }\n            void main() {\\n\\\n                vec2 invSize = 1.0 / texSize;\n                float fSigma = float(SIGMA);\n                float weightSum = gaussianPdf(0.0, fSigma);\n                vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n                    float x = float(i);\n                    float w = gaussianPdf(x, fSigma);\n                    vec2 uvOffset = direction * invSize * x;\n                    vec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n                    vec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n                    diffuseSum += (sample1 + sample2) * w;\n                    weightSum += 2.0 * w;\n                }\n                gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n            }`\n        });\n    }\n\n    getCompositeMaterial(nMips: number): THREE.ShaderMaterial {\n        return new THREE.ShaderMaterial({\n            defines: {\n                NUM_MIPS: nMips\n            },\n\n            uniforms: {\n                blurTexture1: { value: null },\n                blurTexture2: { value: null },\n                blurTexture3: { value: null },\n                blurTexture4: { value: null },\n                blurTexture5: { value: null },\n                dirtTexture: { value: null },\n                bloomStrength: { value: 1.0 },\n                bloomFactors: { value: null },\n                bloomTintColors: { value: null },\n                bloomRadius: { value: 0.0 }\n            },\n\n            vertexShader: `varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }`,\n\n            fragmentShader: `varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform sampler2D dirtTexture;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[NUM_MIPS];\n                uniform vec3 bloomTintColors[NUM_MIPS];\n\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n\n                void main() {\n                    gl_FragColor = bloomStrength * (\nlerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\nlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\nlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\nlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\nlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n                }`\n        });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport { IPassManager } from \"./IPassManager\";\nexport {\n    IMapAntialiasSettings,\n    IMapRenderingManager,\n    MapRenderingManager\n} from \"./MapRenderingManager\";\nexport { IPass, Pass } from \"./Pass\";\nexport { MSAARenderPass, MSAASampling } from \"./MSAARenderPass\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoBox } from \"@here/harp-geoutils\";\nimport { getOptionValue, ILogger, LoggerManager } from \"@here/harp-utils\";\n\nimport { CopyrightInfo } from \"./CopyrightInfo\";\nimport { CopyrightProvider } from \"./CopyrightProvider\";\n\ndeclare const require: any;\n\nconst RBush = require(\"rbush\");\n\n/**\n * Schema of [Map Tile API copyright\n * endpoint](https://developer.here.com/documentation/map-tile/topics/resource-copyright.html) JSON\n * response.\n */\nexport interface AreaCopyrightInfo {\n    /**\n     * Minimum zoom level for the specified copyright label.\n     */\n    minLevel?: number;\n\n    /**\n     * Maximum zoom level for the specified copyright label.\n     */\n    maxLevel?: number;\n\n    /**\n     * Copyright text to display after the copyright symbol on the map.\n     */\n    label: string;\n\n    /**\n     * Verbose copyright text of the label to display by mouse over label or info menu entry.\n     */\n    alt?: string;\n\n    /**\n     * The bounding boxes define areas where specific copyrights are valid. A bounding box is\n     * defined by bottom (latitude), left (longitude) and top (latitude), right (longitude).\n     *\n     * The default copyright has no boxes element and covers all other areas.\n     */\n    boxes?: Array<[number, number, number, number]>;\n}\n\n/**\n * Schema of [Map Tile API copyright\n * endpoint](https://developer.here.com/documentation/map-tile/topics/resource-copyright.html) JSON\n * response.\n */\nexport interface CopyrightCoverageResponse {\n    [scheme: string]: AreaCopyrightInfo[];\n}\n\n/**\n * Base class to provide copyrights based on copyright coverage information, defined by geographical\n * bounding boxes and relevant zoom level ranges.\n */\nexport abstract class CopyrightCoverageProvider implements CopyrightProvider {\n    /** Logger instance. */\n    protected readonly logger: ILogger = LoggerManager.instance.create(\"CopyrightCoverageProvider\");\n\n    private m_cachedTreePromise: Promise<any> | undefined;\n\n    /** Asynchronously retrieves copyright coverage data.\n     * @param abortSignal - Optional AbortSignal to cancel the request.\n     */\n    abstract getCopyrightCoverageData(abortSignal?: AbortSignal): Promise<AreaCopyrightInfo[]>;\n\n    /** @inheritdoc */\n    getTree(): Promise<any> {\n        if (this.m_cachedTreePromise !== undefined) {\n            return this.m_cachedTreePromise;\n        }\n\n        this.m_cachedTreePromise = this.getCopyrightCoverageData()\n            .then(coverageInfo => this.initRBush(coverageInfo))\n            .catch(error => {\n                this.logger.error(error);\n                return new RBush();\n            });\n\n        return this.m_cachedTreePromise;\n    }\n\n    /** @inheritdoc */\n    async getCopyrights(geoBox: GeoBox, level: number): Promise<CopyrightInfo[]> {\n        const tree = await this.getTree();\n\n        const result: CopyrightInfo[] = [];\n\n        const matchingEntries: AreaCopyrightInfo[] = tree.search({\n            minX: geoBox.west,\n            minY: geoBox.south,\n            maxX: geoBox.east,\n            maxY: geoBox.north\n        });\n\n        for (const entry of matchingEntries) {\n            const minLevel = getOptionValue(entry.minLevel, 0);\n            const maxLevel = getOptionValue(entry.maxLevel, Infinity);\n\n            if (level >= minLevel && level <= maxLevel) {\n                if (result.find(item => item.id === entry.label) === undefined) {\n                    result.push({ id: entry.label });\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Initializes RBush.\n     *\n     * @param entries - Entries for tree.\n     * @returns RBush instance.\n     */\n    initRBush(entries: AreaCopyrightInfo[]): any {\n        const tree = new RBush();\n\n        if (!entries) {\n            this.logger.warn(\"No copyright coverage data provided\");\n            return tree;\n        }\n\n        for (const entry of entries) {\n            const { minLevel, maxLevel, label, alt } = entry;\n\n            if (!entry.boxes) {\n                tree.insert({\n                    minX: -180,\n                    minY: -90,\n                    maxX: 180,\n                    maxY: 180,\n                    minLevel,\n                    maxLevel,\n                    label,\n                    alt\n                });\n            } else {\n                for (const box of entry.boxes) {\n                    const [minY, minX, maxY, maxX] = box;\n                    tree.insert({\n                        minX,\n                        minY,\n                        maxX,\n                        maxY,\n                        minLevel,\n                        maxLevel,\n                        label,\n                        alt\n                    });\n                }\n            }\n        }\n\n        return tree;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { getOptionValue } from \"@here/harp-utils\";\n\nimport { MapView, MapViewEventNames } from \"../MapView\";\nimport { CopyrightInfo } from \"./CopyrightInfo\";\n\n/**\n * Helper class that maintains up-to-date {@link MapView} copyright information in DOM element.\n *\n * @example\n *\n *     // HTML snippet\n *     <div id=\"copyrightNotice\" style=\"position:absolute; right:0; bottom:0; z-index:100\"></div>\n *\n *     // JavaScript\n *     const mapView = new MapView({ ... });\n *     CopyrightElementHandler.install(\"copyrightNotice\", mapView);\n */\nexport class CopyrightElementHandler {\n    /**\n     * Install {@link CopyrightElementHandler} on DOM element and - optionally -\n     * attach to a {@link MapView} instance.\n     *\n     * @param element - HTML DOM element or a HTML DOM element id\n     * @param mapView -, optional, [[attach]] to this {@link MapView}\n     */\n    static install(element: string | HTMLElement, mapView?: MapView): CopyrightElementHandler {\n        return new CopyrightElementHandler(element, mapView);\n    }\n\n    /**\n     * Static copyright info.\n     *\n     * Use when {@link MapView}'s {@link DataSource}'s do not provide proper copyright information.\n     */\n    staticInfo: CopyrightInfo[] | undefined;\n\n    private readonly m_defaults: Map<string, CopyrightInfo> = new Map();\n    private m_element: HTMLElement;\n    private m_mapViews: MapView[] = [];\n\n    /**\n     * Creates a new `CopyrightElementHandler` that updates the DOM element with the copyright info\n     * of the given `mapView`.\n     *\n     * Note: Generally, the static [[install]] method can be used to create and attach a new\n     * `CopyrightElementHandler` to a {@link MapView}\n     *\n     * @param element - HTML DOM element or a HTML DOM element id\n     * @param mapView - optional, [[attach]] to this {@link MapView} instance\n     */\n    constructor(element: string | HTMLElement, mapView?: MapView) {\n        if (typeof element === \"string\") {\n            const htmlElement = document.getElementById(element);\n            if (!htmlElement) {\n                throw new Error(`CopyrightElementHandler: unable to find DOM element #${element}`);\n            }\n            this.m_element = htmlElement;\n        } else {\n            this.m_element = element;\n        }\n\n        if (mapView !== undefined) {\n            this.attach(mapView);\n        }\n    }\n\n    /**\n     * Destroys this object by removing all event listeners from the attached {@link MapView}s.\n     */\n    destroy() {\n        for (const mapView of this.m_mapViews) {\n            mapView.removeEventListener(MapViewEventNames.CopyrightChanged, this.update);\n        }\n    }\n\n    /**\n     * Attaches this {@link CopyrightInfo} updates from {@link MapView} instance.\n     */\n    attach(mapView: MapView): this {\n        this.m_mapViews.push(mapView);\n\n        mapView.addEventListener(MapViewEventNames.CopyrightChanged, this.update);\n        this.update();\n\n        return this;\n    }\n\n    /**\n     * Stop following {@link CopyrightInfo} updates from {@link MapView} instance.\n     */\n    detach(mapView: MapView): this {\n        mapView.removeEventListener(MapViewEventNames.CopyrightChanged, this.update);\n\n        this.m_mapViews = this.m_mapViews.filter(item => item !== mapView);\n        this.update();\n\n        return this;\n    }\n\n    /**\n     * Set {@link CopyrightInfo} defaults to be used in case\n     * {@link DataSource} does not provide deatailed\n     * copyright information.\n     *\n     * @remarks\n     * The defaults will applied to all undefined `year`, `label` and `link` values in the copyright\n     * information retrieved from {@link MapView}.\n     */\n    setDefaults(defaults: CopyrightInfo[] | undefined): this {\n        this.m_defaults.clear();\n        if (defaults !== undefined) {\n            for (const item of defaults) {\n                this.m_defaults.set(item.id, item);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets the [[staticInfo]] property.\n     *\n     * A `CopyrightElementHandler` always displays a deduplicated sum of static copyright info and\n     * copyright information obtained from attached {@link MapView}s.\n     *\n     * This information is used when {@link DataSource}\n     * instances of given {@link MapView} do not provide\n     * copyright information.\n     */\n    setStaticCopyightInfo(staticInfo: CopyrightInfo[] | undefined): this {\n        this.staticInfo = staticInfo;\n        return this;\n    }\n\n    /**\n     * Update copyright info text in controlled HTML element.\n     */\n    update = () => {\n        const mergedCopyrightInfo = this.m_mapViews\n            .map(mapView => mapView.copyrightInfo)\n            .reduce(CopyrightInfo.mergeArrays, this.staticInfo ?? []);\n\n        // Conditionally hiding of element with copyright information.\n        // If nothing to show we schould to avoid empty white rectangle in right bottom corner.\n        if (mergedCopyrightInfo.length === 0) {\n            this.m_element.style.display = \"none\";\n            return;\n        } else {\n            this.m_element.style.display = \"block\";\n        }\n\n        if (this.m_defaults.size !== 0) {\n            for (const sourceInfo of mergedCopyrightInfo) {\n                const defaults = this.m_defaults.get(sourceInfo.id);\n                if (defaults !== undefined) {\n                    sourceInfo.year = getOptionValue(sourceInfo.year, defaults.year);\n                    sourceInfo.label = getOptionValue(sourceInfo.label, defaults.label);\n                    sourceInfo.link = getOptionValue(sourceInfo.link, defaults.link);\n                }\n            }\n        }\n        const deduped = CopyrightInfo.mergeArrays(mergedCopyrightInfo);\n\n        this.m_element.innerHTML = CopyrightInfo.formatAsHtml(deduped);\n    };\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { getOptionValue, MathUtils } from \"@here/harp-utils\";\n\n/**\n * Copyright info attached to data displayed on map. Provided by {@link DataSource} and attached\n * to {@link Tile}s.\n *\n * In most cases, an application should display this information on {@link MapView} to conform with\n * licencing terms of its map data providers.\n *\n * @see {@link CopyrightElementHandler}\n */\nexport interface CopyrightInfo {\n    /**\n     * Unique id of the copyright holder.\n     *\n     * @remarks\n     * `id`s should be unique. It is recommended to build them from unique identifiers like\n     * registered domain names.\n     *\n     * Examples:\n     *\n     *  * `openstreetmap.org` - for data originating from OpenStreetMap project\n     *  * `naturalearthdata.com` - for data originating from Natural Earth dataset\n     *\n     * Note: {@link DataSource} may return {@link CopyrightInfo}\n     * with only `id`, thus defining only holder\n     * of copyright, however, valid attribution may require proper `label` and `link`.\n     *\n     * Entries with same `id` are deduplicated by {@link CopyrightInfo.mergeArrays}.\n     */\n    id: string;\n\n    /**\n     * Copyright text to display after the copyright symbol on the map.\n     *\n     * If undefined, `id` is used as text label.\n     * Set it to empty string to not render a copyright info.\n     */\n    label?: string;\n\n    /**\n     * Optional URL pointing to further copyright information.\n     */\n    link?: string;\n\n    /**\n     * Optional, copyright notice year.\n     */\n    year?: number;\n}\n\nexport namespace CopyrightInfo {\n    /**\n     * Merge {@link CopyrightInfo} arrays, removing duplicates.\n     *\n     * `id` and `label` are considered keys in deduplication algorithm.\n     *\n     * @param sources - non-duplicate elements from this array are added to `target`\n     * @returns merge of all copyright infos in `sources`\n     */\n    export function mergeArrays(a: CopyrightInfo[], b?: CopyrightInfo[]): CopyrightInfo[] {\n        const result: CopyrightInfo[] = [];\n        for (const source of [a, b]) {\n            if (source === undefined) {\n                continue;\n            }\n\n            for (const sourceInfo of source) {\n                const existingInfo = result.find(\n                    findItem =>\n                        findItem.id === sourceInfo.id ||\n                        (findItem.label !== undefined && findItem.label === sourceInfo.label)\n                );\n\n                if (existingInfo === undefined) {\n                    result.push({ ...sourceInfo });\n                } else {\n                    existingInfo.year = MathUtils.max2(sourceInfo.year, existingInfo.year);\n                    existingInfo.label = getOptionValue(sourceInfo.label, existingInfo.label);\n                    existingInfo.link = getOptionValue(sourceInfo.link, existingInfo.link);\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Format copyright information to a HTML string that can be displayed in the UI.\n     *\n     * * Empty list returns empty string.\n     * * Entries with empty (but defined) labels are skipped.\n     *\n     * @param copyrightInfo - Array of copyrights to format.\n     */\n    export function formatAsHtml(copyrightInfo: CopyrightInfo[]): string {\n        if (copyrightInfo.length === 0) {\n            return \"\";\n        }\n\n        const filtered = copyrightInfo.filter(entry => entry.label !== \"\");\n        if (filtered.length === 0) {\n            return \"\";\n        }\n\n        return (\n            \" \" +\n            filtered\n                .map(entry => {\n                    const label = entry.label ?? entry.id;\n                    const text = entry.year !== undefined ? `${entry.year} ${label}` : label;\n                    const link = entry.link;\n                    return link\n                        ? `<a href=\"${link}\" target=\"_blank\" rel=\"noreferrer noopener\">${text}</a>`\n                        : `${text}`;\n                })\n                .join(\", \")\n        );\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ITransferManager, TransferManager } from \"@here/harp-transfer-manager\";\n\nimport {\n    AreaCopyrightInfo,\n    CopyrightCoverageProvider,\n    CopyrightCoverageResponse\n} from \"./CopyrightCoverageProvider\";\n\ninterface RequestHeaders {\n    [field: string]: string;\n}\n\n/**\n * Copyright provider which retrieves copyright coverage information from provided URL.\n */\nexport class UrlCopyrightProvider extends CopyrightCoverageProvider {\n    private m_cachedCopyrightResponse: Promise<AreaCopyrightInfo[]> | undefined;\n\n    /**\n     * Default constructor.\n     *\n     * @param m_fetchURL - URL to fetch copyrights data from.\n     * @param m_baseScheme - Scheme to get copyrights from.\n     * @param m_requestHeaders - Optional request headers for requests(e.g. Authorization)\n     */\n    constructor(\n        private readonly m_fetchURL: string,\n        private readonly m_baseScheme: string,\n        private m_requestHeaders?: RequestHeaders,\n        private readonly m_transferManager: ITransferManager = TransferManager.instance()\n    ) {\n        super();\n    }\n\n    /**\n     * Sets request headers.\n     * @param headers -\n     */\n    setRequestHeaders(headers: RequestHeaders | undefined) {\n        this.m_requestHeaders = headers;\n    }\n\n    /**\n     * @inheritdoc\n     * @override\n     */\n    getCopyrightCoverageData(abortSignal?: AbortSignal): Promise<AreaCopyrightInfo[]> {\n        if (this.m_cachedCopyrightResponse !== undefined) {\n            return this.m_cachedCopyrightResponse;\n        }\n\n        this.m_cachedCopyrightResponse = this.m_transferManager\n            .downloadJson<CopyrightCoverageResponse>(this.m_fetchURL, {\n                headers: this.m_requestHeaders,\n                signal: abortSignal\n            })\n            .then(json => json[this.m_baseScheme])\n            .catch(error => {\n                this.logger.error(error);\n                return [];\n            });\n\n        return this.m_cachedCopyrightResponse;\n    }\n}\n","/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryKind, Pickability } from \"@here/harp-datasource-protocol\";\nimport {\n    EdgeLengthGeometrySubdivisionModifier,\n    SubdivisionMode\n} from \"@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier\";\nimport { SphericalGeometrySubdivisionModifier } from \"@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier\";\nimport { Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport { MapMeshBasicMaterial, MapMeshStandardMaterial } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { Tile } from \"../Tile\";\nimport { LodMesh } from \"./LodMesh\";\nimport { projectTilePlaneCorners } from \"./ProjectTilePlaneCorners\";\nimport { registerTileObject } from \"./RegisterTileObject\";\n\nconst tmpV = new THREE.Vector3();\n\n/**\n * Creates and adds a background plane mesh for the tile.\n * @param tile - The tile to which the ground plane belongs.\n * @param renderOrder - The plane render order.\n * @param materialOrColor - The plane material or a color for a default material.\n * @param opacity - The plane opacity.\n * @param createTexCoords - Whether to create texture coordinates.\n * @param receiveShadow - Whether the plane should receive shadows.\n * @param createMultiLod - Whether to generate multiple LODs for sphere projection.\n * @internal\n */\nexport function addGroundPlane(\n    tile: Tile,\n    renderOrder: number,\n    materialOrColor: THREE.Material | THREE.Material[] | number = tile.mapView.clearColor,\n    opacity: number = 1,\n    createTexCoords: boolean = false,\n    receiveShadow: boolean = tile.mapView.shadowsEnabled,\n    createMultiLod: boolean = tile.mapView.enableMixedLod !== false\n): THREE.Mesh {\n    const mesh = createGroundPlane(\n        tile,\n        createTexCoords,\n        receiveShadow,\n        materialOrColor,\n        createMultiLod,\n        opacity\n    );\n    mesh.receiveShadow = receiveShadow;\n    mesh.renderOrder = renderOrder;\n    registerTileObject(tile, mesh, GeometryKind.Background, { pickability: Pickability.transient });\n    tile.objects.push(mesh);\n    return mesh;\n}\n\nfunction createGroundPlane(\n    tile: Tile,\n    createTexCoords: boolean,\n    receiveShadow: boolean,\n    materialOrColor: THREE.Material | THREE.Material[] | number,\n    createMultiLod: boolean,\n    opacity: number\n): THREE.Mesh {\n    const { dataSource, projection } = tile;\n    const sourceProjection = dataSource.getTilingScheme().projection;\n    const shouldSubdivide = projection.type === ProjectionType.Spherical;\n    const useLocalTargetCoords = !shouldSubdivide;\n\n    const material =\n        typeof materialOrColor === \"number\"\n            ? createGroundPlaneMaterial(\n                  new THREE.Color(materialOrColor),\n                  receiveShadow,\n                  projection.type === ProjectionType.Spherical,\n                  opacity\n              )\n            : materialOrColor;\n\n    const geometry = createGroundPlaneGeometry(\n        tile,\n        useLocalTargetCoords,\n        createTexCoords,\n        receiveShadow\n    );\n\n    if (!shouldSubdivide) {\n        return new THREE.Mesh(geometry, material);\n    }\n\n    const geometries: THREE.BufferGeometry[] = [];\n    const sphericalModifier = new SphericalGeometrySubdivisionModifier(\n        THREE.MathUtils.degToRad(10),\n        sourceProjection\n    );\n\n    if (!createMultiLod) {\n        sphericalModifier.modify(geometry);\n        toLocalTargetCoords(geometry, sourceProjection, tile);\n\n        return new THREE.Mesh(geometry, material);\n    }\n\n    // Use a [[LodMesh]] to adapt tesselation of tile depending on zoom level\n    for (let zoomLevelOffset = 0; zoomLevelOffset < 4; ++zoomLevelOffset) {\n        const subdivision = Math.pow(2, zoomLevelOffset);\n        const zoomLevelGeometry = geometry.clone();\n        if (subdivision > 1) {\n            const edgeModifier = new EdgeLengthGeometrySubdivisionModifier(\n                subdivision,\n                tile.geoBox,\n                SubdivisionMode.All,\n                sourceProjection\n            );\n            edgeModifier.modify(zoomLevelGeometry);\n        }\n        sphericalModifier.modify(zoomLevelGeometry);\n        toLocalTargetCoords(zoomLevelGeometry, sourceProjection, tile);\n        geometries.push(zoomLevelGeometry);\n    }\n    return new LodMesh(geometries, material);\n}\n\nfunction toLocalTargetCoords(geom: THREE.BufferGeometry, srcProjection: Projection, tile: Tile) {\n    const attr = geom.getAttribute(\"position\") as THREE.BufferAttribute;\n    const oldArray = attr.array as Float64Array;\n    // Convert to single precision before rendering (WebGL does not support double\n    // precision).\n    const newArray = new Float32Array(oldArray.length);\n    for (let i = 0; i < attr.array.length; i += 1) {\n        tmpV.fromBufferAttribute(attr, i);\n        tile.projection.reprojectPoint(srcProjection, tmpV, tmpV).sub(tile.center);\n        tmpV.toArray(newArray, i * 3);\n    }\n    attr.array = newArray;\n    attr.needsUpdate = true;\n}\n\nfunction createGroundPlaneGeometry(\n    tile: Tile,\n    useLocalTargetCoords: boolean,\n    createTexCoords: boolean,\n    receiveShadow: boolean\n): THREE.BufferGeometry {\n    const { dataSource, projection } = tile;\n    const sourceProjection = dataSource.getTilingScheme().projection;\n    const tmpV = new THREE.Vector3();\n\n    const geometry = new THREE.BufferGeometry();\n    const tileCorners = projectTilePlaneCorners(tile, sourceProjection);\n    const cornersArray = [tileCorners.sw, tileCorners.se, tileCorners.nw, tileCorners.ne];\n    if (useLocalTargetCoords) {\n        for (const corner of cornersArray) {\n            projection.reprojectPoint(sourceProjection, corner, corner).sub(tile.center);\n        }\n    }\n    // Use 64bits floats for world coordinates to avoid precision issues on coordinate\n    // tranformations. The array must be converted to single precision before rendering.\n    const bufferArray = useLocalTargetCoords ? new Float32Array(12) : new Float64Array(12);\n    const posAttr = new THREE.BufferAttribute(bufferArray, 3).copyVector3sArray(cornersArray);\n    geometry.setAttribute(\"position\", posAttr);\n\n    if (receiveShadow) {\n        // Webmercator needs to have it negated to work correctly.\n        sourceProjection.surfaceNormal(tileCorners.sw, tmpV).negate();\n        const normAttr = new THREE.BufferAttribute(new Float32Array(12), 3).copyVector3sArray(\n            Array(4).fill(tmpV)\n        );\n        geometry.setAttribute(\"normal\", normAttr);\n    }\n    geometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));\n\n    if (createTexCoords) {\n        const uvAttr = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), 2);\n        geometry.setAttribute(\"uv\", uvAttr);\n    }\n\n    return geometry;\n}\n\nfunction createGroundPlaneMaterial(\n    color: THREE.Color,\n    receiveShadow: boolean,\n    depthWrite: boolean,\n    opacity: number\n): THREE.Material {\n    if (receiveShadow) {\n        return new MapMeshStandardMaterial({\n            color,\n            visible: true,\n            depthWrite,\n            removeDiffuseLight: true,\n            opacity\n        });\n    } else {\n        return new MapMeshBasicMaterial({\n            color,\n            visible: true,\n            depthWrite,\n            opacity\n        });\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport { sampleBilinear } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { VertexCache } from \"./VertexCache\";\n\n/**\n * @internal\n * BufferAttribute decorator that displaces on the fly the coordinates in a given attribute using a\n * specified displacement map.\n */\nexport class DisplacedBufferAttribute extends THREE.BufferAttribute {\n    private static readonly MAX_CACHE_SIZE = 6;\n    private m_texture?: Float32Array;\n    private m_textureWidth: number = 0;\n    private m_textureHeight: number = 0;\n    private readonly m_cache = new VertexCache(DisplacedBufferAttribute.MAX_CACHE_SIZE);\n    private m_lastBufferIndex?: number;\n    private readonly m_lastPos = new THREE.Vector3();\n    private readonly m_tmpNormal = new THREE.Vector3();\n\n    /**\n     * Creates an instance of displaced buffer attribute.\n     * @param originalAttribute - The buffer attribute to be displaced\n     *                            (e.g. the position attribute).\n     * @param m_normals - The normals along which the coordinates will be displaced.\n     * @param m_uvs - The uv coordinates to be used to sample the displacement map.\n     * @param displacementMap - A texture with the displacement values in 32bit floats.\n     */\n    constructor(\n        public originalAttribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        private m_normals: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        private m_uvs: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        displacementMap: THREE.DataTexture\n    ) {\n        super(originalAttribute.array, originalAttribute.itemSize, originalAttribute.normalized);\n        this.resetTexture(displacementMap);\n    }\n\n    /**\n     * Resets the displaced buffer attribute to use new buffer attributes or displacement map.\n     * @param originalAttribute - The buffer attribute to be displaced\n     *                            (e.g. the position attribute).\n     * @param normals - The normals along which the coordinates will be displaced.\n     * @param uvs -  The uv coordinates to be used to sample the displacement map.\n     * @param displacementMap - A texture with the displacement values in 32bit floats.\n     */\n    reset(\n        originalAttribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        normals: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        uvs: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n        displacementMap: THREE.DataTexture\n    ) {\n        this.array = originalAttribute.array;\n        this.itemSize = originalAttribute.itemSize;\n        this.count = this.array.length / this.itemSize;\n        this.normalized = originalAttribute.normalized;\n        this.originalAttribute = originalAttribute;\n        this.m_normals = normals;\n        this.m_uvs = uvs;\n        this.m_cache.clear();\n        this.m_lastBufferIndex = undefined;\n        this.resetTexture(displacementMap);\n    }\n\n    // HARP-9585: These getters are overrides of the base class ones, however tslint doesn't\n    // recognize them as such.\n    getX(index: number): number {\n        return this.getDisplacedCoordinate(index).x;\n    }\n\n    getY(index: number): number {\n        return this.getDisplacedCoordinate(index).y;\n    }\n\n    getZ(index: number): number {\n        return this.getDisplacedCoordinate(index).z;\n    }\n\n    private resetTexture(displacementMap: THREE.DataTexture) {\n        this.m_texture = new Float32Array(displacementMap.image.data.buffer);\n        this.m_textureWidth = displacementMap.image.width;\n        this.m_textureHeight = displacementMap.image.height;\n    }\n\n    private getDisplacedCoordinate(bufferIndex: number): Vector3Like {\n        if (bufferIndex === this.m_lastBufferIndex) {\n            return this.m_lastPos;\n        }\n        this.m_lastBufferIndex = bufferIndex;\n        if (this.m_cache.get(bufferIndex, this.m_lastPos)) {\n            return this.m_lastPos;\n        }\n        this.displacePosition(bufferIndex);\n        this.m_cache.set(bufferIndex, this.m_lastPos);\n        return this.m_lastPos;\n    }\n\n    private displacePosition(bufferIndex: number) {\n        this.m_lastPos.fromBufferAttribute(\n            this.originalAttribute as THREE.BufferAttribute,\n            bufferIndex\n        );\n        const normals = this.m_normals as THREE.BufferAttribute;\n        this.m_tmpNormal.fromBufferAttribute(normals, bufferIndex);\n        const uvs = this.m_uvs;\n        const u = THREE.MathUtils.clamp(uvs.getX(bufferIndex), 0, 1);\n        const v = THREE.MathUtils.clamp(uvs.getY(bufferIndex), 0, 1);\n        const displacement = sampleBilinear(\n            this.m_texture!,\n            this.m_textureWidth,\n            this.m_textureHeight,\n            u,\n            v\n        );\n        this.m_lastPos.add(this.m_tmpNormal.multiplyScalar(displacement));\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { DisplacedBufferAttribute } from \"./DisplacedBufferAttribute\";\n\nconst tmpV1 = new THREE.Vector3();\nconst tmpV2 = new THREE.Vector3();\nconst tmpBox = new THREE.Box3();\n\n/**\n * @internal\n * Range of displacement values found in a given displacement map.\n */\nexport interface DisplacementRange {\n    min: number;\n    max: number;\n}\n\n/**\n * @internal\n * Displace a box in a given direction by a specified range. The original box min and max vertices\n * are translated as a result by displacementRange.min and displacementRange.max respectively.\n * @param box - The original box to displace.\n * @param displacementRange - The minimum and maximum displacement values.\n * @param displacementDir - Direction in which the displacement will be applied.\n * @return The displaced box.\n */\nexport function displaceBox(\n    box: THREE.Box3,\n    displacementRange: DisplacementRange,\n    displacementDir: THREE.Vector3\n): THREE.Box3 {\n    tmpBox.copy(box);\n    const tmpNormalMin = tmpV1.copy(displacementDir);\n    const tmpNormalMax = tmpV2.copy(tmpNormalMin);\n    box.translate(tmpNormalMin.multiplyScalar(displacementRange.min)).union(\n        tmpBox.translate(tmpNormalMax.multiplyScalar(displacementRange.max))\n    );\n    return box;\n}\n\n/**\n * @internal\n * BufferGeometry decorator that displaces on the fly the position attribute using a specified\n * displacement map.\n */\nexport class DisplacedBufferGeometry extends THREE.BufferGeometry {\n    private readonly m_displacedPositions: DisplacedBufferAttribute;\n    private readonly m_originalBoundingBox = new THREE.Box3();\n\n    /**\n     * Creates an instance of displaced buffer geometry.\n     * @param originalGeometry - The goeometry to be displaced.\n     * @param displacementMap - A texture with the displacement values.\n     * @param displacementRange - The displacement value range found in the displacement map.\n     * @param displacedPositions - Buffer attribute that will be used for displaced positions if\n     * provided, otherwise a new buffer attribute will be created.\n     */\n    constructor(\n        public originalGeometry: THREE.BufferGeometry,\n        displacementMap: THREE.DataTexture,\n        public displacementRange: DisplacementRange,\n        displacedPositions?: DisplacedBufferAttribute\n    ) {\n        super();\n        if (!displacedPositions) {\n            this.m_displacedPositions = new DisplacedBufferAttribute(\n                originalGeometry.attributes.position,\n                originalGeometry.attributes.normal,\n                originalGeometry.attributes.uv,\n                displacementMap\n            );\n        } else {\n            this.m_displacedPositions = displacedPositions;\n        }\n        this.resetAttributes();\n    }\n\n    /**\n     * Resets the displaced buffer geometry to use new geometry or displacement map.\n     * @param geometry - The goeometry to be displaced.\n     * @param displacementMap - A texture with the displacement values.\n     * @param displacementRange - The displacement value range found in the displacement map.\n     */\n    reset(\n        geometry: THREE.BufferGeometry,\n        displacementMap: THREE.DataTexture,\n        displacementRange: DisplacementRange\n    ) {\n        this.originalGeometry = geometry;\n        const positions = geometry.attributes.position;\n        const normals = geometry.attributes.normal;\n        const uvs = geometry.attributes.uv;\n        this.m_displacedPositions.reset(positions, normals, uvs, displacementMap);\n        const displacementRangeChanged =\n            this.displacementRange.min !== displacementRange.min ||\n            this.displacementRange.max !== displacementRange.max;\n        this.displacementRange = displacementRange;\n        this.resetAttributes();\n        this.resetBoundingVolumes(displacementRangeChanged);\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    computeBoundingBox(): void {\n        // Calculate a coarse approximation of the displaced geometry bbox by displacing the\n        // original bbox and enlarging it to cover the whole displacement range.\n        // This approximation is used to avoid having to displace the whole geometry, which will\n        // be done only if the bbox test passes.\n        if (this.originalGeometry.boundingBox === null) {\n            this.originalGeometry.computeBoundingBox();\n        }\n        const origBBox = this.m_originalBoundingBox.copy(this.originalGeometry.boundingBox!);\n        if (this.boundingBox === null) {\n            this.boundingBox = origBBox.clone();\n        } else {\n            this.boundingBox.copy(origBBox);\n        }\n        displaceBox(\n            this.boundingBox,\n            this.displacementRange,\n            tmpV1.fromBufferAttribute(this.attributes.normal as THREE.BufferAttribute, 0)\n        );\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    computeBoundingSphere(): void {\n        // Use as coarse approximation the sphere bounding the bbox.\n        if (this.boundingBox === null) {\n            this.computeBoundingBox();\n        }\n        if (this.boundingSphere === null) {\n            this.boundingSphere = new THREE.Sphere();\n        }\n        this.boundingBox!.getBoundingSphere(this.boundingSphere!);\n    }\n\n    private needsBoundingBoxUpdate(displacementRangeChanged: boolean): boolean {\n        return (\n            displacementRangeChanged ||\n            (this.boundingBox !== null &&\n                (!this.originalGeometry.boundingBox ||\n                    !this.m_originalBoundingBox.equals(this.originalGeometry.boundingBox)))\n        );\n    }\n\n    private resetBoundingVolumes(displacementRangeChanged: boolean) {\n        if (this.needsBoundingBoxUpdate(displacementRangeChanged)) {\n            this.computeBoundingBox();\n            if (this.boundingSphere) {\n                this.computeBoundingSphere();\n            }\n        }\n    }\n\n    private resetAttributes() {\n        this.index = this.originalGeometry.index;\n        this.groups = this.originalGeometry.groups;\n        this.drawRange = this.originalGeometry.drawRange;\n        this.attributes = { ...this.originalGeometry.attributes };\n        this.attributes.position = this.m_displacedPositions;\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { DisplacementFeature, hasDisplacementFeature } from \"@here/harp-materials\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { DisplacedBufferAttribute } from \"./DisplacedBufferAttribute\";\nimport { DisplacedBufferGeometry, DisplacementRange } from \"./DisplacedBufferGeometry\";\n\nfunction isDisplacementMaterial(material: any): material is DisplacementFeature {\n    const isDisplacementFeature = hasDisplacementFeature(material);\n    assert(isDisplacementFeature, \"Material does not support displacement maps.\");\n    return isDisplacementFeature;\n}\n\nfunction isDataTextureMap(map?: THREE.Texture | null): map is THREE.DataTexture {\n    if (!map) {\n        return false;\n    }\n    const isDataTexture = map instanceof THREE.DataTexture;\n    assert(isDataTexture, \"Material does not support displacement maps.\");\n    return isDataTexture;\n}\n\n/**\n * Mesh with geometry modified by a displacement map. Overrides raycasting behaviour to apply\n * displacement map before intersection test.\n * @internal\n */\nexport class DisplacedMesh extends THREE.Mesh {\n    private static displacedPositions?: DisplacedBufferAttribute;\n\n    private static getDisplacedPositionAttribute(\n        geometry: THREE.BufferGeometry,\n        displacementMap: THREE.DataTexture\n    ): DisplacedBufferAttribute {\n        // Reuse same buffer attribute for all meshes since it's only needed during the\n        // intersection test.\n        if (!DisplacedMesh.displacedPositions) {\n            DisplacedMesh.displacedPositions = new DisplacedBufferAttribute(\n                geometry.attributes.position,\n                geometry.attributes.normal,\n                geometry.attributes.uv,\n                displacementMap\n            );\n        } else {\n            DisplacedMesh.displacedPositions.reset(\n                geometry.attributes.position,\n                geometry.attributes.normal,\n                geometry.attributes.uv,\n                displacementMap\n            );\n        }\n        return DisplacedMesh.displacedPositions;\n    }\n\n    displacedGeometry?: DisplacedBufferGeometry;\n\n    /**\n     * Creates an instance of displaced mesh.\n     * @param geometry - Original geometry to displace.\n     * @param material - Material(s) to be used by the mesh. All must have the same\n     *                   displacement map.\n     * @param m_getDisplacementRange - Displacement values range getter.\n     * @param [m_raycastStrategy] Function that will be used to find ray intersections. If not\n     * provided, THREE.Mesh's raycast will be used.\n     */\n    constructor(\n        geometry: THREE.BufferGeometry,\n        material: THREE.Material | THREE.Material[],\n        private readonly m_getDisplacementRange: () => DisplacementRange,\n        private readonly m_raycastStrategy?: (\n            mesh: THREE.Mesh,\n            raycaster: THREE.Raycaster,\n            intersects: THREE.Intersection[]\n        ) => void\n    ) {\n        super(geometry, material);\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    raycast(raycaster: THREE.Raycaster, intersects: THREE.Intersection[]): void {\n        // All materials in the object are expected to have the same displacement map.\n        const firstMaterial = this.firstMaterial;\n\n        // Use default raycasting implementation if there's no displacement material or if there's\n        // no displacement map or its type is not supported.\n        if (\n            !isDisplacementMaterial(firstMaterial) ||\n            !isDataTextureMap(firstMaterial.displacementMap)\n        ) {\n            super.raycast(raycaster, intersects);\n            return;\n        }\n        const displacementMap = firstMaterial.displacementMap;\n        const displacementRange = { ...this.m_getDisplacementRange() };\n\n        assert(this.geometry instanceof THREE.BufferGeometry, \"Unsupported geometry type.\");\n        const geometry = this.geometry as THREE.BufferGeometry;\n        if (this.displacedGeometry) {\n            this.displacedGeometry.reset(geometry, displacementMap, displacementRange);\n        } else {\n            this.displacedGeometry = new DisplacedBufferGeometry(\n                geometry,\n                displacementMap,\n                displacementRange,\n                DisplacedMesh.getDisplacedPositionAttribute(geometry, displacementMap)\n            );\n        }\n\n        // Replace the original geometry by the displaced one only during the intersection test.\n        this.geometry = this.displacedGeometry;\n        if (this.m_raycastStrategy) {\n            this.m_raycastStrategy(this, raycaster, intersects);\n        } else {\n            super.raycast(raycaster, intersects);\n        }\n        super.geometry = this.displacedGeometry.originalGeometry;\n    }\n\n    private get firstMaterial(): THREE.Material {\n        return Array.isArray(this.material) ? this.material[0] : this.material;\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * A mesh that can store multiple versions of a geometry with differents level of detail.\n * The rendered level of detail can be adapted during runtime.\n * @internal\n * @hidden\n */\nexport class LodMesh extends THREE.Mesh {\n    private m_geometries: THREE.BufferGeometry[] | undefined;\n\n    /**\n     * Creates a [[LodMesh]] with given geometries and materials\n     * @param geometries - A list of geometries with different levels of detail\n     * @param material - Material for the mesh\n     */\n    constructor(\n        geometries?: THREE.BufferGeometry[],\n        material?: THREE.Material | THREE.Material[] | undefined\n    ) {\n        super(undefined, material);\n\n        this.geometries = geometries;\n    }\n\n    /**\n     * Update geometries of mesh\n     */\n    set geometries(geometries: THREE.BufferGeometry[] | undefined) {\n        // dispose previous geometries\n        if (this.m_geometries !== geometries) {\n            this.disposeGeometries();\n        }\n\n        this.m_geometries = geometries;\n        if (this.geometries && this.m_geometries!.length > 0) {\n            this.geometry = this.m_geometries![0];\n        }\n    }\n\n    /**\n     * Get geometries of mesh\n     */\n    get geometries() {\n        return this.m_geometries;\n    }\n\n    /**\n     * Change the rendered level of detail of the mesh\n     * @param level - The level of detail (index of the geometry in the list).\n     */\n    setLevelOfDetail(level: number): void {\n        if (!this.m_geometries || this.m_geometries.length === 0) {\n            return;\n        }\n        level = THREE.MathUtils.clamp(level, 0, this.m_geometries.length - 1);\n\n        this.geometry = this.m_geometries[level];\n    }\n\n    /**\n     * Dispose all geometries of mesh\n     */\n    private disposeGeometries(): void {\n        if (this.m_geometries) {\n            for (const geometry of this.m_geometries!) {\n                geometry.dispose();\n            }\n        }\n        this.geometry.dispose();\n    }\n}\n","/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { MapMeshBasicMaterial, MapMeshStandardMaterial } from \"@here/harp-materials\";\nimport { LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { getFeatureDataSize, TileFeatureData } from \"../Tile\";\nimport { LodMesh } from \"./LodMesh\";\n\n// Estimation of the size of an Object3D with all the simple properties, like matrices and flags.\n// There may be cases where it is possible to construct Object3Ds with considerable less memory\n// consumption, but this value is used to simplify the estimation.\nconst MINIMUM_OBJECT3D_SIZE_ESTIMATION = 1000;\n\nconst MINIMUM_ATTRIBUTE_SIZE_ESTIMATION = 56;\n\nconst logger = LoggerManager.instance.create(\"Object3DUtils\");\n\n/**\n * @internal\n */\nexport namespace Object3DUtils {\n    /**\n     * Describes estimated usage of memory on heap and GPU.\n     */\n    export interface MemoryUsage {\n        heapSize: number;\n        gpuSize: number;\n    }\n\n    function estimateTextureSize(\n        texture: THREE.Texture | null,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        if (\n            texture === null ||\n            texture === undefined ||\n            texture.image === undefined ||\n            texture.image === null\n        ) {\n            return;\n        }\n\n        if (texture.uuid !== undefined && visitedObjects.get(texture.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(texture.uuid, true);\n\n        // May be HTMLImage or ImageData\n        const image = texture.image;\n        // Assuming RGBA\n        const imageBytes = 4 * image.width * image.height;\n        objectSize.heapSize += imageBytes;\n        objectSize.gpuSize += imageBytes;\n    }\n\n    function estimateMaterialSize(\n        material: THREE.Material,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        if (material.uuid !== undefined && visitedObjects.get(material.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(material.uuid, true);\n\n        if (\n            material instanceof THREE.RawShaderMaterial ||\n            material instanceof THREE.ShaderMaterial\n        ) {\n            const rawMaterial = material;\n            for (const name in rawMaterial.uniforms) {\n                if (rawMaterial.uniforms[name] !== undefined) {\n                    const uniform = rawMaterial.uniforms[name];\n                    if (uniform instanceof THREE.Texture) {\n                        estimateTextureSize(uniform, objectSize, visitedObjects);\n                    }\n                }\n            }\n        } else if (\n            material instanceof THREE.MeshBasicMaterial ||\n            material instanceof MapMeshBasicMaterial\n        ) {\n            const meshMaterial = material;\n            estimateTextureSize(meshMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.specularMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(meshMaterial.envMap, objectSize, visitedObjects);\n        } else if (material instanceof MapMeshStandardMaterial) {\n            const standardMaterial = material;\n\n            estimateTextureSize(standardMaterial.map, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.lightMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.aoMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.emissiveMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.bumpMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.normalMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.displacementMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.roughnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.metalnessMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.alphaMap, objectSize, visitedObjects);\n            estimateTextureSize(standardMaterial.envMap, objectSize, visitedObjects);\n        } else if (\n            material instanceof THREE.LineBasicMaterial ||\n            material instanceof THREE.LineDashedMaterial ||\n            material instanceof THREE.PointsMaterial\n        ) {\n            // Nothing to be done here\n        } else {\n            logger.warn(\"estimateMeshSize: unidentified material: \", material);\n        }\n    }\n\n    function estimateAttributeSize(\n        attribute: any,\n        attrName: string,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        // Attributes (apparently) do not have their uuid set up.\n        if (attribute.uuid === undefined) {\n            attribute.uuid = THREE.MathUtils.generateUUID();\n        }\n\n        if (visitedObjects.get(attribute.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(attribute.uuid, true);\n\n        let attrBytes = 0;\n        let bytesPerElement = 4;\n        if (attribute.array.BYTES_PER_ELEMENT !== undefined) {\n            bytesPerElement = attribute.array.BYTES_PER_ELEMENT;\n        }\n        if (\n            attribute instanceof THREE.InterleavedBufferAttribute ||\n            attribute instanceof THREE.BufferAttribute\n        ) {\n            attrBytes = bytesPerElement * attribute.count * attribute.itemSize;\n        } else {\n            logger.warn(\"estimateMeshSize: unidentified attribute: \", attrName);\n        }\n\n        objectSize.heapSize += attrBytes + MINIMUM_ATTRIBUTE_SIZE_ESTIMATION;\n        objectSize.gpuSize += attrBytes;\n    }\n\n    function estimateGeometrySize(\n        geometry: THREE.BufferGeometry,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        const isNewObject =\n            geometry.uuid === undefined || visitedObjects.get(geometry.uuid) !== true;\n\n        if (!isNewObject) {\n            return;\n        }\n        visitedObjects.set(geometry.uuid, true);\n\n        if (geometry === undefined) {\n            // Nothing more to calculate.\n            return;\n        }\n\n        const attributes = geometry.attributes;\n        if (attributes === undefined) {\n            logger.warn(\"estimateGeometrySize: unidentified geometry: \", geometry);\n            return;\n        }\n\n        for (const property in attributes) {\n            if (attributes[property] !== undefined) {\n                estimateAttributeSize(attributes[property], property, objectSize, visitedObjects);\n            }\n        }\n        if (geometry.index !== null) {\n            estimateAttributeSize(geometry.index, \"index\", objectSize, visitedObjects);\n        }\n    }\n\n    function estimateMeshSize(\n        object: THREE.Object3D,\n        objectSize: MemoryUsage,\n        visitedObjects: Map<string, boolean>\n    ): void {\n        if (!object.isObject3D || object instanceof THREE.Scene) {\n            return;\n        }\n\n        if (object.uuid !== undefined && visitedObjects.get(object.uuid) === true) {\n            return;\n        }\n        visitedObjects.set(object.uuid, true);\n\n        if ((object as any).isMesh || (object as any).isLine || (object as any).isPoints) {\n            // Estimated minimum impact on heap.\n            let heapSize = MINIMUM_OBJECT3D_SIZE_ESTIMATION;\n            const gpuSize = 0;\n\n            // Cast to LodMesh class which contains the minimal required properties sub-set.\n            const mesh = object as LodMesh;\n\n            // Calculate material(s) impact.\n            if (mesh.material !== undefined) {\n                if (Array.isArray(mesh.material)) {\n                    const materials = mesh.material as THREE.Material[];\n                    for (const material of materials) {\n                        estimateMaterialSize(material, objectSize, visitedObjects);\n                    }\n                } else {\n                    const material = mesh.material as THREE.Material;\n                    estimateMaterialSize(material, objectSize, visitedObjects);\n                }\n            }\n\n            // Calculate cost of geometry.\n            if (mesh.geometries !== undefined) {\n                for (const geometry of mesh.geometries) {\n                    estimateGeometrySize(geometry, objectSize, visitedObjects);\n                }\n            } else if (mesh.geometry !== undefined) {\n                estimateGeometrySize(mesh.geometry, objectSize, visitedObjects);\n            }\n\n            // Add info that is required for picking (parts of) objects and match them to\n            // the featureID in the map data.\n            const featureData: TileFeatureData | undefined =\n                object.userData !== undefined\n                    ? (object.userData.feature as TileFeatureData)\n                    : undefined;\n\n            if (featureData !== undefined) {\n                heapSize += getFeatureDataSize(featureData);\n            }\n\n            objectSize.heapSize += heapSize;\n            objectSize.gpuSize += gpuSize;\n        } else {\n            logger.warn(\"estimateMeshSize: unidentified object\", object);\n        }\n    }\n\n    /**\n     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials\n     * and/or attributes will be counted multiple times.\n     *\n     * @param object - The mesh object to evaluate\n     * @param size - The {@link MemoryUsage} to update.\n     * @param visitedObjects - Optional map to store large objects that could be shared.\n     *\n     * @returns Estimate of object size in bytes for heap and GPU.\n     */\n    export function estimateSize(\n        object: THREE.Object3D,\n        parentSize?: MemoryUsage,\n        visitedObjects?: Map<string, boolean>\n    ): MemoryUsage {\n        const size =\n            parentSize !== undefined\n                ? parentSize\n                : {\n                      heapSize: 0,\n                      gpuSize: 0\n                  };\n\n        if (visitedObjects === undefined) {\n            visitedObjects = new Map();\n        }\n\n        estimateMeshSize(object, size, visitedObjects);\n\n        if (object.children.length > 0) {\n            for (const child of object.children) {\n                estimateSize(child, size, visitedObjects);\n            }\n        }\n        return size;\n    }\n}\n","/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeoCoordinates, Projection } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\nimport { Tile } from \"../Tile\";\n\n/**\n * Coordinates of a tile's corners.\n * @internal\n * @hidden\n */\nexport interface TileCorners {\n    se: THREE.Vector3;\n    sw: THREE.Vector3;\n    ne: THREE.Vector3;\n    nw: THREE.Vector3;\n}\n\n/**\n * Returns the corners of the tile's geo bounding box projected using a given projection.\n * @param tile - The tile whose corners will be projected.\n * @param projection - The projection to be used.\n * @returns The projected tile corners.\n * @internal\n * @hidden\n */\nexport function projectTilePlaneCorners(tile: Tile, projection: Projection): TileCorners {\n    const { east, west, north, south } = tile.geoBox;\n    const sw = projection.projectPoint(new GeoCoordinates(south, west), new THREE.Vector3());\n    const se = projection.projectPoint(new GeoCoordinates(south, east), new THREE.Vector3());\n    const nw = projection.projectPoint(new GeoCoordinates(north, west), new THREE.Vector3());\n    const ne = projection.projectPoint(new GeoCoordinates(north, east), new THREE.Vector3());\n    return { sw, se, nw, ne };\n}\n","/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryKind, GeometryKindSet } from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\n\nimport { MapObjectAdapter, MapObjectAdapterParams } from \"../MapObjectAdapter\";\nimport { Tile } from \"../Tile\";\n\n/**\n * Adds a THREE object to the root of the tile and register [[MapObjectAdapter]].\n *\n * Sets the owning tiles datasource.name and the `tileKey` in the `userData` property of the\n * object, such that the tile it belongs to can be identified during picking.\n *\n * @param tile - The {@link Tile} to add the object to.\n * @param object - The object to add to the root of the tile.\n * @param geometryKind - The kind of object. Can be used for filtering.\n * @param mapAdapterParams - additional parameters for [[MapObjectAdapter]]\n */\nexport function registerTileObject(\n    tile: Tile,\n    object: THREE.Object3D,\n    geometryKind: GeometryKind | GeometryKindSet | undefined,\n    mapAdapterParams?: MapObjectAdapterParams\n) {\n    const kind =\n        geometryKind instanceof Set\n            ? Array.from((geometryKind as GeometryKindSet).values())\n            : Array.isArray(geometryKind)\n            ? geometryKind\n            : [geometryKind];\n\n    MapObjectAdapter.create(object, {\n        dataSource: tile.dataSource,\n        kind,\n        level: tile.tileKey.level,\n        ...mapAdapterParams\n    });\n\n    // TODO legacy fields, encoded directly in `userData to be removed\n    if (object.userData === undefined) {\n        object.userData = {};\n    }\n\n    const userData = object.userData;\n    userData.tileKey = tile.tileKey;\n    userData.dataSource = tile.dataSource.name;\n\n    userData.kind = kind;\n\n    // Force a visibility check of all objects.\n    tile.resetVisibilityCounter();\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { OrientedBox3 } from \"@here/harp-geoutils\";\nimport { SolidLineMaterial } from \"@here/harp-materials\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { displaceBox, DisplacedBufferGeometry, DisplacementRange } from \"./DisplacedBufferGeometry\";\n\nconst tmpSphere = new THREE.Sphere();\nconst tmpInverseMatrix = new THREE.Matrix4();\nconst tmpRay = new THREE.Ray();\nconst tmpLine1 = new THREE.Line3();\nconst tmpBox = new THREE.Box3();\nconst tmpOBB = new OrientedBox3();\nconst tmpPlane = new THREE.Plane();\nconst tmpV1 = new THREE.Vector3();\nconst tmpV2 = new THREE.Vector3();\nconst tmpV3 = new THREE.Vector3();\nconst tmpV4 = new THREE.Vector3();\n\n// Strides to access the index buffer. See [[createLineGeometry]].\n// Stride between the start vertex indices of consecutive segments, each one made of 2 triangles.\nconst SEGMENT_STRIDE = 6;\n// Stride between the start and end vertex indices of a segment. Vertices are duplicated so that\n// each copy is extruded in opposite directions in the vertex shader.\nconst VERTEX_STRIDE = 2;\n\nfunction isSolidLineMaterial(material: THREE.Material | THREE.Material[]): boolean {\n    return Array.isArray(material)\n        ? material.every(mat => mat instanceof SolidLineMaterial)\n        : material instanceof SolidLineMaterial;\n}\n\n/**\n * Identify the position attribute that has been used to create the bounding volumes.\n * Also store version info to be able to detect changes to the data.\n */\ninterface AttributeInfo {\n    /** Attribute used for bounding volume creation. */\n    data: THREE.BufferAttribute | THREE.InterleavedBuffer;\n\n    /** Version of attribute at time of bounding volume creation. */\n    version: number | undefined;\n}\n\n/**\n * Create an [[AttributeInfo]] for the specified attribute.\n * @param attribute The attribute to retrieve version info from.\n * @returns The [[AttributeInfo]] containing a reference and version of the attribute's data.\n */\nfunction getAttributeInfo(\n    attribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute\n): AttributeInfo {\n    const isBufferAttribute = (attribute as THREE.BufferAttribute).isBufferAttribute === true;\n\n    const data = isBufferAttribute\n        ? (attribute as THREE.BufferAttribute)\n        : (attribute as THREE.InterleavedBufferAttribute).data;\n\n    return {\n        data,\n        version: data.version\n    };\n}\n\n/**\n * Check if an attribute has changed compared to the version info.\n * @param attribute Attribute to check.\n * @param attrInfo Attribute version info.\n * @returns `true` if the attribute is the same, `false` otherwise.\n */\nfunction attributeChanged(\n    attribute: THREE.BufferAttribute | THREE.InterleavedBufferAttribute,\n    attrInfo: AttributeInfo\n): boolean {\n    const isBufferAttribute = (attribute as THREE.BufferAttribute).isBufferAttribute === true;\n\n    const data = isBufferAttribute\n        ? (attribute as THREE.BufferAttribute)\n        : (attribute as THREE.InterleavedBufferAttribute).data;\n\n    return (\n        attrInfo === undefined ||\n        attrInfo.data !== data ||\n        ((attribute as THREE.BufferAttribute).isBufferAttribute &&\n            attrInfo.version !== data.version)\n    );\n}\n\n/**\n * Computes the bounding sphere of the part of a given geometry corresponding to a feature.\n * @param geometry - The geometry containing the feature.\n * @param featureBeginIndex - The index where the feature starts in the geometry's\n *                            indices attribute.\n * @param featureEndIndex - The index where the feature end in the geometry's indices attribute.\n * @returns The feature bounding sphere.\n */\nfunction computeFeatureBoundingSphere(\n    geometry: THREE.BufferGeometry | DisplacedBufferGeometry,\n    featureBeginIndex: number,\n    featureEndIndex: number\n): THREE.Sphere {\n    let displacementRange: DisplacementRange | undefined;\n\n    if (geometry instanceof DisplacedBufferGeometry) {\n        displacementRange = geometry.displacementRange;\n        geometry = geometry.originalGeometry;\n    }\n\n    const attributes = geometry.attributes;\n    const pos = attributes.position as THREE.BufferAttribute;\n    const indices = geometry.index!.array;\n    const sphere = new THREE.Sphere();\n    const bbox = tmpBox.makeEmpty();\n    const vertex = tmpV1;\n\n    // First compute the bounding box for all line segments.\n    for (let i = featureBeginIndex; i < featureEndIndex; i += SEGMENT_STRIDE) {\n        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i]));\n        bbox.expandByPoint(vertex.fromBufferAttribute(pos, indices[i + VERTEX_STRIDE]));\n    }\n\n    if (displacementRange) {\n        // If geometry is displaced, expand the bounding box to cover the whole displacement range,\n        // and return the sphere bounding the box. This is a coarse estimation, but avoids having\n        // to displace all vertices.\n        // All normals in the geometry are assumed to be the same or close enough so that any of\n        // them can be used as displacement direction. For sphere projection, the surface normals\n        // within a tile are approximately the same from level 4 onwards. Here are some examples of\n        // the minimum dot product between normals in a tile (normals at tile's opposite corners):\n        // TILE: (6,9,4): 0.9806892129880023\n        // TILE: (12,17,5): 0.9946739445457075\n        // TILE: (25,34,6): 0.9986326302953471\n        // TILE: (50,68,7): 0.9996583822992287\n        // TILE: (1620,2199,12): 0.9999996706085572\n        const normal = tmpV2;\n        normal.fromBufferAttribute(geometry.attributes.normal as THREE.BufferAttribute, 0);\n        return displaceBox(bbox, displacementRange, normal).getBoundingSphere(sphere);\n    }\n\n    return bbox.getBoundingSphere(sphere);\n}\n\n/**\n * Finds the intersection of a ray with a extruded line.\n * @param ray - Intersection ray in object's local space.\n * @param line - The centerline.\n * @param vExtrusion - Line extrusion vector.\n * @param normal - Extrusion plane normal.\n * @param hWidth - Extrusion half width.\n * @returns Distance of the extruded line intersection to the ray origin.\n */\nfunction intersectExtrudedLine(\n    ray: THREE.Ray,\n    line: THREE.Line3,\n    vExtrusion: THREE.Vector3,\n    normal: THREE.Vector3,\n    hWidth: number\n): number {\n    const obb = tmpOBB;\n    line.getCenter(obb.position);\n    line.delta(obb.xAxis).normalize();\n    obb.yAxis.copy(vExtrusion);\n    obb.zAxis.copy(normal);\n    obb.extents.set(line.distance() / 2, hWidth, hWidth);\n\n    if (obb.contains(ray.origin)) {\n        return 0;\n    }\n    return obb.intersectsRay(ray) ?? Infinity;\n}\n\n/**\n * Finds the intersection of a ray with the closest end cap of a extruded line.\n * @param ray - Intersection ray in object's local space.\n * @param line - The centerline.\n * @param hWidth - Extrusion half width.\n * @returns Distance of the end cap intersection to the ray origin.\n */\nfunction intersectClosestEndCap(ray: THREE.Ray, line: THREE.Line3, hWidth: number): number {\n    const sphere = new THREE.Sphere(line.start, hWidth);\n    const startCapT = sphere.containsPoint(ray.origin)\n        ? 0\n        : ray.intersectSphere(sphere, tmpV4)\n        ? tmpV4.sub(ray.origin).length()\n        : Infinity;\n    sphere.center.copy(line.end);\n    const endCapT = sphere.containsPoint(ray.origin)\n        ? 0\n        : ray.intersectSphere(sphere, tmpV4)\n        ? tmpV4.sub(ray.origin).length()\n        : Infinity;\n    return Math.min(startCapT, endCapT);\n}\n\n/**\n * Intersects line\n * @param ray - Intersection ray in object's local space.\n * @param line - The line to intersect.\n * @param vExtrusion - Line extrusion vector.\n * @param hWidth - The line's extrusion half width.\n * @param hWidthSq - The line's extrusion half width squared.\n * @param plane - The extrusion plane.\n * @param interPlane - The intersection of the ray with the extrusion plane.\n * @param outInterLine - The ray intersection with the extruded line.\n * @returns true if ray intersects the extruded line, false otherwise.\n */\nfunction intersectLine(\n    ray: THREE.Ray,\n    line: THREE.Line3,\n    vExtrusion: THREE.Vector3,\n    hWidth: number,\n    hWidthSq: number,\n    plane: THREE.Plane,\n    interPlane: THREE.Vector3,\n    outInterLine: THREE.Vector3\n): boolean {\n    if (interPlane.equals(ray.origin) && ray.direction.dot(plane.normal) === 0) {\n        // Corner case: ray is coplanar to extruded line, find distance to extruded line sides\n        // and end caps.\n        const extrLineT = intersectExtrudedLine(ray, line, vExtrusion, plane.normal, hWidth);\n        const endCapT = intersectClosestEndCap(ray, line, hWidth);\n\n        const minT = Math.min(extrLineT, endCapT);\n        if (minT === Infinity) {\n            return false;\n        }\n        ray.at(minT, outInterLine);\n        return true;\n    }\n\n    // The plain intersection is also a line intersection only if it's closer to the line\n    // than the extrusion half width.\n    const distSq = interPlane.distanceToSquared(line.closestPointToPoint(interPlane, true, tmpV4));\n\n    if (distSq > hWidthSq) {\n        return false;\n    }\n    outInterLine.copy(interPlane);\n    return true;\n}\n\n/**\n * Finds the intersections of a ray with a partition of a solid line mesh representing a feature.\n * @param mesh - The mesh whose intersections will be found.\n * @param raycaster - Contains the intersection ray.\n * @param localRay - Same ray as raycaster.ray but in object's local space.\n * @param halfWidth - The line's extrusion half width.\n * @param lHalfWidth - The line's extrusion half width in mesh local space.\n * @param lHalfWidthSq - The line's extrusion half width squared in mesh local space.\n * @param beginIdx - The index where the feature starts in the mesh geometry's indices attribute.\n * @param endIdx - The index where the feature end in the mesh geometry's indices attribute.\n * @param bSphere - The feature bounding sphere.\n * @param intersections - Array where all intersections found between ray and feature will\n *                        be pushed.\n */\nfunction intersectFeature(\n    mesh: THREE.Mesh,\n    raycaster: THREE.Raycaster,\n    localRay: THREE.Ray,\n    halfWidth: number,\n    lHalfWidth: number,\n    lHalfWidthSq: number,\n    beginIdx: number,\n    endIdx: number,\n    bSphere: THREE.Sphere,\n    intersections: THREE.Intersection[]\n): void {\n    const vExt = tmpV1;\n    const plane = tmpPlane;\n    const interPlane = tmpV2;\n    const line = tmpLine1;\n\n    const geometry = mesh.geometry as THREE.BufferGeometry;\n    const attributes = geometry.attributes;\n    const position = attributes.position as THREE.BufferAttribute;\n    const bitangent = attributes.biTangent;\n    const indices = geometry.index!.array;\n\n    tmpSphere.copy(bSphere);\n    tmpSphere.applyMatrix4(mesh.matrixWorld);\n    tmpSphere.radius += halfWidth;\n\n    if (!raycaster.ray.intersectsSphere(tmpSphere)) {\n        return;\n    }\n\n    for (let i = beginIdx; i < endIdx; i += SEGMENT_STRIDE) {\n        const a = indices[i];\n        const b = indices[i + VERTEX_STRIDE];\n\n        // Find the plane containing the line segment, using the segment start, end and extrusion\n        // vector.\n        line.start.fromBufferAttribute(position, a);\n        line.end.fromBufferAttribute(position, b);\n        vExt.set(bitangent.getX(a), bitangent.getY(a), bitangent.getZ(a)).normalize();\n        plane.setFromCoplanarPoints(line.start, tmpV3.copy(line.start).add(vExt), line.end);\n        if (plane.normal.manhattanLength() === 0) {\n            // Invalid plane, coplanar points are actually collinear because:\n            // a) The line segment has length 0.\n            // b) The extrusion vector has length 0.\n            // c) The extrusion and segment directions are the same.\n            // In any case it's a degenerate segment, skip it.\n            continue;\n        }\n\n        // The ray intersection if any, will be on the extrusion plane.\n        if (!localRay.intersectPlane(plane, interPlane)) {\n            continue;\n        }\n\n        const interLine = tmpV3;\n        if (\n            !intersectLine(\n                localRay,\n                line,\n                vExt,\n                lHalfWidth,\n                lHalfWidthSq,\n                plane,\n                interPlane,\n                interLine\n            )\n        ) {\n            continue;\n        }\n\n        // Move back to world space for distance calculation\n        const interLineWorld = interLine.applyMatrix4(mesh.matrixWorld);\n\n        const distance = raycaster.ray.origin.distanceTo(interLineWorld);\n\n        if (distance < raycaster.near || distance > raycaster.far) {\n            continue;\n        }\n\n        intersections.push({\n            distance,\n            point: interLineWorld.clone(),\n            index: i,\n            object: mesh\n        });\n    }\n}\n\nconst singleFeatureStart = [0];\nconst MAX_SCALE_RATIO_DIFF = 1e-2;\n\n/**\n * Finds the intersections of a ray with a group within a solid line mesh.\n * @param mesh - The mesh whose intersections will be found.\n * @param material - The material used by the group inside the mesh.\n * @param raycaster -  Contains the intersection ray.\n * @param localRay - Same ray as raycaster.ray but in object's local space.\n * @param firstFeatureIdx - Index of the first feature in the group.\n * @param groupEndIdx - Index of the last vertex in the group.\n * @param intersections -  Array where all intersections found between ray and group will be pushed.\n * @returns The next feature index after the group.\n */\nfunction intersectGroup(\n    mesh: THREE.Mesh,\n    material: THREE.Material,\n    raycaster: THREE.Raycaster,\n    localRay: THREE.Ray,\n    firstFeatureIdx: number,\n    groupEndIdx: number,\n    intersections: THREE.Intersection[]\n): number {\n    const bVolumes = mesh.userData.feature.boundingVolumes;\n    assert(mesh.geometry instanceof THREE.BufferGeometry, \"Unsupported geometry type.\");\n    const geometry = mesh.geometry as THREE.BufferGeometry;\n    assert(isSolidLineMaterial(material), \"Unsupported material type\");\n    const solidLineMaterial = material as SolidLineMaterial;\n\n    const halfWidth = (solidLineMaterial.lineWidth + solidLineMaterial.outlineWidth) / 2;\n    // Assumption: scaling is uniform or close enough to use a local width independent of direction.\n    assert(Math.abs(1 - mesh.scale.x / mesh.scale.y) < MAX_SCALE_RATIO_DIFF);\n    assert(Math.abs(1 - mesh.scale.x / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);\n    assert(Math.abs(1 - mesh.scale.y / mesh.scale.z) < MAX_SCALE_RATIO_DIFF);\n    const localHalfWidth = halfWidth / ((mesh.scale.x + mesh.scale.y + mesh.scale.z) / 3);\n    const localHalfWidthSq = localHalfWidth * localHalfWidth;\n    const featureStarts = mesh.userData.feature.starts ?? singleFeatureStart;\n\n    let featureIdx = firstFeatureIdx;\n    let beginIdx = featureStarts[featureIdx];\n    const lastFeatureIdx = featureStarts.length - 1;\n\n    while (beginIdx < groupEndIdx) {\n        const bVolumeIdx = featureIdx;\n        const endIdx = featureIdx < lastFeatureIdx ? featureStarts[++featureIdx] : groupEndIdx;\n        if (bVolumeIdx >= bVolumes.length) {\n            // Geometry might be extruded on any direction. To avoid extruding all vertices, the\n            // centerline geometry is used to compute a bounding sphere whose radius is later\n            // expanded by the extrusion half width to ensure it contains the extruded geometry.\n            bVolumes.push(computeFeatureBoundingSphere(geometry, beginIdx, endIdx));\n        }\n        intersectFeature(\n            mesh,\n            raycaster,\n            localRay,\n            halfWidth,\n            localHalfWidth,\n            localHalfWidthSq,\n            beginIdx,\n            endIdx,\n            bVolumes[bVolumeIdx],\n            intersections\n        );\n        beginIdx = endIdx;\n    }\n    return featureIdx;\n}\n\n/**\n * Mesh formed by extruding a polyline in the shaders. Overrides raycasting behaviour to account for\n * extrusion, see [[SolidLineMaterial]].\n * @internal\n */\nexport class SolidLineMesh extends THREE.Mesh {\n    /**\n     * Finds the intersections of a ray with a mesh, assuming the mesh is a polyline extruded in\n     * the shaders (see [[SolidLineMaterial]]).\n     * @param mesh - The mesh whose intersections will be found.\n     * @param raycaster - Contains the intersection ray.\n     * @param intersections - Array where all intersections found between ray and mesh will\n     *                        be pushed.\n     */\n    static raycast(\n        mesh: THREE.Mesh,\n        raycaster: THREE.Raycaster,\n        intersections: THREE.Intersection[]\n    ): void {\n        assert(mesh.geometry instanceof THREE.BufferGeometry, \"Unsupported geometry type\");\n        const geometry = mesh.geometry as THREE.BufferGeometry;\n        assert(geometry.index !== null, \"Geometry does not have indices\");\n        const matrixWorld = mesh.matrixWorld;\n\n        tmpInverseMatrix.copy(matrixWorld).invert();\n        const localRay = tmpRay.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n\n        // Test intersection of ray with each of the features within the mesh.\n        if (mesh.userData.feature === undefined) {\n            mesh.userData.feature = {};\n        }\n\n        const positionAttribute = geometry.attributes[\"position\"];\n        const attributeInfo: AttributeInfo | undefined = mesh.userData.feature\n            .attributeInfo as AttributeInfo;\n\n        // Rebuild bounding volumes if geometry has been modified.\n        if (\n            attributeInfo === undefined ||\n            mesh.userData.feature.boundingVolumes === undefined ||\n            attributeChanged(positionAttribute, attributeInfo)\n        ) {\n            mesh.userData.feature.boundingVolumes = [];\n            mesh.userData.feature.attributeInfo = getAttributeInfo(positionAttribute);\n        }\n\n        const indices = geometry.index!.array;\n\n        if (Array.isArray(mesh.material)) {\n            let nextFeatureIdx = 0;\n            for (const group of geometry.groups) {\n                const material = mesh.material[group.materialIndex!];\n                const groupEndIdx = group.start + group.count;\n                nextFeatureIdx = intersectGroup(\n                    mesh,\n                    material,\n                    raycaster,\n                    localRay,\n                    nextFeatureIdx,\n                    groupEndIdx,\n                    intersections\n                );\n            }\n        } else {\n            intersectGroup(\n                mesh,\n                mesh.material,\n                raycaster,\n                localRay,\n                0,\n                indices.length,\n                intersections\n            );\n        }\n    }\n\n    /**\n     * Creates an instance of SolidLineMesh.\n     * @param geometry - Mesh geometry.\n     * @param material - Material(s) to be used by the mesh. They must be instances of\n     * [[SolidLineMaterial]].\n     */\n    constructor(geometry: THREE.BufferGeometry, material: THREE.Material | THREE.Material[]) {\n        super(geometry, material);\n    }\n\n    // HARP-9585: Override of base class method, however tslint doesn't recognize it as such.\n    raycast(raycaster: THREE.Raycaster, intersects: THREE.Intersection[]): void {\n        SolidLineMesh.raycast(this, raycaster, intersects);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryType, getFeatureId } from \"@here/harp-datasource-protocol\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { Tile, TileFeatureData } from \"../Tile\";\nimport {\n    BufferedGeometryLineAccessor,\n    BufferedGeometryObject3dAccessor,\n    IGeometryAccessor,\n    ILineAccessor,\n    IndexedBufferedGeometryLineAccessor,\n    IObject3dAccessor,\n    isLineAccessor,\n    isObject3dAccessor\n} from \"./TileGeometry\";\n\nconst logger = LoggerManager.instance.create(\"TileDataAccessor\");\n\n/**\n * Interface for a client visitor that is used to visit all `THREE.Object`s in a tile.\n */\nexport interface ITileDataVisitor {\n    tile: Tile;\n\n    /**\n     * Should return `true` if the visitor wants to visit the object with the specified\n     * `featureId`. This function is called before the type of the object is even known.\n     * @remarks Number ids are deprecated in favor of strings.\n     */\n    wantsFeature(featureId: number | string | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the point with the specified\n     * `featureId`.\n     * @remarks Number ids are deprecated in favor of strings.\n     */\n    wantsPoint(featureId: number | string | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the line with the specified\n     * `featureId`.\n     * @remarks Number ids are deprecated in favor of strings.\n     */\n    wantsLine(featureId: number | string | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the area object with the specified\n     * `featureId`.\n     * @remarks Number ids are deprecated in favor of strings.\n     */\n    wantsArea(featureId: number | string | undefined): boolean;\n\n    /**\n     * Should return `true` if the visitor wants to visit the object with the specified\n     * `featureId`.\n     * @remarks Number ids are deprecated in favor of strings.\n     */\n    wantsObject3D(featureId: number | string | undefined): boolean;\n\n    /**\n     * Visits a point object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     * @remarks Number ids are deprecated in favor of strings.\n     */\n    visitPoint(featureId: number | string | undefined): void;\n\n    /**\n     * Visits a line object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     * @remarks Number ids are deprecated in favor of strings.\n     */\n    visitLine(featureId: number | string | undefined, lineAccessor: ILineAccessor): void;\n\n    /**\n     * Visit an area object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     * @remarks Number ids are deprecated in favor of strings.\n     */\n    visitArea(featureId: number | string | undefined): void;\n\n    /**\n     * Visits a 3D object with the specified `featureId`; use `pointAccessor` to get the\n     * object's properties.\n     * @remarks Number ids are deprecated in favor of strings.\n     */\n    visitObject3D(\n        featureId: number | string | undefined,\n        object3dAccessor: IObject3dAccessor\n    ): void;\n}\n\n/**\n * An interface that provides options for {@link TileDataAccessor}.\n */\nexport interface TileDataAccessorOptions {\n    /** Limit to objects that have `featureID`s. */\n    onlyWithFeatureIds?: boolean;\n    /** Sets and overrides `wantPoints`, `wantLines`, `wantAreas`, `wantObject3D`. */\n    wantsAll?: boolean;\n    /** `true` to visit points. */\n    wantsPoints?: boolean;\n    /** `true` to visit lines. */\n    wantsLines?: boolean;\n    /** `true` to visit area objects. */\n    wantsAreas?: boolean;\n    /** `true` to visit general 3D objects. */\n    wantsObject3D?: boolean;\n}\n\n/**\n * An accessor for all geometries in a tile.\n *\n * @remarks\n * This class uses a client-provided {@link ITileDataVisitor}\n * to visit all objects, based on filtering options specified\n * by both, the `TileDataAccessor` and\n * the visitor itself.\n */\nexport class TileDataAccessor {\n    private readonly m_wantsPoints: boolean;\n    private readonly m_wantsLines: boolean;\n    private readonly m_wantsAreas: boolean;\n    private readonly m_wantsObject3D: boolean;\n\n    /**\n     * Constructs a `TileDataAccessor` instance.\n     *\n     * @param tile - The tile to access.\n     * @param visitor - The visitor.\n     * @param options - Options for the tile.\n     */\n    constructor(\n        public tile: Tile,\n        private readonly visitor: ITileDataVisitor,\n        options: TileDataAccessorOptions\n    ) {\n        const wantsAll = options.wantsAll === true;\n        this.m_wantsPoints = wantsAll || !(options.wantsPoints === false);\n        this.m_wantsLines = wantsAll || !(options.wantsLines === false);\n        this.m_wantsAreas = wantsAll || !(options.wantsAreas === false);\n        this.m_wantsObject3D = wantsAll || !(options.wantsObject3D === false);\n    }\n\n    /**\n     * Calls the visitor on all objects in the tile.\n     */\n    visitAll(): void {\n        const objects = this.tile.objects;\n\n        for (const object of objects) {\n            this.visitObject(object);\n        }\n    }\n\n    /**\n     * Visits a single object. This function should normally be called during visiting.\n     *\n     * @param object - The object to visit.\n     */\n    protected visitObject(object: THREE.Object3D): void {\n        const featureData: TileFeatureData | undefined =\n            object.userData !== undefined\n                ? (object.userData.feature as TileFeatureData)\n                : undefined;\n\n        // early opt out if there is no feature data, or if the feature data has only a single id\n        // and the visitor wants to ignore that featureId\n        if (\n            featureData === undefined ||\n            (featureData.objInfos !== undefined &&\n                featureData.objInfos.length === 1 &&\n                !this.visitor.wantsFeature(getFeatureId(featureData.objInfos[0])))\n        ) {\n            return;\n        }\n\n        const geometryType = featureData.geometryType;\n        if (geometryType === undefined) {\n            logger.warn(\"#visitObject: visiting object failed, no geometryType\", object);\n            return;\n        }\n\n        assert(featureData.objInfos !== undefined, \"featureData.ids missing\");\n        assert(featureData.starts !== undefined, \"featureData.starts missing\");\n        assert(Array.isArray(featureData.starts), \"featureData.starts is not an array\");\n        if (featureData.objInfos !== undefined && featureData.starts !== undefined) {\n            assert(\n                featureData.objInfos.length === featureData.starts.length,\n                \"featureData.ids and featureData.starts have unequal length\"\n            );\n        }\n\n        switch (geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                if (!this.m_wantsPoints) {\n                    return;\n                }\n                break;\n            case GeometryType.SolidLine:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.TextPath:\n                if (!this.m_wantsLines) {\n                    return;\n                }\n                break;\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                if (!this.m_wantsAreas) {\n                    return;\n                }\n                break;\n            case GeometryType.Object3D:\n                if (!this.m_wantsObject3D) {\n                    return;\n                }\n                break;\n            default:\n                logger.warn(\"#visitObject: invalid geometryType\");\n        }\n\n        if (object.type !== \"Mesh\") {\n            logger.warn(\"#visitObject: visiting object failed, not of type 'Mesh'\", object);\n            return;\n        }\n\n        const mesh = object as THREE.Mesh;\n\n        this.visitMesh(mesh, featureData);\n    }\n\n    /**\n     * Gets the `BufferGeometry` from the specified object. This function requires the\n     * attribute `position` in `BufferGeometry` to be set.\n     *\n     * @param object - The object from which to get the geometry.\n     * @returns the geometry of the object, or `undefined`.\n     */\n    protected getBufferGeometry(object: THREE.Mesh): THREE.BufferGeometry | undefined {\n        const geometry = object.geometry;\n\n        if (geometry.type !== \"BufferGeometry\") {\n            logger.warn(\"#visitObject: object does not have BufferGeometry\");\n            return undefined;\n        }\n\n        const bufferGeometry = geometry as THREE.BufferGeometry;\n\n        // we know its a BufferAttribute because it is a BufferGeometry\n        const position: THREE.BufferAttribute = bufferGeometry.getAttribute(\n            \"position\"\n        ) as THREE.BufferAttribute;\n\n        if (!position) {\n            logger.warn(\"#visitLines: BufferGeometry has no position attribute\");\n            return undefined;\n        }\n\n        return bufferGeometry;\n    }\n\n    /**\n     * Obtains an accessor for the nonindexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType - The type of geometry.\n     * @param object - The object for which to access the attributes and geometry.\n     * @param bufferGeometry - The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    protected getGeometryAccessor(\n        geometryType: GeometryType,\n        object: THREE.Mesh,\n        bufferGeometry: THREE.BufferGeometry\n    ): IGeometryAccessor | undefined {\n        switch (geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.SolidLine:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.TextPath:\n                return new BufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.Object3D:\n                return new BufferedGeometryObject3dAccessor(object, geometryType, bufferGeometry);\n            default:\n                logger.warn(\"#getGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Obtains an accessor for the indexed geometry. This function may return `undefined`\n     * if the accessor is not implemented.\n     *\n     * @param geometryType - The type of geometry.\n     * @param object - The object for which to access the attributes and geometry.\n     * @param bufferGeometry - The object's `BufferGeometry`.\n     * @returns an accessor for a specified object, if available.\n     */\n    protected getIndexedGeometryAccessor(\n        geometryType: GeometryType,\n        object: THREE.Mesh,\n        bufferGeometry: THREE.BufferGeometry\n    ): IGeometryAccessor | undefined {\n        switch (geometryType) {\n            case GeometryType.Point:\n            case GeometryType.Text:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.SolidLine:\n            case GeometryType.ExtrudedLine:\n            case GeometryType.TextPath:\n                return new IndexedBufferedGeometryLineAccessor(\n                    object,\n                    geometryType,\n                    bufferGeometry\n                );\n            case GeometryType.Polygon:\n            case GeometryType.ExtrudedPolygon:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            case GeometryType.Object3D:\n                // return new RoBufferedGeometryLineAccessor(object, geometryType, bufferGeometry);\n                return undefined;\n            default:\n                logger.warn(\"#getIndexedGeometryAccessor: invalid geometryType\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Visit the object.\n     *\n     * @param meshObject - Object of type `Mesh`.\n     * @param featureData - Dataset stored along with the object.\n     */\n    protected visitMesh(meshObject: THREE.Mesh, featureData: TileFeatureData): void {\n        const { objInfos, starts } = featureData;\n        const geometryType = featureData.geometryType;\n\n        // make linter happy: we already know that these both are valid\n        if (objInfos === undefined || starts === undefined || geometryType === undefined) {\n            return;\n        }\n\n        let geometryAccessor: IGeometryAccessor | undefined;\n\n        for (let featureIndex = 0; featureIndex < objInfos.length; featureIndex++) {\n            const featureId = getFeatureId(objInfos[featureIndex]);\n\n            if (!this.visitor.wantsFeature(featureId)) {\n                continue;\n            }\n\n            const featureStart = starts[featureIndex];\n            let featureEnd: number = -1;\n\n            // lazy creation of accessor, in case featureId was not wanted...\n            if (geometryAccessor === undefined) {\n                const bufferGeometry = this.getBufferGeometry(meshObject);\n                if (bufferGeometry === undefined) {\n                    continue;\n                }\n\n                if (bufferGeometry.index !== null) {\n                    geometryAccessor = this.getIndexedGeometryAccessor(\n                        geometryType,\n                        meshObject,\n                        bufferGeometry\n                    );\n                } else {\n                    geometryAccessor = this.getGeometryAccessor(\n                        geometryType,\n                        meshObject,\n                        bufferGeometry\n                    );\n                }\n\n                if (geometryAccessor === undefined) {\n                    logger.warn(\"#visitObject: no accessor geometryType\", geometryType);\n                    continue;\n                }\n            }\n\n            featureEnd =\n                featureIndex < starts.length - 1\n                    ? starts[featureIndex + 1]\n                    : geometryAccessor.getCount();\n\n            // setup/update the accessor for the new range of the object\n            geometryAccessor.setRange(featureStart, featureEnd);\n\n            switch (geometryType) {\n                case GeometryType.Point:\n                case GeometryType.Text:\n                    this.visitor.visitPoint(featureId);\n                    break;\n                case GeometryType.SolidLine:\n                case GeometryType.ExtrudedLine:\n                case GeometryType.TextPath:\n                    assert(isLineAccessor(geometryAccessor));\n                    this.visitor.visitLine(featureId, (geometryAccessor as any) as ILineAccessor);\n                    break;\n                case GeometryType.Polygon:\n                case GeometryType.ExtrudedPolygon:\n                    this.visitor.visitArea(featureId);\n                    break;\n                case GeometryType.Object3D:\n                    assert(isObject3dAccessor(geometryAccessor));\n                    this.visitor.visitObject3D(\n                        featureId,\n                        (geometryAccessor as any) as IObject3dAccessor\n                    );\n                    break;\n                default:\n                    logger.warn(\"#visitObject: invalid geometryType\");\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryType } from \"@here/harp-datasource-protocol\";\nimport { reconstructLineWidth } from \"@here/harp-lines\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nconst logger = LoggerManager.instance.create(\"TileGeometry\");\n\n/**\n * Interface to access lines. Allows read access for some important attributes.\n */\nexport interface ILineAccessor {\n    /**\n     * Hint for the original type of geometry.\n     */\n    geometryType: GeometryType;\n\n    /**\n     * Get the color from materials.\n     */\n    color: THREE.Color | undefined | Array<THREE.Color | undefined>;\n\n    /**\n     * Get the width. May have to be reconstructed from triangulated line mesh.\n     */\n    width: number | undefined;\n\n    /**\n     * Render order.\n     */\n    renderOrder: number;\n\n    /**\n     * Helper for function `isLineAccessor`.\n     *\n     * @returns `true` if it is a line accessor.\n     */\n    isLineAccessor(): boolean;\n\n    /**\n     * Clear the object from the mesh.\n     */\n    clear(): void;\n\n    /**\n     * Get vertices from the object.\n     */\n    getVertices(): Float32Array | undefined;\n}\n\n/**\n * Helper function to check if an accessor is of type `ILineAccessor`.\n *\n * @param arg - `true` if `arg` is `ILineAccessor`.\n * @internal\n */\nexport function isLineAccessor(arg: any): arg is ILineAccessor {\n    /**\n     * Get vertices from the object.\n     *\n     * @param mode - Specifies which part of the vertices should be returned.\n     */\n\n    return typeof arg.isLineAccessor === \"function\" && arg.isLineAccessor() === true;\n}\n\n/**\n * Accessor for unspecified 3D objects, like landmarks.\n */\nexport interface IObject3dAccessor {\n    /**\n     * Hint for the original type of geometry.\n     */\n    geometryType: GeometryType;\n\n    /**\n     * Get the color from materials.\n     */\n    color: THREE.Color | undefined | Array<THREE.Color | undefined>;\n\n    /**\n     * Render order.\n     */\n    renderOrder: number;\n\n    /**\n     * Helper for function `isObject3dAccessor`.\n     *\n     * @returns `true` if it is a line accessor.\n     */\n    isObject3dAccessor(): boolean;\n\n    /**\n     * Clear the object from the mesh.\n     */\n    clear(): void;\n\n    getVertices(): Float32Array | undefined;\n}\n\n/**\n * Helper function to check if an accessor is of type `IObject3dAccessor`.\n *\n * @param arg - `true` if `arg` is `IObject3dAccessor`.\n * @internal\n */\nexport function isObject3dAccessor(arg: any): arg is IObject3dAccessor {\n    return typeof arg.isObject3dAccessor === \"function\" && arg.isObject3dAccessor() === true;\n}\n\n/**\n * Basic interface for geometry accessors.\n */\nexport interface IGeometryAccessor {\n    /**\n     * Get the number of primitives (vertices of triangles).\n     *\n     * @returns Number of primitives.\n     */\n    getCount(): number;\n\n    /**\n     * Set range of primitives in this object related to one or more buffers.\n     *\n     * @param start - Start index in buffers.\n     * @param end - End index in buffers (+1).\n     */\n    setRange(start: number, end: number): void;\n}\n\n/**\n * Geometry accessor for both indexed and nonindexed `BufferedGeometry`.\n */\nexport abstract class BufferedGeometryAccessorBase implements IGeometryAccessor {\n    protected start: number = -1;\n    protected end: number = -1;\n    protected startCapSize: number = 0;\n    protected endCapSize: number = 0;\n    protected position: THREE.BufferAttribute;\n    protected itemSize: number;\n\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        protected readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        assert(!!object);\n\n        if (bufferGeometry.type !== \"BufferGeometry\") {\n            logger.error(\n                \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong \" + \"type\"\n            );\n        }\n        assert(\n            bufferGeometry.type === \"BufferGeometry\",\n            \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has wrong type\"\n        );\n\n        // we know its a BufferAttribute because it is a BufferGeometry\n        this.position = this.bufferGeometry.getAttribute(\"position\") as THREE.BufferAttribute;\n        this.itemSize = this.position.itemSize;\n\n        if (!this.position) {\n            logger.warn(\n                \"BufferedGeometryAccessor#constructor: BufferGeometry has no position \" +\n                    \"attribute\"\n            );\n        }\n\n        if (this.position.array.constructor !== Float32Array) {\n            logger.warn(\n                \"BufferedGeometryAccessor#constructor: BufferGeometry.position: \" +\n                    \"unsupported ArrayBuffer\"\n            );\n        }\n    }\n\n    /**\n     * Get the number of accessible geometries in this buffer.\n     *\n     * @returns Number of primitives in this geometry.\n     */\n    getCount(): number {\n        return this.position.count;\n    }\n\n    /**\n     * Get `renderOrder` of object.\n     *\n     * @returns `renderOrder` of the object.\n     */\n    get renderOrder(): number {\n        return this.object.renderOrder;\n    }\n\n    setRange(start: number, end: number, startCapSize: number = 0, endCapSize: number = 0) {\n        assert(start >= 0);\n        assert(end >= 0);\n        assert(start <= end);\n        this.start = start;\n        this.end = end;\n        this.startCapSize = startCapSize;\n        this.endCapSize = endCapSize;\n    }\n\n    /**\n     * Get one or more colors from materials.\n     */\n    get color(): THREE.Color | undefined | Array<THREE.Color | undefined> {\n        /**\n         * TODO: Get color(s) from vertex colors\n         */\n        const getColor = (material: THREE.Material) => {\n            const meshMaterial = material as THREE.MeshBasicMaterial;\n            if (\n                meshMaterial.type === \"MeshBasicMaterial\" ||\n                meshMaterial.type === \"MeshStandardMaterial\"\n            ) {\n                return meshMaterial.color;\n            } else if (meshMaterial.type === \"RawShaderMaterial\") {\n                const rawShaderMaterial = material as THREE.RawShaderMaterial;\n\n                if (rawShaderMaterial.name === \"SolidLineMaterial\") {\n                    return rawShaderMaterial.uniforms.diffuseColor.value as THREE.Color;\n                }\n\n                logger.warn(\n                    \"BufferedGeometryAccessor#color: unknown shader material name\",\n                    rawShaderMaterial.name\n                );\n            } else {\n                logger.warn(\n                    \"BufferedGeometryAccessor#color: unknown material type\",\n                    meshMaterial.type\n                );\n            }\n\n            return undefined;\n        };\n\n        if (Array.isArray(this.object.material)) {\n            const results = new Array<THREE.Color | undefined>();\n            const materials = this.object.material as THREE.Material[];\n\n            for (const material of materials) {\n                results.push(getColor(material));\n            }\n\n            return results;\n        } else {\n            return getColor(this.object.material);\n        }\n    }\n}\n\n/**\n * Abstract base class of an accessor for nonindexed geometry.\n */\nexport abstract class BufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    /**\n     * Create an object of type `BufferedGeometryAccessor`\n     *\n     * @param object - mesh object\n     * @param geometryType - type of geometry to be used\n     * @param bufferGeometry - which buffer geometry to use\n     * @param stride - geometry stride length\n     */\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        protected readonly bufferGeometry: THREE.BufferGeometry,\n        protected stride: number\n    ) {\n        super(object, geometryType, bufferGeometry);\n    }\n\n    clear(): void {\n        assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n\n        const positionsArray = this.position.array as number[];\n\n        const start = this.start * this.itemSize;\n        const end = this.end * this.itemSize;\n\n        for (let i = start; i < end; i++) {\n            positionsArray[i] = 0;\n        }\n\n        this.position.needsUpdate = true;\n    }\n\n    getVertices(): Float32Array | undefined {\n        assert(this.checkSetUp(), \"BufferedGeometryAccessor not setup\");\n\n        const start = this.start;\n        const end = this.end;\n\n        return (this.position.array as Float32Array).subarray(\n            start * this.itemSize,\n            end * this.itemSize\n        );\n    }\n\n    protected checkSetUp(): boolean {\n        return (\n            this.position !== undefined &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.position.count &&\n            this.start <= this.end\n        );\n    }\n}\n\n/**\n * Accessor for nonindexed line geometry.\n */\nexport class BufferedGeometryLineAccessor\n    extends BufferedGeometryAccessor\n    implements ILineAccessor {\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        super(object, geometryType, bufferGeometry, 3);\n    }\n\n    isLineAccessor(): boolean {\n        return true;\n    }\n\n    get width(): number | undefined {\n        //TODO: There is no implementation of such a line, yet...\n        assert(this.checkSetUp(), \"RoBufferedGeometryLineAccessor not setup\");\n        return undefined;\n    }\n}\n\n/**\n * Accessor for nonindexed unspecified (`Object3D`) geometry.\n */\nexport class BufferedGeometryObject3dAccessor\n    extends BufferedGeometryAccessor\n    implements IObject3dAccessor {\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        super(object, geometryType, bufferGeometry, 1);\n    }\n\n    isObject3dAccessor(): boolean {\n        return true;\n    }\n\n    /** @override */\n    getVertices(): Float32Array | undefined {\n        return super.getVertices();\n    }\n}\n\n/**\n * Abstract base class of indexed geometry.\n */\nexport abstract class IndexedBufferedGeometryAccessor extends BufferedGeometryAccessorBase {\n    indices: number[];\n\n    /**\n     * Creates an abstract class `IndexedBufferedGeometryAccessor`.\n     *\n     * @param object - mesh to be used\n     * @param geometryType - type of geometry\n     * @param bufferGeometry - geometry used\n     * @param start -\n     * @param end -\n     */\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        protected readonly bufferGeometry: THREE.BufferGeometry,\n        start?: number,\n        end?: number\n    ) {\n        super(object, geometryType, bufferGeometry);\n\n        this.indices =\n            this.bufferGeometry.index !== null\n                ? (this.bufferGeometry.index.array as number[])\n                : ((undefined as any) as number[]);\n\n        if (!this.indices) {\n            logger.warn(\n                \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry has no \" + \"index\"\n            );\n            assert(!!this.indices);\n        } else {\n            if (!(this.indices instanceof Uint32Array)) {\n                logger.warn(\n                    \"IndexedBufferedGeometryAccessor#constructor: BufferGeometry index \" +\n                        \"has wrong type\"\n                );\n                assert(this.indices instanceof Uint32Array);\n            }\n        }\n    }\n\n    /**\n     * Returns number of primitives, which is not known in this base class, so we return the number\n     * of indices.\n     *\n     * @returns The number of indices in the geometry.\n     * @override\n     */\n    getCount(): number {\n        return this.indices.length;\n    }\n\n    protected checkSetUp(): boolean {\n        return (\n            !!this.indices &&\n            this.start !== undefined &&\n            this.end !== undefined &&\n            this.start >= 0 &&\n            this.end <= this.indices.length &&\n            this.start <= this.end\n        );\n    }\n}\n\n/**\n * Accessor for lines in an indexed geometry.\n */\nexport class IndexedBufferedGeometryLineAccessor\n    extends IndexedBufferedGeometryAccessor\n    implements ILineAccessor {\n    constructor(\n        readonly object: THREE.Mesh,\n        readonly geometryType: GeometryType,\n        readonly bufferGeometry: THREE.BufferGeometry\n    ) {\n        super(object, geometryType, bufferGeometry, 3);\n    }\n\n    isLineAccessor(): boolean {\n        return true;\n    }\n\n    /**\n     * Reconstructs line width from triangulated geometry.\n     *\n     * @returns Line width.\n     */\n    get width(): number | undefined {\n        assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n\n        if (this.geometryType === GeometryType.ExtrudedLine) {\n            const start = this.start + this.startCapSize;\n            const positionArray = this.position.array as Float32Array;\n            return reconstructLineWidth(positionArray, start);\n        }\n\n        return undefined;\n    }\n\n    clear(): void {\n        assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n\n        const start = this.start;\n        const end = this.end;\n\n        for (let i = start; i < end; i++) {\n            this.indices[i] = 0;\n        }\n\n        if (this.bufferGeometry.index !== null) {\n            this.bufferGeometry.index.needsUpdate = true;\n        }\n    }\n\n    getVertices(): Float32Array | undefined {\n        assert(this.checkSetUp(), \"RoIndexedBufferedGeometryLineAccessor not setup\");\n\n        const itemSize = this.itemSize;\n\n        const start = this.start;\n        const end = this.end;\n\n        const result = new Float32Array((end - start) * itemSize);\n        const positionArray = this.position.array;\n\n        if (itemSize === 2) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n            }\n        }\n        if (itemSize === 3) {\n            for (let i = start, j = 0; i < end; i++, j += itemSize) {\n                const index = this.indices[i];\n                result[j + 0] = positionArray[index * itemSize + 0];\n                result[j + 1] = positionArray[index * itemSize + 1];\n                result[j + 2] = positionArray[index * itemSize + 2];\n            }\n        } else {\n            for (let i = start, j = 0; i < end; i++, j++) {\n                const index = this.indices[i];\n                for (let k = 0; k < itemSize; k++) {\n                    result[j * itemSize + k] = positionArray[index * itemSize + k];\n                }\n            }\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    Attachment,\n    BaseTechniqueParams,\n    BufferAttribute,\n    CallExpr,\n    DecodedTile,\n    Env,\n    Expr,\n    ExtrudedPolygonTechnique,\n    FillTechnique,\n    Geometry,\n    GeometryKindSet,\n    getArrayConstructor,\n    getPropertyValue,\n    IndexedTechnique,\n    InterleavedBufferAttribute,\n    isCirclesTechnique,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isFillTechnique,\n    isJsonExpr,\n    isLineMarkerTechnique,\n    isLineTechnique,\n    isPoiTechnique,\n    isSegmentsTechnique,\n    isSolidLineTechnique,\n    isSquaresTechnique,\n    isStandardTechnique,\n    isTerrainTechnique,\n    isTextTechnique,\n    MakeTechniqueAttrs,\n    MapEnv,\n    needsVertexNormals,\n    Pickability,\n    SolidLineTechnique,\n    StandardExtrudedLineTechnique,\n    Technique,\n    TerrainTechnique,\n    TextPathGeometry,\n    transientToPickability,\n    Value\n} from \"@here/harp-datasource-protocol\";\nimport {\n    ExprEvaluatorContext,\n    OperatorDescriptor\n} from \"@here/harp-datasource-protocol/lib/ExprEvaluator\";\nimport { EarthConstants, ProjectionType } from \"@here/harp-geoutils\";\nimport {\n    EdgeMaterial,\n    EdgeMaterialParameters,\n    ExtrusionFeature,\n    FadingFeature,\n    hasExtrusionFeature,\n    isHighPrecisionLineMaterial,\n    MapMeshDepthMaterial,\n    MapMeshStandardMaterial,\n    setDisplacementMapToMaterial,\n    setShaderMaterialDefine,\n    SolidLineMaterial\n} from \"@here/harp-materials\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport {\n    applyBaseColorToMaterial,\n    buildMetricValueEvaluator,\n    buildObject,\n    createMaterial,\n    getBufferAttribute,\n    usesObject3D\n} from \"../DecodedTileHelpers\";\nimport {\n    createDepthPrePassMesh,\n    isRenderDepthPrePassEnabled,\n    setDepthPrePassStencil\n} from \"../DepthPrePass\";\nimport { DisplacementMap, TileDisplacementMap } from \"../DisplacementMap\";\nimport { MapAdapterUpdateEnv, MapMaterialAdapter } from \"../MapMaterialAdapter\";\nimport { MapViewPoints } from \"../MapViewPoints\";\nimport { PathBlockingElement } from \"../PathBlockingElement\";\nimport { TextElementBuilder } from \"../text/TextElementBuilder\";\nimport { Tile, TileFeatureData } from \"../Tile\";\nimport { addGroundPlane } from \"./AddGroundPlane\";\nimport { registerTileObject } from \"./RegisterTileObject\";\n\nconst logger = LoggerManager.instance.create(\"TileGeometryCreator\");\n\nconst tmpVector3 = new THREE.Vector3();\nconst tmpVector2 = new THREE.Vector2();\n\nclass AttachmentCache {\n    readonly bufferAttributes = new Map<BufferAttribute, THREE.BufferAttribute>();\n\n    readonly interleavedAttributes = new Map<\n        InterleavedBufferAttribute,\n        Array<{ name: string; attribute: THREE.InterleavedBufferAttribute }>\n    >();\n}\n\nclass MemoCallExpr extends CallExpr implements OperatorDescriptor {\n    private readonly m_deps: string[];\n    private readonly m_cachedProperties: Array<Value | undefined> = [];\n    private m_cachedValue?: Value;\n\n    constructor(expr: Expr) {\n        super(\"memo\", [expr]);\n        this.m_deps = Array.from(expr.dependencies().properties);\n        this.descriptor = this;\n    }\n\n    call(context: ExprEvaluatorContext): Value {\n        let changed = false;\n\n        this.m_deps.forEach((d, i) => {\n            const newValue = context.env.lookup(d);\n            if (!changed && newValue !== this.m_cachedProperties[i]) {\n                changed = true;\n            }\n            if (changed) {\n                this.m_cachedProperties[i] = newValue;\n            }\n        });\n\n        if (changed || this.m_cachedValue === undefined) {\n            this.m_cachedValue = context.evaluate(this.args[0]);\n        }\n\n        return this.m_cachedValue;\n    }\n}\n\nclass AttachmentInfo {\n    constructor(\n        readonly geometry: Geometry,\n        readonly info: Attachment,\n        readonly cache: AttachmentCache\n    ) {}\n\n    getBufferAttribute(description: BufferAttribute): THREE.BufferAttribute {\n        if (this.cache.bufferAttributes.has(description)) {\n            return this.cache.bufferAttributes.get(description)!;\n        }\n        const attribute = getBufferAttribute(description);\n        this.cache.bufferAttributes.set(description, attribute);\n        return attribute;\n    }\n\n    getInterleavedBufferAttributes(description: InterleavedBufferAttribute) {\n        const interleavedAttributes = this.cache.interleavedAttributes.get(description);\n\n        if (interleavedAttributes) {\n            return interleavedAttributes;\n        }\n\n        const ArrayCtor = getArrayConstructor(description.type);\n        const buffer = new ArrayCtor(description.buffer);\n        const interleavedBuffer = new THREE.InterleavedBuffer(buffer, description.stride);\n\n        const attrs = description.attributes.map(interleavedAttr => {\n            const attribute = new THREE.InterleavedBufferAttribute(\n                interleavedBuffer,\n                interleavedAttr.itemSize,\n                interleavedAttr.offset,\n                false\n            );\n            const name = interleavedAttr.name;\n            return { name, attribute };\n        });\n\n        this.cache.interleavedAttributes.set(description, attrs);\n        return attrs;\n    }\n}\n\nfunction addToExtrudedMaterials(\n    material: THREE.Material | THREE.Material[],\n    extrudedMaterials: ExtrusionFeature[]\n) {\n    if (Array.isArray(material)) {\n        const materials = material as ExtrusionFeature[];\n        extrudedMaterials.push(...materials);\n    } else {\n        extrudedMaterials.push(material as ExtrusionFeature);\n    }\n}\n\n/**\n * Parameters that control fading.\n */\nexport interface FadingParameters {\n    fadeNear?: number;\n    fadeFar?: number;\n}\n\n/**\n * Parameters that control fading for extruded buildings with fading edges.\n */\nexport interface PolygonFadingParameters extends FadingParameters {\n    color?: string | number;\n    colorMix?: number;\n    lineFadeNear?: number;\n    lineFadeFar?: number;\n}\n\n/**\n * Support class to create geometry for a {@link Tile} from a {@link @here/harp-datasource-protocol#DecodedTile}.\n * @internal\n */\nexport class TileGeometryCreator {\n    private static m_instance: TileGeometryCreator;\n\n    /**\n     * The `instance` of the `TileGeometryCreator`.\n     *\n     * @returns TileGeometryCreator\n     */\n    static get instance(): TileGeometryCreator {\n        return this.m_instance || (this.m_instance = new TileGeometryCreator());\n    }\n\n    /**\n     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.\n     */\n    private constructor() {\n        //\n    }\n\n    /**\n     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a\n     * technique is identified as disabled, its property `enabled` is set to `false`.\n     *\n     * @param decodedTile - The decodedTile containing the actual tile map data.\n     * @param enabledKinds - Optional [[GeometryKindSet]] used to specify which object kinds should be\n     *      created.\n     * @param disabledKinds - Optional [[GeometryKindSet]] used to filter objects that should not be\n     *      created.\n     */\n    initDecodedTile(\n        decodedTile: DecodedTile,\n        enabledKinds?: GeometryKindSet | undefined,\n        disabledKinds?: GeometryKindSet | undefined\n    ) {\n        for (const technique of decodedTile.techniques) {\n            const kind = technique.kind;\n\n            // No info about kind, no way to filter it.\n            if (kind === undefined || (kind instanceof Set && kind.size === 0)) {\n                technique._kindState = true;\n                continue;\n            }\n\n            // Technique is enabled only if enabledKinds is defined and technique belongs to that set or\n            // if that's not the case, disabledKinds must be undefined or technique does not belong to it.\n            technique._kindState =\n                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(kind)) ||\n                (enabledKinds !== undefined && enabledKinds.hasOrIntersects(kind));\n        }\n\n        for (const srcGeometry of decodedTile.geometries) {\n            for (const group of srcGeometry.groups) {\n                group.createdOffsets = [];\n            }\n        }\n    }\n\n    /**\n     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before\n     * calling this method.\n     *\n     * @see [[TileGeometryCreator#initDecodedTile]]\n     *\n     * @param tile - The {@link Tile} to process.\n     * @param decodedTile - The decodedTile containing the actual tile map data.\n     * @returns Promise resolved when all textures are ready to render.\n     */\n    createAllGeometries(tile: Tile, decodedTile: DecodedTile): Promise<void> {\n        const filter = (technique: IndexedTechnique): boolean => {\n            return technique._kindState !== false;\n        };\n\n        let texturesReady: Promise<any> = Promise.resolve();\n        const onNewTexture = (texturePromise: Promise<THREE.Texture>) => {\n            texturesReady = Promise.all([\n                texturesReady,\n                texturePromise\n                    .then(texture => {\n                        tile.addOwnedTexture(texture);\n                        if (!texture.image) {\n                            return Promise.resolve();\n                        }\n                        return new Promise<void>(resolve => {\n                            texture.onUpdate = () => {\n                                (texture.onUpdate as any) = null;\n                                resolve();\n                            };\n                            tile.mapView.renderer.initTexture(texture);\n                        });\n                    })\n                    .catch(() => {}) // Keep waiting for the other textures even if one fails.\n            ]);\n        };\n        this.createObjects(tile, decodedTile, onNewTexture, filter);\n\n        this.preparePois(tile, decodedTile);\n\n        // TextElements do not get their geometry created by Tile, but are managed on a\n        // higher level.\n        const textFilter = (technique: IndexedTechnique): boolean => {\n            if (\n                !isPoiTechnique(technique) &&\n                !isLineMarkerTechnique(technique) &&\n                !isTextTechnique(technique)\n            ) {\n                return false;\n            }\n            return filter(technique);\n        };\n        this.createTextElements(tile, decodedTile, textFilter);\n\n        this.createLabelRejectionElements(tile, decodedTile);\n\n        // HARP-7899, disable ground plane for globe\n        if (tile.dataSource.addGroundPlane && tile.projection.type === ProjectionType.Planar) {\n            // The ground plane is required for when we zoom in and we fall back to the parent\n            // (whilst the new tiles are loading), in that case the ground plane ensures that the\n            // parent's geometry doesn't show through.\n            addGroundPlane(tile, -1);\n        }\n        return texturesReady;\n    }\n\n    createLabelRejectionElements(tile: Tile, decodedTile: DecodedTile) {\n        if (decodedTile.pathGeometries === undefined) {\n            return;\n        }\n        for (const path of decodedTile.pathGeometries) {\n            tile.addBlockingElement(new PathBlockingElement(path.path));\n        }\n    }\n\n    /**\n     * Processes the given tile and assign default values for geometry kinds,\n     * render orders and label priorities.\n     *\n     * @param {Tile} tile\n     * @param {(GeometryKindSet | undefined)} enabledKinds\n     * @param {(GeometryKindSet | undefined)} disabledKinds\n     */\n    processTechniques(\n        tile: Tile,\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): void {\n        const decodedTile = tile.decodedTile;\n\n        if (decodedTile === undefined) {\n            return;\n        }\n\n        // Speedup and simplify following code: Test all techniques if they intersect with\n        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be\n        // ignored hereafter.\n        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n\n        // compile the dynamic expressions.\n        const exprPool = tile.dataSource.exprPool;\n        decodedTile.techniques.forEach((technique: any) => {\n            for (const propertyName in technique) {\n                if (!technique.hasOwnProperty(propertyName)) {\n                    continue;\n                }\n                const value = technique[propertyName];\n                if (isJsonExpr(value) && propertyName !== \"kind\") {\n                    // \"kind\" is reserved.\n                    try {\n                        let expr = Expr.fromJSON(value);\n                        if (expr.dependencies().volatile !== true) {\n                            expr = new MemoCallExpr(Expr.fromJSON(value));\n                        }\n                        technique[propertyName] = expr.intern(exprPool);\n                    } catch (error) {\n                        logger.error(\"Failed to compile expression:\", error);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Splits the text paths that contain sharp corners.\n     *\n     * @param tile - The {@link Tile} to process paths on.\n     * @param textPathGeometries - The original path geometries that may have defects.\n     * @param textFilter -: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    prepareTextPaths(\n        textPathGeometries: TextPathGeometry[],\n        decodedTile: DecodedTile,\n        textFilter?: (technique: IndexedTechnique) => boolean\n    ): TextPathGeometry[] {\n        const processedPaths = new Array<TextPathGeometry>();\n        const newPaths = textPathGeometries.slice();\n\n        while (newPaths.length > 0) {\n            const textPath = newPaths.pop();\n\n            if (textPath === undefined) {\n                break;\n            }\n\n            const technique = decodedTile.techniques[textPath.technique];\n            if (\n                !isTextTechnique(technique) ||\n                (textFilter !== undefined && !textFilter(technique))\n            ) {\n                continue;\n            }\n\n            processedPaths.push(textPath);\n        }\n        return processedPaths;\n    }\n\n    /**\n     * Creates {@link TextElement} objects from the decoded tile and list of materials specified. The\n     * priorities of the {@link TextElement}s are updated to simplify label placement.\n     *\n     * @param tile - The {@link Tile} to create the testElements on.\n     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.\n     * @param textFilter -: Optional filter. Should return true for any text technique that is\n     *      applicable.\n     */\n    createTextElements(\n        tile: Tile,\n        decodedTile: DecodedTile,\n        textFilter?: (technique: IndexedTechnique) => boolean\n    ) {\n        const mapView = tile.mapView;\n        const worldOffsetX = tile.computeWorldOffsetX();\n\n        const discreteZoomLevel = Math.floor(mapView.zoomLevel);\n        const discreteZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n\n        const textElementBuilder = new TextElementBuilder(\n            discreteZoomEnv,\n            tile.textStyleCache,\n            tile.dataSource.dataSourceOrder\n        );\n\n        if (decodedTile.textPathGeometries !== undefined) {\n            const textPathGeometries = this.prepareTextPaths(\n                decodedTile.textPathGeometries,\n                decodedTile,\n                textFilter\n            );\n\n            for (const textPath of textPathGeometries) {\n                const technique = decodedTile.techniques[textPath.technique];\n\n                if (\n                    technique._kindState === false ||\n                    !isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))\n                ) {\n                    continue;\n                }\n\n                const path: THREE.Vector3[] = [];\n                for (let i = 0; i < textPath.path.length; i += 3) {\n                    path.push(\n                        new THREE.Vector3(\n                            textPath.path[i] + worldOffsetX,\n                            textPath.path[i + 1],\n                            textPath.path[i + 2]\n                        )\n                    );\n                }\n\n                const textElement = textElementBuilder\n                    .withTechnique(technique)\n                    .build(\n                        textPath.text,\n                        path,\n                        tile.offset,\n                        tile.dataSource.name,\n                        tile.dataSource.dataSourceOrder,\n                        textPath.objInfos,\n                        textPath.pathLengthSqr\n                    );\n\n                tile.addTextElement(textElement);\n            }\n        }\n\n        if (decodedTile.textGeometries !== undefined) {\n            for (const text of decodedTile.textGeometries) {\n                if (text.technique === undefined || text.stringCatalog === undefined) {\n                    continue;\n                }\n\n                const technique = decodedTile.techniques[text.technique];\n\n                if (\n                    technique._kindState === false ||\n                    !isTextTechnique(technique) ||\n                    (textFilter !== undefined && !textFilter(technique))\n                ) {\n                    continue;\n                }\n\n                const positions = new THREE.BufferAttribute(\n                    new Float64Array(text.positions.buffer),\n                    text.positions.itemCount\n                );\n\n                const numPositions = positions.count;\n                if (numPositions < 1) {\n                    continue;\n                }\n\n                textElementBuilder.withTechnique(technique);\n\n                for (let i = 0; i < numPositions; ++i) {\n                    const x = positions.getX(i) + worldOffsetX;\n                    const y = positions.getY(i);\n                    const z = positions.getZ(i);\n                    const label = text.stringCatalog[text.texts[i]];\n                    if (label === undefined) {\n                        // skip missing labels\n                        continue;\n                    }\n\n                    const attributes = text.objInfos?.[i];\n                    const point = new THREE.Vector3(x, y, z);\n                    const textElement = textElementBuilder.build(\n                        label!,\n                        point,\n                        tile.offset,\n                        tile.dataSource.name,\n                        tile.dataSource.dataSourceOrder,\n                        attributes\n                    );\n                    tile.addTextElement(textElement);\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates `Tile` objects from the decoded tile and list of materials specified.\n     *\n     * @param tile - The {@link Tile} to create the geometry on.\n     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.\n     * @param onTextureCreated - Callback for each texture created, getting a promise that will be\n     * resolved once the texture is loaded. Texture is not uploaded to GPU.\n     * @param techniqueFilter -: Optional filter. Should return true for any technique that is\n     *      applicable.\n     */\n    createObjects(\n        tile: Tile,\n        decodedTile: DecodedTile,\n        onTextureCreated: (texture: Promise<THREE.Texture>) => void,\n        techniqueFilter?: (technique: IndexedTechnique) => boolean\n    ) {\n        const mapView = tile.mapView;\n        const materials: THREE.Material[] = [];\n        const extrudedMaterials: THREE.Material[] = [];\n        const animatedExtrusionHandler = mapView.animatedExtrusionHandler;\n        const discreteZoomLevel = Math.floor(mapView.zoomLevel);\n        const discreteZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n        const objects = tile.objects;\n        const viewRanges = mapView.viewRanges;\n        const elevationEnabled = mapView.elevationProvider !== undefined;\n\n        for (const attachment of this.getAttachments(decodedTile)) {\n            const srcGeometry = attachment.geometry;\n            const groups = attachment.info.groups;\n            const groupCount = groups.length;\n\n            for (let groupIndex = 0; groupIndex < groupCount; ) {\n                const group = groups[groupIndex++];\n                const start = group.start;\n                const techniqueIndex = group.technique;\n                const technique = decodedTile.techniques[techniqueIndex];\n\n                if (group.createdOffsets === undefined) {\n                    group.createdOffsets = [];\n                }\n\n                if (\n                    group.createdOffsets!.includes(tile.offset) ||\n                    technique._kindState === false ||\n                    (techniqueFilter !== undefined && !techniqueFilter(technique))\n                ) {\n                    continue;\n                }\n\n                let count = group.count;\n                group.createdOffsets!.push(tile.offset);\n\n                // compress consecutive groups\n                for (\n                    ;\n                    groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex;\n                    ++groupIndex\n                ) {\n                    if (start + count !== groups[groupIndex].start) {\n                        break;\n                    }\n\n                    count += groups[groupIndex].count;\n\n                    // Mark this group as created, so it does not get processed again.\n                    groups[groupIndex].createdOffsets!.push(tile.offset);\n                }\n\n                if (!usesObject3D(technique)) {\n                    continue;\n                }\n                const extrusionAnimationEnabled: boolean =\n                    animatedExtrusionHandler?.setAnimationProperties(technique, discreteZoomEnv) ??\n                    false;\n\n                let material: THREE.Material | undefined = materials[techniqueIndex];\n\n                if (material === undefined) {\n                    material = createMaterial(\n                        mapView.renderer.capabilities,\n                        {\n                            technique,\n                            env: mapView.env,\n                            fog: mapView.scene.fog !== null,\n                            shadowsEnabled: mapView.shadowsEnabled\n                        },\n                        onTextureCreated\n                    );\n                    if (material === undefined) {\n                        continue;\n                    }\n                    if (extrusionAnimationEnabled && hasExtrusionFeature(material)) {\n                        addToExtrudedMaterials(material, extrudedMaterials);\n                    }\n                    materials[techniqueIndex] = material;\n                }\n\n                const techniqueKind = technique.kind;\n\n                // Modify the standard textured shader to support height-based coloring.\n                if (isTerrainTechnique(technique)) {\n                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);\n                }\n\n                const bufferGeometry = new THREE.BufferGeometry();\n\n                srcGeometry.vertexAttributes?.forEach(vertexAttribute => {\n                    const buffer = attachment.getBufferAttribute(vertexAttribute);\n                    bufferGeometry.setAttribute(vertexAttribute.name, buffer);\n                });\n\n                srcGeometry.interleavedVertexAttributes?.forEach(attr => {\n                    attachment\n                        .getInterleavedBufferAttributes(attr)\n                        .forEach(({ name, attribute }) =>\n                            bufferGeometry.setAttribute(name, attribute)\n                        );\n                });\n\n                const index = attachment.info.index ?? srcGeometry.index;\n                if (index) {\n                    bufferGeometry.setIndex(attachment.getBufferAttribute(index));\n                }\n\n                if (!bufferGeometry.getAttribute(\"normal\") && needsVertexNormals(technique)) {\n                    bufferGeometry.computeVertexNormals();\n                }\n\n                bufferGeometry.addGroup(start, count);\n\n                if (isSolidLineTechnique(technique)) {\n                    // TODO: Unify access to shader defines via SolidLineMaterial setters\n                    assert(!isHighPrecisionLineMaterial(material));\n                    const lineMaterial = material as SolidLineMaterial;\n                    if (\n                        technique.clipping === true &&\n                        tile.projection.type === ProjectionType.Planar\n                    ) {\n                        tile.boundingBox.getSize(tmpVector3);\n                        tmpVector2.set(tmpVector3.x, tmpVector3.y);\n                        lineMaterial.clipTileSize = tmpVector2;\n                    }\n\n                    if (bufferGeometry.getAttribute(\"color\")) {\n                        setShaderMaterialDefine(lineMaterial, \"USE_COLOR\", true);\n                    }\n                }\n\n                // Add the solid line outlines as a separate object.\n                const hasSolidLinesOutlines: boolean =\n                    isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;\n\n                // When the source geometry is split in groups, we\n                // should create objects with an array of materials.\n                const hasFeatureGroups =\n                    Expr.isExpr(technique.enabled) &&\n                    srcGeometry.featureStarts &&\n                    srcGeometry.featureStarts.length > 0;\n\n                const object = buildObject(\n                    technique,\n                    bufferGeometry,\n                    hasFeatureGroups ? [material] : material,\n                    tile,\n                    elevationEnabled\n                );\n\n                object.renderOrder = getPropertyValue(technique.renderOrder, mapView.env);\n\n                if (attachment.info.uuid !== undefined) {\n                    object.uuid = attachment.info.uuid;\n                    object.userData.geometryId = attachment.info.uuid;\n                }\n\n                if (\n                    (isCirclesTechnique(technique) || isSquaresTechnique(technique)) &&\n                    technique.enablePicking !== undefined\n                ) {\n                    (object as MapViewPoints).enableRayTesting = technique.enablePicking!;\n                }\n\n                if (isLineTechnique(technique) || isSegmentsTechnique(technique)) {\n                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                    FadingFeature.addRenderHelper(\n                        object,\n                        viewRanges,\n                        fadingParams.fadeNear,\n                        fadingParams.fadeFar,\n                        false\n                    );\n                }\n\n                if (isSolidLineTechnique(technique)) {\n                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n\n                    FadingFeature.addRenderHelper(\n                        object,\n                        viewRanges,\n                        fadingParams.fadeNear,\n                        fadingParams.fadeFar,\n                        false\n                    );\n                }\n\n                if (isExtrudedLineTechnique(technique)) {\n                    // extruded lines are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n                    if (technique.fadeFar !== undefined) {\n                        const fadingParams = this.getFadingParams(\n                            mapView.env,\n                            technique as StandardExtrudedLineTechnique\n                        );\n\n                        FadingFeature.addRenderHelper(\n                            object,\n                            viewRanges,\n                            fadingParams.fadeNear,\n                            fadingParams.fadeFar,\n                            true\n                        );\n                    }\n                }\n\n                this.addUserData(tile, srcGeometry, technique, object);\n\n                if (isExtrudedPolygonTechnique(technique)) {\n                    object.castShadow = mapView.shadowsEnabled;\n                    object.receiveShadow = mapView.shadowsEnabled;\n                } else if (isStandardTechnique(technique) || isFillTechnique(technique)) {\n                    object.receiveShadow = mapView.shadowsEnabled;\n                }\n\n                if (\n                    isExtrudedPolygonTechnique(technique) ||\n                    isStandardTechnique(technique) ||\n                    isFillTechnique(technique)\n                ) {\n                    // filled polygons are normal meshes, and need transparency only when fading or\n                    // dynamic properties is defined.\n\n                    if (technique.fadeFar !== undefined) {\n                        const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                        FadingFeature.addRenderHelper(\n                            object,\n                            viewRanges,\n                            fadingParams.fadeNear,\n                            fadingParams.fadeFar,\n                            true\n                        );\n                    }\n                }\n\n                const renderDepthPrePass =\n                    isExtrudedPolygonTechnique(technique) &&\n                    isRenderDepthPrePassEnabled(technique, discreteZoomEnv);\n\n                if (renderDepthPrePass) {\n                    const depthPassMesh = createDepthPrePassMesh(object as THREE.Mesh);\n                    this.addUserData(tile, srcGeometry, technique, depthPassMesh);\n                    // Set geometry kind for depth pass mesh so that it gets the displacement map\n                    // for elevation overlay.\n                    registerTileObject(tile, depthPassMesh, techniqueKind, {\n                        technique,\n                        pickability: Pickability.transient\n                    });\n                    objects.push(depthPassMesh);\n\n                    if (extrusionAnimationEnabled) {\n                        addToExtrudedMaterials(depthPassMesh.material, extrudedMaterials);\n                    }\n\n                    setDepthPrePassStencil(depthPassMesh, object as THREE.Mesh);\n                }\n\n                const techniquePickability = transientToPickability(\n                    getPropertyValue(technique.transient, mapView.env)\n                );\n                // register all objects as pickable except solid lines with outlines, in that case\n                // it's enough to make outlines pickable.\n                registerTileObject(tile, object, techniqueKind, {\n                    technique,\n                    pickability: hasSolidLinesOutlines\n                        ? Pickability.transient\n                        : techniquePickability\n                });\n                objects.push(object);\n\n                // Add the extruded polygon edges as a separate geometry.\n                if (\n                    isExtrudedPolygonTechnique(technique) &&\n                    attachment.info.edgeIndex !== undefined\n                ) {\n                    // When the source geometry is split in groups, we\n                    // should create objects with an array of materials.\n                    const hasEdgeFeatureGroups =\n                        Expr.isExpr(technique.enabled) &&\n                        srcGeometry.edgeFeatureStarts &&\n                        srcGeometry.edgeFeatureStarts.length > 0;\n\n                    const buildingTechnique = technique as ExtrudedPolygonTechnique;\n                    const edgeGeometry = new THREE.BufferGeometry();\n                    edgeGeometry.setAttribute(\"position\", bufferGeometry.getAttribute(\"position\"));\n\n                    const colorAttribute = bufferGeometry.getAttribute(\"color\");\n                    if (colorAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"color\", colorAttribute);\n                    }\n\n                    const extrusionAttribute = bufferGeometry.getAttribute(\"extrusionAxis\");\n                    if (extrusionAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"extrusionAxis\", extrusionAttribute);\n                    }\n\n                    const normalAttribute = bufferGeometry.getAttribute(\"normal\");\n                    if (normalAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"normal\", normalAttribute);\n                    }\n\n                    const uvAttribute = bufferGeometry.getAttribute(\"uv\");\n                    if (uvAttribute !== undefined) {\n                        edgeGeometry.setAttribute(\"uv\", uvAttribute);\n                    }\n\n                    edgeGeometry.setIndex(\n                        attachment.getBufferAttribute(attachment.info.edgeIndex!)\n                    );\n\n                    // Read the uniforms from the technique values (and apply the default values).\n                    const extrudedPolygonTechnique = technique as ExtrudedPolygonTechnique;\n\n                    const fadingParams = this.getPolygonFadingParams(\n                        discreteZoomEnv,\n                        extrudedPolygonTechnique\n                    );\n\n                    // Configure the edge material based on the theme values.\n                    const materialParams: EdgeMaterialParameters = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar,\n                        extrusionRatio: extrusionAnimationEnabled ? 0 : undefined,\n                        vertexColors: bufferGeometry.getAttribute(\"color\") ? true : false,\n                        rendererCapabilities: mapView.renderer.capabilities\n                    };\n                    const edgeMaterial = new EdgeMaterial(materialParams);\n                    const edgeObj = new THREE.LineSegments(\n                        edgeGeometry,\n                        hasEdgeFeatureGroups ? [edgeMaterial] : edgeMaterial\n                    );\n\n                    this.addUserData(tile, srcGeometry, technique, edgeObj);\n\n                    // Set the correct render order.\n                    edgeObj.renderOrder = object.renderOrder + 0.1;\n\n                    FadingFeature.addRenderHelper(\n                        edgeObj,\n                        viewRanges,\n                        fadingParams.lineFadeNear,\n                        fadingParams.lineFadeFar,\n                        false\n                    );\n\n                    if (extrusionAnimationEnabled) {\n                        addToExtrudedMaterials(edgeObj.material, extrudedMaterials);\n                    }\n\n                    registerTileObject(tile, edgeObj, techniqueKind, {\n                        technique,\n                        pickability: Pickability.transient\n                    });\n\n                    MapMaterialAdapter.create(edgeMaterial, {\n                        color: buildingTechnique.lineColor,\n                        objectColor: buildingTechnique.color,\n                        opacity: buildingTechnique.opacity,\n                        lineWidth: (frameMapView: MapAdapterUpdateEnv) => {\n                            // lineWidth for ExtrudedPolygonEdges only supports 0 or 1\n                            const value = getPropertyValue(\n                                buildingTechnique.lineWidth,\n                                frameMapView.env\n                            );\n                            if (typeof value === \"number\") {\n                                return THREE.MathUtils.clamp(value, 0, 1);\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    objects.push(edgeObj);\n                }\n\n                // animate the extrusion of buildings\n                if (isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {\n                    object.customDepthMaterial = new MapMeshDepthMaterial({\n                        depthPacking: THREE.RGBADepthPacking\n                    });\n                    addToExtrudedMaterials(object.customDepthMaterial, extrudedMaterials);\n                }\n\n                // Add the fill area edges as a separate geometry.\n\n                if (isFillTechnique(technique) && attachment.info.edgeIndex) {\n                    const hasEdgeFeatureGroups =\n                        Expr.isExpr(technique.enabled) &&\n                        srcGeometry.edgeFeatureStarts &&\n                        srcGeometry.edgeFeatureStarts.length > 0;\n\n                    const outlineGeometry = new THREE.BufferGeometry();\n                    outlineGeometry.setAttribute(\n                        \"position\",\n                        bufferGeometry.getAttribute(\"position\")\n                    );\n                    outlineGeometry.setIndex(\n                        attachment.getBufferAttribute(attachment.info.edgeIndex!)\n                    );\n\n                    const fillTechnique = technique as FillTechnique;\n\n                    const fadingParams = this.getPolygonFadingParams(mapView.env, fillTechnique);\n\n                    // Configure the edge material based on the theme values.\n                    const materialParams: EdgeMaterialParameters = {\n                        color: fadingParams.color,\n                        colorMix: fadingParams.colorMix,\n                        fadeNear: fadingParams.lineFadeNear,\n                        fadeFar: fadingParams.lineFadeFar,\n                        vertexColors: bufferGeometry.getAttribute(\"color\") ? true : false,\n                        rendererCapabilities: mapView.renderer.capabilities\n                    };\n                    const outlineMaterial = new EdgeMaterial(materialParams);\n                    const outlineObj = new THREE.LineSegments(\n                        outlineGeometry,\n                        hasEdgeFeatureGroups ? [outlineMaterial] : outlineMaterial\n                    );\n                    outlineObj.renderOrder = object.renderOrder + 0.1;\n\n                    FadingFeature.addRenderHelper(\n                        outlineObj,\n                        viewRanges,\n                        fadingParams.lineFadeNear,\n                        fadingParams.lineFadeFar,\n                        false\n                    );\n\n                    this.addUserData(tile, srcGeometry, technique, outlineObj);\n\n                    registerTileObject(tile, outlineObj, techniqueKind, {\n                        technique,\n                        pickability: techniquePickability\n                    });\n                    MapMaterialAdapter.create(outlineMaterial, {\n                        color: fillTechnique.lineColor,\n                        objectColor: fillTechnique.color,\n                        opacity: fillTechnique.opacity\n                    });\n                    objects.push(outlineObj);\n                }\n\n                // Add the fill area edges as a separate geometry.\n                if (hasSolidLinesOutlines) {\n                    const outlineTechnique = technique as SolidLineTechnique;\n                    const outlineMaterial = material.clone() as SolidLineMaterial;\n                    applyBaseColorToMaterial(\n                        outlineMaterial,\n                        outlineMaterial.color,\n                        outlineTechnique,\n                        outlineTechnique.secondaryColor ?? 0x000000,\n                        discreteZoomEnv\n                    );\n\n                    if (outlineTechnique.secondaryCaps !== undefined) {\n                        outlineMaterial.caps = getPropertyValue(\n                            outlineTechnique.secondaryCaps,\n                            mapView.env\n                        );\n                    }\n                    const outlineObj = buildObject(\n                        technique,\n                        bufferGeometry,\n                        outlineMaterial,\n                        tile,\n                        elevationEnabled\n                    );\n\n                    outlineObj.renderOrder =\n                        (getPropertyValue(outlineTechnique.secondaryRenderOrder, mapView.env) ??\n                            0) - 0.0000001;\n\n                    this.addUserData(tile, srcGeometry, technique, outlineObj);\n\n                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);\n                    FadingFeature.addRenderHelper(\n                        outlineObj,\n                        viewRanges,\n                        fadingParams.fadeNear,\n                        fadingParams.fadeFar,\n                        false\n                    );\n\n                    const secondaryWidth = buildMetricValueEvaluator(\n                        outlineTechnique.secondaryWidth,\n                        outlineTechnique.metricUnit\n                    );\n                    registerTileObject(tile, outlineObj, techniqueKind, { technique });\n                    const mainMaterialAdapter = MapMaterialAdapter.get(material);\n\n                    const outlineMaterialAdapter = MapMaterialAdapter.create(outlineMaterial, {\n                        color: outlineTechnique.secondaryColor,\n                        opacity: outlineTechnique.opacity,\n                        caps: outlineTechnique.secondaryCaps,\n                        // Still handled above\n                        lineWidth: (frameMapView: MapAdapterUpdateEnv) => {\n                            if (!mainMaterialAdapter) {\n                                return;\n                            }\n                            mainMaterialAdapter.ensureUpdated(frameMapView);\n                            const mainLineWidth =\n                                mainMaterialAdapter.currentStyledProperties.lineWidth;\n\n                            const secondaryLineWidth = getPropertyValue(\n                                secondaryWidth,\n                                mapView.env\n                            );\n                            const opacity = outlineMaterialAdapter.currentStyledProperties\n                                .opacity as number | null;\n                            if (\n                                typeof mainLineWidth === \"number\" &&\n                                typeof secondaryLineWidth === \"number\"\n                            ) {\n                                if (\n                                    secondaryLineWidth <= mainLineWidth &&\n                                    (opacity === null || opacity === undefined || opacity === 1)\n                                ) {\n                                    // We could mark object as invisible somehow, not sure how\n                                    // objectAdapter.markInvisible();\n                                    return 0;\n                                } else {\n                                    return secondaryLineWidth;\n                                }\n                            } else {\n                                return 0;\n                            }\n                        }\n                    });\n                    objects.push(outlineObj);\n                }\n            }\n        }\n        if (extrudedMaterials.length > 0) {\n            mapView.animatedExtrusionHandler.add(tile, extrudedMaterials);\n        }\n    }\n\n    /**\n     * Prepare the {@link Tile}s pois. Uses the {@link PoiManager} in {@link MapView}.\n     */\n    preparePois(tile: Tile, decodedTile: DecodedTile) {\n        if (decodedTile.poiGeometries !== undefined) {\n            tile.mapView.poiManager.addPois(tile, decodedTile);\n        }\n    }\n\n    /**\n     * Gets the attachments of the given {@link @here/harp-datasource-protocol#DecodedTile}.\n     *\n     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.\n     */\n    private *getAttachments(decodedTile: DecodedTile): Generator<AttachmentInfo> {\n        const cache = new AttachmentCache();\n\n        for (const geometry of decodedTile.geometries) {\n            // the main attachment\n\n            const mainAttachment: Attachment = {\n                index: geometry.index,\n                edgeIndex: geometry.edgeIndex,\n                uuid: geometry.uuid,\n                groups: geometry.groups\n            };\n\n            yield new AttachmentInfo(geometry, mainAttachment, cache);\n\n            if (geometry.attachments) {\n                // the additional attachments\n                for (const info of geometry.attachments) {\n                    yield new AttachmentInfo(geometry, info, cache);\n                }\n            }\n        }\n    }\n\n    private setupTerrainMaterial(\n        technique: TerrainTechnique,\n        material: THREE.Material,\n        terrainColor: number\n    ) {\n        if (!technique.map || !technique.displacementMap) {\n            // Render terrain using the given color.\n            const stdMaterial = material as MapMeshStandardMaterial;\n            stdMaterial.color.set(terrainColor);\n            // Remove displacement map, otherwise it would elevate terrain geometry and make it\n            // twice as high as it should be.\n            setDisplacementMapToMaterial(null, stdMaterial);\n            return;\n        }\n\n        // Render terrain using height-based colors.\n        (material as any).onBeforeCompile = (shader: THREE.Shader) => {\n            shader.fragmentShader = shader.fragmentShader.replace(\n                \"#include <map_pars_fragment>\",\n                `#include <map_pars_fragment>\n    uniform sampler2D displacementMap;\n    uniform float displacementScale;\n    uniform float displacementBias;`\n            );\n            shader.fragmentShader = shader.fragmentShader.replace(\n                \"#include <map_fragment>\",\n                `#ifdef USE_MAP\n    float minElevation = ${EarthConstants.MIN_ELEVATION.toFixed(1)};\n    float maxElevation = ${EarthConstants.MAX_ELEVATION.toFixed(1)};\n    float elevationRange = maxElevation - minElevation;\n\n    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;\n    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );\n    texelColor = mapTexelToLinear( texelColor );\n    diffuseColor *= texelColor;\n#endif`\n            );\n            // We remove the displacement map from manipulating the vertices, it is\n            // however still required for the pixel shader, so it can't be directly\n            // removed.\n            shader.vertexShader = shader.vertexShader.replace(\n                \"#include <displacementmap_vertex>\",\n                \"\"\n            );\n        };\n        (material as MapMeshStandardMaterial).displacementMap!.needsUpdate = true;\n    }\n\n    private addUserData(\n        tile: Tile,\n        srcGeometry: Geometry,\n        technique: Technique,\n        object: THREE.Object3D\n    ) {\n        if (isTerrainTechnique(technique)) {\n            assert(\n                Object.keys(object.userData).length === 0,\n                \"Unexpected user data in terrain object\"\n            );\n\n            assert(\n                typeof srcGeometry.objInfos![0] === \"object\",\n                \"Wrong attribute map type for terrain geometry\"\n            );\n\n            const displacementMap = (srcGeometry.objInfos as DisplacementMap[])[0];\n            const tileDisplacementMap: TileDisplacementMap = {\n                tileKey: tile.tileKey,\n                texture: new THREE.DataTexture(\n                    displacementMap.buffer,\n                    displacementMap.xCountVertices,\n                    displacementMap.yCountVertices,\n                    THREE.LuminanceFormat,\n                    THREE.FloatType\n                ),\n                displacementMap,\n                geoBox: tile.geoBox\n            };\n            object.userData = tileDisplacementMap;\n        } else {\n            // Set the feature data for picking with `MapView.intersectMapObjects()` except for\n            // solid-line which uses tile-based picking.\n            const isOutline =\n                object.type === \"LineSegments\" &&\n                (isExtrudedPolygonTechnique(technique) || isFillTechnique(technique));\n            const featureData: TileFeatureData = {\n                geometryType: srcGeometry.type,\n                starts: isOutline ? srcGeometry.edgeFeatureStarts : srcGeometry.featureStarts,\n                objInfos: srcGeometry.objInfos\n            };\n            object.userData.feature = featureData;\n            object.userData.technique = technique;\n        }\n    }\n\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    private getFadingParams(\n        env: Env,\n        technique: MakeTechniqueAttrs<BaseTechniqueParams>\n    ): FadingParameters {\n        const fadeNear =\n            technique.fadeNear !== undefined\n                ? getPropertyValue(technique.fadeNear, env)\n                : FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar =\n            technique.fadeFar !== undefined\n                ? getPropertyValue(technique.fadeFar, env)\n                : FadingFeature.DEFAULT_FADE_FAR;\n        return {\n            fadeNear,\n            fadeFar\n        };\n    }\n\n    /**\n     * Gets the fading parameters for several kinds of objects.\n     */\n    private getPolygonFadingParams(\n        env: Env,\n        technique: FillTechnique | ExtrudedPolygonTechnique\n    ): PolygonFadingParameters {\n        let color: string | number | undefined;\n        let colorMix = EdgeMaterial.DEFAULT_COLOR_MIX;\n\n        if (technique.lineColor !== undefined) {\n            color = getPropertyValue(technique.lineColor, env);\n            if (isExtrudedPolygonTechnique(technique)) {\n                const extrudedPolygonTechnique = technique as ExtrudedPolygonTechnique;\n                colorMix =\n                    extrudedPolygonTechnique.lineColorMix !== undefined\n                        ? extrudedPolygonTechnique.lineColorMix\n                        : EdgeMaterial.DEFAULT_COLOR_MIX;\n            }\n        }\n\n        const fadeNear =\n            technique.fadeNear !== undefined\n                ? getPropertyValue(technique.fadeNear, env)\n                : FadingFeature.DEFAULT_FADE_NEAR;\n        const fadeFar =\n            technique.fadeFar !== undefined\n                ? getPropertyValue(technique.fadeFar, env)\n                : FadingFeature.DEFAULT_FADE_FAR;\n\n        const lineFadeNear =\n            technique.lineFadeNear !== undefined\n                ? getPropertyValue(technique.lineFadeNear, env)\n                : fadeNear;\n        const lineFadeFar =\n            technique.lineFadeFar !== undefined\n                ? getPropertyValue(technique.lineFadeFar, env)\n                : fadeFar;\n\n        if (color === undefined) {\n            color = EdgeMaterial.DEFAULT_COLOR;\n        }\n\n        return {\n            color,\n            colorMix,\n            fadeNear,\n            fadeFar,\n            lineFadeNear,\n            lineFadeFar\n        };\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    DecodedTile,\n    GeometryKind,\n    GeometryKindSet,\n    isExtrudedLineTechnique,\n    isExtrudedPolygonTechnique,\n    isFillTechnique,\n    isLineMarkerTechnique,\n    isLineTechnique,\n    isPoiTechnique,\n    isSegmentsTechnique,\n    isSolidLineTechnique,\n    isTextTechnique,\n    Technique\n} from \"@here/harp-datasource-protocol\";\nimport { PerformanceTimer, TaskQueue } from \"@here/harp-utils\";\n\nimport { TileTaskGroups } from \"../MapView\";\nimport { PerformanceStatistics } from \"../Statistics\";\nimport { Tile } from \"../Tile\";\nimport { TileGeometryCreator } from \"./TileGeometryCreator\";\n\nfunction addDiscardedTileToStats(tile: Tile) {\n    const stats = PerformanceStatistics.instance;\n    if (stats.enabled) {\n        const name = tile.dataSource.name;\n        const level = tile.tileKey.level;\n        const col = tile.tileKey.column;\n        const row = tile.tileKey.row;\n        const reason = tile.disposed ? `disposed` : `invisible`;\n\n        stats.currentFrame.addMessage(\n            `Decoded tile: ${name} # lvl=${level} col=${col} row=${row} DISCARDED - ${reason}`\n        );\n    }\n}\n\n/**\n * The state the {@link TileGeometryLoader}.\n */\nexport enum TileGeometryLoaderState {\n    Initialized = 0,\n    CreationQueued = 1,\n    CreatingGeometry = 2,\n    Finished = 3,\n    Canceled = 4,\n    Disposed = 5\n}\n\n/**\n * Loads the geometry for its {@link Tile}. Loads all geometry in a single step.\n * @internal\n */\nexport class TileGeometryLoader {\n    /**\n     * Make sure that all technique have their geometryKind set, either from the theme or their\n     * default value.\n     *\n     * Also gather set of the [[GeometryKind]]s found in the techniques and return it.\n     *\n     * @param {DecodedTile} decodedTile\n     * @returns {GeometryKindSet} The set of kinds used in the decodeTile.\n     */\n    static prepareAvailableGeometryKinds(decodedTile: DecodedTile): GeometryKindSet {\n        const foundSet: GeometryKindSet = new GeometryKindSet();\n\n        for (const technique of decodedTile.techniques) {\n            const geometryKind = TileGeometryLoader.compileGeometryKind(technique);\n\n            if (geometryKind instanceof Set) {\n                for (const kind of geometryKind) {\n                    foundSet.add(kind);\n                }\n            } else {\n                foundSet.add(geometryKind);\n            }\n        }\n        return foundSet;\n    }\n\n    /**\n     * Make sure that the technique has its geometryKind set, either from the theme or their default\n     * value.\n     *\n     * @param {Technique} technique\n     */\n    static compileGeometryKind(technique: Technique): GeometryKind | GeometryKindSet {\n        let geometryKind = technique.kind;\n\n        // Set default kind based on technique.\n        if (geometryKind === undefined) {\n            if (isFillTechnique(technique)) {\n                geometryKind = GeometryKind.Area;\n            } else if (\n                isLineTechnique(technique) ||\n                isSolidLineTechnique(technique) ||\n                isSegmentsTechnique(technique) ||\n                isExtrudedLineTechnique(technique)\n            ) {\n                geometryKind = GeometryKind.Line;\n            } else if (isExtrudedPolygonTechnique(technique)) {\n                geometryKind = GeometryKind.Building;\n            } else if (\n                isPoiTechnique(technique) ||\n                isLineMarkerTechnique(technique) ||\n                isTextTechnique(technique)\n            ) {\n                geometryKind = GeometryKind.Label;\n            } else {\n                geometryKind = GeometryKind.All;\n            }\n\n            technique.kind = geometryKind;\n        } else if (Array.isArray(geometryKind)) {\n            geometryKind = technique.kind = new GeometryKindSet(geometryKind);\n        }\n\n        return geometryKind;\n    }\n\n    private m_decodedTile?: DecodedTile;\n    private m_availableGeometryKinds: GeometryKindSet | undefined;\n    private m_enabledKinds: GeometryKindSet | undefined;\n    private m_disabledKinds: GeometryKindSet | undefined;\n    private m_priority: number = 0;\n    private m_state: TileGeometryLoaderState = TileGeometryLoaderState.Initialized;\n    private m_finishedPromise: Promise<void>;\n    private m_resolveFinishedPromise?: () => void;\n    private m_rejectFinishedPromise?: () => void;\n\n    constructor(private readonly m_tile: Tile, private readonly m_taskQueue: TaskQueue) {\n        this.m_finishedPromise = new Promise((resolve, reject) => {\n            this.m_resolveFinishedPromise = resolve;\n            this.m_rejectFinishedPromise = reject;\n        });\n    }\n\n    set priority(value: number) {\n        this.m_priority = value;\n    }\n\n    //This is not a getter as it need to be bound to this for the taskqueue\n    getPriority(): number {\n        return this.m_priority;\n    }\n\n    /**\n     * The {@link Tile} this `TileGeometryLoader` is managing.\n     */\n    get tile(): Tile {\n        return this.m_tile;\n    }\n\n    /**\n     * `True` if a decoded Tile is set\n     */\n    get hasDecodedTile(): boolean {\n        return this.m_decodedTile !== undefined;\n    }\n\n    /**\n     * `True` if all geometry of the `Tile` has been loaded and the loading process is finished.\n     */\n    get isFinished(): boolean {\n        return this.m_state === TileGeometryLoaderState.Finished;\n    }\n\n    /**\n     * `True` if loader is finished, canceled or disposed.\n     */\n    get isSettled(): boolean {\n        return this.isFinished || this.isCanceled || this.isDisposed;\n    }\n\n    /**\n     * Returns a promise resolved when this `TileGeometryLoader` is in\n     * `TileGeometryLoaderState.Finished` state, or rejected when it's in\n     * `TileGeometryLoaderState.Cancelled` or `TileGeometryLoaderState.Disposed` states.\n     */\n    waitFinished(): Promise<void> {\n        return this.m_finishedPromise;\n    }\n\n    /**\n     * Set the {@link @here/harp-datasource-protocol#DecodedTile} of the tile.\n     *\n     * @remarks\n     * Is called after the decoded tile has been loaded, and\n     * prepares its content for later processing in the 'updateXXX' methods.\n     *\n     * @param {DecodedTile} decodedTile The decoded tile with the flat geometry data belonging to\n     *      this tile.\n     * @returns {DecodedTile} The processed decoded tile.\n     */\n    setDecodedTile(decodedTile: DecodedTile): DecodedTile {\n        this.m_decodedTile = decodedTile;\n\n        if (this.hasDecodedTile) {\n            this.m_availableGeometryKinds = TileGeometryLoader.prepareAvailableGeometryKinds(\n                this.m_decodedTile\n            );\n        }\n        return this.m_decodedTile;\n    }\n\n    /**\n     * The kinds of geometry stored in this {@link Tile}.\n     */\n    get availableGeometryKinds(): GeometryKindSet | undefined {\n        return this.m_availableGeometryKinds;\n    }\n\n    /**\n     * Start with or continue with loading geometry. Called repeatedly until `isFinished` is `true`.\n     */\n    update(enabledKinds?: GeometryKindSet, disabledKinds?: GeometryKindSet): void {\n        const tile = this.tile;\n\n        // Geometry kinds have changed but some is already created, so reset\n        if (this.tile.hasGeometry && !this.compareGeometryKinds(enabledKinds, disabledKinds)) {\n            this.reset();\n        }\n\n        // First time this tile is handled, or reset has been requested.\n        if (\n            (this.m_state === TileGeometryLoaderState.Initialized ||\n                this.m_state === TileGeometryLoaderState.Canceled) &&\n            tile.decodedTile !== undefined\n        ) {\n            if (this.m_state === TileGeometryLoaderState.Initialized) {\n                TileGeometryCreator.instance.processTechniques(tile, enabledKinds, disabledKinds);\n                this.setGeometryKinds(enabledKinds, disabledKinds);\n                this.setDecodedTile(tile.decodedTile);\n            }\n            this.queueGeometryCreation(enabledKinds, disabledKinds);\n        }\n    }\n\n    /**\n     * Cancel geometry loading.\n     */\n    cancel() {\n        addDiscardedTileToStats(this.tile);\n        this.m_state = TileGeometryLoaderState.Canceled;\n        this.m_rejectFinishedPromise?.();\n    }\n\n    /**\n     * Dispose of any resources.\n     */\n    dispose(): void {\n        addDiscardedTileToStats(this.tile);\n        this.clear();\n        this.m_state = TileGeometryLoaderState.Disposed;\n        this.m_rejectFinishedPromise?.();\n    }\n\n    /**\n     * Reset the loader to its initial state and cancels any asynchronous work.\n     * @remarks\n     * This method prepares the loader to reload new geometry. Since the loader does not transition\n     * to a final state, the promise returned by {@link TileGeometryLoader.waitFinished} is not\n     * settled.\n     */\n    reset(): void {\n        this.clear();\n\n        if (this.isSettled) {\n            this.m_finishedPromise = new Promise((resolve, reject) => {\n                this.m_resolveFinishedPromise = resolve;\n                this.m_rejectFinishedPromise = reject;\n            });\n        }\n        this.m_state = TileGeometryLoaderState.Initialized;\n    }\n\n    /**\n     * Finish geometry loading.\n     */\n    finish() {\n        this.m_decodedTile = undefined;\n        this.m_state = TileGeometryLoaderState.Finished;\n        this.m_resolveFinishedPromise?.();\n    }\n\n    private clear() {\n        this.m_availableGeometryKinds?.clear();\n        this.m_enabledKinds?.clear();\n        this.m_disabledKinds?.clear();\n        this.m_decodedTile = undefined;\n    }\n\n    private queueGeometryCreation(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ) {\n        if (this.m_state === TileGeometryLoaderState.CreationQueued) {\n            return;\n        }\n\n        this.m_taskQueue.add({\n            execute: this.createGeometry.bind(this, enabledKinds, disabledKinds),\n            group: TileTaskGroups.CREATE,\n            getPriority: this.getPriority.bind(this),\n            isExpired: () => {\n                return this.m_state !== TileGeometryLoaderState.CreationQueued;\n            },\n            estimatedProcessTime: () => {\n                //TODO: this seems to be close in many cases, but take some measures to confirm\n                return (this.tile.decodedTile?.decodeTime ?? 30) / 6;\n            }\n        });\n\n        this.m_state = TileGeometryLoaderState.CreationQueued;\n    }\n\n    private async createGeometry(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): Promise<void> {\n        if (this.m_state === TileGeometryLoaderState.CreatingGeometry) {\n            return;\n        }\n        this.m_state = TileGeometryLoaderState.CreatingGeometry;\n\n        const tile = this.tile;\n        const decodedTile = this.m_decodedTile;\n        // Just a sanity check that satisfies compiler check below.\n        if (decodedTile === undefined) {\n            this.finish();\n            return;\n        }\n\n        const stats = PerformanceStatistics.instance;\n        let now = 0;\n        if (stats.enabled) {\n            now = PerformanceTimer.now();\n        }\n\n        const geometryCreator = TileGeometryCreator.instance;\n\n        tile.clear();\n        // Set up techniques which should be processed.\n        geometryCreator.initDecodedTile(decodedTile, enabledKinds, disabledKinds);\n        await geometryCreator.createAllGeometries(tile, decodedTile);\n        if (stats.enabled) {\n            this.addStats(stats, now);\n        }\n        this.finish();\n        tile.dataSource.requestUpdate();\n    }\n\n    private addStats(stats: PerformanceStatistics, now: number) {\n        const tile = this.tile;\n        const decodedTile = this.m_decodedTile;\n        if (decodedTile === undefined) {\n            return;\n        }\n\n        const geometryCreationTime = PerformanceTimer.now() - now;\n        const currentFrame = stats.currentFrame;\n\n        // Account for the geometry creation in the current frame.\n        currentFrame.addValue(\"render.fullFrameTime\", geometryCreationTime);\n        currentFrame.addValue(\"render.geometryCreationTime\", geometryCreationTime);\n\n        currentFrame.addValue(\"geometry.geometryCreationTime\", geometryCreationTime);\n        currentFrame.addValue(\"geometryCount.numGeometries\", decodedTile.geometries.length);\n        currentFrame.addValue(\"geometryCount.numTechniques\", decodedTile.techniques.length);\n        currentFrame.addValue(\n            \"geometryCount.numPoiGeometries\",\n            decodedTile.poiGeometries !== undefined ? decodedTile.poiGeometries.length : 0\n        );\n        currentFrame.addValue(\n            \"geometryCount.numTextGeometries\",\n            decodedTile.textGeometries !== undefined ? decodedTile.textGeometries.length : 0\n        );\n        currentFrame.addValue(\n            \"geometryCount.numTextPathGeometries\",\n            decodedTile.textPathGeometries !== undefined ? decodedTile.textPathGeometries.length : 0\n        );\n        currentFrame.addValue(\n            \"geometryCount.numPathGeometries\",\n            decodedTile.pathGeometries !== undefined ? decodedTile.pathGeometries.length : 0\n        );\n        currentFrame.addMessage(\n            // tslint:disable-next-line: max-line-length\n            `Decoded tile: ${tile.dataSource.name} # lvl=${tile.tileKey.level} col=${tile.tileKey.column} row=${tile.tileKey.row}`\n        );\n    }\n\n    /**\n     * Stores geometry kinds used to load decoded tile geometry.\n     *\n     * This values are stored to detect geometry kind changes during loading.\n     *\n     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.\n     * @param disabledKinds - Set of geometry kinds that won't be rendered.\n     */\n    private setGeometryKinds(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): void {\n        if (enabledKinds !== undefined) {\n            this.m_enabledKinds = Object.assign(\n                this.m_enabledKinds ?? new GeometryKindSet(),\n                enabledKinds\n            );\n        }\n        if (disabledKinds !== undefined) {\n            this.m_disabledKinds = Object.assign(\n                this.m_disabledKinds ?? new GeometryKindSet(),\n                disabledKinds\n            );\n        }\n    }\n\n    /**\n     * Compare enabled and disabled geometry kinds with currently set.\n     *\n     * Method compares input sets with recently used geometry kinds in performance wise\n     * manner, taking special care of undefined and zero size sets.\n     *\n     * @param enabledKinds - Set of geometry kinds to be displayed or undefined.\n     * @param disabledKinds - Set of geometry kinds that won't be rendered.\n     * @return `true` only if sets are logically equal, meaning that undefined and empty sets\n     * may result in same geometry (techniques kind) beeing rendered.\n     */\n    private compareGeometryKinds(\n        enabledKinds: GeometryKindSet | undefined,\n        disabledKinds: GeometryKindSet | undefined\n    ): boolean {\n        const enabledSame = this.m_enabledKinds === enabledKinds;\n        const disabledSame = this.m_disabledKinds === disabledKinds;\n        // Same references, no need to compare.\n        if (enabledSame && disabledSame) {\n            return true;\n        }\n        const enabledEmpty =\n            (this.m_enabledKinds === undefined || this.m_enabledKinds.size === 0) &&\n            (enabledKinds === undefined || enabledKinds.size === 0);\n        const disabledEmpty =\n            (this.m_disabledKinds === undefined || this.m_disabledKinds.size === 0) &&\n            (disabledKinds === undefined || disabledKinds.size === 0);\n\n        // We deal only with empty, the same or undefined sets - fast return, no need to compare.\n        if (\n            (enabledEmpty && disabledEmpty) ||\n            (enabledSame && disabledEmpty) ||\n            (disabledSame && enabledEmpty)\n        ) {\n            return true;\n        }\n        // It is enough that one the the sets are different, try to spot difference otherwise\n        // return true. Compare only non-empty sets.\n        if (!enabledEmpty) {\n            // If one set undefined then other must be non-empty, for sure different.\n            if (enabledKinds === undefined || this.m_enabledKinds === undefined) {\n                return false;\n            }\n            // Both defined and non-empty, compare the sets.\n            else if (!enabledKinds.has(this.m_enabledKinds)) {\n                return false;\n            }\n        }\n        if (!disabledEmpty) {\n            // One set defined and non-empty other undefined, for sure different.\n            if (disabledKinds === undefined || this.m_disabledKinds === undefined) {\n                return false;\n            }\n            // Both defined and non-empty, compare the sets.\n            else if (!disabledKinds.has(this.m_disabledKinds)) {\n                return false;\n            }\n        }\n        // No difference found.\n        return true;\n    }\n\n    /**\n     * `True` if TileGeometryLoader was canceled\n     */\n    private get isCanceled(): boolean {\n        return this.m_state === TileGeometryLoaderState.Canceled;\n    }\n\n    /**\n     * `True` if TileGeometryLoader was disposed\n     */\n    private get isDisposed(): boolean {\n        return this.m_state === TileGeometryLoaderState.Disposed;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryKind, GeometryKindSet } from \"@here/harp-datasource-protocol\";\n\nimport { MapObjectAdapter } from \"../MapObjectAdapter\";\nimport { MapView } from \"../MapView\";\nimport { Tile } from \"../Tile\";\n\ntype TileUpdateCallback = (tile: Tile) => void;\n\n/**\n * Manages the content (the geometries) of a tile.\n * @internal\n */\nexport class TileGeometryManager {\n    /**\n     * The set of geometry kinds that is enabled. Their geometry will be created after decoding.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    get enabledGeometryKinds(): GeometryKindSet {\n        return this.enabledKinds;\n    }\n\n    /**\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    set enabledGeometryKinds(kinds: GeometryKindSet) {\n        this.enabledKinds = kinds;\n    }\n\n    /**\n     * The set of geometry kinds that is disabled. Their geometry will not be created after\n     * decoding.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    get disabledGeometryKinds(): GeometryKindSet {\n        return this.disabledKinds;\n    }\n\n    /**\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    set disabledGeometryKinds(kinds: GeometryKindSet) {\n        this.disabledKinds = kinds;\n    }\n\n    /**\n     * The set of geometry kinds that is hidden. Their geometry may be created, but it is hidden\n     * until the method `hideKind` with an argument of `addOrRemoveToHiddenSet:false` is called.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    get hiddenGeometryKinds(): GeometryKindSet {\n        return this.hiddenKinds;\n    }\n\n    /**\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    set hiddenGeometryKinds(kinds: GeometryKindSet) {\n        this.hiddenKinds = kinds;\n        this.incrementVisibilityCounter();\n    }\n\n    /**\n     * If set to `true`, the filters of enabled/disabledGeometryKinds are applied, otherwise they\n     * are ignored.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    enableFilterByKind: boolean = true;\n\n    protected get visibilityCounter(): number {\n        return this.m_visibilityCounter;\n    }\n\n    protected enabledKinds: GeometryKindSet = new GeometryKindSet();\n    protected disabledKinds: GeometryKindSet = new GeometryKindSet();\n    protected hiddenKinds: GeometryKindSet = new GeometryKindSet();\n\n    protected m_tileUpdateCallback: TileUpdateCallback | undefined;\n\n    /**\n     * Optimization for evaluation in `update()` method. Only if a kind is hidden/unhidden, the\n     * visibility of the kinds is applied to their geometries.\n     */\n    private m_visibilityCounter: number = 1;\n\n    /**\n     * Creates an instance of `TileGeometryManager` with a reference to the {@link MapView}.\n     */\n    constructor(protected mapView: MapView) {}\n\n    /**\n     * Process the {@link Tile}s for rendering. May alter the content of the tile per frame.\n     */\n    updateTiles(tiles: Tile[]): void {\n        let prio = 0;\n        for (const tile of tiles) {\n            //this assumes the tiles are ordered by priority, this is currently done in\n            // the visible tile set with 0 as the highest priority\n            const tilePriority = prio++;\n            const updateDone = tile.updateGeometry(\n                tilePriority,\n                this.enableFilterByKind ? this.enabledGeometryKinds : undefined,\n                this.enableFilterByKind ? this.disabledGeometryKinds : undefined\n            );\n            if (updateDone && this.m_tileUpdateCallback) {\n                this.m_tileUpdateCallback(tile);\n            }\n        }\n\n        // If the visibility status of the kinds changed since the last update, the new visibility\n        // status is applied (again).\n        if (this.updateTileObjectVisibility(tiles)) {\n            this.mapView.update();\n        }\n    }\n\n    /**\n     * Clear the enabled, disabled and hidden sets.\n     */\n    clear(): void {\n        this.enabledKinds.clear();\n        this.disabledKinds.clear();\n        this.hiddenKinds.clear();\n    }\n\n    /**\n     * Enable a [[GeometryKind]] by adding it to the enabled set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the enabled set.\n     * @param {boolean} addOrRemoveToEnabledSet Pass in `true` to add the kind to the set, pass in\n     *      `false` to remove from that set.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    enableKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToEnabledSet: boolean = true\n    ): void {\n        this.enableDisableKinds(this.enabledKinds, kind, addOrRemoveToEnabledSet);\n    }\n\n    /**\n     * Disable a [[GeometryKind]] by adding it to the disabled set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the disabled set.\n     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to add the kind to the set, pass in\n     *      `false` to remove from that set.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    disableKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToDisabledSet: boolean = true\n    ): void {\n        this.enableDisableKinds(this.disabledKinds, kind, addOrRemoveToDisabledSet);\n    }\n\n    /**\n     * Hide a [[GeometryKind]] by adding it to the hidden set, or remove it from that set.\n     *\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind The kind to add or remove\n     *      from the hidden set.\n     * @param {boolean} addOrRemoveToHiddenSet Pass in `true` to hide the kind(s), `false` to show\n     *      it again.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    hideKind(\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addOrRemoveToHiddenSet: boolean = true\n    ): void {\n        let visibilityHasChanged = false;\n\n        if (Array.isArray(kind) || kind instanceof Set) {\n            for (const oneKind of kind) {\n                const visibilityChange = this.addRemove(\n                    this.hiddenKinds,\n                    oneKind,\n                    addOrRemoveToHiddenSet\n                );\n                visibilityHasChanged = visibilityHasChanged || visibilityChange;\n            }\n        } else {\n            visibilityHasChanged = this.addRemove(this.hiddenKinds, kind, addOrRemoveToHiddenSet);\n        }\n\n        // Will be evaluated in the next update()\n        if (visibilityHasChanged) {\n            this.incrementVisibilityCounter();\n        }\n    }\n\n    /**\n     * Return all [[GeometryKind]]s that are contained in the tiles.\n     *\n     * @param {IterableIterator<Tile>} tiles The\n     * @returns {GeometryKindSet}\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    getAvailableKinds(tiles: IterableIterator<Tile>): GeometryKindSet {\n        const visibleKinds: GeometryKindSet = new GeometryKindSet();\n        for (const tile of tiles) {\n            const tileKinds = tile.loadedGeometryKinds;\n            if (tileKinds !== undefined) {\n                for (const kind of tileKinds) {\n                    visibleKinds.add(kind);\n                }\n            }\n        }\n        return visibleKinds;\n    }\n\n    /**\n     * Apply the visibility status taken from the `hiddenKinds` to all geometries in the specified\n     * tiles.\n     *\n     * @param {Tile[]} tiles List of [[Tiles]] to process the visibility status of.\n     */\n    updateTileObjectVisibility(tiles: Tile[]): boolean {\n        let needUpdate = false;\n\n        for (const tile of tiles) {\n            if (tile.objects.length === 0 || tile.visibilityCounter === this.visibilityCounter) {\n                continue;\n            }\n            tile.visibilityCounter = this.visibilityCounter;\n\n            for (const object of tile.objects) {\n                const objectAdapter = MapObjectAdapter.get(object);\n                const geometryKind = objectAdapter?.kind;\n                if (geometryKind !== undefined) {\n                    const nowVisible = !geometryKind.some(kind => this.hiddenKinds.has(kind));\n                    needUpdate = needUpdate || object.visible !== nowVisible;\n                    object.visible = nowVisible;\n                }\n            }\n        }\n        return needUpdate;\n    }\n\n    /**\n     * Sets a callback that will be called for every updated tile on [[updateTiles]].\n     *\n     * @param {TileUpdateCallback} callback The callback that will be called after a tile has been\n     * updated, passing the updated tile as argument. If `undefined`, a previously set callback will\n     * be cleared.\n     */\n    setTileUpdateCallback(callback?: TileUpdateCallback): void {\n        this.m_tileUpdateCallback = callback;\n    }\n\n    protected incrementVisibilityCounter(): number {\n        return ++this.m_visibilityCounter;\n    }\n\n    /**\n     * Add or remove a kind|array of kinds|set of kinds from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    private enableDisableKinds(\n        set: GeometryKindSet,\n        kind: GeometryKind | GeometryKind[] | GeometryKindSet,\n        addToSet: boolean\n    ): void {\n        if (Array.isArray(kind)) {\n            for (const oneKind of kind as GeometryKind[]) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        } else if (kind instanceof Set) {\n            const kindSet = kind as GeometryKindSet;\n            for (const oneKind of kindSet) {\n                this.addRemove(set, oneKind, addToSet);\n            }\n        } else if (kind !== undefined) {\n            this.addRemove(set, kind, addToSet);\n        }\n    }\n\n    /**\n     * Add or remove a single kind from the specified kind set.\n     *\n     * @hidden\n     * @param {GeometryKindSet} set\n     * @param {(GeometryKind | GeometryKind[] | GeometryKindSet)} kind\n     * @param {boolean} addToSet\n     */\n    private addRemove(kindsSet: GeometryKindSet, kind: GeometryKind, addToSet: boolean): boolean {\n        if (addToSet) {\n            if (!kindsSet.has(kind)) {\n                kindsSet.add(kind);\n                return true;\n            }\n        } else {\n            if (kindsSet.has(kind)) {\n                kindsSet.delete(kind);\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Vector3Like } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\n\n// Offsets for the fields stored in cache for each vertex.\nenum Field {\n    VertexId = 0,\n    OlderIdx, // Index in cache of the immediately older vertex.\n    NewerIdx, // Index in cache of the immediately newer vertex.\n    X,\n    Y,\n    Z,\n    Count\n}\n\nconst Invalid: number = -1;\n\n/**\n * Compact vertex LRU Cache for on the fly temporary mesh transformations.\n * @internal\n */\nexport class VertexCache {\n    private m_cache: number[] = []; // Stores all fields for every cached vertex (see Field).\n    private m_vertexCount: number = 0;\n    private m_oldestIdx: number = 0;\n    private m_newestIdx: number = 0;\n\n    /**\n     * Creates a new cache with the specified maximum size.\n     * @param maxVertexCount - The maximum number of vertices the cache will store.\n     */\n    constructor(readonly maxVertexCount: number) {\n        this.m_cache.length = this.maxVertexCount * Field.Count;\n        this.clear();\n    }\n\n    /**\n     * Clears the vertex cache.\n     */\n    clear() {\n        this.m_cache.fill(Invalid);\n        this.m_vertexCount = 0;\n    }\n\n    /**\n     * Gets a vertex from cache.\n     * @param vertexId - The id of the vertex to get.\n     * @param vertex - The vertex coordinates will be set here if found.\n     * @returns whether the vertex was found on cache.\n     */\n    get(vertexId: number, vertex: Vector3Like): boolean {\n        const vertexIdx = this.find(vertexId);\n        if (vertexIdx === undefined) {\n            return false;\n        }\n        this.promoteEntry(vertexIdx);\n        this.getVertex(vertexIdx, vertex);\n        return true;\n    }\n\n    /**\n     * Sets a vertex in cache. It's assumed there's no vertex with the same id already in cache.\n     * @param vertexId - The vertex id.\n     * @param vertex - The vertex coordinates.\n     */\n    set(vertexId: number, vertex: Vector3Like) {\n        let vertexIdx = Invalid;\n        if (this.m_vertexCount < this.maxVertexCount) {\n            vertexIdx = this.m_vertexCount * Field.Count;\n            this.m_vertexCount++;\n        } else {\n            vertexIdx = this.m_oldestIdx;\n        }\n        if (this.m_vertexCount === 1) {\n            this.m_oldestIdx = this.m_newestIdx = vertexIdx;\n        } else {\n            this.promoteEntry(vertexIdx);\n        }\n        this.setVertex(vertexIdx, vertexId, vertex);\n    }\n\n    private find(vertexId: number): number | undefined {\n        const size = this.m_cache.length;\n        for (let i = 0; i < size; i += Field.Count) {\n            if (this.m_cache[i] === vertexId) {\n                return i;\n            }\n        }\n        return undefined;\n    }\n\n    private promoteEntry(vertexIdx: number): void {\n        if (vertexIdx === this.m_newestIdx) {\n            return;\n        } // already newest, nothing to do\n        // re-link newer and older items\n        const newerIdx = this.getNewerIdx(vertexIdx);\n        const olderIdx = this.getOlderIdx(vertexIdx);\n        if (newerIdx !== Invalid) {\n            assert(this.getOlderIdx(newerIdx) === vertexIdx);\n            this.setOlderIdx(newerIdx, olderIdx);\n        }\n        if (olderIdx !== Invalid) {\n            assert(this.getNewerIdx(olderIdx) === vertexIdx);\n            this.setNewerIdx(olderIdx, newerIdx);\n        }\n        if (vertexIdx === this.m_oldestIdx) {\n            this.m_oldestIdx = newerIdx;\n        }\n        // re-link ourselves\n        this.setNewerIdx(vertexIdx, Invalid);\n        this.setOlderIdx(vertexIdx, this.m_newestIdx);\n        // finally, set ourselves as the newest entry\n        assert(this.m_newestIdx !== Invalid);\n        assert(this.getNewerIdx(this.m_newestIdx) === Invalid);\n        this.setNewerIdx(this.m_newestIdx, vertexIdx);\n        this.m_newestIdx = vertexIdx;\n    }\n\n    private getOlderIdx(vertexIdx: number): number {\n        return this.m_cache[vertexIdx + Field.OlderIdx];\n    }\n\n    private setOlderIdx(vertexIdx: number, olderIdx: number): void {\n        this.m_cache[vertexIdx + Field.OlderIdx] = olderIdx;\n    }\n\n    private getNewerIdx(vertexIdx: number): number {\n        return this.m_cache[vertexIdx + Field.NewerIdx];\n    }\n\n    private setNewerIdx(vertexIdx: number, newerIdx: number): void {\n        this.m_cache[vertexIdx + Field.NewerIdx] = newerIdx;\n    }\n\n    private getVertex(vertexIdx: number, vertex: Vector3Like): void {\n        vertex.x = this.m_cache[vertexIdx + Field.X];\n        vertex.y = this.m_cache[vertexIdx + Field.Y];\n        vertex.z = this.m_cache[vertexIdx + Field.Z];\n    }\n\n    private setVertex(vertexIdx: number, vertexId: number, vertex: Vector3Like): void {\n        this.m_cache[vertexIdx] = vertexId;\n        this.m_cache[vertexIdx + Field.X] = vertex.x;\n        this.m_cache[vertexIdx + Field.Y] = vertex.y;\n        this.m_cache[vertexIdx + Field.Z] = vertex.z;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GeometryKind } from \"@here/harp-datasource-protocol\";\nimport { Projection } from \"@here/harp-geoutils\";\nimport { setDisplacementMapToMaterial } from \"@here/harp-materials\";\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { TileDisplacementMap } from \"../DisplacementMap\";\nimport { ElevationProvider } from \"../ElevationProvider\";\nimport { TextElement } from \"../text/TextElement\";\nimport { Tile, TileObject } from \"../Tile\";\n\n/**\n * Overlays the specified object's geometry on the elevation represented by the given displacement\n * map .\n *\n * @param object - The object to be overlaid.\n * @param displacementMap - Texture representing the elevation data used to overlay the object.\n */\nfunction overlayObject(object: TileObject, displacementMap: THREE.DataTexture): void {\n    if (!(\"material\" in object)) {\n        return;\n    }\n    const setDisplacementMap = setDisplacementMapToMaterial.bind(null, displacementMap);\n    const material = (object as any).material as THREE.Mesh[\"material\"];\n\n    if (Array.isArray(material)) {\n        material.forEach(setDisplacementMap);\n    } else if (material) {\n        setDisplacementMap(material);\n    }\n}\n\n/**\n * Overlays the specified coordinates on top of elevation data if available.\n *\n * @param worldCoords - World coordinates to overlay.\n * @param elevationProvider - Used to sample elevation data.\n * @param displacementMap - Elevation data to be sampled.\n * @param projection - Projection from geo to world space.\n * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation\n * data not available).\n */\nfunction overlayPosition(\n    worldCoords: THREE.Vector3,\n    elevationProvider: ElevationProvider,\n    displacementMap: TileDisplacementMap,\n    projection: Projection\n): boolean {\n    // TODO: Move calculation of text element geoCoordinates to decoder.\n    const geoCoords = projection.unprojectPoint(worldCoords);\n\n    if (displacementMap.geoBox.contains(geoCoords)) {\n        geoCoords.altitude = elevationProvider.sampleHeight(geoCoords, displacementMap);\n    } else {\n        geoCoords.altitude = elevationProvider.getHeight(geoCoords, displacementMap.tileKey.level);\n        if (geoCoords.altitude === undefined) {\n            return false;\n        }\n    }\n    projection.projectPoint(geoCoords, worldCoords);\n    return true;\n}\n\n/**\n * Overlays the specified coordinates on top of elevation data if available.\n *\n * @param path - World coordinates to overlay.\n * @param elevationProvider - Used to sample elevation data.\n * @param displacementMap - Elevation data to be sampled.\n * @param projection - Projection from geo to world space.\n * @returns `true` if the position was successfully overlaid, `false` otherwise (e.g. elevation\n * data not available).\n */\nfunction overlayPath(\n    path: THREE.Vector3[],\n    elevationProvider: ElevationProvider,\n    displacementMap: TileDisplacementMap,\n    projection: Projection\n): boolean {\n    for (const position of path) {\n        if (!overlayPosition(position, elevationProvider, displacementMap, projection)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Overlays a text element on top of elevation data if available.\n *\n * @param textElement - The text element whose geometry will be overlaid.\n * @param elevationProvider -  Used to sample elevation data.\n * @param displacementMap - Elevation data to be sampled.\n * @param projection - Projection from geo to world space.\n */\nexport function overlayTextElement(\n    textElement: TextElement,\n    elevationProvider: ElevationProvider,\n    displacementMap: TileDisplacementMap,\n    projection: Projection\n) {\n    assert(!textElement.elevated);\n    if (!displacementMap) {\n        return;\n    }\n\n    textElement.elevated = textElement.path\n        ? overlayPath(textElement.path, elevationProvider, displacementMap, projection)\n        : overlayPosition(textElement.position, elevationProvider, displacementMap, projection);\n}\n\n/**\n * Overlays the geometry in the given tile on top of elevation data if available. The tile's\n * elevation may be updated with a more precise range.\n *\n * @param tile - The tile whose geometry will be overlaid.\n */\nexport function overlayOnElevation(tile: Tile): void {\n    const elevationProvider = tile.mapView.elevationProvider;\n\n    if (elevationProvider === undefined || tile.objects.length === 0) {\n        return;\n    }\n    const firstObject = tile.objects[0];\n    if (\n        !firstObject.userData ||\n        !firstObject.userData.kind ||\n        !firstObject.userData.kind.find((kind: GeometryKind) => {\n            return kind !== GeometryKind.All && kind !== GeometryKind.Terrain;\n        })\n    ) {\n        return;\n    }\n\n    const displacementMap = elevationProvider.getDisplacementMap(tile.tileKey);\n    if (displacementMap === undefined) {\n        return;\n    }\n\n    // TODO: HARP-8808 Apply displacement maps once per material.\n    for (const object of tile.objects) {\n        overlayObject(object, displacementMap.texture);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { MipMapGenerator } from \"./MipMapGenerator\";\n\n/** Any type supported by WebGLRenderingContext.texImage2D() for texture creation */\nexport type TexturizableImage =\n    | HTMLImageElement\n    | HTMLCanvasElement\n    | HTMLVideoElement\n    | ImageData\n    | ImageBitmap;\n\nconst logger = LoggerManager.instance.create(\"loadImage\");\nconst mipMapGenerator = new MipMapGenerator();\n\n/**\n * `ImageItem` is used to identify an image in the {@link ImageCache}.\n */\nexport class ImageItem {\n    /** Mip maps for image data */\n    mipMaps?: ImageData[];\n    /** Turns to `true` if the loading has been cancelled. */\n    cancelled?: boolean;\n    /** `loadingPromise` is only used during loading/generating the image. */\n    private loadingPromise?: Promise<ImageItem | undefined>;\n\n    /**\n     * Create the `ImageItem`.\n     *\n     * @param url - URL of the image, or unique identifier.\n     * @param image - Optional image if already loaded.\n     */\n    constructor(readonly url: string, public image?: TexturizableImage) {}\n\n    get loaded(): boolean {\n        return this.image !== undefined && this.mipMaps !== undefined;\n    }\n\n    get loading(): boolean {\n        return this.loadingPromise !== undefined;\n    }\n\n    /**\n     * Load an {@link ImageItem}.\n     *\n     * @remarks\n     * If the loading process is already running, it returns the current promise.\n     *\n     * @param imageItem - `ImageItem` containing the URL to load image from.\n     * @returns An {@link ImageItem} if the image has already been loaded, a promise otherwise.\n     */\n    loadImage(): Promise<ImageItem | undefined> {\n        if (this.loaded) {\n            return Promise.resolve(this);\n        }\n\n        if (this.loading) {\n            return this.loadingPromise!;\n        }\n\n        this.loadingPromise = new Promise((resolve, reject) => {\n            if (this.image) {\n                const image = this.image;\n                if (image instanceof HTMLImageElement && !image.complete) {\n                    image.addEventListener(\"load\", this.finalizeImage.bind(this, image, resolve));\n                    image.addEventListener(\"error\", reject);\n                } else {\n                    this.finalizeImage(this.image, resolve);\n                }\n                return;\n            }\n\n            logger.debug(`Loading image: ${this.url}`);\n            if (this.cancelled === true) {\n                logger.debug(`Cancelled loading image: ${this.url}`);\n                resolve(undefined);\n            } else {\n                new THREE.ImageLoader().load(\n                    this.url,\n                    (image: HTMLImageElement) => {\n                        if (this.cancelled === true) {\n                            logger.debug(`Cancelled loading image: ${this.url}`);\n                            resolve(undefined);\n                            return;\n                        }\n\n                        this.finalizeImage(image, resolve);\n                    },\n                    undefined,\n                    errorEvent => {\n                        logger.error(`... loading image failed: ${this.url} : ${errorEvent}`);\n\n                        this.loadingPromise = undefined;\n                        reject(`... loading image failed: ${this.url} : ${errorEvent}`);\n                    }\n                );\n            }\n        });\n\n        return this.loadingPromise;\n    }\n\n    private finalizeImage(image: TexturizableImage, resolve: (item: ImageItem) => void) {\n        this.image = image;\n        this.mipMaps = mipMapGenerator.generateTextureAtlasMipMap(this);\n        this.loadingPromise = undefined;\n        resolve(this);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { ImageItem, TexturizableImage } from \"./Image\";\n\n/**\n * Combines an {@link ImageItem} with a list of owners (which can be any object) that reference it.\n */\nclass ImageCacheItem {\n    /**\n     * The list of owners referencing the {@link ImageItem}.\n     */\n    owners: any[] = [];\n\n    /**\n     * Instantiates `ImageCacheItem`.\n     *\n     * @param imageItem - The {@link ImageItem} referenced by the associated owners.\n     * @param owner - First owner referencing the {@link ImageItem}.\n     */\n    constructor(public imageItem: ImageItem, owner: any) {\n        this.owners.push(owner);\n    }\n}\n\n/**\n * @internal\n *\n * `ImageCache` is a singleton, so it can be used with multiple owners on a single page.\n *\n * @remarks\n * This allows to have an image loaded only once for multiple views.\n * THREE is doing something similar,\n * but does not allow to share images that have been loaded from a canvas (which we may need to do\n * if we use SVG images for textures).\n *\n * One application that makes our own cache necessary is the generation of our own textures from\n * data that is not an URL.\n *\n * The `ImageCache` can be improved by adding statistics for memory footprint as well.\n */\nexport class ImageCache {\n    /**\n     * Returns the singleton `instance` of the `ImageCache`.\n     */\n    static get instance(): ImageCache {\n        if (ImageCache.m_instance === undefined) {\n            ImageCache.m_instance = new ImageCache();\n        }\n        return ImageCache.m_instance;\n    }\n\n    /**\n     * Dispose the singleton object.\n     *\n     * @remarks\n     * Not normally implemented for singletons, but good for debugging.\n     */\n    static dispose(): void {\n        ImageCache.m_instance = undefined;\n    }\n\n    private static m_instance: ImageCache | undefined;\n\n    private readonly m_images: Map<string, ImageCacheItem> = new Map();\n\n    /**\n     * Add an image definition to the global cache. Useful when the image data is already loaded.\n     *\n     * @param owner - Specify which {@link any} requests the image.\n     * @param url - URL of image.\n     * @param image - Optional {@link TexturizableImage}.\n     */\n    registerImage(owner: any, url: string, image?: TexturizableImage): ImageItem {\n        let imageCacheItem = this.findImageCacheItem(url);\n        if (imageCacheItem) {\n            if (owner !== undefined && !imageCacheItem.owners.includes(owner)) {\n                imageCacheItem.owners.push(owner);\n            }\n            return imageCacheItem.imageItem;\n        }\n\n        imageCacheItem = {\n            imageItem: new ImageItem(url, image),\n            owners: [owner]\n        };\n\n        this.m_images.set(url, imageCacheItem);\n\n        return imageCacheItem.imageItem;\n    }\n\n    /**\n     * Remove an image from the cache..\n     *\n     * @param url - URL of the image.\n     * @param owner - Owner removing the image.\n     * @returns `true` if image has been removed.\n     */\n    removeImage(url: string, owner: any): boolean {\n        const cacheItem = this.m_images.get(url);\n        if (cacheItem !== undefined) {\n            this.unlinkCacheItem(cacheItem, owner);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find {@link ImageItem} for the specified URL.\n     *\n     * @param url - URL of image.\n     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.\n     */\n    findImage(url: string): ImageItem | undefined {\n        const cacheItem = this.m_images.get(url);\n        if (cacheItem !== undefined) {\n            return cacheItem.imageItem;\n        }\n        return undefined;\n    }\n\n    /**\n     * Clear all {@link ImageItem}s belonging to an owner.\n     *\n     * @remarks\n     * May remove cached items if no owner is registered anymore.\n     *\n     * @param owner - specify to remove all items registered by {@link any}.\n     * @returns Number of images removed.\n     */\n    clear(owner: any) {\n        this.m_images.forEach(cacheItem => {\n            this.unlinkCacheItem(cacheItem, owner);\n        });\n    }\n\n    /**\n     * Returns the number of all cached {@link ImageItem}s.\n     */\n    get size(): number {\n        return this.m_images.size;\n    }\n\n    /**\n     * Find the cached {@link ImageItem} by URL.\n     *\n     * @param url - URL of image.\n     */\n    private findImageCacheItem(url: string): ImageCacheItem | undefined {\n        return this.m_images.get(url);\n    }\n\n    /**\n     * Cancel loading an image.\n     *\n     * @param imageItem - Item to cancel loading.\n     */\n    private cancelLoading(imageItem: ImageItem) {\n        if (imageItem.loading) {\n            // Notify that we are cancelling.\n            imageItem.cancelled = true;\n        }\n    }\n\n    /**\n     * Remove the cacheItem from cache, unless the item is used by another owner, in that case the\n     * link to the owner is removed from the item, just like a reference count.\n     *\n     * @param cacheItem The cache item to be removed.\n     * @param owner - Specify which owner removes the image.\n     * If no owner is specified, the cache item is removed even if it has owners.\n     */\n    private unlinkCacheItem(cacheItem: ImageCacheItem, owner: any) {\n        const ownerIndex = cacheItem.owners.indexOf(owner);\n        if (ownerIndex >= 0) {\n            cacheItem.owners.splice(ownerIndex, 1);\n        }\n        if (cacheItem.owners.length === 0) {\n            this.m_images.delete(cacheItem.imageItem.url);\n            this.cancelLoading(cacheItem.imageItem);\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\n\nimport { ImageItem, TexturizableImage } from \"./Image\";\nimport { ImageCache } from \"./ImageCache\";\n\n/**\n * Cache images wrapped into {@link ImageItem}s for a {@link MapView}.\n *\n * @remarks\n * An image may have multiple names in a theme, the `MapViewImageCache` maps different names to the\n * same image URL, and allows to share the image by URL to different MapViews.\n * Within a MapView instance, the (optional) name is unique, so registering multiple images with the\n * same name is invalid.\n *\n * The `MapViewImageCache` uses a global {@link ImageCache} to actually store (and generate) the\n * image data.\n */\nexport class MapViewImageCache {\n    private readonly m_name2Url: Map<string, string> = new Map();\n    private readonly m_urlNameCount: Map<string, number> = new Map();\n\n    /**\n     * Add an image from an URL and optionally start loading it, storing the resulting\n     * {@link TexturizableImage} in a {@link ImageItem}.\n     *\n     * @remarks\n     * Names are unique within a {@link MapView}. URLs are not unique, multiple images with\n     * different names can have the same URL. Still, URLs are are loaded only once.\n     * If an image with the same name is already registered an error is thrown.\n     *\n     * @param name - Image name.\n     * @param url - Image URL.\n     * @param startLoading - Optional. Pass `true` to start loading the image in the background.\n     * @returns The resulting {@link ImageItem} or a promise for it if it starts loading.\n     */\n    addImage(\n        name: string,\n        url: string,\n        startLoading?: boolean\n    ): ImageItem | Promise<ImageItem | undefined>;\n\n    /**\n     * Add an image storing it in a {@link ImageItem}.\n     *\n     * @remarks\n     * Names are unique within a {@link MapView}. If an image with the same name is already\n     * registered an error is thrown.\n     *\n     * @param name - Unique image name.\n     * @param image - The image to add.\n     * @returns The resulting {@link ImageItem}\n     */\n    addImage(name: string, image: TexturizableImage): ImageItem;\n\n    addImage(\n        name: string,\n        urlOrImage: string | TexturizableImage,\n        startLoading = true\n    ): ImageItem | Promise<ImageItem | undefined> {\n        if (typeof urlOrImage === \"string\") {\n            const url = urlOrImage;\n            const imageItem = this.registerImage(name, url);\n\n            return startLoading ? imageItem.loadImage() : imageItem;\n        }\n\n        const image = urlOrImage;\n        return this.registerImage(name, undefined, image);\n    }\n\n    /**\n     * Remove the image with this name from the cache.\n     *\n     * @param name - Name of the image.\n     * @returns `true` if item has been removed.\n     */\n    removeImage(name: string): boolean {\n        const url = this.m_name2Url.get(name);\n        if (url !== undefined) {\n            this.m_name2Url.delete(name);\n\n            let nameCount = 1;\n            if (name !== url) {\n                const result = this.m_urlNameCount.get(url);\n                assert(result !== undefined);\n                nameCount = result!;\n                assert(nameCount > 0);\n            }\n\n            if (nameCount > 1) {\n                // There is another name sharing this URL.\n                this.m_urlNameCount.set(url, nameCount - 1);\n            } else {\n                // URL was used by this image only, remove the image.\n                this.m_urlNameCount.delete(url);\n                ImageCache.instance.removeImage(url, this);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Find {@link ImageItem} by its name.\n     *\n     * @param name - Name of image.\n     */\n    findImageByName(name: string): ImageItem | undefined {\n        const url = this.m_name2Url.get(name);\n        if (url === undefined) {\n            return undefined;\n        }\n        return ImageCache.instance.findImage(url);\n    }\n\n    /**\n     * Remove all {@link ImageItem}s from the cache.\n     *\n     * @remarks\n     * Also removes all {@link ImageItem}s that belong to this\n     * {@link MapView} from the global {@link ImageCache}.\n     * @returns Number of images removed.\n     */\n    clear() {\n        ImageCache.instance.clear(this);\n        this.m_name2Url.clear();\n        this.m_urlNameCount.clear();\n    }\n\n    /**\n     * Register an existing image by name. If the name already exists and error is thrown.\n     *\n     * @param name - Image name.\n     * @param url - Optional image URL.\n     * @param image - Optional {@link TexturizableImage}.\n     */\n    private registerImage(name: string, url?: string, image?: TexturizableImage): ImageItem {\n        if (this.hasName(name)) {\n            throw new Error(\"duplicate name in cache\");\n        }\n\n        if (url === undefined) {\n            // If no url given, an image must be provided directly. In this case the name is used\n            // as url.\n            assert(image !== undefined);\n            url = name;\n        }\n\n        if (url !== name) {\n            const nameCount = this.m_urlNameCount.get(url) ?? 0;\n            this.m_urlNameCount.set(url, nameCount + 1);\n        }\n\n        this.m_name2Url.set(name, url);\n        return ImageCache.instance.registerImage(this, url, image);\n    }\n\n    private hasName(name: string): boolean {\n        return this.m_name2Url.get(name) !== undefined;\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { ImageItem, TexturizableImage } from \"./Image\";\n\nconst isNode = typeof window === \"undefined\";\n\n/**\n * Mip map generator resizes textures to next bigger power-of-two size by adding padding\n * and creates mip map levels.\n * @internal\n */\nexport class MipMapGenerator {\n    /**\n     * Gets size of an image padded to the next bigger power-of-two size\n     * @param width - Width of image\n     * @param height - Height of image\n     */\n    static getPaddedSize(width: number, height: number): { width: number; height: number } {\n        return {\n            width: THREE.MathUtils.ceilPowerOfTwo(width),\n            height: THREE.MathUtils.ceilPowerOfTwo(height)\n        };\n    }\n\n    private readonly m_paddingCanvas?: HTMLCanvasElement;\n    private readonly m_paddingContext?: CanvasRenderingContext2D;\n    private readonly m_resizeCanvas?: HTMLCanvasElement;\n    private readonly m_resizeContext?: CanvasRenderingContext2D;\n\n    constructor() {\n        if (!isNode) {\n            this.m_paddingCanvas = document.createElement(\"canvas\");\n            this.m_paddingContext = this.m_paddingCanvas.getContext(\"2d\")!;\n            this.m_resizeCanvas = document.createElement(\"canvas\");\n            this.m_resizeContext = this.m_resizeCanvas.getContext(\"2d\")!;\n        }\n    }\n\n    /**\n     * Generate downsampled mip map levels from an image.\n     * If the input image is not power-of-two the image is padded to the\n     * next bigger power-of-two size.\n     * @param image - Input image\n     * @returns A list of images with mip maps of the input image\n     */\n    generateTextureAtlasMipMap(image: ImageItem): ImageData[] {\n        if (isNode) {\n            throw new Error(\"MipMapGenerator only works in browser.\");\n        }\n\n        if (image.image === undefined) {\n            throw new Error(\"Can not generate mip maps. Image data not loaded!\");\n        }\n        const imageData = image.image;\n        const mipMaps: ImageData[] = [];\n\n        // Add initial texture with padding as level 0\n        const { width: paddedWidth, height: paddedHeight } = MipMapGenerator.getPaddedSize(\n            imageData.width,\n            imageData.height\n        );\n        this.copyImageWithPadding(imageData, paddedWidth, paddedHeight);\n        mipMaps.push(this.m_paddingContext!.getImageData(0, 0, paddedWidth, paddedHeight));\n\n        let width = paddedWidth * 0.5;\n        let height = paddedHeight * 0.5;\n        // HARP-10765 WebGL complains if we don't generate down to a 1x1 texture (this was the case\n        // previously when height != width), and thus the final texture generated was 2x1 texture\n        // and not 1x1.\n        while (width >= 1 || height >= 1) {\n            const mipMapLevel = mipMaps.length;\n            const previousImage = mipMaps[mipMapLevel - 1];\n            // Resize previous mip map level\n            mipMaps.push(this.resizeImage(previousImage, Math.max(width, 1), Math.max(height, 1)));\n            width *= 0.5;\n            height *= 0.5;\n        }\n\n        return mipMaps;\n    }\n\n    /**\n     * Copy image to a canvas and add padding if necessary.\n     * @param image - Input image.\n     * @param width - Width of output image\n     * @param height - Width of output image\n     * @returns Canvas with image and padding.\n     */\n    private copyImageWithPadding(\n        image: TexturizableImage,\n        width: number,\n        height: number\n    ): HTMLCanvasElement {\n        this.m_paddingCanvas!.width = width;\n        this.m_paddingCanvas!.height = height;\n\n        this.m_paddingContext!.clearRect(0, 0, width, height);\n        if (image instanceof ImageData) {\n            this.m_paddingContext!.putImageData(image, 0, 0);\n        } else {\n            this.m_paddingContext!.drawImage(image, 0, 0);\n        }\n\n        // Add horizontal padding\n        if (image.width !== width) {\n            this.m_paddingContext!.drawImage(\n                this.m_paddingCanvas!,\n                image.width - 1,\n                0,\n                1,\n                image.height,\n                image.width,\n                0,\n                width - image.width,\n                image.height\n            );\n        }\n\n        // Add vertical padding\n        if (image.height !== height) {\n            this.m_paddingContext!.drawImage(\n                this.m_paddingCanvas!,\n                0,\n                image.height - 1,\n                width,\n                1,\n                0,\n                image.height,\n                width,\n                height - image.height\n            );\n        }\n\n        return this.m_paddingCanvas!;\n    }\n\n    /**\n     * Resize an image.\n     *\n     * Quality of resized image is best when\n     * image.width and image.height are even numbers and the image\n     * is resized by factor 0.5 or 2.\n     * @param image - Input image\n     * @param width - Width of output image\n     * @param height - Height of output image\n     * @return Resized image\n     */\n    private resizeImage(image: ImageData, width: number, height: number): ImageData {\n        //  Copy image data to canvas because ImageData can't be resized directly\n        const paddedImage = this.copyImageWithPadding(image, image.width, image.height);\n\n        // Resize image to resize canvas\n        this.m_resizeCanvas!.width = width;\n        this.m_resizeCanvas!.height = height;\n        this.m_resizeContext!.clearRect(0, 0, width, height);\n        this.m_resizeContext!.drawImage(paddedImage, 0, 0, width, height);\n\n        return this.m_resizeContext!.getImageData(0, 0, width, height);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { MemoryUsage } from \"@here/harp-text-canvas\";\nimport { Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { getPixelFromImage, screenToUvCoordinates } from \"./PixelPicker\";\n\n/**\n * Declares an interface for a `struct` containing a [[BoxBuffer]]'s attribute state information.\n */\nexport interface State {\n    positionAttributeCount: number;\n    colorAttributeCount: number;\n    uvAttributeCount: number;\n    indexAttributeCount: number;\n    pickInfoCount: number;\n}\n\n/**\n * Initial number of boxes in BoxBuffer.\n */\nconst START_BOX_BUFFER_SIZE = 0;\n\n/**\n * Maximum number of boxes in BoxBuffer.\n */\nconst MAX_BOX_BUFFER_SIZE = 32 * 1024;\n\n/**\n * Number of vertices per box/glyph element: 4 corners.\n */\nconst NUM_VERTICES_PER_ELEMENT = 4;\n\n/**\n * Number of indices added per box/glyph: 2 triangles, 6 indices.\n */\nconst NUM_INDICES_PER_ELEMENT = 6;\n\n/**\n * Number of values per position.\n */\nconst NUM_POSITION_VALUES_PER_VERTEX = 3;\n\n/**\n * Number of values per color.\n */\nconst NUM_COLOR_VALUES_PER_VERTEX = 4;\n\n/**\n * Number of values per UV.\n */\nconst NUM_UV_VALUES_PER_VERTEX = 4;\n\n/**\n * Number of values per index.\n */\nconst NUM_INDEX_VALUES_PER_VERTEX = 1;\n\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n\n/**\n * SubClass of [[THREE.Mesh]] to identify meshes that have been created by [[BoxBuffer]] and\n * [[TextBuffer]]. Add the isEmpty flag to quickly test for empty meshes.\n */\nexport class BoxBufferMesh extends THREE.Mesh {\n    constructor(geometry: THREE.BufferGeometry, material: THREE.Material | THREE.Material[]) {\n        super(geometry, material);\n\n        this.type = \"BoxBufferMesh\";\n    }\n\n    /**\n     * A mesh that has no positions and indices set is defined to be empty.\n     *\n     * @returns `True` if no indices have been added to the mesh.\n     */\n    get isEmpty(): boolean {\n        if (this.geometry === undefined) {\n            return true;\n        } else {\n            const bufferGeometry = this.geometry as THREE.BufferGeometry;\n            return bufferGeometry.index === null || bufferGeometry.index.count === 0;\n        }\n    }\n}\n\n/**\n * Buffer for (untransformed) `Box2` objects. Can be used to create a single geometry for screen-\n * aligned boxes, like POIs.\n */\nexport class BoxBuffer {\n    /**\n     * {@link @here/harp-datasource-protocol#BufferAttribute} holding the `BoxBuffer` position data.\n     */\n    private m_positionAttribute?: THREE.BufferAttribute;\n\n    /**\n     * {@link @here/harp-datasource-protocol#BufferAttribute} holding the `BoxBuffer` color data.\n     */\n    private m_colorAttribute?: THREE.BufferAttribute;\n\n    /**\n     * {@link @here/harp-datasource-protocol#BufferAttribute} holding the `BoxBuffer` uv data.\n     */\n    private m_uvAttribute?: THREE.BufferAttribute;\n\n    /**\n     * {@link @here/harp-datasource-protocol#BufferAttribute} holding the `BoxBuffer` index data.\n     */\n    private m_indexAttribute?: THREE.BufferAttribute;\n    private readonly m_pickInfos: Array<any | undefined>;\n\n    /**\n     * [[BufferGeometry]] holding all the different\n     * {@link @here/harp-datasource-protocol#BufferAttribute}s.\n     */\n    private m_geometry: THREE.BufferGeometry | undefined;\n\n    /**\n     * [[Mesh]] used for rendering.\n     */\n    private m_mesh: BoxBufferMesh | undefined;\n\n    private m_size: number = 0;\n\n    /**\n     * Creates a new `BoxBuffer`.\n     *\n     * @param m_material - Material to be used for [[Mesh]] of this `BoxBuffer`.\n     * @param m_renderOrder - Optional renderOrder of this buffer.\n     * @param startElementCount - Initial number of elements this `BoxBuffer` can hold.\n     * @param m_maxElementCount - Maximum number of elements this `BoxBuffer` can hold.\n     */\n    constructor(\n        private readonly m_material: THREE.Material | THREE.Material[],\n        private readonly m_renderOrder: number = 0,\n        startElementCount = START_BOX_BUFFER_SIZE,\n        private readonly m_maxElementCount = MAX_BOX_BUFFER_SIZE\n    ) {\n        this.resizeBuffer(startElementCount);\n        this.m_pickInfos = new Array();\n    }\n\n    /**\n     * Duplicate this `BoxBuffer` with same material and renderOrder.\n     *\n     * @returns A clone of this `BoxBuffer`.\n     */\n    clone(): BoxBuffer {\n        return new BoxBuffer(this.m_material, this.m_renderOrder);\n    }\n\n    /**\n     * Dispose of the geometry.\n     */\n    dispose() {\n        if (this.m_geometry !== undefined) {\n            this.m_geometry.dispose();\n            this.m_geometry = undefined;\n        }\n        this.m_mesh = undefined;\n    }\n\n    /**\n     * Return the current number of elements the buffer can hold.\n     */\n    get size(): number {\n        return this.m_size;\n    }\n\n    /**\n     * Clear's the `BoxBuffer` attribute buffers.\n     */\n    reset() {\n        if (this.m_positionAttribute !== undefined) {\n            this.m_positionAttribute.count = 0;\n            this.m_colorAttribute!.count = 0;\n            this.m_uvAttribute!.count = 0;\n            this.m_indexAttribute!.count = 0;\n            this.m_pickInfos!.length = 0;\n        }\n    }\n\n    /**\n     * Returns `true` if this `BoxBuffer` can hold the specified amount of glyphs. If the buffer\n     * can only add the glyph by increasing the buffer size, the resize() method is called, which\n     * will then create a new geometry for the mesh.\n     *\n     * @param glyphCount - Number of glyphs to be added to the buffer.\n     * @returns `true` if the element (box or glyph) can be added to the buffer, `false` otherwise.\n     */\n    canAddElements(glyphCount = 1): boolean {\n        const indexAttribute = this.m_indexAttribute!;\n        if (\n            indexAttribute.count + glyphCount * NUM_INDICES_PER_ELEMENT >=\n            indexAttribute.array.length\n        ) {\n            // Too many elements for the current buffer, check if we can resize the buffer.\n            if (indexAttribute.array.length >= this.m_maxElementCount * NUM_INDICES_PER_ELEMENT) {\n                return false;\n            }\n\n            const newSize = Math.min(this.m_maxElementCount, this.size === 0 ? 256 : this.size * 2);\n            this.resize(newSize);\n        }\n        return true;\n    }\n\n    /**\n     * Returns this `BoxBuffer`'s attribute [[State]].\n     */\n    saveState(): State {\n        const state: State = {\n            positionAttributeCount: this.m_positionAttribute!.count,\n            colorAttributeCount: this.m_colorAttribute!.count,\n            uvAttributeCount: this.m_uvAttribute!.count,\n            indexAttributeCount: this.m_indexAttribute!.count,\n            pickInfoCount: this.m_pickInfos!.length\n        };\n        return state;\n    }\n\n    /**\n     * Store this `BoxBuffer`'s attribute [[State]] to a previously stored one.\n     *\n     * @param state - [[State]] struct describing a previous attribute state.\n     */\n    restoreState(state: State) {\n        this.m_positionAttribute!.count = state.positionAttributeCount;\n        this.m_colorAttribute!.count = state.colorAttributeCount;\n        this.m_uvAttribute!.count = state.uvAttributeCount;\n        this.m_indexAttribute!.count = state.indexAttributeCount;\n        this.m_pickInfos!.length = state.pickInfoCount;\n    }\n\n    /**\n     * Adds a new box to this `BoxBuffer`.\n     *\n     * @param screenBox - [[Math2D.Box]] holding screen coordinates for this box.\n     * @param uvBox - [[Math2D.UvBox]] holding uv coordinates for this box.\n     * @param color - Box's color.\n     * @param opacity - Box's opacity.\n     * @param distance - Box's distance to camera.\n     * @param pickInfo - Box's picking information.\n     */\n    addBox(\n        screenBox: Math2D.Box,\n        uvBox: Math2D.UvBox,\n        color: THREE.Color,\n        opacity: number,\n        distance: number,\n        pickInfo?: any\n    ): boolean {\n        if (!this.canAddElements()) {\n            return false;\n        }\n\n        const { s0, t0, s1, t1 } = uvBox;\n        const { x, y, w, h } = screenBox;\n\n        // Premultiply alpha into vertex colors\n        const r = Math.round(color.r * opacity * 255);\n        const g = Math.round(color.g * opacity * 255);\n        const b = Math.round(color.b * opacity * 255);\n        const a = Math.round(opacity * 255);\n\n        const positionAttribute = this.m_positionAttribute!;\n        const colorAttribute = this.m_colorAttribute!;\n        const uvAttribute = this.m_uvAttribute!;\n        const indexAttribute = this.m_indexAttribute!;\n\n        const baseVertex = positionAttribute.count;\n        const baseIndex = indexAttribute.count;\n\n        positionAttribute.setXYZ(baseVertex, x, y, distance);\n        positionAttribute.setXYZ(baseVertex + 1, x + w, y, distance);\n        positionAttribute.setXYZ(baseVertex + 2, x, y + h, distance);\n        positionAttribute.setXYZ(baseVertex + 3, x + w, y + h, distance);\n\n        colorAttribute.setXYZW(baseVertex, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 1, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 2, r, g, b, a);\n        colorAttribute.setXYZW(baseVertex + 3, r, g, b, a);\n\n        uvAttribute.setXY(baseVertex, s0, t0);\n        uvAttribute.setXY(baseVertex + 1, s1, t0);\n        uvAttribute.setXY(baseVertex + 2, s0, t1);\n        uvAttribute.setXY(baseVertex + 3, s1, t1);\n\n        indexAttribute.setX(baseIndex, baseVertex);\n        indexAttribute.setX(baseIndex + 1, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 2, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 3, baseVertex + 2);\n        indexAttribute.setX(baseIndex + 4, baseVertex + 1);\n        indexAttribute.setX(baseIndex + 5, baseVertex + 3);\n\n        positionAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        colorAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        uvAttribute.count += NUM_VERTICES_PER_ELEMENT;\n        indexAttribute.count += NUM_INDICES_PER_ELEMENT;\n\n        this.m_pickInfos.push(pickInfo);\n\n        return true;\n    }\n\n    /**\n     * Updates a [[BufferGeometry]] object to reflect the changes in this `TextBuffer`'s attribute\n     * data.\n     */\n    updateBufferGeometry() {\n        const positionAttribute = this.m_positionAttribute!;\n        const colorAttribute = this.m_colorAttribute!;\n        const uvAttribute = this.m_uvAttribute!;\n        const indexAttribute = this.m_indexAttribute!;\n\n        if (positionAttribute.count > 0) {\n            positionAttribute.needsUpdate = true;\n            positionAttribute.updateRange.offset = 0;\n            positionAttribute.updateRange.count =\n                positionAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n\n        if (colorAttribute.count > 0) {\n            colorAttribute.needsUpdate = true;\n            colorAttribute.updateRange.offset = 0;\n            colorAttribute.updateRange.count = colorAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n\n        if (uvAttribute.count > 0) {\n            uvAttribute.needsUpdate = true;\n            uvAttribute.updateRange.offset = 0;\n            uvAttribute.updateRange.count = uvAttribute.count * NUM_VERTICES_PER_ELEMENT;\n        }\n\n        if (indexAttribute.count > 0) {\n            indexAttribute.needsUpdate = true;\n            indexAttribute.updateRange.offset = 0;\n            indexAttribute.updateRange.count = indexAttribute.count;\n        }\n\n        if (this.m_geometry !== undefined) {\n            this.m_geometry.clearGroups();\n            this.m_geometry.addGroup(0, this.m_indexAttribute!.count);\n        }\n    }\n\n    /**\n     * Check if the buffer is empty. If it is empty, the memory usage is minimized to reduce\n     * footprint.\n     */\n    cleanUp() {\n        // If there is nothing in this buffer, resize it, it may never be used again.\n        if (this.m_indexAttribute!.count === 0 && this.size > START_BOX_BUFFER_SIZE) {\n            this.clearAttributes();\n        }\n    }\n\n    /**\n     * Determine if the mesh is empty.\n     */\n    get isEmpty(): boolean {\n        return this.m_mesh!.isEmpty;\n    }\n\n    /**\n     * Get the [[Mesh]] object. The geometry instance of the mesh may change if the buffers are\n     * resized. The mesh, once created, will not change, so it can always be added to the scene.\n     */\n    get mesh(): BoxBufferMesh {\n        if (this.m_mesh === undefined) {\n            this.resize();\n        }\n        return this.m_mesh!;\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * boxes are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     * @param image - Image to test if the pixel is transparent\n     */\n    pickBoxes(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void,\n        image?: CanvasImageSource | ImageData\n    ) {\n        const n = this.m_pickInfos.length;\n        const pickInfos = this.m_pickInfos;\n        const positions = this.m_positionAttribute!;\n        const screenX = screenPosition.x;\n        const screenY = screenPosition.y;\n\n        for (let pickInfoIndex = 0; pickInfoIndex < n; pickInfoIndex++) {\n            const positionIndex = pickInfoIndex * NUM_VERTICES_PER_ELEMENT;\n\n            const minX = positions.getX(positionIndex);\n            if (screenX < minX) {\n                continue;\n            }\n\n            const maxX = positions.getX(positionIndex + 1);\n            if (screenX > maxX) {\n                continue;\n            }\n\n            const minY = positions.getY(positionIndex);\n            if (screenY < minY) {\n                continue;\n            }\n\n            const maxY = positions.getY(positionIndex + 2);\n            if (screenY > maxY) {\n                continue;\n            }\n\n            const box = new Math2D.Box(minX, minY, maxX - minX, maxY - minY);\n            if (\n                image !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo !== undefined &&\n                pickInfos[pickInfoIndex].poiInfo.uvBox !== undefined &&\n                this.isPixelTransparent(\n                    image,\n                    screenX,\n                    screenY,\n                    box,\n                    pickInfos[pickInfoIndex].poiInfo.uvBox,\n                    document.createElement(\"canvas\")\n                )\n            ) {\n                continue;\n            }\n\n            if (pickInfos[pickInfoIndex] !== undefined) {\n                pickCallback(pickInfos[pickInfoIndex]);\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link @here/harp-datasource-protocol#Geometry} object\n     * from all the attribute data stored in this `BoxBuffer`.\n     *\n     * @remarks\n     * The [[Mesh]] object may be created if it is not initialized already.\n     *\n     * @param newSize - Optional number of elements to resize the buffer to.\n     * @param forceResize - Optional flag to force a resize even if new size is smaller than before.\n     */\n    resize(newSize?: number, forceResize?: boolean): BoxBufferMesh {\n        if (this.m_geometry !== undefined) {\n            this.m_geometry.dispose();\n        }\n\n        this.m_geometry = new THREE.BufferGeometry();\n\n        if (newSize !== undefined && (forceResize === true || newSize > this.size)) {\n            this.resizeBuffer(newSize);\n        }\n\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute!);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute!);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute!);\n        this.m_geometry.setIndex(this.m_indexAttribute!);\n        this.m_geometry.addGroup(0, this.m_indexAttribute!.count);\n\n        if (this.m_mesh === undefined) {\n            this.m_mesh = new BoxBufferMesh(this.m_geometry, this.m_material);\n            this.m_mesh.renderOrder = this.m_renderOrder;\n        } else {\n            this.m_mesh.geometry = this.m_geometry;\n        }\n        return this.m_mesh;\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `BoxBuffer`.\n     *\n     * @param info - The info object to increment with the values from this `BoxBuffer`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        const numBytes =\n            this.m_positionAttribute!.count * NUM_POSITION_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.m_colorAttribute!.count * NUM_COLOR_VALUES_PER_VERTEX +\n            this.m_uvAttribute!.count * NUM_UV_VALUES_PER_VERTEX * NUM_BYTES_PER_FLOAT +\n            this.m_indexAttribute!.count * NUM_BYTES_PER_INT32; // May be UInt16, so we overestimate\n\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n\n    /**\n     * Check if a pixel is transparent or not.\n     *\n     * @param image - Image source.\n     * @param xScreenPos - X position of the pixel.\n     * @param yScreenPos - Y position of the pixel.\n     * @param box - Bounding box of the image in screen coordinates.\n     * @param uvBox - Uv box referred to the given bounding box.\n     * @param canvas - Canvas element to draw the image if it's not a `ImageData` object.\n     */\n    private isPixelTransparent(\n        image: CanvasImageSource | ImageData,\n        xScreenPos: number,\n        yScreenPos: number,\n        box: Math2D.Box,\n        uvBox: Math2D.UvBox,\n        canvas?: HTMLCanvasElement\n    ): boolean {\n        const { u, v } = screenToUvCoordinates(xScreenPos, yScreenPos, box, uvBox);\n        const { width, height } = image instanceof SVGImageElement ? image.getBBox() : image;\n        const x = width * u;\n        const y = height * v;\n\n        const pixel = getPixelFromImage(x, y, image, canvas);\n\n        return pixel !== undefined && pixel[3] === 0;\n    }\n\n    /**\n     * Remove current attributes and arrays. Minimizes memory footprint.\n     */\n    private clearAttributes() {\n        this.m_positionAttribute = undefined;\n        this.m_colorAttribute = undefined;\n        this.m_uvAttribute = undefined;\n        this.m_indexAttribute = undefined;\n        this.resize(START_BOX_BUFFER_SIZE, true);\n    }\n\n    /**\n     * Resize the attribute buffers. New value must be larger than the previous one.\n     *\n     * @param newSize - New number of elements in the buffer. Number has to be larger than the\n     *      previous size.\n     */\n    private resizeBuffer(newSize: number) {\n        const newPositionArray = new Float32Array(\n            newSize * NUM_VERTICES_PER_ELEMENT * NUM_POSITION_VALUES_PER_VERTEX\n        );\n\n        if (this.m_positionAttribute !== undefined && this.m_positionAttribute.array.length > 0) {\n            const positionAttributeCount = this.m_positionAttribute.count;\n            newPositionArray.set(this.m_positionAttribute.array);\n            this.m_positionAttribute.array = newPositionArray;\n            this.m_positionAttribute.count = positionAttributeCount;\n        } else {\n            this.m_positionAttribute = new THREE.BufferAttribute(\n                newPositionArray,\n                NUM_POSITION_VALUES_PER_VERTEX\n            );\n            this.m_positionAttribute.count = 0;\n            this.m_positionAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        const newColorArray = new Uint8Array(\n            newSize * NUM_VERTICES_PER_ELEMENT * NUM_COLOR_VALUES_PER_VERTEX\n        );\n\n        if (this.m_colorAttribute !== undefined) {\n            const colorAttributeCount = this.m_colorAttribute.count;\n            newColorArray.set(this.m_colorAttribute.array);\n            this.m_colorAttribute.array = newColorArray;\n            this.m_colorAttribute.count = colorAttributeCount;\n        } else {\n            this.m_colorAttribute = new THREE.BufferAttribute(\n                newColorArray,\n                NUM_COLOR_VALUES_PER_VERTEX,\n                true\n            );\n            this.m_colorAttribute.count = 0;\n            this.m_colorAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        const newUvArray = new Float32Array(\n            newSize * NUM_VERTICES_PER_ELEMENT * NUM_UV_VALUES_PER_VERTEX\n        );\n\n        if (this.m_uvAttribute !== undefined) {\n            const uvAttributeCount = this.m_uvAttribute.count;\n            newUvArray.set(this.m_uvAttribute.array);\n            this.m_uvAttribute.array = newUvArray;\n            this.m_uvAttribute.count = uvAttributeCount;\n        } else {\n            this.m_uvAttribute = new THREE.BufferAttribute(newUvArray, NUM_UV_VALUES_PER_VERTEX);\n            this.m_uvAttribute.count = 0;\n            this.m_uvAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        const numIndexValues = newSize * NUM_INDICES_PER_ELEMENT * NUM_INDEX_VALUES_PER_VERTEX;\n\n        const newIndexArray =\n            numIndexValues > 65535\n                ? new Uint32Array(numIndexValues)\n                : new Uint16Array(numIndexValues);\n\n        if (this.m_indexAttribute !== undefined) {\n            const indexAttributeCount = this.m_indexAttribute.count;\n            newIndexArray.set(this.m_indexAttribute.array);\n            this.m_indexAttribute.array = newIndexArray;\n            this.m_indexAttribute.count = indexAttributeCount;\n        } else {\n            this.m_indexAttribute = new THREE.BufferAttribute(\n                newIndexArray,\n                NUM_INDEX_VALUES_PER_VERTEX\n            );\n            this.m_indexAttribute.count = 0;\n            this.m_indexAttribute.setUsage(THREE.DynamicDrawUsage);\n        }\n\n        this.m_size = newSize;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Math2D, MathUtils } from \"@here/harp-utils\";\n\n/**\n * It returns an array containing the channel colors for the pixel at the given coordinates.\n *\n * @param xPos - X value of the pixel.\n * @param yPos - Y value of the pixel.\n * @param image - The image source.\n * @param canvas - Canvas element that will be used to draw the image, in case the imageData is an\n * ImageBitmap\n */\nexport function getPixelFromImage(\n    xPos: number,\n    yPos: number,\n    image: CanvasImageSource | ImageData,\n    canvas?: HTMLCanvasElement\n): Uint8ClampedArray | undefined {\n    if (image instanceof ImageData) {\n        const stride = image.data.length / (image.height * image.width);\n        return getPixelFromImageData(image, xPos, yPos, stride);\n    }\n\n    if (!canvas) {\n        canvas = document.createElement(\"canvas\");\n    }\n    return getPixelFromCanvasImageSource(image, xPos, yPos, canvas);\n}\n\n/**\n * Given the x and y position in screen coordinates inside the target box, it map them to the UV\n * coordinates.\n * @param screenX - X value in screen coordinates.\n * @param screenY - Y value in screen coordinates.\n * @param box - Bounding box in screen coordinates.\n * @param uvBox - Uv box referred to the given bounding box.\n */\nexport function screenToUvCoordinates(\n    screenX: number,\n    screenY: number,\n    box: Math2D.Box,\n    uvBox: Math2D.UvBox\n): { u: number; v: number } {\n    const minX = box.x;\n    const maxX = box.x + box.w;\n    const minY = box.y;\n    const maxY = box.y + box.h;\n    const u = MathUtils.map(screenX, minX, maxX, uvBox.s0, uvBox.s1);\n    const v = MathUtils.map(screenY, minY, maxY, uvBox.t0, uvBox.t1);\n\n    return { u, v };\n}\n\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image - Image source.\n * @param xPos - X value of the pixel.\n * @param yPos - Y value of the pixel.\n * @param canvas - HTML Canvas element on which the image is drawn.\n */\nexport function getPixelFromCanvasImageSource(\n    image: CanvasImageSource,\n    xPos: number,\n    yPos: number,\n    canvas: HTMLCanvasElement\n): Uint8ClampedArray | undefined {\n    const { width, height } = image instanceof SVGImageElement ? image.getBBox() : image;\n\n    if (xPos > width || xPos < 0 || yPos > height || yPos < 0) {\n        return undefined;\n    }\n\n    let pixelData;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    const context = canvas.getContext(\"2d\");\n    if (context !== null) {\n        context.drawImage(image, 0, 0);\n        pixelData = context.getImageData(xPos, yPos, 1, 1).data;\n    }\n    return pixelData;\n}\n\n/**\n * It returns an Uint8ClampedArray containing the color channel values for the given pixel\n * coordinates. It returns undefined if the given coordinates are out of range.\n *\n * @param image - Image data in which the pixels are stored.\n * @param xPos - X value of the pixel.\n * @param yPos - Y value of the pixel.\n * @param stride - The stride value of the image data.\n */\nexport function getPixelFromImageData(\n    imgData: ImageData,\n    xPos: number,\n    yPos: number,\n    stride: number\n): Uint8ClampedArray | undefined {\n    const getPixel = (imageData: ImageData, index: number, strd: number) => {\n        const i = index * strd;\n        const d = imageData.data;\n        const pixel = new Uint8ClampedArray(strd);\n        for (let s = 0; s < strd; s++) {\n            pixel[0] = d[i + s];\n        }\n        return pixel;\n    };\n    if (xPos > imgData.width || xPos < 0 || yPos > imgData.height || yPos < 0) {\n        return undefined;\n    }\n    return getPixel(imgData, yPos * imgData.width + xPos, stride);\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    composeTechniqueTextureName,\n    Env,\n    getPropertyValue,\n    IndexedTechniqueParams,\n    LineMarkerTechnique,\n    MapEnv,\n    PoiTechnique\n} from \"@here/harp-datasource-protocol\";\nimport { assert, LoggerManager } from \"@here/harp-utils\";\n\nimport { ColorCache } from \"../ColorCache\";\nimport { PoiInfo, TextElement } from \"../text/TextElement\";\n\nconst logger = LoggerManager.instance.create(\"PoiBuilder\");\n\nfunction getImageTexture(technique: PoiTechnique | LineMarkerTechnique, env: MapEnv | Env) {\n    return technique.imageTexture !== undefined\n        ? composeTechniqueTextureName(getPropertyValue(technique.imageTexture, env), technique)\n        : undefined;\n}\n\n/**\n * Constructs {@link PoiInfo} objects from {@link @here/harp-datasource-protocol/Technique} and\n * an icon.\n */\nexport class PoiBuilder {\n    private m_iconMinZoomLevel?: number;\n    private m_iconMaxZoomLevel?: number;\n    private m_textMinZoomLevel?: number;\n    private m_textMaxZoomLevel?: number;\n    private m_technique?: (PoiTechnique | LineMarkerTechnique) & IndexedTechniqueParams;\n    private m_imageTextureName?: string;\n    private m_shieldGroupIndex?: number;\n\n    /**\n     * Constructor\n     *\n     * @param m_env - The {@link @link @here/harp-datasource-protocol#MapEnv} used to evaluate\n     * technique properties.\n     */\n    constructor(private readonly m_env: MapEnv | Env) {}\n\n    /**\n     * Sets a technique that will be used to create PoiInfos on subsequent calls to\n     * {@link PoiBuilder.build} until the next call to this method.\n     *\n     * @param technique - The {@link @here/harp-datasource-protocol/Technique}.\n     * @return This builder.\n     */\n    withTechnique(technique: (PoiTechnique | LineMarkerTechnique) & IndexedTechniqueParams): this {\n        this.m_imageTextureName = getImageTexture(technique, this.m_env);\n\n        this.m_iconMinZoomLevel =\n            getPropertyValue(technique.iconMinZoomLevel ?? technique.minZoomLevel, this.m_env) ??\n            undefined;\n        this.m_iconMaxZoomLevel =\n            getPropertyValue(technique.iconMaxZoomLevel ?? technique.maxZoomLevel, this.m_env) ??\n            undefined;\n        this.m_textMinZoomLevel =\n            getPropertyValue(technique.textMinZoomLevel ?? technique.minZoomLevel, this.m_env) ??\n            undefined;\n        this.m_textMaxZoomLevel =\n            getPropertyValue(technique.textMaxZoomLevel ?? technique.maxZoomLevel, this.m_env) ??\n            undefined;\n\n        this.m_technique = technique;\n        return this;\n    }\n\n    /**\n     * Sets an icon that will be used to create PoiInfos on subsequent calls to\n     * {@link PoiBuilder.build} until the next call to this method.\n     *\n     * @param imageTextureName - The name of the icon image. If undefined, the image defined by the\n     * technique set on the last call to {@link PoiBuilder.withTechnique} wil be used.\n     * @param shieldGroupIndex - Index to a shield group if the icon belongs to one.\n     * @return This builder.\n     */\n    withIcon(imageTextureName?: string, shieldGroupIndex?: number): this {\n        if (imageTextureName !== undefined) {\n            this.m_imageTextureName = imageTextureName;\n        }\n        this.m_shieldGroupIndex = shieldGroupIndex;\n        return this;\n    }\n\n    /**\n     * Creates a {@link PoiInfo} for the given {@link TextElement}.\n     *\n     * @param textElement - The text element the poi info will be attached to.\n     * @return The created PoiInfo or undefined if no icon image was set for it.\n     */\n    build(textElement: TextElement): PoiInfo | undefined {\n        assert(this.m_technique !== undefined);\n        const technique = this.m_technique!;\n        const env = this.m_env;\n        const imageTextureName = this.m_imageTextureName;\n\n        // The POI name to be used is taken from the data, since it will\n        // specify the name of the texture to use.\n\n        // The POI name in the technique may override the POI name from the\n        // data.\n        const poiName =\n            technique.poiTable !== undefined ? technique.poiName ?? imageTextureName : undefined;\n\n        if (imageTextureName !== undefined && poiName !== undefined) {\n            logger.warn(\n                \"Possible duplicate POI icon definition via imageTextureName and poiTable!\"\n            );\n        }\n\n        if (imageTextureName === undefined && poiName === undefined) {\n            textElement.minZoomLevel = textElement.minZoomLevel ?? this.m_textMinZoomLevel;\n            textElement.maxZoomLevel = textElement.maxZoomLevel ?? this.m_textMaxZoomLevel;\n\n            return undefined;\n        }\n\n        const textIsOptional = technique.textIsOptional === true;\n        const iconIsOptional = technique.iconIsOptional === true;\n        const renderTextDuringMovements = !(technique.renderTextDuringMovements === false);\n        const iconMayOverlap = technique.iconMayOverlap ?? technique.textMayOverlap;\n\n        const iconReserveSpace = technique.iconReserveSpace ?? technique.textReserveSpace;\n        const iconColorRaw = getPropertyValue(technique.iconColor, env);\n        const iconColor =\n            iconColorRaw !== null ? ColorCache.instance.getColor(iconColorRaw) : undefined;\n\n        const poiInfo = {\n            technique,\n            imageTextureName,\n            poiTableName: technique.poiTable,\n            poiName,\n            shieldGroupIndex: this.m_shieldGroupIndex,\n            textElement,\n            textIsOptional,\n            iconIsOptional,\n            renderTextDuringMovements,\n            mayOverlap: iconMayOverlap,\n            reserveSpace: iconReserveSpace,\n            iconBrightness: technique.iconBrightness,\n            iconColor,\n            iconMinZoomLevel: this.m_iconMinZoomLevel,\n            iconMaxZoomLevel: this.m_iconMaxZoomLevel,\n            textMinZoomLevel: this.m_textMinZoomLevel,\n            textMaxZoomLevel: this.m_textMaxZoomLevel\n        };\n\n        return poiInfo;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    AttributeMap,\n    composeTechniqueTextureName,\n    DecodedTile,\n    ImageTexture,\n    IndexedTechnique,\n    isLineMarkerTechnique,\n    isPoiTechnique,\n    MapEnv,\n    PoiGeometry\n} from \"@here/harp-datasource-protocol\";\nimport { assert, assertExists, LoggerManager } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { MapView } from \"../MapView\";\nimport { TextElement } from \"../text/TextElement\";\nimport { TextElementBuilder } from \"../text/TextElementBuilder\";\nimport { Tile } from \"../Tile\";\nimport { PoiTable } from \"./PoiTableManager\";\n\nconst logger = LoggerManager.instance.create(\"PoiManager\");\n\n/**\n * Interface for the {@link @here/harp-datasource-protocol#ImageTexture}s\n * that are defined in the atlas.\n */\ninterface ImageTextureDef {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    pixelRatio?: number;\n}\n\nfunction getImageTexture(poiGeometry: PoiGeometry, index: number = 0): string | undefined {\n    if (poiGeometry.imageTextures) {\n        const textureNameIndex = poiGeometry.imageTextures[index];\n        if (textureNameIndex >= 0) {\n            assert(poiGeometry.imageTextures.length > index);\n            return poiGeometry.stringCatalog[textureNameIndex];\n        }\n    }\n    return undefined;\n}\n\nfunction getAttributes(poiGeometry: PoiGeometry, index: number = 0): AttributeMap | undefined {\n    return poiGeometry.objInfos ? poiGeometry.objInfos[index] : undefined;\n}\n\nfunction getPosition(\n    positionAttribute: THREE.BufferAttribute,\n    worldOffsetX: number,\n    index: number = 0\n): THREE.Vector3 {\n    const position = new THREE.Vector3().fromBufferAttribute(positionAttribute, index);\n    position.x += worldOffsetX;\n    return position;\n}\n\nfunction getText(poiGeometry: PoiGeometry, index: number = 0): string {\n    assert(poiGeometry.texts.length > index);\n    const stringIndex = poiGeometry.texts[index];\n    assert(poiGeometry.stringCatalog.length > stringIndex);\n    return poiGeometry.stringCatalog[stringIndex] ?? \"\";\n}\n\n/**\n * POI manager class, responsible for loading the\n * {@link @here/harp-datasource-protocol#PoiGeometry} objects\n * from the {@link @here/harp-datasource-protocol#DecodedTile},\n * and preparing them for rendering.\n *\n * @remarks\n * Also loads and manages the texture atlases for the icons.\n */\nexport class PoiManager {\n    // Keep track of the missing POI table names, but only warn once.\n    private static readonly m_missingPoiTableName: Map<string, boolean> = new Map();\n    private static readonly m_missingPoiName: Map<string, boolean> = new Map();\n\n    /**\n     * Warn about a missing POI table name, but only once.\n     * @param poiTableName - POI mapping table name.\n     * @param poiTable - POI table instance.\n     */\n    private static notifyMissingPoiTable(\n        poiTableName: string,\n        poiTable: PoiTable | undefined\n    ): void {\n        if (poiTableName === undefined) {\n            poiTableName = \"undefined\";\n        }\n        if (PoiManager.m_missingPoiTableName.get(poiTableName) === undefined) {\n            PoiManager.m_missingPoiTableName.set(poiTableName, true);\n            if (poiTable !== undefined && !poiTable.loadedOk) {\n                logger.error(`updatePoiFromPoiTable: Could not load POI table '${poiTableName}'!`);\n            } else {\n                logger.error(\n                    `updatePoiFromPoiTable: No POI table with name '${poiTableName}' found!`\n                );\n            }\n        }\n    }\n\n    /**\n     * Warn about a missing POI name, but only once.\n     * @param poiName - name of POI.\n     * @param poiTableName - POI mapping table name.\n     */\n    private static notifyMissingPoi(poiName: string, poiTableName: string): void {\n        if (poiName === undefined) {\n            poiName = \"undefined\";\n        }\n        const key: string = `${poiTableName}[${poiName}]`;\n        if (PoiManager.m_missingPoiName.get(key) === undefined) {\n            PoiManager.m_missingPoiName.set(key, true);\n            logger.warn(\n                `updatePoiFromPoiTable: ` +\n                    `Cannot find POI info for '${poiName}' in table '${poiTableName}'.`\n            );\n        }\n    }\n\n    private readonly m_imageTextures: Map<string, ImageTexture> = new Map();\n    private readonly m_poiShieldGroups: Map<string, number> = new Map();\n\n    /**\n     * The constructor of the `PoiManager`.\n     *\n     * @param mapView - The {@link MapView} instance that should display the POIs.\n     */\n    constructor(readonly mapView: MapView) {}\n\n    /**\n     * Add all POIs from a decoded tile and store them as {@link TextElement}s in the {@link Tile}.\n     *\n     * Also handles LineMarkers, which is a recurring marker along a line (road).\n     *\n     * @param tile - Tile to add POIs to.\n     * @param decodedTile - DecodedTile containing the raw\n     *                      {@link @here/harp-datasource-protocol#PoiGeometry}\n     *                      objects describing the POIs.\n     */\n    addPois(tile: Tile, decodedTile: DecodedTile): void {\n        const poiGeometries = assertExists(decodedTile.poiGeometries);\n        const worldOffsetX = tile.computeWorldOffsetX();\n\n        const mapView = tile.mapView;\n        const discreteZoomLevel = Math.floor(mapView.zoomLevel);\n        const intZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n        const poiBuilder = new TextElementBuilder(\n            intZoomEnv,\n            tile.textStyleCache,\n            tile.dataSource.dataSourceOrder\n        );\n\n        for (const poiGeometry of poiGeometries) {\n            assert(poiGeometry.technique !== undefined);\n            const techniqueIndex = assertExists(poiGeometry.technique);\n            const technique = decodedTile.techniques[techniqueIndex] as IndexedTechnique;\n\n            if (\n                technique._kindState === false ||\n                (!isLineMarkerTechnique(technique) && !isPoiTechnique(technique))\n            ) {\n                continue;\n            }\n\n            if (technique.showOnMap === false) {\n                continue;\n            }\n\n            const positions = new THREE.BufferAttribute(\n                new Float64Array(poiGeometry.positions.buffer),\n                poiGeometry.positions.itemCount\n            );\n\n            poiBuilder.withTechnique(technique);\n\n            if (isLineMarkerTechnique(technique) && positions.count > 0) {\n                this.addLineMarker(poiBuilder, tile, poiGeometry, positions, worldOffsetX);\n            } else if (isPoiTechnique(technique)) {\n                this.addPoi(poiBuilder, tile, poiGeometry, positions, worldOffsetX);\n            }\n        }\n    }\n\n    /**\n     * Load the texture atlas that defines the segments of the texture that should be used for\n     * specific icons.\n     *\n     * @remarks\n     * Creates an {@link @here/harp-datasource-protocol#ImageTexture}\n     * for every element in the atlas, such that it can\n     * be addressed in the theme file.\n     *\n     * @param imageName - Name of the image from the theme (NOT the url!).\n     * @param atlas - URL of the JSON file defining the texture atlas.\n     * @param abortSignal - Signal to Abort the loading of the Atlas Image\n     */\n    async addTextureAtlas(imageName: string, atlas: string, abortSignal?: AbortSignal) {\n        const response = await fetch(atlas, { signal: abortSignal });\n        if (!response.ok) {\n            throw new Error(`addTextureAtlas: Cannot load textureAtlas: ${response.statusText}`);\n        }\n        try {\n            const jsonAtlas: any | undefined = await response.json();\n\n            if (jsonAtlas === undefined) {\n                logger.info(`addTextureAtlas: TextureAtlas empty: ${atlas}`);\n                return;\n            }\n\n            logger.debug(\n                `addTextureAtlas: Loading textureAtlas '${atlas}' for image '${imageName}'`\n            );\n            for (const textureName of Object.getOwnPropertyNames(jsonAtlas)) {\n                const imageTextureDef = jsonAtlas[textureName] as ImageTextureDef;\n\n                const imageTexture: ImageTexture = {\n                    name: textureName,\n                    image: imageName,\n                    xOffset: imageTextureDef.x,\n                    yOffset: imageTextureDef.y,\n                    width: imageTextureDef.width,\n                    height: imageTextureDef.height\n                };\n\n                this.addImageTexture(imageTexture);\n            }\n            this.mapView.update();\n        } catch (error) {\n            logger.error(`addTextureAtlas: Failed to load textureAtlas '${atlas}' : ${error}`);\n        }\n    }\n\n    /**\n     * Add an {@link @here/harp-datasource-protocol#ImageTexture} such that it\n     * is available as a named entity for techniques in theme files.\n     *\n     * @param imageTexture - {@link @here/harp-datasource-protocol#ImageTexture}\n     *                       that should be available for POIs.\n     */\n    addImageTexture(imageTexture: ImageTexture) {\n        if (imageTexture.name === undefined) {\n            logger.error(\"addImageTexture: Name required\", imageTexture);\n            return;\n        }\n        if (this.m_imageTextures.get(imageTexture.name) !== undefined) {\n            logger.warn(\n                `addImageTexture: Name already used: ${imageTexture.name}` + ` (overriding it)`\n            );\n        }\n\n        this.m_imageTextures.set(imageTexture.name, imageTexture);\n    }\n\n    /**\n     * Return the {@link @here/harp-datasource-protocol#ImageTexture}\n     * registered under the specified name.\n     *\n     * @param name - Name of the {@link @here/harp-datasource-protocol#ImageTexture}.\n     */\n    getImageTexture(name: string): ImageTexture | undefined {\n        return this.m_imageTextures.get(name);\n    }\n\n    /**\n     * Update the {@link TextElement} with the information taken from the {@link PoiTable} which is\n     * referenced in the {@link PoiInfo} of the pointLabel.\n     *\n     * If the requested {@link PoiTable} is not available yet, the function returns `false`.\n     * If the {@link PoiTable} is not defined, or if the references POI has no entry in\n     * the {@link PoiTable}, no action is taken, and the function returns `false`.\n     *\n     * If the {@link PoiTable} has been processed, it returns `true`, indicating that this function\n     * doesn't have to be called again.\n     *\n     * @param pointLabel - The {@link TextElement} to update.\n     *\n     * @returns `true` if the {@link PoiTable} has been processed, and the\n     *          function does not have to be called again.\n     */\n    updatePoiFromPoiTable(pointLabel: TextElement): boolean {\n        const poiInfo = pointLabel.poiInfo;\n        // PoiTable requires poiName to be defined otherwise mapping via PoiTable is\n        // not possible, such as table key is not defined.\n        if (!poiInfo || poiInfo.poiTableName === undefined || poiInfo.poiName === undefined) {\n            return true;\n        }\n\n        // Try to acquire PoiTable\n        const poiTableName = poiInfo.poiTableName;\n        const poiTable = this.mapView.poiTableManager.getPoiTable(poiTableName);\n\n        // Check if PoiTable is found, but its still loading.\n        if (poiTable && poiTable.isLoading) {\n            // The PoiTable is still loading, we have to try again.\n            return false;\n        }\n\n        // Remove poiTableName to mark this POI as processed.\n        poiInfo.poiTableName = undefined;\n\n        // PoiTable not found or can not be loaded.\n        if (!poiTable || !poiTable.loadedOk) {\n            PoiManager.notifyMissingPoiTable(poiTableName, poiTable);\n            return true;\n        }\n\n        // Try to acquire PoiTableEntry.\n        const poiName = poiInfo.poiName;\n        const poiTableEntry = poiTable.getEntry(poiName);\n        if (!poiTableEntry) {\n            PoiManager.notifyMissingPoi(poiName, poiTableName);\n            return true;\n        }\n\n        if (poiTableEntry.iconName !== undefined && poiTableEntry.iconName.length > 0) {\n            poiInfo.imageTextureName = composeTechniqueTextureName(\n                poiTableEntry.iconName,\n                poiInfo.technique\n            );\n        }\n\n        pointLabel.visible = poiTableEntry.visible ?? pointLabel.visible;\n        pointLabel.priority = poiTableEntry.priority ?? pointLabel.priority;\n        poiInfo.iconMinZoomLevel = poiTableEntry.iconMinLevel ?? poiInfo.iconMinZoomLevel;\n        poiInfo.iconMaxZoomLevel = poiTableEntry.iconMaxLevel ?? poiInfo.iconMaxZoomLevel;\n        poiInfo.textMinZoomLevel = poiTableEntry.textMinLevel ?? poiInfo.textMinZoomLevel;\n        poiInfo.textMaxZoomLevel = poiTableEntry.textMaxLevel ?? poiInfo.textMaxZoomLevel;\n\n        TextElementBuilder.alignZoomLevelRanges(pointLabel);\n\n        return true;\n    }\n\n    /**\n     * Clear internal state. Applicable when switching themes.\n     */\n    clear() {\n        this.m_imageTextures.clear();\n        this.m_poiShieldGroups.clear();\n    }\n\n    /**\n     * Add the LineMarker as a POI with multiple positions sharing the same `shieldGroupIndex`.\n     */\n    private addLineMarker(\n        poiBuilder: TextElementBuilder,\n        tile: Tile,\n        poiGeometry: PoiGeometry,\n        positions: THREE.BufferAttribute,\n        worldOffsetX: number\n    ) {\n        const text = getText(poiGeometry);\n        const imageTextureName = getImageTexture(poiGeometry);\n\n        // let the combined image texture name (name of image in atlas, not the URL) and\n        // text of the shield be the group key, at worst scenario it may be: \"undefined-\"\n        const groupKey = imageTextureName + \"-\" + text;\n        let shieldGroupIndex = this.m_poiShieldGroups.get(groupKey);\n        if (shieldGroupIndex === undefined) {\n            shieldGroupIndex = this.m_poiShieldGroups.size;\n            this.m_poiShieldGroups.set(groupKey, shieldGroupIndex);\n        }\n\n        const positionArray: THREE.Vector3[] = [];\n        for (let i = 0; i < positions.count; i += 3) {\n            positionArray.push(getPosition(positions, worldOffsetX, i));\n        }\n        const textElement = poiBuilder\n            .withIcon(imageTextureName, shieldGroupIndex)\n            .build(\n                text,\n                positionArray,\n                tile.offset,\n                tile.dataSource.name,\n                tile.dataSource.dataSourceOrder,\n                getAttributes(poiGeometry)\n            );\n\n        tile.addTextElement(textElement);\n    }\n\n    /**\n     * Create and add POI {@link TextElement}s to tile with a series of positions.\n     */\n    private addPoi(\n        poiBuilder: TextElementBuilder,\n        tile: Tile,\n        poiGeometry: PoiGeometry,\n        positions: THREE.BufferAttribute,\n        worldOffsetX: number\n    ) {\n        for (let i = 0; i < positions.count; ++i) {\n            const offsetDirection = poiGeometry.offsetDirections?.[i] ?? 0;\n\n            const textElement = poiBuilder\n                .withIcon(getImageTexture(poiGeometry, i))\n                .build(\n                    getText(poiGeometry, i),\n                    getPosition(positions, worldOffsetX, i),\n                    tile.offset,\n                    tile.dataSource.name,\n                    tile.dataSource.dataSourceOrder,\n                    getAttributes(poiGeometry, i),\n                    undefined,\n                    offsetDirection\n                );\n\n            tile.addTextElement(textElement);\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Env, getPropertyValue, ImageTexture } from \"@here/harp-datasource-protocol\";\nimport { IconMaterial } from \"@here/harp-materials\";\nimport { MemoryUsage } from \"@here/harp-text-canvas\";\nimport { assert, LoggerManager, Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { ImageItem } from \"../image/Image\";\nimport { MapViewImageCache } from \"../image/MapViewImageCache\";\nimport { MipMapGenerator } from \"../image/MipMapGenerator\";\nimport { ScreenCollisions } from \"../ScreenCollisions\";\nimport { PoiInfo, TextElement } from \"../text/TextElement\";\nimport { BoxBuffer } from \"./BoxBuffer\";\nimport { PoiManager } from \"./PoiManager\";\n\nconst logger = LoggerManager.instance.create(\"PoiRenderer\");\n\n/**\n * Neutral color used as `vColor` attribute of [[IconMaterial]] if no `iconColor` color was\n * specified.\n */\nconst neutralColor = new THREE.Color(1, 1, 1);\n\n/**\n * Temporary color instance used by `addPoi` to pass color derived from `iconBrightness` property.\n */\nconst tmpIconColor = new THREE.Color();\n\nexport interface PoiLayer {\n    id: number;\n    scene: THREE.Scene;\n}\n\n/**\n * @internal\n * Buffer for POIs sharing same material and render order, renderable in a single draw call\n * (WebGL limits apply, see {@link BoxBuffer}).\n */\nexport class PoiBuffer {\n    private m_refCount: number = 0;\n\n    /**\n     * Creates a `PoiBuffer`\n     * @param buffer -\n     * @param layer - The {@link TextCanvas} layer used to render the POIs.\n     */\n    constructor(\n        readonly buffer: BoxBuffer,\n        readonly layer: PoiLayer,\n        private readonly m_onDispose: () => void\n    ) {}\n\n    /**\n     * Increases this `PoiBuffer`'s reference count.\n     * @returns this `PoiBuffer`.\n     */\n    increaseRefCount(): PoiBuffer {\n        ++this.m_refCount;\n        return this;\n    }\n\n    /**\n     * Decreases this `PoiBuffer`'s reference count. All resources will be disposed when the\n     * reference count reaches 0.\n     * @returns this `PoiBuffer`.\n     */\n    decreaseRefCount(): PoiBuffer {\n        assert(this.m_refCount > 0);\n\n        if (--this.m_refCount === 0) {\n            this.dispose();\n        }\n        return this;\n    }\n\n    private dispose() {\n        this.layer.scene.remove(this.buffer.mesh);\n        this.buffer.dispose();\n        this.m_onDispose();\n    }\n}\n\n/**\n * @internal\n *\n * The `PoiBatch` contains the geometry and the material for all POIs that share the same icon image\n * ({@link @here/harp-datasource-protocol#ImageTexture}).\n *\n * There is a `PoiBatch` for every icon in a texture atlas, since the size of the icon in the atlas\n * as well as the texture coordinates are specified in the `PoiBatch`.\n */\nclass PoiBatch {\n    // Enable trilinear filtering to reduce flickering due to distance scaling\n    static readonly trilinear: boolean = true;\n\n    // Map of buffers and their corresponding canvas layers, with render order as key.\n    private readonly m_poiBuffers: Map<number, PoiBuffer>;\n\n    private readonly m_material: IconMaterial;\n\n    /**\n     * Create the `PoiBatch`.\n     *\n     * @param m_rendererCapabilities - The {@link THREE.WebGLCapabilities} used for material\n     * creation.\n     * @param imageItem - The icon that will have his material shared.\n     * @param m_onDispose - Callback executed when the `PoiBatch` is disposed.\n     */\n    constructor(\n        private readonly m_rendererCapabilities: THREE.WebGLCapabilities,\n        readonly imageItem: ImageItem,\n        private readonly m_onDispose: () => void\n    ) {\n        // Texture images should be generated with premultiplied alpha\n        const premultipliedAlpha = true;\n\n        const texture = new THREE.Texture(\n            this.imageItem.image as any,\n            THREE.UVMapping,\n            undefined,\n            undefined,\n            PoiBatch.trilinear ? THREE.LinearFilter : THREE.LinearFilter,\n            PoiBatch.trilinear ? THREE.LinearMipMapLinearFilter : THREE.LinearFilter,\n            THREE.RGBAFormat\n        );\n        if (PoiBatch.trilinear && this.imageItem.mipMaps) {\n            // Generate mipmaps for distance scaling of icon\n            texture.mipmaps = this.imageItem.mipMaps;\n            texture.image = texture.mipmaps[0];\n        }\n        texture.flipY = false;\n        texture.premultiplyAlpha = premultipliedAlpha;\n        texture.needsUpdate = true;\n\n        this.m_material = new IconMaterial({\n            rendererCapabilities: this.m_rendererCapabilities,\n            map: texture\n        });\n\n        this.m_poiBuffers = new Map();\n    }\n\n    /**\n     * Gets the {@link PoiBuffer} for a given layer, creating it if necessary.\n     * @param layer - The {@link PoiLayer} to be used.\n     * @returns The {@link PoiBuffer}.\n     */\n    getBuffer(layer: PoiLayer): PoiBuffer {\n        let poiBuffer = this.m_poiBuffers.get(layer.id);\n        if (poiBuffer) {\n            return poiBuffer.increaseRefCount();\n        }\n        const boxBuffer = new BoxBuffer(this.m_material, layer.id);\n        const mesh = boxBuffer.mesh;\n        mesh.frustumCulled = false;\n\n        layer.scene.add(mesh);\n\n        poiBuffer = new PoiBuffer(boxBuffer, layer, () => {\n            this.disposeBuffer(layer.id);\n        });\n        this.m_poiBuffers.set(layer.id, poiBuffer);\n\n        return poiBuffer.increaseRefCount();\n    }\n\n    /**\n     * Clean the `PoiBatch`, remove all icon boxes. Called before starting a new frame.\n     */\n    reset(): void {\n        for (const poiBuffer of this.m_poiBuffers.values()) {\n            poiBuffer.buffer.reset();\n        }\n    }\n\n    /**\n     * Update the geometry with all the added boxes during the frame.\n     */\n    update(): void {\n        for (const poiBuffer of this.m_poiBuffers.values()) {\n            poiBuffer.buffer.updateBufferGeometry();\n        }\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * boxes are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     * @param image - Image to test if the pixel is transparent\n     */\n    pickBoxes(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void,\n        image?: CanvasImageSource | ImageData\n    ) {\n        for (const poiBuffer of this.m_poiBuffers.values()) {\n            poiBuffer.buffer.pickBoxes(screenPosition, pickCallback, image);\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiBatch`.\n     *\n     * @param info - The info object to increment with the values from this `PoiBatch`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        if (this.imageItem.image !== undefined) {\n            const imageBytes = this.imageItem.image.width * this.imageItem.image.height * 4;\n            info.heapSize += imageBytes;\n            info.gpuSize += imageBytes;\n        }\n        for (const poiBuffer of this.m_poiBuffers.values()) {\n            poiBuffer.buffer.updateMemoryUsage(info);\n        }\n    }\n\n    private dispose() {\n        this.m_poiBuffers.clear();\n        this.m_material.map.dispose();\n        this.m_material.dispose();\n        this.m_onDispose();\n    }\n\n    private disposeBuffer(renderOrder: number) {\n        assert(this.m_poiBuffers.size > 0);\n\n        this.m_poiBuffers.delete(renderOrder);\n        if (this.m_poiBuffers.size === 0) {\n            this.dispose();\n        }\n    }\n}\n\n/**\n * @internal\n * Contains all [[PoiBatch]]es. Selects (and initializes) the correct batch for a POI.\n */\nexport class PoiBatchRegistry {\n    private readonly m_batchMap: Map<string, PoiBatch> = new Map();\n\n    /**\n     * Create the `PoiBatchRegistry`.\n     *\n     * @param m_rendererCapabilities - The {@link THREE.WebGLCapabilities} to be used.\n     */\n    constructor(private readonly m_rendererCapabilities: THREE.WebGLCapabilities) {}\n\n    /**\n     * Register the POI and prepare the [[PoiBatch]] for the POI at first usage.\n     *\n     * @param poiInfo - Describes the POI icon.\n     * @param layer - The {@link PoiLayer} to render to.\n     */\n    registerPoi(poiInfo: PoiInfo, layer: PoiLayer): PoiBuffer | undefined {\n        const { imageItem, imageTexture } = poiInfo;\n\n        if (!imageItem) {\n            // No image found, therefore just return undefined. It will probably come in soon?\n            return undefined;\n        }\n\n        // There is a batch for every ImageDefinition, which could be a texture atlas with many\n        // ImageTextures in it. If the imageTexture is not set, imageTextureName has the actual\n        // image name.\n        assert(poiInfo.imageTextureName !== undefined);\n        const batchKey = imageTexture?.image ?? poiInfo.imageTextureName!;\n        let batch = this.m_batchMap.get(batchKey);\n\n        if (batch === undefined) {\n            batch = new PoiBatch(this.m_rendererCapabilities, imageItem, () => {\n                this.deleteBatch(batchKey);\n            });\n            this.m_batchMap.set(batchKey, batch);\n        }\n\n        return batch.getBuffer(layer);\n    }\n\n    /**\n     * Render a POI image at the specified location.\n     *\n     * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n     * @param screenBox - Box to render icon into in 2D coordinates.\n     * @param viewDistance - Box's distance to camera.\n     * @param opacity - Opacity of icon to allow fade in/out.\n     */\n    addPoi(poiInfo: PoiInfo, screenBox: Math2D.Box, viewDistance: number, opacity: number) {\n        if (poiInfo.isValid === false || !poiInfo.buffer) {\n            logger.warn(\n                \"PoiBatchRegistry: trying to add poiInfo without buffer prepared: \",\n                poiInfo.poiName\n            );\n            return;\n        }\n        assert(poiInfo.uvBox !== undefined);\n\n        let color: THREE.Color;\n        if (poiInfo.iconBrightness !== undefined) {\n            color = tmpIconColor.setScalar(poiInfo.iconBrightness);\n            if (poiInfo.iconColor !== undefined) {\n                color = tmpIconColor.multiply(poiInfo.iconColor);\n            }\n        } else if (poiInfo.iconColor !== undefined) {\n            color = poiInfo.iconColor;\n        } else {\n            color = neutralColor;\n        }\n        poiInfo.buffer.buffer.addBox(\n            screenBox,\n            poiInfo.uvBox!,\n            color,\n            opacity,\n            viewDistance,\n            poiInfo.textElement\n        );\n    }\n\n    /**\n     * Reset all batches, removing all content from the [[PoiBatch]]es. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset(): void {\n        for (const batch of this.m_batchMap.values()) {\n            batch.reset();\n        }\n    }\n\n    /**\n     * Update the geometry of all [[PoiBatch]]es. Called before rendering.\n     */\n    update(): void {\n        for (const batch of this.m_batchMap.values()) {\n            batch.update();\n        }\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * {@link PoiInfo}s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pickTextElements(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void\n    ) {\n        for (const batch of this.m_batchMap.values()) {\n            batch.pickBoxes(screenPosition, pickCallback, batch.imageItem.image);\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiBatchRegistry`.\n     *\n     * @param info - The info object to increment with the values from this `PoiBatchRegistry`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        for (const batch of this.m_batchMap.values()) {\n            batch.updateMemoryUsage(info);\n        }\n    }\n\n    private deleteBatch(batchKey: string) {\n        this.m_batchMap.delete(batchKey);\n    }\n}\n\n// keep track of the missing textures, we throw an error if the number of attempts goes over some\n// threshold.\nconst missingTextureName: Map<string, number> = new Map();\nconst SEARCH_CACHE_ATTEMPTS = 5;\n\nfunction findImageItem(\n    poiInfo: PoiInfo,\n    imageCaches: MapViewImageCache[],\n    imageTexture?: ImageTexture\n): ImageItem | undefined {\n    assert(poiInfo.imageTextureName !== undefined);\n    const imageTextureName = imageTexture ? imageTexture.image : poiInfo.imageTextureName!;\n\n    for (const imageCache of imageCaches) {\n        const imageItem = imageCache.findImageByName(imageTextureName);\n        if (imageItem) {\n            missingTextureName.delete(imageTextureName);\n            return imageItem;\n        }\n    }\n\n    // There is a texture missing in the cache, we attempt again, and then error out.\n    const missingTextureCount = missingTextureName.get(imageTextureName);\n    missingTextureName.set(imageTextureName, missingTextureCount ? missingTextureCount + 1 : 0);\n    if (missingTextureName.get(imageTextureName)! === SEARCH_CACHE_ATTEMPTS) {\n        logger.error(`PoiRenderer::findImageItem: No imageItem found with name:\n            '${imageTexture?.image ?? imageTextureName}'\n            after ${SEARCH_CACHE_ATTEMPTS} attempts.`);\n    }\n    return undefined;\n}\n\n/**\n * @internal\n * Manage POI rendering. Uses a [[PoiBatchRegistry]] to actually create the geometry that is being\n * rendered.\n */\nexport class PoiRenderer {\n    /**\n     * Compute screen box for icon. It is required that `prepareRender` has been successfully called\n     * before `computeScreenBox` may be called.\n     *\n     * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition - Position on screen (2D).\n     * @param scale - Scale to apply to icon.\n     * @param env - Current zoom level.\n     * @param screenBox - Box that will be used to store the result.\n     * @returns The computed screen box for the icon.\n     */\n    static computeIconScreenBox(\n        poiInfo: PoiInfo,\n        screenPosition: THREE.Vector2,\n        scale: number,\n        env: Env,\n        /* out */ screenBox: Math2D.Box = new Math2D.Box()\n    ): Math2D.Box {\n        assert(poiInfo.buffer !== undefined);\n\n        const width = poiInfo.computedWidth! * scale;\n        const height = poiInfo.computedHeight! * scale;\n        const technique = poiInfo.technique;\n        const iconXOffset = getPropertyValue(technique.iconXOffset, env);\n        const iconYOffset = getPropertyValue(technique.iconYOffset, env);\n\n        const centerX =\n            screenPosition.x + (typeof iconXOffset === \"number\" ? iconXOffset : 0) * scale;\n        const centerY =\n            screenPosition.y + (typeof iconYOffset === \"number\" ? iconYOffset : 0) * scale;\n\n        screenBox.x = centerX - width / 2;\n        screenBox.y = centerY - height / 2;\n        screenBox.w = width;\n        screenBox.h = height;\n\n        return screenBox;\n    }\n\n    // the render buffer containing all batches, one batch per texture/material.\n    private readonly m_poiBatchRegistry: PoiBatchRegistry;\n\n    // temporary variable to save allocations\n    private readonly m_tempScreenBox = new Math2D.Box();\n\n    private readonly m_layers: PoiLayer[] = [];\n\n    /**\n     * Create the `PoiRenderer` for the specified {@link MapView}.\n     *\n     * @param m_renderer - The {@link THREE.WebGLRenderer} to be rendered to.\n     * @param m_poiManager - The {@link PoiManager} to be used.\n     * @param m_imageCaches - The {@link ImageCache}s to look for loaded images.\n     */\n    constructor(\n        private readonly m_renderer: THREE.WebGLRenderer,\n        private readonly m_poiManager: PoiManager,\n        private readonly m_imageCaches: MapViewImageCache[]\n    ) {\n        this.m_poiBatchRegistry = new PoiBatchRegistry(this.renderer.capabilities);\n    }\n\n    get renderer(): THREE.WebGLRenderer {\n        return this.m_renderer;\n    }\n\n    /**\n     * Prepare the POI for rendering, and determine which {@link PoiBuffer} should be used. If a\n     * {@link PoiBuffer} is assigned, the POI is ready to be rendered.\n     *\n     * @param pointLabel - TextElement with PoiInfo for rendering the POI icon.\n     * @param env - TODO! The current zoomLevel level of {@link MapView}\n     *\n     * @returns `True` if the space is not already allocated by another object (text label or POI)\n     */\n    prepareRender(pointLabel: TextElement, env: Env): boolean {\n        const poiInfo = pointLabel.poiInfo;\n        if (poiInfo === undefined) {\n            return false;\n        }\n        if (poiInfo.buffer === undefined) {\n            this.preparePoi(pointLabel, env);\n        }\n        return poiInfo.buffer !== undefined;\n    }\n\n    /**\n     * Reset all batches, removing all content from the [[PoiBatchRegistry]]. Called at the\n     * beginning of a frame before the POIs are placed.\n     */\n    reset(): void {\n        this.m_poiBatchRegistry.reset();\n    }\n\n    /**\n     * Add the icon. Icon will only be added if opacity > 0, otherwise only its space will be\n     * allocated.\n     *\n     * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n     * @param screenPosition - Position on screen (2D):\n     * @param screenCollisions - Object handling the collision checks for screen-aligned 2D boxes.\n     * @param viewDistance - Box's distance to camera.\n     * @param scale - Scaling factor to apply to text and icon.\n     * @param allocateScreenSpace - If `true` screen space will be allocated for the icon.\n     * @param opacity - Opacity of icon to allow fade in/out.\n     * @returns - `true` if icon has been actually rendered, `false` otherwise.\n     */\n    addPoi(\n        poiInfo: PoiInfo,\n        screenPosition: THREE.Vector2,\n        screenCollisions: ScreenCollisions,\n        viewDistance: number,\n        scale: number,\n        allocateScreenSpace: boolean,\n        opacity: number,\n        env: Env\n    ): void {\n        assert(poiInfo.buffer !== undefined);\n\n        PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, env, this.m_tempScreenBox);\n\n        if (allocateScreenSpace) {\n            screenCollisions.allocate(this.m_tempScreenBox);\n        }\n\n        if (opacity > 0) {\n            if (!poiInfo.buffer) {\n                this.preparePoi(poiInfo.textElement, env);\n            }\n            this.m_poiBatchRegistry.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);\n        }\n    }\n\n    /**\n     * Update the geometry of all [[PoiBatch]]es. Called before rendering.\n     */\n    update(): void {\n        this.m_poiBatchRegistry.update();\n    }\n\n    /**\n     * @internal\n     *\n     * Adds a layer to the PoiRenderer\n     * @param layerId\n     */\n    addLayer(layerId: number): PoiLayer {\n        let result = this.getLayer(layerId);\n        if (result === undefined) {\n            result = {\n                id: layerId,\n                scene: new THREE.Scene()\n            };\n\n            this.m_layers.push(result);\n            this.m_layers.sort((a: PoiLayer, b: PoiLayer) => {\n                return a.id - b.id;\n            });\n        }\n        return result;\n    }\n\n    /**\n     * Retrieves a specific `Poi` rendering layer.\n     *\n     * @param layerId - Desired layer identifier.\n     *\n     * @returns Selected {@link PoiLayer}\n     */\n    private getLayer(layerId: number): PoiLayer | undefined {\n        return this.m_layers.find(layer => layer.id === layerId);\n    }\n\n    /**\n     * @internal\n     *\n     * Returns all {@link PoiLayer}s of this {@link PoiRenderer}\n     */\n    get layers(): PoiLayer[] {\n        return this.m_layers;\n    }\n\n    /**\n     * Renders the content of this `PoiRenderer`.\n     *\n     * @param camera - Orthographic camera.\n     * @param layer - The Layer to be rendered.\n     */\n    render(camera: THREE.OrthographicCamera, layer: PoiLayer) {\n        this.m_renderer.render(layer.scene, camera);\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * {@link PoiInfo}s are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pickTextElements(\n        screenPosition: THREE.Vector2,\n        pickCallback: (pickData: any | undefined) => void\n    ) {\n        this.m_poiBatchRegistry.pickTextElements(screenPosition, pickCallback);\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.\n     *\n     * @param info - The info object to increment with the values from this `PoiRenderer`.\n     */\n    getMemoryUsage(info: MemoryUsage) {\n        this.m_poiBatchRegistry.updateMemoryUsage(info);\n    }\n\n    /**\n     * Register the POI at the [[PoiBatchRegistry]] which may require some setup, for example\n     * loading of the actual image.\n     */\n    private preparePoi(pointLabel: TextElement, env: Env): void {\n        const poiInfo = pointLabel.poiInfo;\n        if (!poiInfo || !pointLabel.visible) {\n            return;\n        }\n\n        if (poiInfo.buffer !== undefined || poiInfo.isValid === false) {\n            // Already set up, nothing to be done here.\n            return;\n        }\n\n        if (poiInfo.poiTableName !== undefined) {\n            if (this.m_poiManager.updatePoiFromPoiTable(pointLabel)) {\n                if (!pointLabel.visible) {\n                    // PoiTable set this POI to not visible.\n                    return;\n                }\n            } else {\n                // PoiTable has not been loaded, but is required to determine visibility.\n                return;\n            }\n        }\n\n        const imageTextureName = poiInfo.imageTextureName;\n        if (imageTextureName === undefined) {\n            poiInfo.isValid = false;\n            return;\n        }\n\n        const imageTexture = this.m_poiManager.getImageTexture(imageTextureName);\n        const imageItem = findImageItem(poiInfo, this.m_imageCaches, imageTexture);\n        if (!imageItem) {\n            poiInfo.imageItem = null;\n            return;\n        }\n\n        if (imageItem.loaded) {\n            this.setupPoiInfo(poiInfo, imageItem, env, imageTexture);\n            return;\n        }\n\n        if (imageItem.loading) {\n            // already being loaded, will be rendered once available\n            return;\n        }\n\n        imageItem\n            .loadImage()\n            .then(loadedImageItem => {\n                // Skip setup if image was not loaded (cancelled).\n                if (loadedImageItem?.image) {\n                    this.setupPoiInfo(poiInfo, loadedImageItem, env, imageTexture);\n                }\n            })\n            .catch(error => {\n                logger.error(`preparePoi: Failed to load imageItem: '${imageItem.url}`, error);\n                poiInfo.isValid = false;\n            });\n    }\n\n    /**\n     * Setup texture and material for the batch.\n     *\n     * @param poiInfo - {@link PoiInfo} to initialize.\n     * @param imageTexture - Shared {@link @here/harp-datasource-protocol#ImageTexture},\n     *                       defines used area in atlas.\n     * @param imageItem - Shared {@link ImageItem}, contains cached image for texture.\n     * @param env - The current zoom level of {@link MapView}\n     */\n    private setupPoiInfo(\n        poiInfo: PoiInfo,\n        imageItem: ImageItem,\n        env: Env,\n        imageTexture?: ImageTexture\n    ) {\n        assert(poiInfo.uvBox === undefined);\n\n        if (!imageItem.image) {\n            logger.error(\"setupPoiInfo: No imageItem/imageData found\");\n            poiInfo.isValid = false;\n            return;\n        }\n\n        const technique = poiInfo.technique;\n\n        const imageWidth = imageItem.image.width;\n        const imageHeight = imageItem.image.height;\n        const paddedSize = MipMapGenerator.getPaddedSize(imageWidth, imageHeight);\n        const trilinearFiltering = PoiBatch.trilinear && imageItem.mipMaps;\n        const paddedImageWidth = trilinearFiltering ? paddedSize.width : imageWidth;\n        const paddedImageHeight = trilinearFiltering ? paddedSize.height : imageHeight;\n\n        const iconWidth = imageTexture?.width !== undefined ? imageTexture.width : imageWidth;\n        const iconHeight = imageTexture?.height !== undefined ? imageTexture.height : imageHeight;\n\n        const width = imageTexture?.width !== undefined ? imageTexture.width : imageWidth;\n        const height = imageTexture?.height !== undefined ? imageTexture.height : imageHeight;\n        const xOffset = imageTexture?.xOffset !== undefined ? imageTexture.xOffset : 0;\n        const yOffset = imageTexture?.yOffset !== undefined ? imageTexture.yOffset : 0;\n\n        const minS = xOffset / paddedImageWidth;\n        const maxS = (xOffset + width) / paddedImageWidth;\n        const minT = yOffset / paddedImageHeight;\n        const maxT = (yOffset + height) / paddedImageHeight;\n\n        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;\n        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;\n\n        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.\n        const screenWidth = getPropertyValue(technique.screenWidth, env);\n        if (screenWidth !== undefined && screenWidth !== null) {\n            iconScaleV = iconScaleH = screenWidth / iconWidth;\n        }\n\n        const screenHeight = getPropertyValue(technique.screenHeight, env);\n        if (screenHeight !== undefined && screenHeight !== null) {\n            iconScaleV = screenHeight / iconHeight;\n            if (screenWidth !== undefined) {\n                iconScaleH = iconScaleV;\n            }\n        }\n\n        // compute stored values in imageTexture\n        poiInfo.computedWidth = iconWidth * iconScaleH;\n        poiInfo.computedHeight = iconHeight * iconScaleV;\n        poiInfo.uvBox = {\n            s0: minS,\n            t0: maxT,\n            s1: maxS,\n            t1: minT\n        };\n        poiInfo.imageItem = imageItem;\n        poiInfo.imageTexture = imageTexture;\n        poiInfo.buffer = this.m_poiBatchRegistry.registerPoi(\n            poiInfo,\n            this.addLayer(poiInfo.renderOrder!)\n        );\n        poiInfo.isValid = true;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    PoiStackMode,\n    PoiTableDef,\n    PoiTableEntryDef,\n    PoiTableRef\n} from \"@here/harp-datasource-protocol\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { MapView } from \"../MapView\";\n\nconst logger = LoggerManager.instance.create(\"PoiTable\");\n\n/**\n * Class to store and maintain individual POI information for the {@link PoiTable}.\n */\nclass PoiTableEntry implements PoiTableEntryDef {\n    /**\n     * Verify that the JSON description of the POI table entry is valid.\n     *\n     * @param jsonEntry - JSON description of the POI table entry.\n     *\n     * @returns `true` if the `jsonEntry` is valid.\n     */\n    static verifyJSON(jsonEntry: PoiTableEntryDef): boolean {\n        let isOK =\n            typeof jsonEntry.name === \"string\" &&\n            jsonEntry.name.length > 0 &&\n            (jsonEntry.altNames === undefined || Array.isArray(jsonEntry.altNames)) &&\n            (jsonEntry.stackMode === undefined ||\n                jsonEntry.stackMode === \"yes\" ||\n                jsonEntry.stackMode === \"no\" ||\n                jsonEntry.stackMode === \"parent\") &&\n            (jsonEntry.visible === undefined || typeof jsonEntry.visible === \"boolean\") &&\n            (jsonEntry.priority === undefined || typeof jsonEntry.priority === \"number\") &&\n            (jsonEntry.iconMinLevel === undefined || typeof jsonEntry.iconMinLevel === \"number\") &&\n            (jsonEntry.iconMaxLevel === undefined || typeof jsonEntry.iconMaxLevel === \"number\") &&\n            (jsonEntry.textMinLevel === undefined || typeof jsonEntry.textMinLevel === \"number\") &&\n            (jsonEntry.textMaxLevel === undefined || typeof jsonEntry.textMaxLevel === \"number\");\n\n        if (isOK && jsonEntry.altNames !== undefined) {\n            const altNames = jsonEntry.altNames as string[];\n            // eslint-disable-next-line @typescript-eslint/no-for-in-array\n            for (const str in altNames) {\n                if (typeof str !== \"string\") {\n                    isOK = false;\n                    break;\n                }\n            }\n        }\n\n        return isOK;\n    }\n\n    /** Default name of the POI as the key for looking it up. */\n    name?: string;\n    /** Alternative names of the POI. */\n    altNames?: string[];\n    /** Visibility of the POI. If `false`, the POI will not be rendered. */\n    visible?: boolean;\n    /** Name of the icon, defined in the the texture atlases. */\n    iconName?: string;\n    /** Stacking mode of the POI. For future use. */\n    stackMode?: PoiStackMode;\n    /**\n     * Priority of the POI to select the visible set in case there are more POIs than can be\n     * handled.\n     */\n    priority?: number;\n    /** Minimum zoom level to render the icon on. */\n    iconMinLevel?: number;\n    /** Maximum zoom level to render the icon on. */\n    iconMaxLevel?: number;\n    /** Minimum zoom level to render the text label on. */\n    textMinLevel?: number;\n    /** Maximum zoom level to render the text label on. */\n    textMaxLevel?: number;\n\n    /**\n     * Setup the [[PoiTableEntry]] from the JSON description. It is assumed that the jsonEntry has\n     * been verified with [[PoiTableEntry#verifyJSON]].\n     *\n     * @param jsonEntry - JSON description of the POI table entry. Expected to have been verified\n     *                    with [[PoiTableEntry#verifyJSON]].\n     */\n    setup(jsonEntry: PoiTableEntryDef) {\n        this.name = jsonEntry.name;\n        this.altNames = jsonEntry.altNames;\n        this.iconName = jsonEntry.iconName;\n        this.visible = jsonEntry.visible;\n        this.priority = jsonEntry.priority;\n        this.iconMinLevel = jsonEntry.iconMinLevel;\n        this.iconMaxLevel = jsonEntry.iconMaxLevel;\n        this.textMinLevel = jsonEntry.textMinLevel;\n        this.textMaxLevel = jsonEntry.textMaxLevel;\n\n        switch (jsonEntry.stackMode) {\n            case \"yes\":\n                this.stackMode = PoiStackMode.Show;\n                break;\n            case \"no\":\n                this.stackMode = PoiStackMode.Hide;\n                break;\n            case \"parent\":\n                this.stackMode = PoiStackMode.ShowParent;\n                break;\n            default:\n        }\n    }\n}\n\n/**\n * The `PoiTable` stores individual information for each POI type.\n *\n * @remarks\n * If a {@link TextElement} has a\n * reference to a PoiTable (if TextElement.poiInfo.poiTableName is set), information for the\n * TextElement and its icon are read from the PoiTable.\n *\n * The key to look up the POI is taken from the data, in case of OSM data with TileZen data, the\n * `poiNameField` is set to `kind`, which makes the content of the field `kind` in the data the key\n * to look up the POIs in the {@link PoiTable}.\n *\n * On the side of the {@link PoiTable}, the key to look up the PoiTableEntry is either the property\n * \"name\" of the [[PoiTableEntry]] (which should be unique), or the alternative list of names\n * `altNames`, where each value should also be unique. If the property `useAltNamesForKey` is set to\n * `true`, the `altNames` will be used.\n */\nexport class PoiTable {\n    /**\n     * Stores the list of [[PoiTableEntry]]s.\n     */\n    private readonly poiList: PoiTableEntry[] = new Array();\n    /**\n     * Dictionary to look up for [[PoiTableEntry]] quickly. The dictionary is either created for\n     * the `name` property of the [[PoiTableEntry]], which will identify POI, or for all of\n     * alternative the names defined in `altNames` of [[PoiTableEntry]] JSON object.\n     * Value assigned to key it is the index to [[poiList]] array which contain actual\n     * [[PoiTabelEntry]] objects.\n     */\n    private readonly poiDict: Map<string, number> = new Map();\n    private m_isLoading = false;\n    private m_loadedOk: boolean | undefined = undefined;\n\n    /**\n     * Creates an instance of PoiTable.\n     *\n     * @param {string} name Name of the `PoiTable`. Must be unique.\n     * @param {boolean} useAltNamesForKey Pass `true` to use the contents of the property `altNames`\n     *          to find a [[PoiTableEntry]] in the table.\n     */\n    constructor(readonly name: string, readonly useAltNamesForKey: boolean) {}\n\n    /**\n     * Returns `true` if the table is currently being loaded, `false` otherwise.\n     *\n     * @readonly\n     */\n    get isLoading(): boolean {\n        return this.m_isLoading;\n    }\n\n    /**\n     * Returns `true` if the table has been loaded correctly, `false` otherwise.\n     *\n     * @readonly\n     */\n    get loadedOk(): boolean {\n        return this.m_loadedOk === true;\n    }\n\n    /**\n     * Gets [[PoiTableEntry]] for poi name specified.\n     *\n     * @param poiName - poi name or one of its alternative names if [[useAltNamesForKey]] is\n     * set to `true`.\n     * @returns [[PoiTableEntry]] object or undefined if name was not found in dictionary.\n     */\n    getEntry(poiName: string): PoiTableEntry | undefined {\n        const entryIdx: number | undefined = this.poiDict.get(poiName);\n        if (entryIdx !== undefined) {\n            if (entryIdx < this.poiList.length) {\n                return this.poiList[entryIdx];\n            } else {\n                throw new Error(\"Poi table entry index out of stored list!\");\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * Start to load the PoiTable from the specified URL. Can only be called once per table.\n     *\n     * @param {string} poiTableUrl URL that points to the JSON file.\n     * @param {AbortSignal} abortSignal Signal to abort the loading of the poi table file\n     *\n     * @returns {Promise<boolean>} Promise is being resolved once the JSON file has been fetched and\n     *          the `PoiTable` has been set up.\n     */\n    async load(poiTableUrl: string, abortSignal?: AbortSignal): Promise<boolean> {\n        if (this.m_loadedOk !== undefined) {\n            // Only load once.\n            return true;\n        }\n\n        this.m_loadedOk = false;\n\n        const response = await fetch(poiTableUrl, { signal: abortSignal });\n\n        if (!response.ok) {\n            throw new Error(\n                `load: Cannot load POI table at ${poiTableUrl}:` + ` ${response.statusText}`\n            );\n        }\n\n        const jsonPoiTable = (await response.json()) as PoiTableDef;\n        if (jsonPoiTable === undefined) {\n            logger.info(`load: TextureAtlas empty: ${poiTableUrl}`);\n            return true;\n        }\n\n        this.startLoading();\n\n        try {\n            logger.debug(`load: Loading POI table '${poiTableUrl}' for table '${this.name}'`);\n\n            if (jsonPoiTable.poiList !== undefined && Array.isArray(jsonPoiTable.poiList)) {\n                for (const tableEntry of jsonPoiTable.poiList) {\n                    if (PoiTableEntry.verifyJSON(tableEntry)) {\n                        const newPoiEntry = new PoiTableEntry();\n                        newPoiEntry.setup(tableEntry);\n                        const entryIdx = this.poiList.push(newPoiEntry) - 1;\n\n                        if (!this.useAltNamesForKey) {\n                            // Use actual name of entry as the key\n                            if (newPoiEntry.name === undefined) {\n                                logger.warn(\n                                    `load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                        `. No name set in entry: ${tableEntry}.`\n                                );\n                            } else {\n                                this.poiDict.set(newPoiEntry.name, entryIdx);\n                            }\n                        } else {\n                            if (\n                                newPoiEntry.altNames !== undefined &&\n                                newPoiEntry.altNames.length > 0\n                            ) {\n                                // Use the list of alternative names as keys.\n                                for (const altName of newPoiEntry.altNames) {\n                                    this.poiDict.set(altName, entryIdx);\n                                }\n                            } else {\n                                logger.debug(\n                                    `load: Invalid entry in POI table '${poiTableUrl}' : ` +\n                                        `No alternative names set in entry: ${JSON.stringify(\n                                            tableEntry\n                                        )}.`\n                                );\n                            }\n                        }\n                    } else {\n                        logger.warn(\n                            `load: Invalid entry in POI table '${poiTableUrl}' : ${JSON.stringify(\n                                tableEntry\n                            )}`\n                        );\n                    }\n                }\n            }\n            this.m_loadedOk = true;\n            this.finishedLoading();\n        } catch (ex) {\n            logger.error(`load: Failed to load POI table ` + `'${poiTableUrl}' : ${ex}`);\n            this.m_loadedOk = false;\n            this.finishedLoading();\n            return false;\n        }\n        return true;\n    }\n\n    private startLoading() {\n        this.m_isLoading = true;\n    }\n\n    private finishedLoading() {\n        this.m_isLoading = false;\n    }\n}\n\n/**\n * The `PoiTableManager` manages the list of [[PoiTables]] that\n * can be defined in the {@link @here/harp-datasource-protocol#Theme} sfile.\n */\nexport class PoiTableManager {\n    private m_isLoading = false;\n    private m_poiTables: Map<string, PoiTable> = new Map();\n    private readonly m_abortControllers: Map<string, AbortController> = new Map();\n\n    /**\n     * Creates an instance of PoiTableManager.\n     * @param {MapView} mapView Owning {@link MapView}.\n     */\n    constructor(readonly mapView: MapView) {}\n\n    /**\n     * Load the {@link PoiTable}s that are stored in the {@link MapView}s\n     * {@link @here/harp-datasource-protocol#Theme}.\n     *\n     * @remarks\n     * Note that duplicate names of {@link PoiTable}s in the\n     * {@link @here/harp-datasource-protocol#Theme} will lead to inaccessible {@link PoiTable}s.\n     *\n     * @param poiTables - {@link @here/harp-datasource-protocol#PoiTableRef[]}\n     *                containing all {@link PoiTable}s to load.\n     *\n     * @returns Resolved once all the {@link PoiTable}s in\n     *          the {@link @here/harp-datasource-protocol#Theme} have been loaded.\n     */\n    async loadPoiTables(poiTables?: PoiTableRef[]): Promise<void> {\n        const finished = new Promise<void>(resolve => {\n            this.clear();\n\n            // Add the POI tables defined in the theme.\n            if (poiTables !== undefined) {\n                this.startLoading();\n\n                // Gather promises to signal the success of having loaded them all\n                const loadPromises: Array<Promise<boolean>> = new Array();\n\n                poiTables.forEach((poiTableRef: PoiTableRef) => {\n                    if (\n                        poiTableRef !== undefined &&\n                        poiTableRef.name !== undefined &&\n                        typeof poiTableRef.name === \"string\"\n                    ) {\n                        const poiTable = new PoiTable(\n                            poiTableRef.name,\n                            poiTableRef.useAltNamesForKey !== false\n                        );\n                        if (poiTableRef.url !== undefined && typeof poiTableRef.url === \"string\") {\n                            this.addTable(poiTable);\n                            this.m_abortControllers.set(poiTableRef.name, new AbortController());\n                            loadPromises.push(\n                                poiTable.load(\n                                    poiTableRef.url,\n                                    this.m_abortControllers.get(poiTableRef.name)?.signal\n                                )\n                            );\n                        } else {\n                            logger.error(`POI table definition has no valid url: ${poiTableRef}`);\n                        }\n                    } else {\n                        logger.error(`POI table definition has no valid name: ${poiTableRef}`);\n                    }\n                });\n\n                if (loadPromises.length > 0) {\n                    Promise.all(loadPromises).finally(() => {\n                        this.finishLoading();\n                        resolve();\n                    });\n                } else {\n                    this.finishLoading();\n                    resolve();\n                }\n            } else {\n                this.finishLoading();\n                resolve();\n            }\n        });\n\n        return finished;\n    }\n\n    /**\n     * Clear the list of {@link PoiTable}s.\n     */\n    clear() {\n        this.m_poiTables = new Map();\n        this.m_abortControllers.forEach((abortController, name) => {\n            abortController.abort();\n            this.m_abortControllers.delete(name);\n        });\n    }\n\n    /**\n     * Return the map of {@link PoiTable}s.\n     */\n    get poiTables(): Map<string, PoiTable> {\n        return this.m_poiTables;\n    }\n\n    /**\n     * Manually add a {@link PoiTable}. Normally, the [[PoiTables]]s\n     * are specified in the {@link @here/harp-datasource-protocol#Theme}.\n     *\n     * @remarks\n     * Ensure that the name is unique.\n     */\n    addTable(poiTable: PoiTable) {\n        this.m_poiTables.set(poiTable.name, poiTable);\n    }\n\n    /**\n     * Retrieve a {@link PoiTable} by name.\n     *\n     * @param {(string | undefined)} poiTableName Name of the {@link PoiTable}.\n     *\n     * @returns {(PoiTable | undefined)} The found [[poiTable]] if it could be found, `undefined`\n     *          otherwise.\n     */\n    getPoiTable(poiTableName: string | undefined): PoiTable | undefined {\n        return poiTableName === undefined ? undefined : this.m_poiTables.get(poiTableName);\n    }\n\n    /**\n     * Return `true` if the {@link PoiTable}s have finished loading.\n     *\n     * @readonly\n     */\n    get finishedLoading(): boolean {\n        return !this.m_isLoading;\n    }\n\n    private startLoading() {\n        this.m_isLoading = true;\n    }\n\n    private finishLoading() {\n        this.m_isLoading = false;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { FontCatalogConfig } from \"@here/harp-datasource-protocol\";\nimport { FontCatalog } from \"@here/harp-text-canvas\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nconst logger = LoggerManager.instance.create(\"FontCatalogLoader\");\n\ntype FontCatalogCallback = (name: string, catalog: FontCatalog) => void;\n\nexport async function loadFontCatalog(\n    fontCatalogConfig: FontCatalogConfig,\n    onSuccess: FontCatalogCallback,\n    onError?: (error: Error) => void\n): Promise<void> {\n    return await FontCatalog.load(fontCatalogConfig.url, 1024)\n        .then<void>(onSuccess.bind(undefined, fontCatalogConfig.name))\n        .catch((error: Error) => {\n            logger.error(\"Failed to load FontCatalog: \", fontCatalogConfig.name, error);\n            if (onError) {\n                onError(error);\n            }\n        });\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    DefaultTextStyle,\n    hAlignFromPlacement,\n    HorizontalAlignment,\n    hPlacementFromAlignment,\n    TextLayoutStyle,\n    TextPlacement,\n    vAlignFromPlacement,\n    VerticalAlignment,\n    vPlacementFromAlignment\n} from \"@here/harp-text-canvas\";\n\n/**\n * Layout state of the text part of the `TextElement`.\n *\n * Used mainly for multi-anchor placement algorithm.\n * @hidden\n */\nexport class LayoutState {\n    private m_hAlign = DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;\n    private m_vAlign = DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;\n\n    constructor(placement: TextPlacement) {\n        this.textPlacement = placement;\n    }\n\n    /**\n     * Set layout based on theme style defined and optional text placement.\n     *\n     * @param placement - The optional new anchor placement.\n     */\n    set textPlacement(placement: TextPlacement) {\n        this.m_hAlign = hAlignFromPlacement(placement.h);\n        this.m_vAlign = vAlignFromPlacement(placement.v);\n    }\n\n    /**\n     * Acquire current placement setup.\n     *\n     * Function returns alternative or base placement depending on layout state.\n     *\n     * @returns The current anchor placement.\n     */\n    get textPlacement(): TextPlacement {\n        return {\n            h: hPlacementFromAlignment(this.m_hAlign),\n            v: vPlacementFromAlignment(this.m_vAlign)\n        };\n    }\n\n    /**\n     * Reset existing `LayoutState` to contain values from style/theme layout.\n     */\n    reset(layoutStyle: TextLayoutStyle) {\n        this.m_hAlign = layoutStyle.horizontalAlignment;\n        this.m_vAlign = layoutStyle.verticalAlignment;\n    }\n\n    get horizontalAlignment(): HorizontalAlignment {\n        return this.m_hAlign;\n    }\n\n    get verticalAlignment(): VerticalAlignment {\n        return this.m_vAlign;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, GeometryKindSet } from \"@here/harp-datasource-protocol\";\nimport { Projection } from \"@here/harp-geoutils\";\nimport * as THREE from \"three\";\n\nimport { ElevationProvider } from \"../ElevationProvider\";\nimport { MapView } from \"../MapView\";\nimport { ViewState } from \"./ViewState\";\n\n/**\n * View state obtained from a MapView instance.\n */\nexport class MapViewState implements ViewState {\n    private readonly m_lookAtVector = new THREE.Vector3();\n    constructor(\n        private readonly m_mapView: MapView,\n        private readonly m_renderedTilesChangeCheck: () => boolean\n    ) {}\n\n    get worldCenter(): THREE.Vector3 {\n        return this.m_mapView.worldCenter;\n    }\n\n    get cameraIsMoving(): boolean {\n        return this.m_mapView.cameraIsMoving;\n    }\n\n    get maxVisibilityDist(): number {\n        return this.m_mapView.viewRanges.maximum;\n    }\n\n    get zoomLevel(): number {\n        return this.m_mapView.zoomLevel;\n    }\n\n    get env(): Env {\n        return this.m_mapView.env;\n    }\n\n    get frameNumber(): number {\n        return this.m_mapView.frameNumber;\n    }\n\n    get lookAtVector(): THREE.Vector3 {\n        return this.m_mapView.camera.getWorldDirection(this.m_lookAtVector);\n    }\n\n    get lookAtDistance(): number {\n        return this.m_mapView.targetDistance;\n    }\n\n    get isDynamic(): boolean {\n        return this.m_mapView.isDynamicFrame;\n    }\n\n    get hiddenGeometryKinds(): GeometryKindSet | undefined {\n        return this.m_mapView.tileGeometryManager === undefined\n            ? undefined\n            : this.m_mapView.tileGeometryManager.hiddenGeometryKinds;\n    }\n\n    get renderedTilesChanged(): boolean {\n        return this.m_renderedTilesChangeCheck();\n    }\n\n    get projection(): Projection {\n        return this.m_mapView.projection;\n    }\n\n    get elevationProvider(): ElevationProvider | undefined {\n        return this.m_mapView.elevationProvider;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { Env, getPropertyValue, PoiTechnique } from \"@here/harp-datasource-protocol\";\nimport { OrientedBox3, Projection, ProjectionType } from \"@here/harp-geoutils\";\nimport {\n    hAlignFromPlacement,\n    HorizontalPlacement,\n    hPlacementFromAlignment,\n    MeasurementParameters,\n    TextCanvas,\n    TextPlacement,\n    vAlignFromPlacement,\n    VerticalPlacement,\n    vPlacementFromAlignment\n} from \"@here/harp-text-canvas\";\nimport { assert, Math2D, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { PoiManager } from \"../poi/PoiManager\";\nimport { PoiRenderer } from \"../poi/PoiRenderer\";\nimport { CollisionBox, DetailedCollisionBox, IBox, ScreenCollisions } from \"../ScreenCollisions\";\nimport { ScreenProjector } from \"../ScreenProjector\";\nimport { RenderState } from \"./RenderState\";\nimport { PoiInfo, poiIsRenderable, TextElement } from \"./TextElement\";\nimport { TextElementState } from \"./TextElementState\";\nimport { TextElementType } from \"./TextElementType\";\nimport { ViewState } from \"./ViewState\";\n\n/**\n * Minimum number of pixels per character. Used during estimation if there is enough screen space\n * available to render a text.\n */\nconst MIN_AVERAGE_CHAR_WIDTH = 5;\n\n/**\n * Functions related to text element placement.\n */\n\nconst tmpPosition = new THREE.Vector3(0, 0, 0);\nconst tmpCameraDir = new THREE.Vector3(0, 0, 0);\nconst tmpPointDir = new THREE.Vector3(0, 0, 0);\nconst COS_TEXT_ELEMENT_FALLOFF_ANGLE = 0.5877852522924731; // Math.cos(0.3 * Math.PI)\n\n/**\n * Checks whether the distance of the text element to the camera plane meets threshold criteria.\n *\n * @param textElement - The textElement of which the view distance will be checked, with coordinates\n * in world space.\n * @param poiIndex - If TextElement is a line marker, the index into the line marker positions.\n * @param eyePos - The eye (or camera) position that will be used as reference to calculate\n * the distance.\n * @param eyeLookAt - The eye looking direction - normalized.\n * @param maxViewDistance - The maximum distance value.\n * @returns The text element view distance if it's lower than the maximum value, otherwise\n * `undefined`.\n */\nfunction checkViewDistance(\n    textElement: TextElement,\n    poiIndex: number | undefined,\n    eyePos: THREE.Vector3,\n    eyeLookAt: THREE.Vector3,\n    projectionType: ProjectionType,\n    maxViewDistance: number\n): number | undefined {\n    const textDistance = computeViewDistance(textElement, poiIndex, eyePos, eyeLookAt);\n\n    if (projectionType !== ProjectionType.Spherical) {\n        return textDistance <= maxViewDistance ? textDistance : undefined;\n    }\n\n    // For sphere projection: Filter labels that are close to the horizon\n    tmpPosition.copy(textElement.position).normalize();\n    tmpCameraDir.copy(eyePos).normalize();\n    const cosAlpha = tmpPosition.dot(tmpCameraDir);\n    const viewDistance =\n        cosAlpha > COS_TEXT_ELEMENT_FALLOFF_ANGLE && textDistance <= maxViewDistance\n            ? textDistance\n            : undefined;\n\n    return viewDistance;\n}\n\n/**\n * Computes distance of the specified text element to camera plane given with position and normal.\n *\n * The distance is measured as projection of the vector between `eyePosition` and text\n * onto the `eyeLookAt` vector, so it actually computes the distance to plane that\n * contains `eyePosition` and is described with `eyeLookAt` as normal.\n *\n * @note Used for measuring the distances to camera, results in the metric that describes\n * distance to camera near plane (assuming near = 0). Such metric is better as input for labels\n * scaling or fading factors then simple euclidean distance because it does not fluctuate during\n * simple camera panning.\n *\n * @param textElement - The textElement of which the view distance will be checked. It must have\n *                      coordinates in world space.\n * @param poiIndex - If TextElement is a line marker, the index into the line marker positions.\n * @param eyePosition - The world eye coordinates used a reference position to calculate\n *                      the distance.\n * @param eyeLookAt - The eye looking direction or simply said projection plane normal.\n * @returns The text element view distance.\n */\nexport function computeViewDistance(\n    textElement: TextElement,\n    poiIndex: number | undefined,\n    eyePosition: THREE.Vector3,\n    eyeLookAt: THREE.Vector3\n): number {\n    let viewDistance: number;\n\n    // Compute the distances as the distance along plane normal.\n    const path = textElement.path;\n    if (path && path.length > 1) {\n        if (poiIndex !== undefined && path && path.length > poiIndex) {\n            viewDistance = pointToPlaneDistance(path[poiIndex], eyePosition, eyeLookAt);\n        } else {\n            const viewDistance0 = pointToPlaneDistance(path[0], eyePosition, eyeLookAt);\n            const viewDistance1 = pointToPlaneDistance(\n                path[path.length - 1],\n                eyePosition,\n                eyeLookAt\n            );\n\n            viewDistance = Math.min(viewDistance0, viewDistance1);\n        }\n    } else {\n        viewDistance = pointToPlaneDistance(textElement.position, eyePosition, eyeLookAt);\n    }\n\n    return viewDistance;\n}\n\n/**\n * Computes distance between the given point and a plane.\n *\n * May be used to measure distance of point labels to the camera projection (near) plane.\n *\n * @param pointPos - The position to measure distance to.\n * @param planePos - The position of any point on the plane.\n * @param planeNorm - The plane normal vector (have to be normalized already).\n */\nexport function pointToPlaneDistance(\n    pointPos: THREE.Vector3,\n    planePos: THREE.Vector3,\n    planeNorm: THREE.Vector3\n) {\n    const labelCamVec = tmpPointDir.copy(pointPos).sub(planePos);\n    return labelCamVec.dot(planeNorm);\n}\n\n/**\n * Computes the maximum view distance for text elements as a ratio of the given view's maximum far\n * plane distance.\n * @param viewState - The view for which the maximum view distance will be calculated.\n * @param farDistanceLimitRatio - The ratio to apply to the maximum far plane distance.\n * @returns Maximum view distance.\n */\nexport function getMaxViewDistance(viewState: ViewState, farDistanceLimitRatio: number): number {\n    return viewState.maxVisibilityDist * farDistanceLimitRatio;\n}\n\n/**\n * State of fading.\n */\nexport enum PrePlacementResult {\n    Ok = 0,\n    NotReady,\n    Invisible,\n    TooFar,\n    Duplicate,\n    Count\n}\n\nconst tmpPlacementPosition = new THREE.Vector3();\n\n/**\n * Applies early rejection tests for a given text element meant to avoid trying to place labels\n * that are not visible, not ready, duplicates etc...\n * @param textElement - The Text element to check.\n * @param poiIndex - If TextElement is a line marker, the index into the line marker positions\n * @param viewState - The view for which the text element will be placed.\n * @param m_poiManager - To prepare pois for rendering.\n * @param maxViewDistance - If specified, text elements farther than this max distance will be\n *                          rejected.\n * @returns An object with the result code and the text element view distance\n * ( or `undefined` of the checks failed) as second.\n */\nexport function checkReadyForPlacement(\n    textElement: TextElement,\n    poiIndex: number | undefined,\n    viewState: ViewState,\n    poiManager: PoiManager,\n    maxViewDistance?: number\n): { result: PrePlacementResult; viewDistance: number | undefined } {\n    // eslint-disable-next-line prefer-const\n    let viewDistance: number | undefined;\n\n    if (!textElement.visible) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n\n    // If a PoiTable is specified in the technique, the table is required to be\n    // loaded before the POI can be rendered.\n    if (!poiManager.updatePoiFromPoiTable(textElement)) {\n        // PoiTable has not been loaded, but is required to determine\n        // visibility.\n        return { result: PrePlacementResult.NotReady, viewDistance };\n    }\n\n    // Text element visibility and zoom level ranges must be checked after calling\n    // updatePoiFromPoiTable, since that function may change those values.\n    if (\n        !textElement.visible ||\n        viewState.zoomLevel === textElement.maxZoomLevel ||\n        !MathUtils.isClamped(\n            viewState.zoomLevel,\n            textElement.minZoomLevel,\n            textElement.maxZoomLevel\n        )\n    ) {\n        return { result: PrePlacementResult.Invisible, viewDistance };\n    }\n\n    viewDistance =\n        maxViewDistance === undefined\n            ? computeViewDistance(\n                  textElement,\n                  poiIndex,\n                  viewState.worldCenter,\n                  viewState.lookAtVector\n              )\n            : checkViewDistance(\n                  textElement,\n                  poiIndex,\n                  viewState.worldCenter,\n                  viewState.lookAtVector,\n                  viewState.projection.type,\n                  maxViewDistance\n              );\n\n    if (viewDistance === undefined) {\n        return { result: PrePlacementResult.TooFar, viewDistance };\n    }\n\n    return { result: PrePlacementResult.Ok, viewDistance };\n}\n\n/**\n * Computes the offset for a point text accordingly to text alignment (and icon, if any).\n * @param textElement - The text element of which the offset will computed. It must be a point\n * label with [[layoutStyle]] and [[bounds]] already computed.\n * @param textBounds - The text screen bounds.\n * @param placement - The relative anchor placement (may be different then original alignment).\n * @param scale - The scaling factor (due to distance, etc.).\n * @param env - The {@link @here/harp-datasource-protocol#Env} used\n *                  to evaluate technique attributes.\n * @param offset - The offset result.\n */\nfunction computePointTextOffset(\n    textElement: TextElement,\n    textBounds: THREE.Box2,\n    placement: TextPlacement,\n    scale: number,\n    env: Env,\n    offset: THREE.Vector2 = new THREE.Vector2()\n): THREE.Vector2 {\n    assert(\n        textElement.type === TextElementType.PoiLabel ||\n            textElement.type === TextElementType.LineMarker\n    );\n    assert(textElement.layoutStyle !== undefined);\n\n    offset.x = textElement.xOffset;\n    offset.y = textElement.yOffset;\n\n    switch (placement.h) {\n        case HorizontalPlacement.Left:\n            // Already accounts for any margin that is already applied to the text element bounds.\n            offset.x -= textBounds.max.x;\n            break;\n        case HorizontalPlacement.Right:\n            // Account for any margin applied as above.\n            offset.x -= textBounds.min.x;\n            break;\n    }\n    switch (placement.v) {\n        case VerticalPlacement.Top:\n            offset.y -= textBounds.min.y;\n            break;\n        case VerticalPlacement.Center:\n            offset.y -= 0.5 * (textBounds.max.y + textBounds.min.y);\n            break;\n        case VerticalPlacement.Bottom:\n            // Accounts for vertical margin that may be applied to the text bounds.\n            offset.y -= textBounds.max.y;\n            break;\n    }\n\n    if (textElement.poiInfo !== undefined && poiIsRenderable(textElement.poiInfo)) {\n        assert(textElement.poiInfo.computedWidth !== undefined);\n        assert(textElement.poiInfo.computedHeight !== undefined);\n\n        // Apply offset moving text out of the icon\n        offset.x += textElement.poiInfo.computedWidth! * (0.5 + placement.h);\n        offset.y += textElement.poiInfo.computedHeight! * (0.5 + placement.v);\n\n        // Reverse, mirror or project offsets on different axis depending on the placement\n        // required only for alternative placements.\n        const hAlign = hPlacementFromAlignment(textElement.layoutStyle!.horizontalAlignment);\n        const vAlign = vPlacementFromAlignment(textElement.layoutStyle!.verticalAlignment);\n        if (hAlign !== placement.h || vAlign !== placement.v) {\n            // Read icon offset used.\n            const technique = textElement.poiInfo.technique;\n            let iconXOffset = getPropertyValue(technique.iconXOffset, env);\n            let iconYOffset = getPropertyValue(technique.iconYOffset, env);\n            iconXOffset = typeof iconXOffset === \"number\" ? iconXOffset : 0;\n            iconYOffset = typeof iconYOffset === \"number\" ? iconYOffset : 0;\n\n            // Now mirror the text offset relative to icon so manhattan distance is preserved, when\n            // alternative position is taken, this ensures that text-icon relative position is\n            // the same as in base alignment.\n            const hAlignDiff = hAlign - placement.h;\n            const vAlignDiff = vAlign - placement.v;\n            const relOffsetX = iconXOffset - textElement.xOffset;\n            const relOffsetY = iconYOffset - textElement.yOffset;\n            const centerBased =\n                hAlign === HorizontalPlacement.Center || vAlign === VerticalPlacement.Center;\n            if (centerBased) {\n                // Center based alternative placements.\n                offset.x += 2 * Math.abs(hAlignDiff) * relOffsetX;\n                offset.y -= 2 * vAlignDiff * Math.abs(relOffsetX);\n\n                offset.y += 2 * Math.abs(vAlignDiff) * relOffsetY;\n                offset.x -= 2 * hAlignDiff * Math.abs(relOffsetY);\n            } else {\n                // Corner alternative placements\n                offset.x += 2 * Math.min(Math.abs(hAlignDiff), 0.5) * relOffsetX;\n                offset.y -=\n                    2 *\n                    Math.sign(vAlignDiff) *\n                    Math.min(Math.abs(vAlignDiff), 0.5) *\n                    Math.abs(relOffsetX);\n\n                offset.y += 2 * Math.min(Math.abs(vAlignDiff), 0.5) * relOffsetY;\n                offset.x -=\n                    2 *\n                    Math.sign(hAlignDiff) *\n                    Math.min(Math.abs(hAlignDiff), 0.5) *\n                    Math.abs(relOffsetY);\n            }\n        }\n    }\n\n    offset.multiplyScalar(scale);\n    return offset;\n}\n\nconst tmpBox = new THREE.Box2();\nconst tmpBounds = new THREE.Box2();\nconst tmpBoxes: THREE.Box2[] = [];\nconst tmpMeasurementParams: MeasurementParameters = {};\nconst tmpCollisionBoxes: CollisionBox[] = [];\nconst tmpCollisionBox = new CollisionBox();\nconst tmpScreenPosition = new THREE.Vector2();\nconst tmpTextOffset = new THREE.Vector2();\nconst tmp2DBox = new Math2D.Box();\nconst tmpCenter = new THREE.Vector2();\nconst tmpSize = new THREE.Vector2();\n\n/**\n * The margin applied to the text bounds of every point label.\n */\nexport const persistentPointLabelTextMargin = new THREE.Vector2(2, 2);\n/**\n * Additional bounds scaling (described as percentage of full size) applied to the new labels.\n *\n * This additional scaling (margin) allows to account for slight camera position and\n * orientation changes, so new labels are placed only if there is enough space around them.\n * Such margin limits collisions with neighboring labels while doing small camera movements and\n * thus reduces labels flickering.\n */\nexport const newPointLabelTextMarginPercent = 0.1;\n\nexport enum PlacementResult {\n    Ok,\n    Rejected,\n    Invisible\n}\n\n/**\n * Places an icon on screen.\n * @param iconRenderState - The icon state.\n * @param poiInfo - Icon information necessary to compute its dimensions.\n * @param screenPosition - Screen position of the icon.\n * @param scaleFactor - Scaling factor to apply to the icon dimensions.\n * @param screenCollisions - Used to check the icon visibility and collisions.\n * @param env - Current map env.\n * @returns `PlacementResult.Ok` if icon can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n */\nexport function placeIcon(\n    iconRenderState: RenderState,\n    poiInfo: PoiInfo,\n    screenPosition: THREE.Vector2,\n    scaleFactor: number,\n    env: Env,\n    screenCollisions: ScreenCollisions\n): PlacementResult {\n    PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scaleFactor, env, tmp2DBox);\n    if (!screenCollisions.isVisible(tmp2DBox)) {\n        return PlacementResult.Invisible;\n    }\n\n    const iconSpaceAvailable =\n        poiInfo.mayOverlap === true || !screenCollisions.isAllocated(tmp2DBox);\n\n    return !iconSpaceAvailable ? PlacementResult.Rejected : PlacementResult.Ok;\n}\n\n/**\n * Place a point label text using single or multiple alternative placement anchors.\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env} used\n *              to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @param multiAnchor - The parameter decides if multi-anchor placement algorithm should be\n * used, be default [[false]] meaning try to place label using current alignment settings only.\n * @returns `PlacementResult.Ok` if point __label can be placed__ at the base or any optional\n * anchor point. `PlacementResult.Rejected` if there's a collision for all placements. Finally\n * `PlacementResult.Invisible` if it's text is not visible at any placement position.\n */\nexport function placePointLabel(\n    labelState: TextElementState,\n    screenPosition: THREE.Vector2,\n    scale: number,\n    textCanvas: TextCanvas,\n    env: Env,\n    screenCollisions: ScreenCollisions,\n    outScreenPosition: THREE.Vector3,\n    multiAnchor: boolean = false\n): PlacementResult {\n    assert(labelState.element.layoutStyle !== undefined);\n\n    const layoutStyle = labelState.element.layoutStyle!;\n\n    // Check if alternative placements have been provided.\n    multiAnchor =\n        multiAnchor && layoutStyle.placements !== undefined && layoutStyle.placements.length > 1;\n    // For single placement labels or labels with icon rejected, do only current anchor testing.\n    if (!multiAnchor) {\n        return placePointLabelAtCurrentAnchor(\n            labelState,\n            screenPosition,\n            scale,\n            textCanvas,\n            env,\n            screenCollisions,\n            outScreenPosition\n        );\n    }\n    // Otherwise test also alternative text placements.\n    else {\n        return placePointLabelChoosingAnchor(\n            labelState,\n            screenPosition,\n            scale,\n            textCanvas,\n            env,\n            screenCollisions,\n            outScreenPosition\n        );\n    }\n}\n\n/**\n * Try to place a point label text using multiple optional placements.\n *\n * @note Function should be called only for labels with icons not rejected and for text alignments\n * different then [[HorizontalAlignment.Center]] and [[VerticalAlignment.Center]].\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env}\n *              used to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if label can be placed at the base or optional anchor point,\n * `PlacementResult.Rejected` if there's a collision for all placements, `PlacementResult.Invisible`\n * if it's not visible at any placement position.\n *\n * @internal\n * @hidden\n */\nfunction placePointLabelChoosingAnchor(\n    labelState: TextElementState,\n    screenPosition: THREE.Vector2,\n    scale: number,\n    textCanvas: TextCanvas,\n    env: Env,\n    screenCollisions: ScreenCollisions,\n    outScreenPosition: THREE.Vector3\n): PlacementResult {\n    assert(labelState.element.layoutStyle !== undefined);\n    const label = labelState.element;\n\n    // Store label state - persistent or new label.\n    const persistent = labelState.visible;\n\n    // Start with last alignment settings if layout state was stored or\n    // simply begin from layout defined in theme.\n    const lastPlacement = labelState.textPlacement;\n    const placements = label.layoutStyle!.placements;\n    const placementsNum = placements.length;\n    // Find current anchor placement on the optional placements list.\n    // Index of exact match.\n    const matchIdx = placements.findIndex(p => p.h === lastPlacement.h && p.v === lastPlacement.v);\n    assert(matchIdx >= 0);\n    // Will be true if all text placements are invisible.\n    let allInvisible: boolean = true;\n\n    // Iterate all placements starting from current one.\n    for (let i = matchIdx; i < placementsNum + matchIdx; ++i) {\n        const anchorPlacement = placements[i % placementsNum];\n\n        // Bounds may be already calculated for persistent label, force re-calculation only\n        // for alternative (new) placements.\n        const isLastPlacement = i === matchIdx && persistent;\n        // Compute label bounds, visibility or collision according to new layout settings.\n        const placementResult = placePointLabelAtAnchor(\n            labelState,\n            screenPosition,\n            anchorPlacement,\n            scale,\n            textCanvas,\n            env,\n            screenCollisions,\n            !isLastPlacement,\n            tmpPlacementPosition\n        );\n\n        if (placementResult === PlacementResult.Ok) {\n            outScreenPosition.copy(tmpPlacementPosition);\n            return PlacementResult.Ok;\n        }\n        // Store last successful (previous frame) position even if it's now rejected (to fade out).\n        if (isLastPlacement) {\n            outScreenPosition.copy(tmpPlacementPosition);\n        }\n\n        // Invisible = Persistent label out of screen or the new label that is colliding.\n        allInvisible = allInvisible && placementResult === PlacementResult.Invisible;\n    }\n\n    return allInvisible\n        ? // All text's placements out of the screen.\n          PlacementResult.Invisible\n        : // All placements are either colliding or out of screen .\n          PlacementResult.Rejected;\n}\n\n/**\n * Places a point label on a specified text canvas using the alignment (anchor) currently set.\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env}\n *              used to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n *\n * @internal\n * @hidden\n */\nfunction placePointLabelAtCurrentAnchor(\n    labelState: TextElementState,\n    screenPosition: THREE.Vector2,\n    scale: number,\n    textCanvas: TextCanvas,\n    env: Env,\n    screenCollisions: ScreenCollisions,\n    outScreenPosition: THREE.Vector3\n): PlacementResult {\n    assert(labelState.element.layoutStyle !== undefined);\n\n    // Use recently rendered (state stored) layout if available, otherwise theme based style.\n    const lastPlacement = labelState.textPlacement;\n    const result = placePointLabelAtAnchor(\n        labelState,\n        screenPosition,\n        lastPlacement,\n        scale,\n        textCanvas,\n        env,\n        screenCollisions,\n        !labelState.visible,\n        outScreenPosition\n    );\n\n    return result;\n}\n\n/**\n * Auxiliary function that tries to place a point label on a text canvas using specified alignment.\n *\n * @param labelState - State of the point label to place.\n * @param screenPosition - Position of the label in screen coordinates\n * @param placement - Text placement relative to the label position.\n * @param scale - Scale factor to be applied to label dimensions.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param env - The {@link @here/harp-datasource-protocol#Env}\n *              used to evaluate technique attributes.\n * @param screenCollisions - Used to check collisions with other labels.\n * @param forceInvalidation - Set to true if text layout or other params has changed such as text\n * re-measurement is required and text buffer need to be invalidated.\n * @param outScreenPosition - The final label screen position after applying any offsets.\n * @returns `PlacementResult.Ok` if point label can be placed, `PlacementResult.Rejected` if there's\n * a collision, `PlacementResult.Invisible` if it's not visible.\n *\n * @internal\n * @hidden\n */\nfunction placePointLabelAtAnchor(\n    labelState: TextElementState,\n    screenPosition: THREE.Vector2,\n    placement: TextPlacement,\n    scale: number,\n    textCanvas: TextCanvas,\n    env: Env,\n    screenCollisions: ScreenCollisions,\n    forceInvalidation: boolean,\n    outScreenPosition: THREE.Vector3\n): PlacementResult {\n    const label = labelState.element;\n    assert(label.glyphs !== undefined);\n    assert(label.layoutStyle !== undefined);\n\n    const measureText = !label.bounds || forceInvalidation;\n\n    const labelBounds = measureText ? tmpBounds : label.bounds!;\n    if (measureText) {\n        // Override text canvas layout style for measurement.\n        applyTextPlacement(textCanvas, placement);\n\n        tmpMeasurementParams.outputCharacterBounds = undefined;\n        tmpMeasurementParams.path = undefined;\n        tmpMeasurementParams.pathOverflow = false;\n        tmpMeasurementParams.letterCaseArray = label.glyphCaseArray!;\n        // Compute label bounds according to layout settings.\n        textCanvas.measureText(label.glyphs!, labelBounds, tmpMeasurementParams);\n    }\n\n    // Compute text offset from the anchor point\n    const textOffset = computePointTextOffset(\n        label,\n        labelBounds,\n        placement,\n        scale,\n        env,\n        tmpTextOffset\n    ).add(screenPosition);\n\n    // Update output screen position.\n    outScreenPosition.set(textOffset.x, textOffset.y, labelState.renderDistance);\n\n    // Apply additional persistent margin, keep in mind that text bounds just calculated\n    // are not (0, 0, w, h) based, so their coords usually are also non-zero.\n    // TODO: Make the margin configurable\n    tmpBox.copy(labelBounds).expandByVector(persistentPointLabelTextMargin).translate(textOffset);\n    tmpBox.getCenter(tmpCenter);\n    tmpBox.getSize(tmpSize);\n\n    tmpSize.multiplyScalar(scale);\n    tmp2DBox.set(tmpCenter.x - tmpSize.x / 2, tmpCenter.y - tmpSize.y / 2, tmpSize.x, tmpSize.y);\n\n    // Check the text visibility if invisible finish immediately\n    // regardless of the persistence state - no fading required.\n    if (!screenCollisions.isVisible(tmp2DBox)) {\n        return PlacementResult.Invisible;\n    }\n\n    if (measureText) {\n        // Up-scaled label bounds are used only for new labels and only for collision check, this\n        // is intentional to avoid processing labels out of the screen due to increased bounds,\n        // such labels would be again invisible in the next frame.\n        tmpBox.getSize(tmpSize);\n        tmpSize.multiplyScalar(scale * (1 + newPointLabelTextMarginPercent));\n        tmp2DBox.set(\n            tmpCenter.x - tmpSize.x / 2,\n            tmpCenter.y - tmpSize.y / 2,\n            tmpSize.x,\n            tmpSize.y\n        );\n    }\n\n    // Check label's text collision. Collision is more important than visibility (now), because for\n    // icon/text combinations the icon should be rendered if the text is out of bounds, but it may\n    // _not_ be rendered if the text is colliding with another label.\n    if (!label.textMayOverlap && screenCollisions.isAllocated(tmp2DBox)) {\n        return PlacementResult.Rejected;\n    }\n\n    // Don't allocate space for rejected text. When zooming, this allows placement of a\n    // lower priority text element that was displaced by a higher priority one (not\n    // present in the new zoom level) before an even lower priority one takes the space.\n    // Otherwise the lowest priority text will fade in and back out.\n    // TODO: Add a unit test for this scenario.\n    if (label.textReservesSpace) {\n        screenCollisions.allocate(tmp2DBox);\n    }\n\n    // Glyphs arrangement have been changed remove text buffer object which needs to be\n    // re-created.\n    if (measureText) {\n        label.textBufferObject = undefined;\n        label.bounds = label.bounds ? label.bounds.copy(labelBounds) : labelBounds.clone();\n    } else {\n        // Override text canvas layout style for placement.\n        applyTextPlacement(textCanvas, placement);\n    }\n\n    // Save current placement in label state.\n    // TextElementState creates layout snapshot solely for alternative placements which saves\n    // memory that could be wasted on unnecessary objects construction.\n    labelState.textPlacement = placement;\n\n    return PlacementResult.Ok;\n}\n\n/**\n * Applied modified text layout style to TextCanvas for further use.\n * @param textCanvas - TextCanvas reference.\n * @param placement - The text placement to be used.\n */\nfunction applyTextPlacement(textCanvas: TextCanvas, placement: TextPlacement) {\n    // Setup TextCanvas layout settings of the new placement as it is required for further\n    // TextBufferObject creation and measurements in addText().\n    textCanvas.textLayoutStyle.horizontalAlignment = hAlignFromPlacement(placement.h);\n    textCanvas.textLayoutStyle.verticalAlignment = vAlignFromPlacement(placement.v);\n}\n\n/**\n * Places a path label along a given path on a specified text canvas.\n * @param labelState - The state of the path label to place.\n * @param textPath - The text path along which the label will be placed.\n * @param screenPosition - Position of the label in screen coordinates.\n * @param textCanvas - The text canvas where the label will be placed.\n * @param screenCollisions - Used to check collisions with other labels.\n * @returns `PlacementResult.Ok` if path label can be placed, `PlacementResult.Rejected` if there's\n * a collision or text doesn't fit into path, `PlacementResult.Invisible` if it's not visible.\n */\nexport function placePathLabel(\n    labelState: TextElementState,\n    textPath: THREE.Path,\n    screenPosition: THREE.Vector2,\n    textCanvas: TextCanvas,\n    screenCollisions: ScreenCollisions\n): PlacementResult {\n    // Recalculate the text bounds for this path label. If measurement fails, the whole\n    // label doesn't fit the path and should be discarded.\n    tmpMeasurementParams.path = textPath;\n    tmpMeasurementParams.outputCharacterBounds = tmpBoxes;\n    tmpMeasurementParams.letterCaseArray = labelState.element.glyphCaseArray!;\n\n    // TODO: HARP-7648. TextCanvas.measureText does the placement as in TextCanvas.addText but\n    // without storing the result. If the measurement succeeds, the placement work is done\n    // twice.\n    // This could be done in one step (e.g measureAndAddText). Collision test could be injected\n    // in the middle as a function.\n    if (!textCanvas.measureText(labelState.element.glyphs!, tmpBox, tmpMeasurementParams)) {\n        return PlacementResult.Rejected;\n    }\n\n    // Coarse collision check.\n    tmpCollisionBox.copy(tmpBox.translate(screenPosition));\n    if (!screenCollisions.isVisible(tmpCollisionBox)) {\n        return PlacementResult.Invisible;\n    }\n\n    let checkGlyphCollision = false;\n    let candidateBoxes: IBox[] | undefined;\n    if (!labelState.element.textMayOverlap) {\n        candidateBoxes = screenCollisions.search(tmpCollisionBox);\n        checkGlyphCollision = candidateBoxes.length > 0;\n    }\n\n    // Perform per-character collision checks.\n    tmpCollisionBoxes.length = tmpBoxes.length;\n    for (let i = 0; i < tmpBoxes.length; ++i) {\n        const glyphBox = tmpBoxes[i].translate(screenPosition);\n        let collisionBox = tmpCollisionBoxes[i];\n        if (collisionBox === undefined) {\n            collisionBox = new CollisionBox(glyphBox);\n            tmpCollisionBoxes[i] = collisionBox;\n        } else {\n            collisionBox.copy(glyphBox);\n        }\n\n        if (\n            checkGlyphCollision &&\n            screenCollisions.intersectsDetails(collisionBox, candidateBoxes!)\n        ) {\n            return PlacementResult.Rejected;\n        }\n    }\n    // Allocate collision info if needed.\n    if (labelState.element.textReservesSpace) {\n        const collisionBox = new DetailedCollisionBox(tmpCollisionBox, tmpCollisionBoxes.slice());\n        tmpCollisionBoxes.length = 0;\n        screenCollisions.allocate(collisionBox);\n    }\n    return PlacementResult.Ok;\n}\n\n/**\n * Check if a given path label is too small to be rendered.\n * @param textElement - The text element to check.\n * @param screenProjector - Used to project coordinates from world to screen space.\n * @param outScreenPoints - Label path projected to screen space.\n * @returns `true` if label is too small, `false` otherwise.\n */\nexport function isPathLabelTooSmall(\n    textElement: TextElement,\n    screenProjector: ScreenProjector,\n    outScreenPoints: THREE.Vector2[]\n): boolean {\n    assert(textElement.type === TextElementType.PathLabel);\n\n    // Get the screen points that define the label's segments and create a path with\n    // them.\n    outScreenPoints.length = 0;\n    let anyPointVisible = false;\n\n    for (const pt of textElement.points as THREE.Vector3[]) {\n        // Skip invisible points at the beginning of the path.\n        const screenPoint = anyPointVisible\n            ? screenProjector.project(pt, tmpScreenPosition)\n            : screenProjector.projectToScreen(pt, tmpScreenPosition);\n        if (screenPoint === undefined) {\n            continue;\n        }\n        anyPointVisible = true;\n\n        outScreenPoints.push(tmpScreenPosition.clone());\n    }\n\n    // TODO: (HARP-3515)\n    //      The rendering of a path label that contains just a single point that is not\n    //      visible is impossible, which is problematic with long paths.\n    //      Fix: Skip/clip the invisible points at beginning and end of the path to get\n    //      the visible part of the path.\n\n    // If not a single point is visible, skip the path\n    if (!anyPointVisible) {\n        return true;\n    }\n\n    // Check/guess if the screen box can hold a string of that length. It is important\n    // to guess that value without measuring the font first to save time.\n    const minScreenSpace = textElement.text.length * MIN_AVERAGE_CHAR_WIDTH;\n\n    tmpBox.setFromPoints(outScreenPoints);\n    const boxDiagonalSq = tmpBox.max.sub(tmpBox.min).lengthSq();\n\n    if (boxDiagonalSq < minScreenSpace * minScreenSpace) {\n        textElement.dbgPathTooSmall = true;\n        return true;\n    }\n\n    return false;\n}\n\nconst tmpOrientedBox = new OrientedBox3();\n\n/**\n * Calculates the world position of the supplied label. The label will be shifted if there is a\n * specified offsetDirection and value to shift it in.\n * @param poiLabel - The label to shift\n * @param projection - The projection, required to compute the correct direction offset for\n *                     spherical projections.\n * @param env - The environment to extract the worldOffset needed to shift the icon in world space,\n *              if configured in the style.\n * @param outWorldPosition - Preallocated vector to store the result in\n * @returns the [[outWorldPosition]] vector.\n */\nexport function getWorldPosition(\n    poiLabel: TextElement,\n    projection: Projection,\n    env: Env,\n    outWorldPosition: THREE.Vector3\n): THREE.Vector3 {\n    const worldOffsetShiftValue = getPropertyValue(\n        (poiLabel.poiInfo?.technique as PoiTechnique)?.worldOffset,\n        env\n    );\n    outWorldPosition?.copy(poiLabel.position);\n    if (\n        worldOffsetShiftValue !== null &&\n        worldOffsetShiftValue !== undefined &&\n        poiLabel.offsetDirection !== undefined\n    ) {\n        projection.localTangentSpace(poiLabel.position, tmpOrientedBox);\n        const offsetDirectionVector = tmpOrientedBox.yAxis;\n        const offsetDirectionRad = THREE.MathUtils.degToRad(poiLabel.offsetDirection);\n        // Negate to get the normal, i.e. the vector pointing to the sky.\n        offsetDirectionVector.applyAxisAngle(tmpOrientedBox.zAxis.negate(), offsetDirectionRad);\n\n        outWorldPosition.addScaledVector(tmpOrientedBox.yAxis, worldOffsetShiftValue);\n    }\n    return outWorldPosition;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { IChannel } from \"@here/harp-utils\";\n\nexport class PlacementStats {\n    totalGroups: number = 0;\n    resortedGroups: number = 0;\n    total: number = 0;\n    uninitialized: number = 0;\n    tooFar: number = 0;\n    numNotVisible: number = 0;\n    numPathTooSmall: number = 0;\n    numCannotAdd: number = 0;\n    numRenderedPoiIcons: number = 0;\n    numRenderedPoiTexts: number = 0;\n    numPoiTextsInvisible: number = 0;\n    numRenderedTextElements: number = 0;\n\n    constructor(private readonly m_logger: IChannel) {}\n\n    clear() {\n        this.totalGroups = 0;\n        this.resortedGroups = 0;\n        this.total = 0;\n        this.uninitialized = 0;\n        this.tooFar = 0;\n        this.numNotVisible = 0;\n        this.numPathTooSmall = 0;\n        this.numCannotAdd = 0;\n        this.numRenderedPoiIcons = 0;\n        this.numRenderedPoiTexts = 0;\n        this.numPoiTextsInvisible = 0;\n        this.numRenderedTextElements = 0;\n    }\n\n    log() {\n        const numNotRendered =\n            this.uninitialized +\n            this.numPoiTextsInvisible +\n            this.tooFar +\n            this.numNotVisible +\n            this.numCannotAdd;\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"Resorted groups\", this.resortedGroups);\n        this.m_logger.debug(\"Total labels\", this.total);\n        this.m_logger.debug(\"Rendered labels\", this.numRenderedTextElements);\n        this.m_logger.debug(\"Rejected labels\", numNotRendered);\n        this.m_logger.debug(\"Unitialized labels\", this.uninitialized);\n        this.m_logger.debug(\"Rendered poi icons\", this.numRenderedPoiIcons);\n        this.m_logger.debug(\"Rendered poi texts\", this.numRenderedPoiTexts);\n        this.m_logger.debug(\"Poi text invisible\", this.numPoiTextsInvisible);\n        this.m_logger.debug(\"Too far\", this.tooFar);\n        this.m_logger.debug(\"Not visible\", this.numNotVisible);\n        this.m_logger.debug(\"Path too small\", this.numPathTooSmall);\n        this.m_logger.debug(\"Rejected, max glyphs reached\", this.numCannotAdd);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert, MathUtils } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\n/**\n * State of fading.\n */\nexport enum FadingState {\n    Undefined = 0,\n    FadingIn = 1,\n    FadedIn = 2,\n    FadingOut = -1,\n    FadedOut = -2\n}\n\n/**\n * Time to fade in/fade out the labels in milliseconds.\n */\nexport const DEFAULT_FADE_TIME = 800;\n\n/**\n * State of rendering of the icon and text part of the `TextElement`. Mainly for fading the elements\n * in and out, to compute the opacity.\n *\n * @hidden\n */\nexport class RenderState {\n    /**\n     * Current fading value [0..1]\n     */\n    value: number = 0.0;\n\n    /**\n     * Timestamp the fading started.\n     */\n    startTime: number = 0;\n\n    /**\n     * Computed opacity depending on value.\n     */\n    opacity: number = 0.0;\n\n    private m_state = FadingState.Undefined;\n\n    /**\n     * Create a `RenderState`.\n     *\n     * @param fadeTime - The duration of the fading in milliseconds.\n     */\n    constructor(public fadeTime = DEFAULT_FADE_TIME) {}\n\n    /**\n     * Reset existing `RenderState` to appear like a fresh state.\n     */\n    reset() {\n        this.m_state = FadingState.Undefined;\n        this.value = 0.0;\n        this.startTime = 0.0;\n        this.opacity = 0.0;\n    }\n\n    /**\n     * @returns `true` if element state is `FadingState.Undefined`.\n     */\n    isUndefined(): boolean {\n        return this.m_state === FadingState.Undefined;\n    }\n\n    /**\n     * @returns `true` if element is either fading in or fading out.\n     */\n    isFading(): boolean {\n        const fading =\n            this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadingOut;\n        return fading;\n    }\n\n    /**\n     * @returns `true` if element is fading in.\n     */\n    isFadingIn(): boolean {\n        const fadingIn = this.m_state === FadingState.FadingIn;\n        return fadingIn;\n    }\n\n    /**\n     * @returns `true` if element is fading out.\n     */\n    isFadingOut(): boolean {\n        const fadingOut = this.m_state === FadingState.FadingOut;\n        return fadingOut;\n    }\n\n    /**\n     * @returns `true` if element is done with fading in.\n     */\n    isFadedIn(): boolean {\n        const fadedIn = this.m_state === FadingState.FadedIn;\n        return fadedIn;\n    }\n\n    /**\n     * @returns `true` if element is done with fading out.\n     */\n    isFadedOut(): boolean {\n        const fadedOut = this.m_state === FadingState.FadedOut;\n        return fadedOut;\n    }\n\n    /**\n     * @returns `true` if state is neither faded out nor undefined and the opacity is larger\n     * than 0.\n     */\n    isVisible(): boolean {\n        return (\n            this.m_state !== FadingState.FadedOut &&\n            this.m_state !== FadingState.Undefined &&\n            this.opacity > 0\n        );\n    }\n\n    /**\n     * Updates the state to [[FadingState.FadingIn]].\n     * If previous state is [[FadingState.FadingIn]] or [[FadingState.FadedIn]] it remains\n     * unchanged.\n     *\n     * @param time - Current time.\n     * @param disableFading - Optional flag to disable fading.\n     */\n    startFadeIn(time: number, disableFading?: boolean) {\n        if (this.m_state === FadingState.FadingIn || this.m_state === FadingState.FadedIn) {\n            return;\n        }\n\n        if (disableFading === true) {\n            this.value = 1;\n            this.opacity = 1;\n            this.m_state = FadingState.FadedIn;\n            this.startTime = time;\n\n            return;\n        }\n\n        if (this.m_state === FadingState.FadingOut) {\n            // The fadeout is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.value = 1.0 - this.value;\n            this.startTime = time - this.value * this.fadeTime;\n        } else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 0;\n        }\n\n        this.m_state = FadingState.FadingIn;\n    }\n\n    /**\n     * Updates the state to [[FadingState.FadingOut]].\n     * If previous state is [[FadingState.FadingOut]], [[FadingState.FadedOut]] or\n     * [[FadingState.Undefined]] it remains unchanged.\n     *\n     * @param time - Current time.\n     */\n    startFadeOut(time: number) {\n        if (\n            this.m_state === FadingState.FadingOut ||\n            this.m_state === FadingState.FadedOut ||\n            this.m_state === FadingState.Undefined\n        ) {\n            return;\n        }\n\n        if (this.m_state === FadingState.FadingIn) {\n            // The fade-in is not complete: compute the virtual fadingStartTime in the past, to get\n            // a correct end time:\n            this.startTime = time - this.value * this.fadeTime;\n            this.value = 1.0 - this.value;\n        } else {\n            this.startTime = time;\n            this.value = 0.0;\n            this.opacity = 1;\n        }\n\n        this.m_state = FadingState.FadingOut;\n    }\n\n    /**\n     * Updates opacity to current time, changing the state to [[FadingState.FadedOut]] or\n     * [[FadingState.FadedIn]] when the opacity becomes 0 or 1 respectively.\n     * It does nothing if [[isFading]] !== `true`.\n     *\n     * @param time - Current time.\n     * @param disableFading - `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time: number, disableFading: boolean): void {\n        if (this.m_state !== FadingState.FadingIn && this.m_state !== FadingState.FadingOut) {\n            return;\n        }\n\n        if (this.startTime === 0) {\n            this.startTime = time;\n        }\n\n        const fadingTime = time - this.startTime;\n        const startValue = this.m_state === FadingState.FadingIn ? 0 : 1;\n        const endValue = this.m_state === FadingState.FadingIn ? 1 : 0;\n\n        if (disableFading || fadingTime >= this.fadeTime) {\n            this.value = 1.0;\n            this.opacity = endValue;\n            this.m_state =\n                this.m_state === FadingState.FadingIn ? FadingState.FadedIn : FadingState.FadedOut;\n        } else {\n            // TODO: HARP-7648. Do this once for all labels (calculate the last frame value\n            // increment).\n            this.value = fadingTime / this.fadeTime;\n\n            this.opacity = THREE.MathUtils.clamp(\n                MathUtils.smootherStep(startValue, endValue, this.value),\n                0,\n                1\n            );\n            assert(this.isFading());\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * @hidden\n */\nexport class SimpleLineCurve extends THREE.LineCurve {\n    private m_lengths?: number[];\n\n    constructor(v1: THREE.Vector2, v2: THREE.Vector2) {\n        super(v1, v2);\n    }\n\n    getLengths(): number[] {\n        if (this.m_lengths === undefined) {\n            this.m_lengths = [0, this.v2.distanceTo(this.v1)];\n        }\n        return this.m_lengths;\n    }\n}\n\n/**\n * @hidden\n */\nexport class PathParam {\n    private m_point: THREE.Vector2 | undefined;\n\n    constructor(readonly path: THREE.Path, readonly index: number, readonly t: number) {}\n\n    get curve(): THREE.Curve<THREE.Vector2> {\n        return this.path.curves[this.index];\n    }\n\n    get point(): THREE.Vector2 {\n        if (this.m_point === undefined) {\n            this.m_point = this.curve.getPoint(this.t);\n        }\n        return this.m_point;\n    }\n}\n\n/**\n * @hidden\n */\nexport class SimplePath extends THREE.Path {\n    private m_cache?: number[];\n\n    constructor() {\n        super();\n    }\n\n    getLengths(): number[] {\n        if (this.m_cache) {\n            return this.m_cache;\n        }\n        let sum = 0;\n        const lengths = new Array<number>();\n        lengths.push(0);\n\n        this.curves.forEach(curve => {\n            const lineCurve = curve as THREE.LineCurve;\n            sum += lineCurve.v1.distanceTo(lineCurve.v2);\n            lengths.push(sum);\n        });\n        this.m_cache = lengths;\n        return lengths;\n    }\n\n    getParamAt(t: number): PathParam | null {\n        const distance = t * this.getLength();\n        const curveLengths = this.getCurveLengths();\n\n        for (let index = 0; index < curveLengths.length; ++index) {\n            if (curveLengths[index] < distance) {\n                continue;\n            }\n\n            const diff = curveLengths[index] - distance;\n            const curve = this.curves[index] as THREE.LineCurve;\n            const segmentLength = curve.getLength();\n            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n            return new PathParam(this, index, u);\n        }\n\n        return null;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { FontCatalog, TextCanvas } from \"@here/harp-text-canvas\";\nimport { assert } from \"@here/harp-utils\";\n\nexport class TextCanvasFactory {\n    private m_minGlyphCount: number = 0; //Min amount of glyphs each [[TextCanvas]] layer can store.\n    private m_maxGlyphCount: number = 0; //Max amount of glyphs each [[TextCanvas]] layer can store.\n\n    /**\n     * Creates an instance of text canvas factory.\n     * @param m_renderer -\n     */\n    constructor(private readonly m_renderer: THREE.WebGLRenderer) {}\n\n    setGlyphCountLimits(min: number, max: number) {\n        this.m_minGlyphCount = min;\n        this.m_maxGlyphCount = max;\n    }\n\n    /**\n     * Creates text canvas\n     * @param fontCatalog - Initial [[FontCatalog]].\n     * @param name - Optional name for the TextCavas\n     */\n    createTextCanvas(fontCatalog: FontCatalog, name?: string): TextCanvas {\n        assert(this.m_maxGlyphCount > 0);\n\n        return new TextCanvas({\n            renderer: this.m_renderer,\n            fontCatalog,\n            minGlyphCount: this.m_minGlyphCount,\n            maxGlyphCount: this.m_maxGlyphCount,\n            name\n        });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    GeometryKind,\n    GeometryKindSet,\n    ImageTexture,\n    LineMarkerTechnique,\n    PoiStackMode,\n    PoiTechnique\n} from \"@here/harp-datasource-protocol\";\nimport {\n    GlyphData,\n    TextBufferObject,\n    TextLayoutParameters,\n    TextLayoutStyle,\n    TextRenderParameters,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport { Math2D } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { ImageItem } from \"../image/Image\";\nimport { PickResult } from \"../PickHandler\";\nimport { PoiBuffer } from \"../poi/PoiRenderer\";\nimport { TextElementType } from \"./TextElementType\";\n\n/**\n * Additional information for an icon that is to be rendered along with a {@link TextElement}.\n * @internal\n */\nexport interface PoiInfo {\n    /**\n     * Technique defining the POI or LineMarker\n     */\n    technique: PoiTechnique | LineMarkerTechnique;\n\n    /**\n     * Name of the {@link @here/harp-datasource-protocol#ImageTexture} or image in\n     * {@link @here/harp-mapview#userImageCache}.\n     */\n    imageTextureName?: string;\n\n    /**\n     * Icon color override\n     *\n     * @see {@link @here/harp-datasource-protocol#MarkerTechniqueParams.iconColor};\n     */\n    iconColor?: THREE.Color;\n\n    /**\n     * Icon brightness.\n     *\n     * @see {@link @here/harp-datasource-protocol#MarkerTechniqueParams.iconBrightness};\n     */\n    iconBrightness?: number;\n\n    /**\n     * Name of the POI table {@link PoiTable}.\n     */\n    poiTableName?: string;\n\n    /**\n     * Name of the POI description in the {@link PoiTable}.\n     */\n    poiName?: string;\n\n    /**\n     * Specify stack mode. Defaults to `ShowInStack`.\n     */\n    stackMode?: PoiStackMode;\n\n    /**\n     * Minimum zoomLevel at which to display the label icon. No default.\n     */\n    iconMinZoomLevel?: number;\n\n    /**\n     * Maximum zoomLevel at which to display the label icon. No default.\n     */\n    iconMaxZoomLevel?: number;\n\n    /**\n     * Minimum zoomLevel at which to display the label text. No default.\n     */\n    textMinZoomLevel?: number;\n\n    /**\n     * Maximum zoomLevel at which to display the label text. No default.\n     */\n    textMaxZoomLevel?: number;\n\n    /**\n     * If true, the text icon will appear even if the text part is blocked by other labels. Defaults\n     * to `false`.\n     */\n    textIsOptional?: boolean;\n\n    /**\n     * If true, the text will appear even if the icon is blocked by other labels or if it cannot be\n     * rendered because of missing icon graphics. Defaults to `false`.\n     */\n    iconIsOptional?: boolean;\n\n    /**\n     * If `true`, icon is allowed to overlap other labels or icons of lower priority.\n     */\n    mayOverlap?: boolean;\n\n    /**\n     * If `true`, icon will reserve screen space, other markers of lower priority will not be\n     * able to overlap.\n     */\n    reserveSpace?: boolean;\n\n    /**\n     * If isValid is `false`, the icon will no longer be placed or rendered. The reason may be a\n     * missing resource. Defaults to `false`.\n     */\n    isValid?: boolean;\n\n    /**\n     * Reference back to owning {@link TextElement}.\n     */\n    textElement: TextElement;\n\n    /**\n     * @hidden\n     * If false, text will not be rendered during camera movements. Defaults to `true`.\n     */\n    renderTextDuringMovements?: boolean;\n\n    /**\n     * @hidden\n     * Direct access to {@link ImageItem} once it is resolved or `null` if not resolvable.\n     */\n    imageItem?: ImageItem | null;\n\n    /**\n     * @hidden\n     * Direct access to {@link @here/harp-datasource-protocol#ImageTexture} once it is resolved.\n     */\n    imageTexture?: ImageTexture;\n\n    /**\n     * @hidden\n     * Layout help: A shield group is for all [[LineMarker]]s that have the same icon and text,\n     * making them the same road shield icon.\n     */\n    shieldGroupIndex?: number;\n\n    /**\n     * @hidden\n     * Internal reference to a render batch, made up of all icons that use the same Material.\n     */\n    buffer?: PoiBuffer;\n\n    /**\n     * @hidden\n     * Should be computed during loading/initializing of `ImageTexture`.\n     */\n    computedWidth?: number;\n\n    /**\n     * @hidden\n     * Should be computed during loading/initializing of `ImageTexture`.\n     */\n    computedHeight?: number;\n\n    /**\n     * @hidden\n     * Should be computed during loading/initializing of `ImageTexture`.\n     */\n    uvBox?: Math2D.UvBox;\n\n    /**\n     * @hidden\n     * Computed from owning {@link TextElement}. Value is set when `PoiInfo` is assigned to\n     * {@link TextElement}.\n     */\n    renderOrder?: number;\n}\n\n/**\n * Return 'true' if the POI has been successfully prepared for rendering.\n *\n * @param poiInfo - PoiInfo containing information for rendering the POI icon.\n * @internal\n */\nexport function poiIsRenderable(poiInfo: PoiInfo): boolean {\n    return poiInfo.buffer !== undefined;\n}\n\nexport interface TextPickResult extends PickResult {\n    /**\n     * Text of the picked {@link TextElement}\n     */\n    text?: string;\n}\n\n/**\n * State of loading.\n */\nexport enum LoadingState {\n    Requested,\n    Loaded,\n    Initialized\n}\n\n/**\n * `TextElement` is used to create 2D text elements (for example, labels).\n * @internal\n */\nexport class TextElement {\n    /**\n     * Text elements with this priority are placed on screen before any others.\n     */\n    static readonly HIGHEST_PRIORITY = Number.MAX_SAFE_INTEGER;\n\n    /**\n     * Determines visibility. If set to `false`, it will not be rendered.\n     */\n    visible: boolean = true;\n\n    /**\n     * Determines minimum zoom level for visibility. Can be used to reduce the number of visible\n     * `TextElement`s based on zoom level.\n     */\n    minZoomLevel?: number;\n    /**\n     * Determines maximum zoom level for visibility. Can be used to reduce the number of visible\n     * `TextElement`s based on zoom level.\n     */\n    maxZoomLevel?: number;\n\n    /**\n     * If `true`, label is allowed to overlap other labels or icons of lower priority.\n     * @default `false`\n     */\n    mayOverlap?: boolean;\n\n    /**\n     * If `true`, label will reserve screen space, other markers of lower priority will not be\n     * able to overlap.\n     * @default `true`\n     */\n    reserveSpace?: boolean;\n\n    /**\n     * If `true`, the label will always be rendered on top. If overlapping with other labels, the\n     * render order is undefined;\n     * @default `false`\n     */\n    alwaysOnTop?: boolean;\n\n    /**\n     * Ignore distance limit. Used for label in labeled-icons.\n     */\n    ignoreDistance?: boolean;\n\n    /**\n     * Scaling factor of text. Defaults to 0.5, reducing the size ot 50% in the distance.\n     */\n    distanceScale: number = 0.5;\n\n    /**\n     * Optional user data. Will be retrieved during picking.\n     */\n    userData?: any;\n\n    /**\n     * If specified, determines the render order between `TextElement`s. The number different\n     * renderOrders should be as small as possible, because every specific `renderOrder` may result\n     * in one or more draw calls.\n     *\n     * TextElements with the same integer `renderOrder` will be rendered in the same batch.\n     *\n     * The `renderOrder` of `TextElement`s are only relative to other `TextElement`s, and not other\n     * map elements.\n     *\n     * A `TextElement` with a higher `renderOrder` will be rendered after a `TextElement` with a\n     * lower `renderOrder`.\n     */\n    renderOrder: number = 0;\n\n    /**\n     * Specified kind of geometry. One kind is set as default in the technique, and can be\n     * overridden in the style.\n     */\n    kind?: GeometryKind | GeometryKindSet;\n\n    /**\n     * @hidden\n     * Used during rendering.\n     */\n    loadingState?: LoadingState;\n\n    /**\n     * If set to `true` the geometry has been already overlaid on elevation.\n     */\n    elevated: boolean = false;\n\n    /**\n     * @hidden\n     * Array storing the style {@link @here/harp-text-canvas#GlyphData} for\n     * this `TextElement` to speed up label placement in\n     * {@link TextElementsRenderer}. Valid after `loadingState` is `Initialized`.\n     */\n    glyphs?: GlyphData[];\n\n    /**\n     * @hidden\n     * Array storing the casing (`true`: uppercase, `false`: lowercase)\n     * for this `TextElement`.\n     * Used by labels in {@link TextElementsRenderer} to support\n     * `SmallCaps`. Valid after `loadingState`\n     * is `Initialized`.\n     */\n    glyphCaseArray?: boolean[];\n\n    /**\n     * Screen space bounds for this `TextElement`.\n     *\n     * @remarks\n     * Used by point labels in {@link TextElementsRenderer}.\n     * Valid after `loadingState` is `Initialized`.\n     */\n    bounds?: THREE.Box2;\n\n    /**\n     * @hidden\n     * Pre-computed text vertex buffer. Used by point labels in {@link TextElementsRenderer}. Valid\n     * after label becomes visible for the first time.\n     */\n    textBufferObject?: TextBufferObject;\n\n    /**\n     * @hidden\n     * If `true`, the estimated bounding box of the path is too small for the label to fit, so it is\n     * being ignored for rendering in the latest frame.\n     */\n    dbgPathTooSmall?: boolean;\n\n    pathLengthSqr?: number;\n\n    /**\n     * Time to fade in text in milliseconds.\n     * @default [[DEFAULT_FADE_TIME]] 800\n     */\n    textFadeTime?: number;\n\n    type: TextElementType;\n\n    private m_poiInfo?: PoiInfo;\n\n    private m_renderStyle?: TextRenderStyle;\n\n    private m_layoutStyle?: TextLayoutStyle;\n\n    /**\n     * Creates a new `TextElement`.\n     *\n     * @param text - The text to display.\n     * @param points - The position or a list of points for a curved text, both in world space.\n     * @param renderParams - `TextElement` text rendering parameters.\n     * @param layoutParams - `TextElement` text layout parameters.\n     * @param priority - The priority of the `TextElement. Elements with the highest priority get\n     *              placed first, elements with priority of `0` are placed last, elements with a\n     *              negative value are always rendered, ignoring priorities and allowing overrides.\n     * @param xOffset - Optional X offset of this `TextElement` in screen coordinates.\n     * @param yOffset - Optional Y offset of this `TextElement` in screen coordinates.\n     * @param featureId - Optional string to identify feature (originated from {@link DataSource}).\n     *                  Number ids are deprecated in favor of strings.\n     * @param fadeNear - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label starts fading out (opacity decreases).\n     * @param fadeFar - Distance to the camera (0.0 = camera position, 1.0 = farPlane) at which the\n     *              label becomes transparent. A value of <= 0.0 disables fading.\n     * @param offsetDirection - Direction represented as an angle in degrees clockwise from north to\n     * offset the icon in world space.\n     */\n    constructor(\n        readonly text: string,\n        readonly points: THREE.Vector3[] | THREE.Vector3,\n        readonly renderParams: TextRenderParameters | TextRenderStyle,\n        readonly layoutParams: TextLayoutParameters | TextLayoutStyle,\n        public priority = 0,\n        public xOffset: number = 0,\n        public yOffset: number = 0,\n        public featureId?: string | number,\n        public style?: string,\n        public fadeNear?: number,\n        public fadeFar?: number,\n        readonly tileOffset?: number,\n        readonly offsetDirection?: number,\n        readonly dataSourceName?: string,\n        readonly dataSourceOrder?: number\n    ) {\n        if (renderParams instanceof TextRenderStyle) {\n            this.renderStyle = renderParams;\n        }\n        if (layoutParams instanceof TextLayoutStyle) {\n            this.layoutStyle = layoutParams;\n        }\n\n        this.type =\n            points instanceof THREE.Vector3 ? TextElementType.PoiLabel : TextElementType.PathLabel;\n    }\n\n    /**\n     * The text element position or the first point of the path used to render a curved text, both\n     * in world space.\n     */\n    get position(): THREE.Vector3 {\n        if (this.points instanceof Array) {\n            const p = this.points[0];\n            return p;\n        }\n        return this.points as THREE.Vector3;\n    }\n\n    /**\n     * The list of points in world space used to render the text along a path or `undefined`.\n     */\n    get path(): THREE.Vector3[] | undefined {\n        if (this.points instanceof Array) {\n            return this.points;\n        }\n        return undefined;\n    }\n\n    /**\n     * If `true`, `TextElement` is allowed to overlap other labels or icons of lower priority.\n     *\n     * @default `false`\n     */\n    get textMayOverlap(): boolean {\n        return this.mayOverlap === true;\n    }\n\n    set textMayOverlap(mayOverlap: boolean) {\n        this.mayOverlap = mayOverlap;\n    }\n\n    /**\n     * If `true`, `TextElement` will reserve screen space, other markers of lower priority will not\n     * be able to overlap.\n     *\n     * @default `true`\n     */\n    get textReservesSpace(): boolean {\n        return this.reserveSpace !== false;\n    }\n\n    set textReservesSpace(reserveSpace: boolean) {\n        this.reserveSpace = reserveSpace;\n    }\n\n    /**\n     * Contains additional information about icon to be rendered along with text.\n     */\n    get poiInfo(): PoiInfo | undefined {\n        return this.m_poiInfo;\n    }\n\n    set poiInfo(poiInfo: PoiInfo | undefined) {\n        this.m_poiInfo = poiInfo;\n        if (poiInfo !== undefined) {\n            if (this.path !== undefined) {\n                this.type = TextElementType.LineMarker;\n            }\n            const poiRenderOrder = this.renderOrder !== undefined ? this.renderOrder : 0;\n            poiInfo.renderOrder = poiRenderOrder;\n        }\n    }\n\n    /**\n     * @returns The style used to render this text element, undefined if not set yet.\n     */\n    get renderStyle(): TextRenderStyle | undefined {\n        return this.m_renderStyle;\n    }\n\n    /**\n     * Sets style used for text rendering.\n     * @param style - The style to use.\n     */\n    set renderStyle(style: TextRenderStyle | undefined) {\n        this.m_renderStyle = style;\n    }\n\n    /**\n     * @returns The style used to layout this text element, undefined if not set yet.\n     */\n    get layoutStyle(): TextLayoutStyle | undefined {\n        return this.m_layoutStyle;\n    }\n\n    /**\n     * Sets the style used for text layout.\n     * @param style - The style to use.\n     */\n    set layoutStyle(style: TextLayoutStyle | undefined) {\n        this.m_layoutStyle = style;\n    }\n\n    /**\n     * @returns Whether this text element has a valid feature id.\n     */\n    hasFeatureId(): boolean {\n        if (this.featureId === undefined) {\n            return false;\n        }\n\n        if (typeof this.featureId === \"number\") {\n            return this.featureId !== 0;\n        }\n\n        return this.featureId.length > 0;\n    }\n\n    /**\n     * Disposes of any allocated resources.\n     */\n    dispose() {\n        const poiBuffer = this.poiInfo?.buffer;\n        if (poiBuffer) {\n            poiBuffer.decreaseRefCount();\n        }\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    AttributeMap,\n    Env,\n    getFeatureId,\n    getPropertyValue,\n    IndexedTechniqueParams,\n    isTextTechnique,\n    LineMarkerTechnique,\n    MapEnv,\n    PoiTechnique,\n    TextTechnique\n} from \"@here/harp-datasource-protocol\";\nimport {\n    ContextualArabicConverter,\n    TextLayoutStyle,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport { assert, LoggerManager, MathUtils } from \"@here/harp-utils\";\n\nimport { PoiBuilder } from \"../poi/PoiBuilder\";\nimport { TextElement } from \"./TextElement\";\nimport { DEFAULT_TEXT_DISTANCE_SCALE } from \"./TextElementsRenderer\";\nimport { TileTextStyleCache } from \"./TileTextStyleCache\";\n\nconst logger = LoggerManager.instance.create(\"TextElementBuilder\");\n\n/**\n * Constructs {@link TextElement} objects from {@link @here/harp-datasource-protocol/Technique},\n * text, coordinates and optional icon.\n */\nexport class TextElementBuilder {\n    private m_priority?: number;\n    private m_fadeNear?: number;\n    private m_fadeFar?: number;\n    private m_minZoomLevel?: number;\n    private m_maxZoomLevel?: number;\n    private m_distanceScale: number = DEFAULT_TEXT_DISTANCE_SCALE;\n    private m_mayOverlap?: boolean;\n    private m_reserveSpace?: boolean;\n    private m_renderStyle?: TextRenderStyle;\n    private m_layoutStype?: TextLayoutStyle;\n    private m_technique?: (PoiTechnique | LineMarkerTechnique | TextTechnique) &\n        IndexedTechniqueParams;\n\n    private m_renderOrder: number;\n    private m_xOffset?: number;\n    private m_yOffset?: number;\n    private m_poiBuilder?: PoiBuilder;\n    private m_alwaysOnTop?: boolean;\n\n    // Upper bound for render order values coming from a technique. The lowest upper bound\n    // (`renderOrderUpBound`) will be smaller if `baseRenderOrder` is not an integer.\n    static readonly RENDER_ORDER_UP_BOUND = 1e7;\n\n    // Lowest upper bound for render order values, taking into account the `baseRenderOrder` given\n    // at construction.\n    readonly renderOrderUpBound: number;\n\n    /**\n     * Aligns a {@link TextElement}'s minZoomLevel and maxZoomLevel with values set in\n     * {@link PoiInfo}.\n     * @remarks Selects the smaller/larger one of the two min/max values for icon and text, because\n     * the TextElement is a container for both.\n     * @param textElement - The {@link TextElement} whose zoom level ranges will be aligned.\n     */\n    static alignZoomLevelRanges(textElement: TextElement): void {\n        if (!textElement.poiInfo) {\n            return;\n        }\n        const poiInfo = textElement.poiInfo;\n\n        textElement.minZoomLevel =\n            textElement.minZoomLevel ??\n            MathUtils.min2(poiInfo.iconMinZoomLevel, poiInfo.textMinZoomLevel);\n\n        textElement.maxZoomLevel =\n            textElement.maxZoomLevel ??\n            MathUtils.max2(poiInfo.iconMaxZoomLevel, poiInfo.textMaxZoomLevel);\n    }\n\n    /**\n     * Combines two render order numbers into a single one.\n     * @param baseRenderOrder - The most significative part of the render order.\n     * @param offset - The least significative part of the render order. It must be within the\n     * interval (-RENDER_ORDER_UP_BOUND, RENDER_ORDER_UP_BOUND).\n     * @return The combined render order.\n     */\n    static composeRenderOrder(baseRenderOrder: number, offset: number): number {\n        return baseRenderOrder * TextElementBuilder.RENDER_ORDER_UP_BOUND + offset;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param m_env - The {@link @link @here/harp-datasource-protocol#MapEnv} used to evaluate\n     * technique properties.\n     * @param m_styleCache - To cache instances of {@link @here/harp-text-canvas/TextRenderStyle}\n     * and {@link @here/harp-text-canvas/TextLayoutStyle}.\n     */\n    constructor(\n        private readonly m_env: MapEnv | Env,\n        private readonly m_styleCache: TileTextStyleCache,\n        private readonly m_baseRenderOrder: number\n    ) {\n        this.m_renderOrder = m_baseRenderOrder;\n\n        if (Number.isInteger(m_baseRenderOrder)) {\n            this.renderOrderUpBound = TextElementBuilder.RENDER_ORDER_UP_BOUND;\n        } else {\n            // If base render order is not an integer, lower render order upper bound to leave room\n            // for the decimal places.\n            const absBaseRenderOrder = Math.abs(m_baseRenderOrder);\n            this.renderOrderUpBound =\n                (absBaseRenderOrder - Math.floor(absBaseRenderOrder)) *\n                TextElementBuilder.RENDER_ORDER_UP_BOUND;\n        }\n\n        if (!this.isValidRenderOrder(m_baseRenderOrder)) {\n            logger.warn(\n                `Large base render order (${m_baseRenderOrder}) might cause precision issues.`\n            );\n        }\n    }\n\n    /**\n     * Sets a technique that will be used to create text elements on subsequent calls to\n     * {@link TextElementBuilder.build} until the next call to this method.\n     *\n     * @param technique - The {@link @here/harp-datasource-protocol/Technique}.\n     * @return This builder.\n     */\n    withTechnique(\n        technique: (PoiTechnique | LineMarkerTechnique | TextTechnique) & IndexedTechniqueParams\n    ): this {\n        this.m_technique = technique;\n\n        // Make sorting stable.\n        this.m_priority = getPropertyValue(technique.priority, this.m_env) ?? 0;\n\n        this.m_fadeNear = getPropertyValue(technique.fadeNear, this.m_env) ?? undefined;\n        this.m_fadeFar = getPropertyValue(technique.fadeFar, this.m_env) ?? undefined;\n        this.m_minZoomLevel = getPropertyValue(technique.minZoomLevel, this.m_env) ?? undefined;\n        this.m_maxZoomLevel = getPropertyValue(technique.maxZoomLevel, this.m_env) ?? undefined;\n        this.m_distanceScale = technique.distanceScale ?? DEFAULT_TEXT_DISTANCE_SCALE;\n        this.m_renderStyle = this.m_styleCache.getRenderStyle(technique);\n        this.m_layoutStype = this.m_styleCache.getLayoutStyle(technique);\n        this.m_xOffset = getPropertyValue(technique.xOffset, this.m_env);\n        this.m_yOffset = getPropertyValue(technique.yOffset, this.m_env);\n\n        const techniqueRenderOrder = getPropertyValue(technique.renderOrder, this.m_env) ?? 0;\n\n        if (!this.isValidRenderOrder(techniqueRenderOrder)) {\n            const msg = `Unsupported large render order (${techniqueRenderOrder})`;\n            logger.error(msg);\n            assert(false, msg);\n        }\n        this.m_renderOrder = TextElementBuilder.composeRenderOrder(\n            this.m_baseRenderOrder,\n            techniqueRenderOrder\n        );\n\n        if (isTextTechnique(technique)) {\n            this.withTextTechnique(technique);\n        } else {\n            this.withPoiTechnique(technique);\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets an icon that will be used to create text elements on subsequent calls to\n     * {@link TextElementBuilder.build} until the next call to this method.\n     *\n     * @param imageTextureName - The name of the icon image.\n     * @param shieldGroupIndex - Index to the shield group.\n     * @return This builder.\n     */\n    withIcon(imageTextureName?: string, shieldGroupIndex?: number): this {\n        assert(this.m_poiBuilder !== undefined);\n        this.m_poiBuilder!.withIcon(imageTextureName, shieldGroupIndex);\n\n        return this;\n    }\n\n    /**\n     * Creates a {@link TextElement} with the given properties.\n     *\n     * @param text - The text to be displayed.\n     * @param points - The position(s) for the text element.\n     * @param tileOffset - The TextElement's tile offset, see {@link Tile.offset}.\n     * @param dataSourceName - The name of the data source.\n     * @param attributes - TextElement attribute map.\n     * @param pathLengthSqr - Precomputed path length squared for path labels.\n     * @return The created text element.\n     */\n    build(\n        text: string,\n        points: THREE.Vector3 | THREE.Vector3[],\n        tileOffset: number,\n        dataSourceName: string,\n        dataSourceOrder: number,\n        attributes?: AttributeMap,\n        pathLengthSqr?: number,\n        offsetDirection?: number\n    ): TextElement {\n        const featureId = getFeatureId(attributes);\n        assert(this.m_technique !== undefined);\n        assert(this.m_renderStyle !== undefined);\n        assert(this.m_layoutStype !== undefined);\n\n        const technique = this.m_technique!;\n        const renderStyle = this.m_renderStyle!;\n        const layoutStyle = this.m_layoutStype!;\n\n        const textElement = new TextElement(\n            ContextualArabicConverter.instance.convert(text),\n            points,\n            renderStyle,\n            layoutStyle,\n            this.m_priority,\n            this.m_xOffset,\n            this.m_yOffset,\n            featureId,\n            technique.style,\n            this.m_fadeNear,\n            this.m_fadeFar,\n            tileOffset,\n            offsetDirection,\n            dataSourceName,\n            dataSourceOrder\n        );\n        textElement.minZoomLevel = this.m_minZoomLevel;\n        textElement.maxZoomLevel = this.m_maxZoomLevel;\n        textElement.distanceScale = this.m_distanceScale;\n        textElement.mayOverlap = this.m_mayOverlap;\n        textElement.reserveSpace = this.m_reserveSpace;\n        textElement.kind = technique.kind;\n        // Get the userData for text element picking.\n        textElement.userData = attributes;\n        textElement.textFadeTime =\n            technique.textFadeTime !== undefined ? technique.textFadeTime * 1000 : undefined;\n        textElement.pathLengthSqr = pathLengthSqr;\n        textElement.alwaysOnTop = this.m_alwaysOnTop;\n        textElement.renderOrder = this.m_renderOrder;\n\n        textElement.poiInfo = this.m_poiBuilder?.build(textElement);\n        TextElementBuilder.alignZoomLevelRanges(textElement);\n\n        return textElement;\n    }\n\n    private withTextTechnique(technique: TextTechnique & IndexedTechniqueParams) {\n        this.m_mayOverlap = technique.mayOverlap === true;\n        this.m_reserveSpace = technique.reserveSpace !== false;\n        this.m_poiBuilder = undefined;\n    }\n\n    private withPoiTechnique(\n        technique: (PoiTechnique | LineMarkerTechnique) & IndexedTechniqueParams\n    ) {\n        this.m_mayOverlap = technique.textMayOverlap === true;\n        this.m_reserveSpace = technique.textReserveSpace !== false;\n        this.m_alwaysOnTop = technique.alwaysOnTop === true;\n\n        if (!this.m_poiBuilder) {\n            this.m_poiBuilder = new PoiBuilder(this.m_env);\n        }\n        this.m_poiBuilder.withTechnique(technique);\n    }\n\n    private isValidRenderOrder(renderOrder: number) {\n        return Math.abs(renderOrder) < this.renderOrderUpBound;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { PriorityListGroup } from \"@here/harp-utils\";\n\nimport { TextElement } from \"./TextElement\";\n\n/**\n * Group of {@link TextElement} sharing same priority.\n */\nexport class TextElementGroup extends PriorityListGroup<TextElement> {}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { GroupedPriorityList } from \"@here/harp-utils\";\n\nimport { TextElement } from \"./TextElement\";\n\n/**\n * List of {@link TextElement} groups sorted by priority.\n */\nexport class TextElementGroupPriorityList extends GroupedPriorityList<TextElement> {}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { assert } from \"@here/harp-utils\";\n\nimport { TextElementGroup } from \"./TextElementGroup\";\nimport { TextElementState } from \"./TextElementState\";\nimport { TextElementType } from \"./TextElementType\";\n\n/**\n * Type of functions used to do early rejection of elements during group state creation or update.\n * @param textElementState - The state of the text element to check.\n * @returns `undefined` if element was rejected, otherwise its current view distance.\n */\nexport type TextElementFilter = (textElementState: TextElementState) => number | undefined;\n\n/**\n * `TextElementGroupState` keeps the state of a text element group and each element in it while\n * they're being rendered.\n */\nexport class TextElementGroupState {\n    private readonly m_textElementStates: TextElementState[];\n    private m_visited: boolean = false;\n\n    /**\n     * Creates the state for specified group.\n     * @param group - The group of which the state will be created.\n     * @param tileKey - The key of the tile to which this group belongs.\n     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    constructor(\n        readonly group: TextElementGroup,\n        readonly tileKey: TileKey,\n        filter: TextElementFilter\n    ) {\n        assert(group.elements.length > 0);\n        const length = group.elements.length;\n        this.m_textElementStates = [];\n        this.m_visited = true;\n\n        // TODO: HARP-7648. Reduce number of allocations here:\n        // a) Avoid creating the state for labels that don't pass early placement checks and make\n        //    this checks more strict.\n        // b) Break label state objects into a set of arrays held at group level, one for each\n        //    primitive field in the label state.\n        for (let i = 0; i < length; ++i) {\n            const textElement = group.elements[i];\n            if (textElement.type === TextElementType.LineMarker && textElement.path !== undefined) {\n                const numPoints = textElement.path.length;\n                for (let p = 0; p < numPoints; p++) {\n                    const state = new TextElementState(textElement, p);\n                    const textDistance = filter(state);\n                    state.update(textDistance);\n                    this.m_textElementStates.push(state);\n                }\n            } else {\n                const state = new TextElementState(textElement);\n                const textDistance = filter(state);\n                state.update(textDistance);\n                this.m_textElementStates.push(state);\n            }\n        }\n    }\n\n    /**\n     * Indicates whether the group has been submitted to the\n     * {@link TextElementsRenderer} in the current frame.\n     */\n    get visited(): boolean {\n        return this.m_visited;\n    }\n\n    set visited(visited: boolean) {\n        this.m_visited = visited;\n    }\n\n    /**\n     * @returns the priority of the text elements in the group.\n     */\n    get priority() {\n        return this.group.priority;\n    }\n\n    /**\n     * Updates the fading state of all text elements within the group to the specified time.\n     * @param time - The time to which the fading state will be updated.\n     * @param disableFading - `true` if fading is disabled, `false` otherwise.\n     */\n    updateFading(time: number, disableFading: boolean): void {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined) {\n                elementState.updateFading(time, disableFading);\n            }\n        }\n    }\n\n    /**\n     * Calls the specified callback for every visible text elements in the group.\n     * @param visibleElementsCallback - Functions that will be called for every visible text element\n     * in the group.\n     */\n    traverseVisibleElements(visibleElementsCallback: (e: TextElementState) => void): void {\n        for (const elementState of this.m_textElementStates) {\n            if (elementState !== undefined && elementState.visible) {\n                visibleElementsCallback(elementState);\n            }\n        }\n    }\n\n    /**\n     * Updates the states of elements within the group.\n     * @param filter - Function used to do early rejection. @see [[TextElementFilter]].\n     */\n    updateElements(filter: TextElementFilter) {\n        for (const elementState of this.m_textElementStates) {\n            const textDistance = filter(elementState);\n            elementState.update(textDistance);\n        }\n    }\n\n    get size(): number {\n        return this.m_textElementStates.length;\n    }\n\n    /**\n     * Returns text element states.\n     * @returns Array of element states.\n     */\n    get textElementStates(): TextElementState[] {\n        return this.m_textElementStates;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    hAlignFromPlacement,\n    hPlacementFromAlignment,\n    TextPlacement,\n    vAlignFromPlacement,\n    vPlacementFromAlignment\n} from \"@here/harp-text-canvas\";\nimport { assert } from \"@here/harp-utils\";\n\nimport { LayoutState } from \"./LayoutState\";\nimport { RenderState } from \"./RenderState\";\nimport { TextElement } from \"./TextElement\";\nimport { TextElementType } from \"./TextElementType\";\n\n/**\n * `TextElementState` keeps the current state of a text element while it's being rendered.\n */\nexport class TextElementState {\n    /**\n     * @hidden\n     * Used during label placement to reserve space from front to back.\n     */\n    private m_viewDistance: number | undefined;\n\n    /**\n     * @hidden\n     * Used during rendering.\n     */\n    private m_iconRenderState?: RenderState;\n\n    /**\n     * @hidden\n     * Used during rendering.\n     */\n    private m_textRenderState?: RenderState;\n    /**\n     * @hidden\n     * Used to store recently used text layout.\n     */\n    private m_textLayoutState?: LayoutState;\n    /**\n     * @hidden\n     * Stores index into path for TextElements that are of type LineMarker.\n     */\n    private readonly m_lineMarkerIndex?: number;\n\n    /**\n     *\n     * @param element - TextElement this state represents\n     * @param positionIndex - Optional index for TextElements of type LineMarker.\n     */\n    constructor(readonly element: TextElement, positionIndex?: number) {\n        this.m_lineMarkerIndex = positionIndex;\n    }\n\n    get initialized(): boolean {\n        return this.m_textRenderState !== undefined || this.m_iconRenderState !== undefined;\n    }\n\n    /**\n     * @returns `true` if any component of the element is visible, `false` otherwise.\n     */\n    get visible(): boolean {\n        if (this.m_textRenderState !== undefined && this.m_textRenderState.isVisible()) {\n            return true;\n        }\n\n        const iconRenderState = this.iconRenderState;\n        if (iconRenderState !== undefined && iconRenderState.isVisible()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Return the last text placement used.\n     *\n     * If the text wasn't yet rendered or have no alternative placements it will fallback to\n     * style/theme based placement.\n     *\n     * @returns [[TextPlacement]] object containing vertical/horizontal align.\n     */\n    get textPlacement(): TextPlacement {\n        const themeLayout = this.element.layoutStyle!;\n        const stateLayout = this.m_textLayoutState;\n        // Would be good to test for persistence when getting state layout, but with this\n        // most of the isolated placement unit tests will fail.\n        const lastPlacement =\n            stateLayout !== undefined\n                ? stateLayout.textPlacement\n                : {\n                      h: hPlacementFromAlignment(themeLayout.horizontalAlignment),\n                      v: vPlacementFromAlignment(themeLayout.verticalAlignment)\n                  };\n        return lastPlacement;\n    }\n\n    /**\n     * Set text placement to be used.\n     *\n     * This may be base text anchor placement as defined by style or alternative placement.\n     *\n     * @param placement - The new [[TextPlacement]] to be used.\n     */\n    set textPlacement(placement: TextPlacement) {\n        if (this.m_textLayoutState === undefined && this.isBaseTextPlacement(placement) === true) {\n            // Do nothing, layout state is not required cause we leave the base placement.\n            return;\n        }\n        if (this.m_textLayoutState === undefined) {\n            // State is not yet defined, but we have placement to store, either alternative or\n            // not yet specified in the context of layoutStyle.\n            this.m_textLayoutState = new LayoutState(placement);\n        } else {\n            this.m_textLayoutState.textPlacement = placement;\n        }\n    }\n\n    /**\n     * Returns information if the text placement provided is the base one defined in style (theme).\n     *\n     * @param placement - The [[TextPlacement]] to check.\n     * @returns [[true]] if the placement provided is exactly the same as in theme base layout,\n     * [[false]] if it differs from the basic layout provided in style or\n     * [[undefined]] if the layout style is not yet defined so it is hard to say.\n     */\n    isBaseTextPlacement(placement: TextPlacement): boolean | undefined {\n        const themeLayout = this.element.layoutStyle;\n        if (themeLayout !== undefined) {\n            return (\n                hAlignFromPlacement(placement.h) === themeLayout.horizontalAlignment &&\n                vAlignFromPlacement(placement.v) === themeLayout.verticalAlignment\n            );\n        }\n        return undefined;\n    }\n\n    /**\n     * Resets the element to an initialized state.\n     */\n    reset() {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.reset();\n        }\n        if (this.m_textLayoutState !== undefined) {\n            if (this.element.layoutStyle !== undefined) {\n                this.m_textLayoutState.reset(this.element.layoutStyle);\n            } else {\n                this.m_textLayoutState = undefined;\n            }\n        }\n\n        if (this.iconRenderState) {\n            (this.m_iconRenderState as RenderState).reset();\n        }\n        this.m_viewDistance = undefined;\n        this.element.textBufferObject = undefined;\n        this.element.bounds = undefined;\n    }\n\n    /**\n     * Replaces given text element, inheriting its current state.\n     * The predecessor text element state is erased.\n     * @param predecessor - Text element state to be replaced.\n     */\n    replace(predecessor: TextElementState) {\n        this.m_textRenderState = predecessor.m_textRenderState;\n        this.m_textLayoutState = predecessor.m_textLayoutState;\n        this.m_iconRenderState = predecessor.m_iconRenderState;\n        predecessor.m_textRenderState = undefined;\n        predecessor.m_textLayoutState = undefined;\n        predecessor.m_iconRenderState = undefined;\n\n        if (this.element.glyphs === undefined) {\n            // Use the predecessor glyphs and case array until proper ones are computed.\n            this.element.glyphs = predecessor.element.glyphs;\n            this.element.glyphCaseArray = predecessor.element.glyphCaseArray;\n        }\n        this.element.bounds = undefined;\n        this.element.textBufferObject = undefined;\n    }\n\n    /**\n     * Returns the last computed distance of the text element to the camera.\n     * @returns Distance to camera.\n     */\n    get viewDistance(): number | undefined {\n        return this.m_viewDistance;\n    }\n\n    /**\n     * Updates the text element state.\n     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    update(viewDistance: number | undefined) {\n        if (!this.initialized && viewDistance !== undefined) {\n            this.initializeRenderStates();\n        }\n\n        this.setViewDistance(viewDistance);\n    }\n\n    /**\n     * Sets the distance of the element to the current view center.\n     * @param viewDistance - The new view distance to set. If `undefined`, element is considered to\n     * be out of view.\n     */\n    setViewDistance(viewDistance: number | undefined) {\n        this.m_viewDistance = viewDistance;\n    }\n\n    /**\n     * Return the last distance that has been computed for sorting during placement. This may not be\n     * the actual distance if the camera is moving, as the distance is computed only during\n     * placement. If the property `alwaysOnTop` is true, the value returned is always `0`.\n     *\n     * @returns 0 or negative distance to camera.\n     */\n    get renderDistance(): number {\n        return this.element.alwaysOnTop === true\n            ? 0\n            : this.m_viewDistance !== undefined\n            ? -this.m_viewDistance\n            : 0;\n    }\n\n    /**\n     * @returns The text render state.\n     */\n    get textRenderState(): RenderState | undefined {\n        return this.m_textRenderState;\n    }\n\n    /**\n     * Returns the icon render state for the case where the text element has only one icon.\n     * @returns The icon render state if the text element has a single icon, otherwise undefined.\n     */\n    get iconRenderState(): RenderState | undefined {\n        return this.m_iconRenderState;\n    }\n\n    /**\n     * Returns the index into the path of the TextElement if the TextElement is of type LineMarker,\n     * `undefined` otherwise.\n     */\n    public get lineMarkerIndex(): number | undefined {\n        return this.m_lineMarkerIndex;\n    }\n\n    /**\n     * Returns the position of the TextElement. If this TextElementState belongs to a TextElement\n     * of type LineMarker, it returns the position of the marker at the references index in the\n     * path of the TextElement.\n     */\n    public get position(): THREE.Vector3 {\n        return this.element.path !== undefined && this.m_lineMarkerIndex !== undefined\n            ? this.element.path[this.m_lineMarkerIndex]\n            : this.element.position;\n    }\n\n    /**\n     * Updates the fading state to the specified time.\n     * @param time - The current time.\n     * @param disableFading - If `True` there will be no fading transitions, i.e., state will go\n     * directly from FadedIn to FadedOut and vice versa.\n     */\n    updateFading(time: number, disableFading: boolean): void {\n        if (this.m_textRenderState !== undefined) {\n            this.m_textRenderState.updateFading(time, disableFading);\n        }\n\n        if (this.iconRenderState !== undefined) {\n            this.iconRenderState.updateFading(time, disableFading);\n        }\n    }\n\n    /**\n     * Initialize text and icon render states\n     */\n    private initializeRenderStates() {\n        assert(this.m_textRenderState === undefined);\n        assert(this.m_textLayoutState === undefined);\n        assert(this.m_iconRenderState === undefined);\n\n        const { textFadeTime } = this.element;\n        this.m_textRenderState = new RenderState(textFadeTime);\n\n        if (\n            this.element.type === TextElementType.PoiLabel ||\n            this.element.type === TextElementType.LineMarker\n        ) {\n            // If there's no fade time for icon, use same as text to keep fading of text and icon\n            // in sync.\n            const techniqueIconFadeTime = this.element.poiInfo?.technique.iconFadeTime;\n            const iconFadeTime =\n                techniqueIconFadeTime !== undefined ? techniqueIconFadeTime * 1000 : textFadeTime;\n            this.m_iconRenderState = new RenderState(iconFadeTime);\n        }\n    }\n}\n\n/**\n * Test if the TextElement this {@link TextElementState} refers to is of type LineMarker.\n * @param state - Text element state to test.\n */\nexport function isLineMarkerElementState(state: TextElementState) {\n    return (state as any).m_lineMarkerIndex !== undefined;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { assert, LoggerManager, LogLevel } from \"@here/harp-utils\";\n\nimport { TextElement } from \"./TextElement\";\nimport { TextElementGroup } from \"./TextElementGroup\";\nimport { TextElementFilter, TextElementGroupState } from \"./TextElementGroupState\";\nimport { isLineMarkerElementState, TextElementState } from \"./TextElementState\";\nimport { TextElementType } from \"./TextElementType\";\n\nconst logger = LoggerManager.instance.create(\"TextElementsStateCache\", { level: LogLevel.Log });\n\n/**\n * Label distance tolerance squared in meters. Point labels with the same name that are closer in\n * world space than this value are treated as the same label. Used to identify duplicate labels in\n * overlapping tiles and label replacements at different storage levels.\n */\nfunction getDedupSqDistTolerance(zoomLevel: number) {\n    // Defining here a minimum tolerance of 10m at zoom level 13 or higher.\n    const minSqTol = 100;\n    const minSqTolLevel = 13;\n    const maxLevelDelta = 4;\n    const levelDelta = Math.min(\n        maxLevelDelta,\n        minSqTolLevel - Math.min(minSqTolLevel, Math.floor(zoomLevel))\n    );\n    // Distance tolerance computed applying a factor over an arbitrary minimum tolerance for a\n    // chosen zoom level. The factor is an exponential function on zoom level delta wrt minimum\n    // tolerance zoom level.\n    // error = sqrt(sqError) = sqrt(minSqError* 2^(4d)) = minError*2^(2d)\n\n    return minSqTol << (levelDelta << 2);\n}\n\nconst tmpCachedDuplicate: { entries: TextElementState[]; index: number } = {\n    entries: [],\n    index: -1\n};\n\nfunction getCacheKey(element: TextElement): string | number {\n    return element.hasFeatureId() ? element.featureId! : element.text;\n}\n\n/**\n * Finds a duplicate for a text element among a list of candidates using their feature ids.\n * @param elementState - The state of the text element for which the duplicate will be found.\n * @param candidates - The list of candidates to check.\n * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.\n */\nfunction findDuplicateById(\n    elementState: TextElementState,\n    candidates: TextElementState[]\n): number | undefined {\n    // Cached entries with same feature id found, find the entry with the same tile offset.\n    const element = elementState.element;\n    const duplicateIndex = candidates.findIndex(\n        entry => entry.element.tileOffset === element.tileOffset\n    );\n    if (duplicateIndex === -1) {\n        return -1;\n    }\n    const candidateElement = candidates[duplicateIndex];\n    const candidate = candidateElement.element;\n    assert(element.featureId === candidate.featureId);\n\n    if (candidate.text !== element.text) {\n        // Labels with different text shouldn't share the same feature id. This points to\n        // an issue on the map data side. Submit a ticket to the corresponding map backend\n        // issue tracking system if available (e.g. OLPRPS project in JIRA for OMV),\n        // indicating affected labels including tile keys, texts and feature id.\n        logger.debug(\n            `Text feature id ${element.featureId} collision between \"${element.text} and \\\n             ${candidate.text}`\n        );\n        return undefined;\n    }\n\n    return duplicateIndex;\n}\n\ntype DuplicateCmp = (\n    newCandidate: TextElement,\n    newDistance: number,\n    oldCandidate: TextElement,\n    oldDistance: number\n) => boolean;\n\n// Duplicate criteria for path labels. Candidates are better the longer their paths are.\nfunction isBetterPathDuplicate(\n    newCandidate: TextElement,\n    _newDistance: number,\n    oldCandidate: TextElement,\n    _oldDistance: number\n): boolean {\n    if (newCandidate.pathLengthSqr === undefined) {\n        return false;\n    }\n    if (oldCandidate.pathLengthSqr === undefined) {\n        return false;\n    }\n    return newCandidate.pathLengthSqr > oldCandidate.pathLengthSqr;\n}\n\n// Duplicate criteria for point labels. Candidates are better the nearer they are to the label being\n// tested for duplicates.\nfunction isBetterPointDuplicate(\n    _newCandidate: TextElement,\n    newDistance: number,\n    _oldCandidate: TextElement,\n    oldDistance: number\n): boolean {\n    return newDistance < oldDistance;\n}\n\n/**\n * Finds a duplicate for a text element among a list of candidates using their text and distances.\n * @param elementState - The state of the text element for which the duplicate will be found.\n * @param candidates - The list of candidates to check.\n * @param zoomLevel - Current zoom level.\n * @returns The index of the candidate chosen as duplicate, or `undefined` if none was found.\n */\nfunction findDuplicateByText(\n    elementState: TextElementState,\n    candidates: TextElementState[],\n    zoomLevel: number\n): number {\n    const element = elementState.element;\n    const maxSqDistError = getDedupSqDistTolerance(zoomLevel);\n    const entryCount = candidates.length;\n    const elementPosition = elementState.position;\n    const elementVisible = elementState.visible;\n    const isLineMarker = isLineMarkerElementState(elementState);\n    let dupIndex: number = -1;\n    let duplicate: TextElement | undefined;\n    let dupDistSquared: number = Infinity;\n    const isBetterDuplicate: DuplicateCmp =\n        element.type === TextElementType.PathLabel ? isBetterPathDuplicate : isBetterPointDuplicate;\n\n    for (let i = 0; i < entryCount; ++i) {\n        const candidateEntry = candidates[i];\n        const cachedElement = candidateEntry.element;\n        const areDiffType =\n            element.type !== cachedElement.type ||\n            isLineMarker !== isLineMarkerElementState(candidateEntry);\n        const areBothVisible = elementVisible && candidateEntry.visible;\n        if (areDiffType || areBothVisible) {\n            // Two text elements with different type or visible at the same time are always\n            // considered distinct.\n            continue;\n        }\n        const distSquared = elementPosition.distanceToSquared(cachedElement.position);\n        if (distSquared > maxSqDistError) {\n            // Cached text element is too far away to be a duplicate.\n            continue;\n        }\n\n        if (\n            duplicate === undefined ||\n            isBetterDuplicate(cachedElement, distSquared, duplicate, dupDistSquared)\n        ) {\n            dupIndex = i;\n            duplicate = cachedElement;\n            dupDistSquared = distSquared;\n        }\n    }\n\n    return dupIndex;\n}\n\n/**\n * Caches the state of text element groups currently rendered as well as the text element states\n * belonging to them, including their fading state and text deduplication information.\n */\nexport class TextElementStateCache {\n    private readonly m_referenceMap = new Map<TextElementGroup, TextElementGroupState>();\n    private m_sortedGroupStates: TextElementGroupState[] | undefined;\n\n    // Cache for point labels which may have duplicates in same tile or in neighboring tiles.\n    private readonly m_textMap = new Map<string | number, TextElementState[]>();\n\n    /**\n     * Gets the state corresponding to a given text element group or sets a newly created state if\n     * not found. It updates the states of the text elements belonging to the group using the\n     * specified parameters.\n     * @param textElementGroup - The group of which the state will be obtained.\n     * @param tileKey - The key of the tile to which the group belongs.\n     * @param textElementFilter - Filter used to decide if a text element must be initialized,\n     * @see [[TextElementGroupState]] construction.\n     * @returns Tuple with the group state as first element and a boolean indicating whether the\n     * state was found in cache (`true`) or newly created (`false`) as second element.\n     */\n    getOrSet(\n        textElementGroup: TextElementGroup,\n        tileKey: TileKey,\n        textElementFilter: TextElementFilter\n    ): [TextElementGroupState, boolean] {\n        let groupState = this.get(textElementGroup);\n\n        if (groupState !== undefined) {\n            groupState.updateElements(textElementFilter);\n            return [groupState, true];\n        }\n\n        groupState = new TextElementGroupState(textElementGroup, tileKey, textElementFilter);\n        this.set(textElementGroup, groupState);\n\n        return [groupState, false];\n    }\n\n    get size(): number {\n        return this.m_referenceMap.size;\n    }\n\n    /**\n     * @hidden\n     * @returns Size of internal cache for deduplication for debugging purposes.\n     */\n    get cacheSize(): number {\n        return this.m_textMap.size;\n    }\n\n    /**\n     * @returns All text element group states in the cache by group priority.\n     */\n    get sortedGroupStates(): TextElementGroupState[] {\n        if (this.m_sortedGroupStates === undefined) {\n            this.m_sortedGroupStates = Array.from(this.m_referenceMap.values());\n            this.m_sortedGroupStates.sort((a: TextElementGroupState, b: TextElementGroupState) => {\n                return b.group.priority - a.group.priority;\n            });\n        }\n\n        assert(this.m_referenceMap.size === this.m_sortedGroupStates.length);\n        return this.m_sortedGroupStates;\n    }\n\n    /**\n     * Updates state of all cached groups, discarding those that are not needed anymore.\n     * @param time - The current time.\n     * @param disableFading - `True` if fading is currently disabled, `false` otherwise.\n     * @param findReplacements - `True` to replace each visible unvisited text element with a\n     * visited duplicate.\n     * @param zoomLevel - Current zoom level.\n     * @returns `True` if any textElementGroup was evicted from cache, false otherwise.\n     */\n    update(time: number, disableFading: boolean, findReplacements: boolean, zoomLevel: number) {\n        const replaceCallback = findReplacements\n            ? this.replaceElement.bind(this, zoomLevel)\n            : undefined;\n\n        let anyEviction = false;\n        for (const [key, groupState] of this.m_referenceMap.entries()) {\n            if (groupState.visited) {\n                groupState.updateFading(time, disableFading);\n            } else {\n                if (findReplacements) {\n                    groupState.traverseVisibleElements(replaceCallback!);\n                }\n                this.m_referenceMap.delete(key);\n                this.m_sortedGroupStates = undefined;\n                anyEviction = true;\n            }\n        }\n        return anyEviction;\n    }\n\n    /**\n     * Clears visited state for all text element groups in cache.\n     */\n    clearVisited() {\n        for (const groupState of this.m_referenceMap.values()) {\n            groupState.visited = false;\n        }\n    }\n\n    clearTextCache() {\n        this.m_textMap.clear();\n    }\n\n    /**\n     * Clears the whole cache contents.\n     */\n    clear() {\n        this.m_referenceMap.clear();\n        this.m_sortedGroupStates = undefined;\n        this.m_textMap.clear();\n    }\n\n    /**\n     * Removes duplicates for a given text element.\n     *\n     * @param zoomLevel - Current zoom level.\n     * @param elementState - State of the text element to deduplicate.\n     * @returns True if it's the remaining element after deduplication, false if it's been marked\n     * as duplicate.\n     */\n    deduplicateElement(zoomLevel: number, elementState: TextElementState): boolean {\n        const cacheResult = this.findDuplicate(elementState, zoomLevel);\n\n        if (cacheResult === undefined) {\n            // Text not found so far, add this element to cache.\n            this.m_textMap.set(getCacheKey(elementState.element), [elementState]);\n            return true;\n        }\n\n        if (cacheResult.index === -1) {\n            // No duplicate found among elements with same text,add this one to cache.\n            cacheResult.entries.push(elementState);\n            return true;\n        }\n\n        // Duplicate found, check whether there's a label already visible and keep that one.\n        const cachedDuplicate = cacheResult.entries[cacheResult.index];\n\n        if (!cachedDuplicate.visible && elementState.visible) {\n            // New label is visible, substitute the cached label.\n            cacheResult.entries[cacheResult.index] = elementState;\n            cachedDuplicate.reset();\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Replaces a visible unvisited text element with a visited duplicate.\n     * @param zoomLevel - Current zoom level.\n     * @param elementState - State of the text element to deduplicate.\n     * @returns `true` if an item from the cache has been reused and its state has been replaced,\n     * `false` otherwise.\n     */\n    replaceElement(zoomLevel: number, elementState: TextElementState): boolean {\n        assert(elementState.visible);\n        const cacheResult = this.findDuplicate(elementState, zoomLevel);\n\n        if (cacheResult === undefined || cacheResult.index === -1) {\n            // No replacement found;\n            return false;\n        }\n\n        const replacement = cacheResult.entries[cacheResult.index];\n        assert(!replacement.visible);\n\n        replacement.replace(elementState);\n        return true;\n    }\n\n    /**\n     * Gets the state corresponding to a given text element group.\n     * @param textElementGroup - The group of which the state will be obtained.\n     * @returns The group state if cached, otherwise `undefined`.\n     */\n    private get(textElementGroup: TextElementGroup): TextElementGroupState | undefined {\n        const groupState = this.m_referenceMap.get(textElementGroup);\n\n        if (groupState !== undefined) {\n            groupState.visited = true;\n        }\n        return groupState;\n    }\n\n    /**\n     * Sets a specified state for a given text element group.\n     * @param textElementGroup -  The group of which the state will be set.\n     * @param textElementGroupState - The state to set for the group.\n     */\n    private set(textElementGroup: TextElementGroup, textElementGroupState: TextElementGroupState) {\n        assert(textElementGroup.elements.length > 0);\n        this.m_referenceMap.set(textElementGroup, textElementGroupState);\n        this.m_sortedGroupStates = undefined;\n    }\n\n    private findDuplicate(\n        elementState: TextElementState,\n        zoomLevel: number\n    ): { entries: TextElementState[]; index: number } | undefined {\n        // Point labels may have duplicates (as can path labels), Identify them\n        // and keep the one we already display.\n\n        const element = elementState.element;\n        const cachedEntries = this.m_textMap.get(getCacheKey(element));\n\n        if (cachedEntries === undefined) {\n            // No labels found with the same key.\n            return undefined;\n        }\n\n        tmpCachedDuplicate.entries = cachedEntries;\n        const index = element.hasFeatureId()\n            ? findDuplicateById(elementState, cachedEntries)\n            : findDuplicateByText(elementState, cachedEntries, zoomLevel);\n\n        if (index === undefined) {\n            // Feature id collision, try finding duplicates using text as key.\n            element.featureId = undefined;\n            return this.findDuplicate(elementState, zoomLevel);\n        }\n        tmpCachedDuplicate.index = index;\n        return tmpCachedDuplicate;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Types of text elements.\n */\nexport enum TextElementType {\n    PoiLabel,\n    PathLabel,\n    LineMarker\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    FontCatalogConfig,\n    LineMarkerTechnique,\n    TextStyleDefinition\n} from \"@here/harp-datasource-protocol\";\nimport { TileKey, Vector3Like } from \"@here/harp-geoutils\";\nimport {\n    AdditionParameters,\n    DEFAULT_TEXT_CANVAS_LAYER,\n    FontCatalog,\n    TextBufferAdditionParameters,\n    TextBufferCreationParameters,\n    TextCanvas,\n    TextLayoutStyle,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport {\n    assert,\n    LoggerManager,\n    LogLevel,\n    Math2D,\n    MathUtils,\n    PerformanceTimer\n} from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { DataSource } from \"../DataSource\";\nimport { debugContext } from \"../DebugContext\";\nimport { overlayTextElement } from \"../geometry/overlayOnElevation\";\nimport { MapViewImageCache } from \"../image/MapViewImageCache\";\nimport { PickObjectType } from \"../PickHandler\";\nimport { PickListener } from \"../PickListener\";\nimport { PoiManager } from \"../poi/PoiManager\";\nimport { PoiLayer, PoiRenderer } from \"../poi/PoiRenderer\";\nimport { IBox, LineWithBound, ScreenCollisions, ScreenCollisionsDebug } from \"../ScreenCollisions\";\nimport { ScreenProjector } from \"../ScreenProjector\";\nimport { Tile } from \"../Tile\";\nimport { MapViewUtils } from \"../Utils\";\nimport { DataSourceTileList } from \"../VisibleTileSet\";\nimport { loadFontCatalog } from \"./FontCatalogLoader\";\nimport {\n    checkReadyForPlacement,\n    computeViewDistance,\n    getMaxViewDistance,\n    getWorldPosition,\n    isPathLabelTooSmall,\n    placeIcon,\n    PlacementResult,\n    placePathLabel,\n    placePointLabel,\n    pointToPlaneDistance,\n    PrePlacementResult\n} from \"./Placement\";\nimport { PlacementStats } from \"./PlacementStats\";\nimport { RenderState } from \"./RenderState\";\nimport { SimpleLineCurve, SimplePath } from \"./SimplePath\";\nimport { TextCanvasFactory } from \"./TextCanvasFactory\";\nimport { LoadingState, TextElement, TextPickResult } from \"./TextElement\";\nimport { TextElementGroup } from \"./TextElementGroup\";\nimport { TextElementFilter, TextElementGroupState } from \"./TextElementGroupState\";\nimport {\n    initializeDefaultOptions,\n    TextElementsRendererOptions\n} from \"./TextElementsRendererOptions\";\nimport { TextElementState } from \"./TextElementState\";\nimport { TextElementStateCache } from \"./TextElementStateCache\";\nimport { TextElementType } from \"./TextElementType\";\nimport { TextElementStyle, TextStyleCache } from \"./TextStyleCache\";\nimport { UpdateStats } from \"./UpdateStats\";\nimport { ViewState } from \"./ViewState\";\n\ninterface RenderParams {\n    numRenderedTextElements: number;\n    // TODO: HARP-7373. Move to update() method at the end of the frame.\n    fadeAnimationRunning: boolean;\n    time: number;\n}\n\nenum Pass {\n    PersistentLabels,\n    NewLabels\n}\n\nexport type TextCanvases = Map<string, TextCanvas | undefined>;\n\nexport const DEFAULT_FONT_CATALOG_NAME = \"default\";\n\n/**\n * Default distance scale. Will be applied if distanceScale is not defined in the technique.\n * Defines the scale that will be applied to labeled icons (icon and text) in the distance.\n * @internal\n */\nexport const DEFAULT_TEXT_DISTANCE_SCALE = 0.5;\n\n/**\n * Maximum number of recommended labels. If more labels are encountered, the \"overloaded\" mode is\n * set, which modifies the behavior of label placement and rendering, trying to keep delivering an\n * interactive performance. The overloaded mode should not be activated if the {@link MapView} is\n * rendering a static image (camera not moving and no animation running).\n */\nconst OVERLOAD_LABEL_LIMIT = 20000;\n\n/**\n * If \"overloaded\" is `true`:\n *\n * Default number of labels/POIs updated in a frame. They are rendered only if they fit. If the\n * camera is not moving, it is ignored. See [[TextElementsRenderer.isUpdatePending]].\n */\nconst OVERLOAD_UPDATED_LABEL_LIMIT = 100;\n\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for placement. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isUpdatePending]].\n */\nconst OVERLOAD_UPDATE_TIME_LIMIT = 5;\n\n/**\n * If \"overloaded\" is `true`:\n *\n * Maximum time in milliseconds available for rendering. If value is <= 0, or if the camera is not\n * moving, it is ignored. See [[TextElementsRenderer.isUpdatePending]].\n */\nconst OVERLOAD_PLACE_TIME_LIMIT = 10;\n\nconst logger = LoggerManager.instance.create(\"TextElementsRenderer\", { level: LogLevel.Log });\n\n// Development flag: Enable debug print.\nconst PRINT_LABEL_DEBUG_INFO: boolean = false;\nconst updateStats = PRINT_LABEL_DEBUG_INFO ? new UpdateStats(logger) : undefined;\nconst placementStats = PRINT_LABEL_DEBUG_INFO ? new PlacementStats(logger) : undefined;\n\nconst tempPosition = new THREE.Vector3();\nconst tempScreenPosition = new THREE.Vector2();\nconst tempScreenPoints: THREE.Vector2[] = [];\nconst tempPoiScreenPosition = new THREE.Vector2();\nconst tmpTextBufferCreationParams: TextBufferCreationParameters = {};\nconst tmpAdditionParams: AdditionParameters = {};\nconst tmpBufferAdditionParams: TextBufferAdditionParameters = {};\nconst cache = {\n    vector2: [new THREE.Vector2()]\n};\n\nclass TileTextElements {\n    constructor(readonly tile: Tile, readonly group: TextElementGroup) {}\n}\n\nclass TextElementLists {\n    constructor(readonly lists: TileTextElements[]) {}\n\n    get priority() {\n        assert(this.lists.length > 0);\n        // All text element lists here have the same priority.\n        return this.lists[0].group.priority;\n    }\n\n    /**\n     * Sum up the number of elements in all lists.\n     */\n    count(): number {\n        let n = 0;\n        for (const list of this.lists) {\n            n += list.group.elements.length;\n        }\n        return n;\n    }\n}\n\nfunction checkIfTextElementsChanged(dataSourceTileList: DataSourceTileList[]) {\n    let textElementsChanged = false;\n\n    dataSourceTileList.forEach(({ renderedTiles }) => {\n        renderedTiles.forEach(tile => {\n            if (tile.textElementsChanged) {\n                tile.textElementsChanged = false;\n                textElementsChanged = true;\n            }\n        });\n    });\n\n    return textElementsChanged;\n}\n\nfunction hasTextElements(dataSourceTileList: DataSourceTileList[]): boolean {\n    for (let i = 0; i < dataSourceTileList.length; i++) {\n        for (const [_key, value] of dataSourceTileList[i].renderedTiles) {\n            if (value.hasTextElements()) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction addTextToCanvas(\n    textElement: TextElement,\n    canvas: TextCanvas,\n    screenPosition: THREE.Vector3,\n    path?: THREE.Path,\n    pathOverflow?: boolean\n) {\n    tmpAdditionParams.path = path;\n    tmpAdditionParams.pathOverflow = pathOverflow;\n    tmpAdditionParams.layer = textElement.renderOrder;\n    tmpAdditionParams.letterCaseArray = textElement.glyphCaseArray;\n    tmpAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n    canvas.addText(textElement.glyphs!, screenPosition, tmpAdditionParams);\n}\n\nfunction addTextBufferToCanvas(\n    textElementState: TextElementState,\n    canvas: TextCanvas,\n    screenPosition: THREE.Vector3,\n    fadeFactor: number,\n    scaleFactor: number\n): boolean {\n    const textElement = textElementState.element;\n    const textRenderState = textElementState.textRenderState;\n    const opacity = textRenderState!.opacity * fadeFactor * textElement.renderStyle!.opacity;\n\n    if (opacity === 0) {\n        return false;\n    }\n\n    // Compute the TextBufferObject when we know we're gonna render this label.\n    tmpTextBufferCreationParams.letterCaseArray = textElement.glyphCaseArray;\n    if (textElement.textBufferObject === undefined) {\n        textElement.textBufferObject = canvas.createTextBufferObject(\n            textElement.glyphs!,\n            tmpTextBufferCreationParams\n        );\n    }\n    const backgroundIsVisible =\n        textElement.renderStyle!.backgroundOpacity > 0 &&\n        canvas.textRenderStyle.fontSize.backgroundSize > 0;\n\n    tmpBufferAdditionParams.layer = textElement.renderOrder;\n    tmpBufferAdditionParams.position = screenPosition;\n    tmpBufferAdditionParams.scale = scaleFactor;\n    tmpBufferAdditionParams.opacity = opacity;\n    tmpBufferAdditionParams.backgroundOpacity = backgroundIsVisible\n        ? tmpBufferAdditionParams.opacity * textElement.renderStyle!.backgroundOpacity\n        : 0.0;\n    tmpBufferAdditionParams.pickingData = textElement.userData ? textElement : undefined;\n    canvas.addTextBufferObject(textElement.textBufferObject!, tmpBufferAdditionParams);\n    return true;\n}\n\nfunction shouldRenderPointText(\n    labelState: TextElementState,\n    viewState: ViewState,\n    options: TextElementsRendererOptions\n): boolean {\n    const textRenderState: RenderState | undefined = labelState.textRenderState;\n    const label = labelState.element;\n    const poiInfo = label.poiInfo;\n\n    assert(label.type !== TextElementType.PathLabel);\n\n    const hasText = textRenderState !== undefined && label.text !== \"\";\n    if (!hasText) {\n        return false;\n    }\n\n    const visibleInZoomLevel =\n        poiInfo === undefined ||\n        MathUtils.isClamped(\n            viewState.zoomLevel,\n            poiInfo.textMinZoomLevel,\n            poiInfo.textMaxZoomLevel\n        );\n\n    if (!visibleInZoomLevel) {\n        return false;\n    }\n\n    const poiTextMaxDistance = getMaxViewDistance(viewState, options.maxDistanceRatioForPoiLabels!);\n    const visibleAtDistance =\n        label.ignoreDistance === true ||\n        labelState.viewDistance === undefined ||\n        (labelState.viewDistance < poiTextMaxDistance && labelState.viewDistance > 0);\n    if (!visibleAtDistance) {\n        return false;\n    }\n\n    // If there's an icon, render text only if icon is valid or optional.\n    return !poiInfo || poiInfo.isValid === true || poiInfo.iconIsOptional === true;\n}\n\nfunction shouldRenderPoiText(labelState: TextElementState, viewState: ViewState) {\n    // Do not actually render (just allocate space) if camera is moving and\n    // renderTextDuringMovements is not true.\n    const poiInfo = labelState.element.poiInfo;\n\n    return (\n        !viewState.cameraIsMoving ||\n        poiInfo === undefined ||\n        poiInfo.renderTextDuringMovements === true\n    );\n}\n\nfunction isPlacementTimeExceeded(startTime: number | undefined): boolean {\n    // startTime is set in overload mode.\n    if (startTime === undefined || OVERLOAD_PLACE_TIME_LIMIT <= 0) {\n        return false;\n    }\n    const endTime = PerformanceTimer.now();\n    const elapsedTime = endTime - startTime;\n    if (elapsedTime > OVERLOAD_PLACE_TIME_LIMIT) {\n        logger.debug(\"Placement time limit exceeded.\");\n        return true;\n    }\n    return false;\n}\n\nfunction createDefaultFontCatalogConfig(defaultFontCatalogUrl: string): FontCatalogConfig {\n    return {\n        name: DEFAULT_FONT_CATALOG_NAME,\n        url: defaultFontCatalogUrl\n    };\n}\n\n/**\n *\n * Internal class to manage all text rendering.\n */\nexport class TextElementsRenderer {\n    private m_loadPromisesCount: number = 0;\n    private m_loadPromise: Promise<any> | undefined;\n    private readonly m_options: TextElementsRendererOptions;\n\n    private readonly m_textCanvases: TextCanvases = new Map();\n\n    private m_overlayTextElements?: TextElement[];\n\n    // TODO: Replace this for an array of textures when more fonts are in use.\n    private m_debugGlyphTextureCacheMesh?: THREE.Mesh;\n    private m_debugGlyphTextureCacheWireMesh?: THREE.LineSegments;\n\n    private readonly m_tmpVector = new THREE.Vector2();\n    private readonly m_tmpVector3 = new THREE.Vector3();\n    private readonly m_cameraLookAt = new THREE.Vector3();\n    private m_overloaded: boolean = false;\n    private m_cacheInvalidated: boolean = false;\n    private m_addNewLabels: boolean = true;\n    private m_forceNewLabelsPass: boolean = false;\n\n    private readonly m_textElementStateCache: TextElementStateCache = new TextElementStateCache();\n    private readonly m_camera = new THREE.OrthographicCamera(-1, 1, 1, -1);\n    private m_defaultFontCatalogConfig: FontCatalogConfig | undefined;\n    private m_poiRenderer: PoiRenderer;\n    private readonly m_textStyleCache: TextStyleCache = new TextStyleCache();\n    private readonly m_screenCollisions:\n        | ScreenCollisions\n        | ScreenCollisionsDebug = new ScreenCollisions();\n\n    private readonly m_textCanvasFactory: TextCanvasFactory;\n\n    /**\n     * indicates if the TextElementsRenderer is still updating, includes fading, elevations etc\n     */\n    private m_isUpdatePending: boolean = false;\n\n    /**\n     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as\n     * a preprocessing step, which is not done every frame, and also renders the placed\n     * {@link TextElement}s every frame.\n     *\n     * @param m_viewState - State of the view for which this renderer will draw text.\n     * @param m_screenProjector - Projects 3D coordinates into screen space.\n     * @param m_poiManager - To prepare pois for rendering.\n     * @param m_renderer - The renderer to be used.\n     * @param m_imageCaches - The Image Caches to look for Icons.\n     * @param options - Configuration options for the text renderer. See\n     * @param textCanvasFactory - Optional A TextCanvasFactory to override the default.\n     * @param poiRenderer - Optional A PoiRenderer to override the default.\n     * @param screenCollisions - Optional  ScreenCollisions to override the default.\n     * [[TextElementsRendererOptions]].\n     */\n    constructor(\n        private readonly m_viewState: ViewState,\n        private readonly m_screenProjector: ScreenProjector,\n        private readonly m_poiManager: PoiManager,\n        private m_renderer: THREE.WebGLRenderer,\n        private readonly m_imageCaches: MapViewImageCache[],\n        options: TextElementsRendererOptions,\n        textCanvasFactory?: TextCanvasFactory,\n        poiRenderer?: PoiRenderer,\n        screenCollisions?: ScreenCollisions\n    ) {\n        this.m_options = { ...options };\n        initializeDefaultOptions(this.m_options);\n        if (screenCollisions) {\n            this.m_screenCollisions = screenCollisions;\n        } else if (\n            this.m_options.collisionDebugCanvas !== undefined &&\n            this.m_options.collisionDebugCanvas !== null\n        ) {\n            this.m_screenCollisions = new ScreenCollisionsDebug(\n                this.m_options.collisionDebugCanvas\n            );\n        }\n\n        this.m_textCanvasFactory = textCanvasFactory ?? new TextCanvasFactory(this.m_renderer);\n        this.m_textCanvasFactory.setGlyphCountLimits(\n            this.m_options.minNumGlyphs!,\n            this.m_options.maxNumGlyphs!\n        );\n\n        this.m_poiRenderer =\n            poiRenderer ?? new PoiRenderer(this.m_renderer, this.m_poiManager, this.m_imageCaches);\n\n        this.initializeCamera();\n\n        this.initializeDefaultFontCatalog();\n        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);\n    }\n\n    /**\n     * Disable all fading animations (for debugging and performance measurement). Defaults to\n     * `false`.\n     */\n    set disableFading(disable: boolean) {\n        this.m_options.disableFading = disable;\n    }\n\n    get disableFading(): boolean {\n        return this.m_options.disableFading === true;\n    }\n\n    get styleCache() {\n        return this.m_textStyleCache;\n    }\n\n    get delayLabelsUntilMovementFinished(): boolean {\n        return this.m_options.delayLabelsUntilMovementFinished === true;\n    }\n\n    set delayLabelsUntilMovementFinished(delay: boolean) {\n        this.m_options.delayLabelsUntilMovementFinished = delay;\n    }\n\n    /**\n     * If `true`, a replacement glyph (\"?\") is rendered for every missing glyph.\n     */\n    get showReplacementGlyphs() {\n        return this.m_options.showReplacementGlyphs === true;\n    }\n\n    /**\n     * If `true`, a replacement glyph (\"?\") is rendered for every missing glyph.\n     */\n    set showReplacementGlyphs(value: boolean) {\n        this.m_options.showReplacementGlyphs = value;\n\n        this.m_textCanvases.forEach(textCanvas => {\n            if (textCanvas?.fontCatalog) {\n                textCanvas.fontCatalog.showReplacementGlyphs = value;\n            }\n        });\n    }\n\n    restoreRenderers(renderer: THREE.WebGLRenderer) {\n        this.m_renderer = renderer;\n        this.m_poiRenderer = new PoiRenderer(\n            this.m_renderer,\n            this.m_poiManager,\n            this.m_imageCaches\n        );\n        //TODO: restore TextCanvasRenderers\n    }\n\n    /**\n     * Updates the FontCatalogs used by this {@link TextElementsRenderer}.\n     *\n     * @param fontCatalogs - The new list of {@link FontCatalogConfig}s\n     */\n    async updateFontCatalogs(fontCatalogs?: FontCatalogConfig[]) {\n        if (this.m_defaultFontCatalogConfig) {\n            if (\n                !fontCatalogs ||\n                fontCatalogs.findIndex(config => {\n                    return config.name === DEFAULT_FONT_CATALOG_NAME;\n                }) === -1\n            ) {\n                // not other default catalog available, keep the old one\n                if (!fontCatalogs) {\n                    fontCatalogs = [];\n                }\n                // Never remove the default Canvas if set per configuration\n                fontCatalogs.unshift(this.m_defaultFontCatalogConfig);\n            } else {\n                if (this.m_textCanvases.has(DEFAULT_FONT_CATALOG_NAME)) {\n                    this.m_textCanvases.delete(DEFAULT_FONT_CATALOG_NAME);\n                }\n            }\n        }\n\n        if (fontCatalogs && fontCatalogs.length > 0) {\n            // Remove obsolete ones\n            for (const [name] of this.m_textCanvases) {\n                if (\n                    fontCatalogs.findIndex(catalog => {\n                        return catalog.name === name;\n                    }) < 0\n                ) {\n                    this.m_textCanvases.delete(name);\n                }\n            }\n\n            // Add new catalogs\n            for (const fontCatalog of fontCatalogs) {\n                await this.addTextCanvas(fontCatalog);\n            }\n        } else {\n            this.m_textCanvases.clear();\n        }\n        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);\n    }\n\n    async updateTextStyles(\n        textStyles?: TextStyleDefinition[],\n        defaultTextStyle?: TextStyleDefinition\n    ) {\n        this.m_textStyleCache.updateTextStyles(textStyles, defaultTextStyle);\n        await this.waitLoaded();\n        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);\n        this.invalidateCache();\n    }\n\n    /**\n     * Render the text using the specified camera into the current canvas.\n     *\n     * @param camera - Orthographic camera to use.\n     */\n    renderText(farPlane: number) {\n        this.m_camera.far = farPlane;\n        this.updateGlyphDebugMesh();\n\n        let previousLayer: PoiLayer | undefined;\n        this.m_poiRenderer.update();\n        for (const poiLayer of this.m_poiRenderer.layers) {\n            for (const [, textCanvas] of this.m_textCanvases) {\n                textCanvas?.render(this.m_camera, previousLayer?.id, poiLayer.id, undefined, false);\n            }\n            this.m_poiRenderer.render(this.m_camera, poiLayer);\n            previousLayer = poiLayer;\n        }\n        for (const [, textCanvas] of this.m_textCanvases) {\n            textCanvas?.render(this.m_camera, previousLayer?.id, undefined, undefined, false);\n        }\n    }\n\n    /**\n     * Forces update of text elements in the next call to [[placeText]].\n     */\n    invalidateCache() {\n        this.m_cacheInvalidated = true;\n    }\n\n    /**\n     * Notify `TextElementsRenderer` that the camera has started a movement.\n     */\n    movementStarted() {\n        if (this.delayLabelsUntilMovementFinished) {\n            this.m_addNewLabels = false;\n        }\n    }\n\n    /**\n     * Notify `TextElementsRenderer` that the camera has finished its movement.\n     */\n    movementFinished() {\n        this.invalidateCache();\n        if (this.delayLabelsUntilMovementFinished) {\n            this.m_addNewLabels = true;\n        }\n    }\n\n    /**\n     * Is `true` if number of {@link TextElement}s in visible tiles is larger than the recommended\n     * number `OVERLOAD_LABEL_LIMIT`.\n     */\n    get overloaded(): boolean {\n        return this.m_overloaded;\n    }\n\n    /**\n     * Places text elements for the current frame.\n     * @param dataSourceTileList - List of tiles to be rendered for each data source.\n     * @param time - Current frame time.\n     */\n    placeText(dataSourceTileList: DataSourceTileList[], time: number) {\n        const tileTextElementsChanged = checkIfTextElementsChanged(dataSourceTileList);\n\n        const textElementsAvailable =\n            this.hasOverlayText() || tileTextElementsChanged || hasTextElements(dataSourceTileList);\n\n        this.m_isUpdatePending = false;\n\n        if (\n            !textElementsAvailable &&\n            !this.m_cacheInvalidated &&\n            !this.m_viewState.renderedTilesChanged\n        ) {\n            return;\n        }\n\n        const updateTextElements =\n            this.m_cacheInvalidated ||\n            tileTextElementsChanged ||\n            this.m_viewState.renderedTilesChanged;\n\n        const findReplacements = updateTextElements && this.m_addNewLabels;\n        if (findReplacements) {\n            this.m_textElementStateCache.clearVisited();\n            this.updateTextElements(dataSourceTileList);\n        }\n        const anyTextGroupEvicted = this.m_textElementStateCache.update(\n            time,\n            this.m_options.disableFading!,\n            findReplacements,\n            this.m_viewState.zoomLevel\n        );\n\n        // TODO: this seems extremly suboptimal.. review if an update is possible\n        this.reset();\n        if (this.m_addNewLabels) {\n            this.prepopulateScreenWithBlockingElements(dataSourceTileList);\n        }\n\n        // New text elements must be placed either if text elements were updated in this frame\n        // or if any text element group was evicted. The second case happens when the group is not\n        // visited anymore and all it's elements just became invisible, which means there's newly\n        // available screen space where new text elements could be placed. A common scenario where\n        // this happens is zooming in/out: text groups from the old level may still be fading out\n        // after all groups in the new level were updated.\n        const placeNewTextElements =\n            (updateTextElements || anyTextGroupEvicted) && this.m_addNewLabels;\n        this.placeTextElements(time, placeNewTextElements);\n        this.placeOverlayTextElements();\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    addOverlayText(textElements: TextElement[]): void {\n        if (textElements.length === 0) {\n            return;\n        }\n        this.m_overlayTextElements =\n            this.m_overlayTextElements === undefined\n                ? textElements.slice()\n                : this.m_overlayTextElements.concat(textElements);\n    }\n\n    /**\n     * Adds new overlay text elements to this `MapView`.\n     *\n     * @param textElements - Array of {@link TextElement} to be added.\n     */\n    clearOverlayText(): void {\n        this.m_overlayTextElements = [];\n    }\n\n    /**\n     * @returns Whether there's overlay text to be rendered.\n     */\n    hasOverlayText(): boolean {\n        return this.m_overlayTextElements !== undefined && this.m_overlayTextElements.length > 0;\n    }\n\n    get overlayText(): TextElement[] | undefined {\n        return this.m_overlayTextElements;\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple\n     * {@link TextElement}s are found, the order of the results is unspecified.\n     *\n     * Note: {@link TextElement}s with identical `featureId` or\n     * identical `userData` will only appear\n     * once in the list `pickResults`.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickResults - Array filled with pick results.\n     */\n    pickTextElements(screenPosition: THREE.Vector2, pickListener: PickListener) {\n        const pickHandler = (pickData: any | undefined, pickObjectType: PickObjectType) => {\n            if (pickData === undefined) {\n                return;\n            }\n            const textElement = pickData as TextElement;\n            const pickResult: TextPickResult = {\n                type: pickObjectType,\n                point: screenPosition,\n                distance: 0,\n                renderOrder: textElement.renderOrder,\n                featureId: textElement.featureId,\n                userData: textElement.userData,\n                dataSourceName: textElement.dataSourceName,\n                dataSourceOrder: textElement.dataSourceOrder,\n                text: textElement.text\n            };\n\n            pickListener.addResult(pickResult);\n        };\n\n        for (const [, textCanvas] of this.m_textCanvases) {\n            textCanvas?.pickText(screenPosition, (pickData: any | undefined) => {\n                pickHandler(pickData, PickObjectType.Text);\n            });\n        }\n\n        this.m_poiRenderer.pickTextElements(screenPosition, (pickData: any | undefined) => {\n            pickHandler(pickData, PickObjectType.Icon);\n        });\n    }\n\n    /**\n     * `true` if any resource used by any `FontCatalog` is still loading.\n     */\n    get loading(): boolean {\n        return this.m_loadPromisesCount > 0;\n    }\n\n    /**\n     * `true` if TextElements are not placed finally but are still updating, including fading or\n     * waiting for elevation.\n     */\n    get isUpdatePending(): boolean {\n        return this.m_isUpdatePending;\n    }\n\n    /**\n     * Waits till all pending resources from any `FontCatalog` are loaded.\n     */\n    async waitLoaded(): Promise<void> {\n        if (this.m_loadPromise !== undefined) {\n            return await this.m_loadPromise;\n        }\n    }\n\n    /**\n     * Reset the current text render states of all visible tiles.\n     *\n     * @remarks\n     * All {@link TextElement}s will fade in\n     * after that as if they have just been added.\n     */\n    clearRenderStates() {\n        this.m_textElementStateCache.clear();\n    }\n\n    /**\n     * Return memory used by all objects managed by `TextElementsRenderer`.\n     *\n     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.\n     */\n    getMemoryUsage(): MapViewUtils.MemoryUsage {\n        const memoryUsage = {\n            heapSize: 0,\n            gpuSize: 0\n        };\n\n        for (const [, textCanvas] of this.m_textCanvases) {\n            textCanvas?.getMemoryUsage(memoryUsage);\n        }\n        this.m_poiRenderer.getMemoryUsage(memoryUsage);\n\n        return memoryUsage;\n    }\n\n    private async addDefaultTextCanvas(): Promise<void> {\n        if (\n            this.m_textCanvases.has(DEFAULT_FONT_CATALOG_NAME) ||\n            !this.m_defaultFontCatalogConfig\n        ) {\n            return;\n        }\n        await this.addTextCanvas(this.m_defaultFontCatalogConfig);\n        this.m_textStyleCache.updateTextCanvases(this.m_textCanvases);\n    }\n\n    /**\n     * Reset internal state at the beginning of a frame.\n     */\n    private reset() {\n        this.m_cameraLookAt.copy(this.m_viewState.lookAtVector);\n        this.m_screenCollisions.reset();\n        for (const [, textCanvas] of this.m_textCanvases) {\n            textCanvas?.clear();\n        }\n        this.m_poiRenderer.reset();\n    }\n\n    /**\n     * Fills the screen with lines projected from world space, see [[Tile.blockingElements]].\n     * @note These boxes have highest priority, so will block all other labels.\n     * @param dataSourceTileList - List of tiles to be rendered for each data source.\n     */\n    private prepopulateScreenWithBlockingElements(dataSourceTileList: DataSourceTileList[]) {\n        const boxes: IBox[] = [];\n        dataSourceTileList.forEach(renderListEntry => {\n            const startLinePointProj = new THREE.Vector3();\n            const endLinePointProj = new THREE.Vector3();\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                for (const pathBlockingElement of tile.blockingElements) {\n                    if (pathBlockingElement.points.length < 2) {\n                        continue;\n                    }\n                    this.m_screenProjector.project3(\n                        pathBlockingElement.points[0],\n                        startLinePointProj\n                    );\n                    for (let i = 1; i < pathBlockingElement.points.length; i++) {\n                        this.m_screenProjector.project3(\n                            pathBlockingElement.points[i],\n                            endLinePointProj\n                        );\n                        const line = pathBlockingElement.screenSpaceLines[i - 1];\n                        line.start.copy(startLinePointProj);\n                        line.end.copy(endLinePointProj);\n                        const lineWithBound: LineWithBound = {\n                            minX: Math.min(startLinePointProj.x, endLinePointProj.x),\n                            maxX: Math.max(startLinePointProj.x, endLinePointProj.x),\n                            minY: Math.min(startLinePointProj.y, endLinePointProj.y),\n                            maxY: Math.max(startLinePointProj.y, endLinePointProj.y),\n                            line\n                        };\n                        boxes.push(lineWithBound);\n                        startLinePointProj.copy(endLinePointProj);\n                    }\n                }\n            }\n        });\n        this.m_screenCollisions.allocateIBoxes(boxes);\n    }\n\n    /**\n     * @returns True if whole group was processed for placement,\n     * false otherwise (e.g. placement limit reached).\n     */\n    private placeTextElementGroup(\n        groupState: TextElementGroupState,\n        renderParams: RenderParams,\n        maxNumPlacedLabels: number | undefined,\n        pass: Pass\n    ): boolean {\n        // Unvisited text elements are never placed.\n        assert(groupState.visited);\n\n        const shieldGroups: number[][] = [];\n        const hiddenKinds = this.m_viewState.hiddenGeometryKinds;\n        const projection = this.m_viewState.projection;\n        const elevationProvider = this.m_viewState.elevationProvider;\n        const elevationMap = elevationProvider?.getDisplacementMap(groupState.tileKey);\n\n        for (const textElementState of groupState.textElementStates) {\n            if (pass === Pass.PersistentLabels) {\n                if (placementStats) {\n                    ++placementStats.total;\n                }\n            }\n            // Limit labels only in new labels pass (Pass.NewLabels).\n            else if (\n                maxNumPlacedLabels !== undefined &&\n                renderParams.numRenderedTextElements >= maxNumPlacedLabels\n            ) {\n                logger.debug(\"Placement label limit exceeded.\");\n                return false;\n            }\n\n            // Skip all labels that are not initialized (didn't pass early placement tests)\n            // or don't belong to this pass.\n            if (!textElementState.initialized) {\n                if (placementStats) {\n                    ++placementStats.uninitialized;\n                }\n                continue;\n            }\n            if (textElementState.viewDistance === undefined || textElementState.viewDistance < 0) {\n                if (placementStats) {\n                    ++placementStats.tooFar;\n                }\n                continue;\n            }\n\n            const elementVisible = textElementState.visible;\n            if (\n                (pass === Pass.PersistentLabels && !elementVisible) ||\n                (pass === Pass.NewLabels && elementVisible)\n            ) {\n                continue;\n            }\n\n            const textElement = textElementState.element;\n\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n\n            // TODO: HARP-7648. Discard hidden kinds sooner, before placement.\n            // Check if the label should be hidden.\n            if (\n                hiddenKinds !== undefined &&\n                textElement.kind !== undefined &&\n                hiddenKinds.hasOrIntersects(textElement.kind)\n            ) {\n                continue;\n            }\n\n            if (elevationProvider !== undefined && !textElement.elevated) {\n                if (!elevationMap) {\n                    this.m_isUpdatePending = true;\n                    this.m_forceNewLabelsPass = true;\n                    continue;\n                }\n                overlayTextElement(textElement, elevationProvider, elevationMap, projection);\n            }\n            const elementType = textElement.type;\n            const isPathLabel = elementType === TextElementType.PathLabel;\n\n            // For paths, check if the label may fit.\n            if (isPathLabel) {\n                if (isPathLabelTooSmall(textElement, this.m_screenProjector, tempScreenPoints)) {\n                    if (placementStats) {\n                        placementStats.numNotVisible++;\n                    }\n                    if (textElement.dbgPathTooSmall === true) {\n                        if (placementStats) {\n                            placementStats.numPathTooSmall++;\n                        }\n                    }\n                    textElementState.reset();\n                    continue;\n                }\n            }\n\n            const forceNewPassOnLoaded = true;\n            if (textCanvas) {\n                // This ensures that textElement.renderStyle and textElement.layoutStyle are\n                // already instantiated and initialized with theme style values.\n                if (!this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded)) {\n                    continue;\n                }\n\n                const layer = textCanvas.getLayer(\n                    textElement.renderOrder ?? DEFAULT_TEXT_CANVAS_LAYER\n                );\n\n                // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n                if (layer !== undefined) {\n                    if (\n                        layer.storage.drawCount + textElement.glyphs!.length >\n                        layer.storage.capacity\n                    ) {\n                        if (placementStats) {\n                            ++placementStats.numCannotAdd;\n                        }\n                        logger.warn(\"layer glyph storage capacity exceeded.\");\n                        continue;\n                    }\n                }\n\n                // Set the current style for the canvas.\n                // This means text canvas has always references (not a copy) to text element styles.\n                // The only exception is multi-anchor placement where layoutStyle need to be\n                // modified and thus textCanvas will using its own copy of textElement.layoutStyle.\n                // See: placePointLabel()\n                textCanvas.textRenderStyle = textElement.renderStyle!;\n                textCanvas.textLayoutStyle = textElement.layoutStyle!;\n            }\n\n            switch (elementType) {\n                case TextElementType.PoiLabel:\n                    this.addPoiLabel(textElementState, textCanvas, renderParams);\n                    break;\n                case TextElementType.LineMarker:\n                    this.addLineMarkerLabel(\n                        textElementState,\n                        shieldGroups,\n                        textCanvas,\n                        renderParams\n                    );\n                    break;\n                case TextElementType.PathLabel:\n                    if (textCanvas) {\n                        this.addPathLabel(\n                            textElementState,\n                            tempScreenPoints,\n                            textCanvas,\n                            renderParams\n                        );\n                    }\n            }\n        }\n        return true;\n    }\n\n    private initializeGlyphs(\n        textElement: TextElement,\n        textElementStyle: TextElementStyle,\n        forceNewPassOnLoaded: boolean\n    ): boolean {\n        // Trigger the glyph load if needed.\n        if (textElement.loadingState === LoadingState.Initialized) {\n            return textElement.glyphs !== undefined;\n        }\n\n        assert(textElementStyle.textCanvas !== undefined);\n        const textCanvas = textElementStyle.textCanvas!;\n\n        if (textElement.loadingState === undefined) {\n            textElement.loadingState = LoadingState.Requested;\n\n            if (textElement.renderStyle === undefined) {\n                textElement.renderStyle = new TextRenderStyle({\n                    ...textElementStyle.renderParams,\n                    ...textElement.renderParams\n                });\n            }\n            if (textElement.layoutStyle === undefined) {\n                textElement.layoutStyle = new TextLayoutStyle({\n                    ...textElementStyle.layoutParams,\n                    ...textElement.layoutParams\n                });\n            }\n\n            if (textElement.text === \"\") {\n                textElement.loadingState = LoadingState.Loaded;\n            } else {\n                const newLoadPromise = textCanvas.fontCatalog\n                    .loadCharset(textElement.text, textElement.renderStyle)\n                    .then(() => {\n                        --this.m_loadPromisesCount;\n                        textElement.loadingState = LoadingState.Loaded;\n                        this.m_isUpdatePending = true;\n                        this.m_forceNewLabelsPass =\n                            this.m_forceNewLabelsPass || forceNewPassOnLoaded;\n                    });\n                if (this.m_loadPromisesCount === 0) {\n                    this.m_loadPromise = undefined;\n                }\n                ++this.m_loadPromisesCount;\n\n                this.m_loadPromise =\n                    this.m_loadPromise === undefined\n                        ? newLoadPromise\n                        : Promise.all([this.m_loadPromise, newLoadPromise]);\n            }\n        }\n        if (textElement.loadingState === LoadingState.Loaded) {\n            textCanvas.textRenderStyle = textElement.renderStyle!;\n            textCanvas.textLayoutStyle = textElement.layoutStyle!;\n            textElement.glyphCaseArray = [];\n            textElement.bounds = undefined;\n            textElement.glyphs = textCanvas.fontCatalog.getGlyphs(\n                textElement.text,\n                textCanvas.textRenderStyle,\n                textElement.glyphCaseArray\n            );\n            textElement.loadingState = LoadingState.Initialized;\n        }\n        // Return true as soon as a text element has some glyphs assigned so that it's rendered.\n        // The glyphs may be either the final ones or some temporal glyphs inherited from a\n        // predecessor as part of the text element replacement process.\n        // See TextElementState.replace().\n        return textElement.glyphs !== undefined;\n    }\n\n    private initializeCamera() {\n        this.m_camera.position.z = 1;\n        this.m_camera.near = 0;\n    }\n\n    updateCamera() {\n        const { width, height } = this.m_renderer.getSize(cache.vector2[0]);\n        this.m_camera.left = width / -2;\n        this.m_camera.right = width / 2;\n        this.m_camera.bottom = height / -2;\n        this.m_camera.top = height / 2;\n        this.m_camera.updateProjectionMatrix();\n        this.m_camera.updateMatrixWorld(false);\n        this.m_screenCollisions.update(width, height);\n    }\n\n    private initializeDefaultFontCatalog() {\n        if (this.m_options.fontCatalog) {\n            this.m_defaultFontCatalogConfig = createDefaultFontCatalogConfig(\n                this.m_options.fontCatalog\n            );\n            this.addDefaultTextCanvas();\n        }\n    }\n\n    private async addTextCanvas(fontCatalogConfig: FontCatalogConfig): Promise<void> {\n        const catalogCallback = (name: string, catalog: FontCatalog) => {\n            if (this.m_textCanvases.has(name)) {\n                const loadedTextCanvas = this.m_textCanvasFactory.createTextCanvas(catalog, name);\n\n                catalog.showReplacementGlyphs = this.showReplacementGlyphs;\n\n                // Check if the textCanvas has not been removed in the meantime\n                this.m_textCanvases.set(name, loadedTextCanvas);\n            }\n        };\n        const errorCallback = () => {\n            this.m_textCanvases.delete(fontCatalogConfig.name);\n        };\n        if (this.m_textCanvases.has(fontCatalogConfig.name)) {\n            return Promise.resolve();\n        } else {\n            // Reserve map space, until loaded or error\n            this.m_textCanvases.set(fontCatalogConfig.name, undefined);\n            const newLoadPromise = loadFontCatalog(\n                fontCatalogConfig,\n                catalogCallback,\n                errorCallback\n            )\n                .then(() => {\n                    --this.m_loadPromisesCount;\n                })\n                .catch(error => {\n                    logger.info(\"rendering without font catalog, only icons possible\", error);\n                    --this.m_loadPromisesCount;\n                });\n            if (this.m_loadPromisesCount === 0) {\n                this.m_loadPromise = undefined;\n            }\n            ++this.m_loadPromisesCount;\n            this.m_loadPromise =\n                this.m_loadPromise === undefined\n                    ? newLoadPromise\n                    : Promise.all([this.m_loadPromise, newLoadPromise]);\n            return newLoadPromise;\n        }\n    }\n\n    private updateGlyphDebugMesh() {\n        const debugGlyphs = debugContext.getValue(\"DEBUG_GLYPHS\");\n        if (debugGlyphs === undefined) {\n            return;\n        }\n\n        if (debugGlyphs && this.m_debugGlyphTextureCacheMesh === undefined) {\n            this.initializeGlyphDebugMesh();\n        }\n        assert(this.m_debugGlyphTextureCacheMesh !== undefined);\n        assert(this.m_debugGlyphTextureCacheWireMesh !== undefined);\n\n        this.m_debugGlyphTextureCacheMesh!.visible = debugGlyphs;\n        this.m_debugGlyphTextureCacheWireMesh!.visible = debugGlyphs;\n    }\n\n    private initializeGlyphDebugMesh() {\n        if (this.m_textCanvases.size === 0) {\n            return;\n        }\n        const defaultTextCanvas = this.m_textCanvases.values().next().value;\n        const defaultFontCatalog = defaultTextCanvas.fontCatalog;\n\n        // Initialize glyph-debugging mesh.\n        const planeGeometry = new THREE.PlaneGeometry(\n            defaultFontCatalog.textureSize.width / 2.5,\n            defaultFontCatalog.textureSize.height / 2.5,\n            defaultFontCatalog.textureSize.width / defaultFontCatalog.maxWidth,\n            defaultFontCatalog.textureSize.height / defaultFontCatalog.maxHeight\n        );\n        const material = new THREE.MeshBasicMaterial({\n            transparent: true,\n            depthWrite: false,\n            depthTest: false,\n            map: defaultFontCatalog.texture\n        });\n        this.m_debugGlyphTextureCacheMesh = new THREE.Mesh(planeGeometry, material);\n        this.m_debugGlyphTextureCacheMesh.renderOrder = 10000;\n        this.m_debugGlyphTextureCacheMesh.visible = false;\n\n        this.m_debugGlyphTextureCacheMesh.name = \"glyphDebug\";\n\n        const wireframe = new THREE.WireframeGeometry(planeGeometry);\n        const wireframeMaterial = new THREE.LineBasicMaterial({\n            transparent: true,\n            color: 0x999999,\n            depthWrite: false,\n            depthTest: false\n        });\n        this.m_debugGlyphTextureCacheWireMesh = new THREE.LineSegments(\n            wireframe,\n            wireframeMaterial\n        );\n        this.m_debugGlyphTextureCacheWireMesh.renderOrder = 9999;\n        this.m_debugGlyphTextureCacheWireMesh.visible = false;\n\n        this.m_debugGlyphTextureCacheWireMesh.name = \"glyphDebug\";\n\n        defaultTextCanvas\n            .getLayer(DEFAULT_TEXT_CANVAS_LAYER)!\n            .storage.scene.add(\n                this.m_debugGlyphTextureCacheMesh,\n                this.m_debugGlyphTextureCacheWireMesh\n            );\n    }\n\n    /**\n     * Visit all visible tiles and add/ their text elements to cache.\n     *\n     * @remarks\n     * The update of {@link TextElement}s is a time consuming process,\n     * and cannot be done every frame, but should only\n     * be done when the camera moved (a lot) of whenever the set of visible tiles change.\n     *\n     * The actually rendered {@link TextElement}s are stored internally\n     * until the next update is done\n     * to speed up rendering when no camera movement was detected.\n     * @param dataSourceTileList - List of tiles to be rendered for each data source.\n     */\n    private updateTextElements(dataSourceTileList: DataSourceTileList[]) {\n        if (updateStats) {\n            updateStats.clear();\n        }\n\n        this.m_textElementStateCache.clearTextCache();\n        this.m_cacheInvalidated = false;\n\n        this.checkIfOverloaded(dataSourceTileList);\n\n        // Used with tile offset to compute the x coordinate offset for tiles.\n        const updateStartTime =\n            this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : undefined;\n\n        // TODO: HARP-7648. Skip all data sources that won't contain text.\n        // TODO: HARP-7651. Higher priority labels should be updated before lower priority ones\n        // across all data sources.\n        // TODO: HARP-7373. Use rendered tiles (tiles currently rendered to cover the view,\n        // including fallbacks if necessary) instead of visible tiles (target tiles that might not\n        // be decoded yet).\n        // Otherwise labels persistent when crossing a zoom level boundary will flicker (fade out\n        // and back in) due to the delay in decoding the visible tiles.\n        dataSourceTileList.forEach(tileList => {\n            this.updateTextElementsFromSource(\n                tileList.dataSource,\n                tileList.storageLevel,\n                Array.from(tileList.renderedTiles.values()),\n                updateStartTime\n            );\n        });\n\n        if (updateStats) {\n            updateStats.log();\n        }\n    }\n\n    private updateTextElementsFromSource(\n        tileDataSource: DataSource,\n        storageLevel: number,\n        visibleTiles: Tile[],\n        updateStartTime: number | undefined\n    ) {\n        if (updateStats) {\n            updateStats.tiles += visibleTiles.length;\n        }\n        const sortedTiles = visibleTiles;\n\n        // TODO: HARP-7648. Really needed? Should it be done here or in VisibleTileSet?\n        sortedTiles.sort((a: Tile, b: Tile) => {\n            return a.tileKey.mortonCode() - b.tileKey.mortonCode();\n        });\n\n        const sortedGroups: TextElementLists[] = [];\n        this.createSortedGroupsForSorting(tileDataSource, storageLevel, sortedTiles, sortedGroups);\n\n        let numTextElementsUpdated = 0;\n\n        for (const textElementLists of sortedGroups) {\n            this.selectTextElementsToUpdateByDistance(textElementLists);\n\n            // The value of updateStartTime is set if this.overloaded is true.\n            if (updateStartTime !== undefined) {\n                // If overloaded and all time is used up, exit early.\n                if (OVERLOAD_UPDATE_TIME_LIMIT > 0) {\n                    const endTime = PerformanceTimer.now();\n                    const elapsedTime = endTime - updateStartTime;\n                    if (elapsedTime > OVERLOAD_UPDATE_TIME_LIMIT) {\n                        logger.debug(\"Update time limit exceeded.\");\n                        break;\n                    }\n                }\n\n                // Try not to update too many elements. They will be checked for visibility each\n                // frame.\n                numTextElementsUpdated += textElementLists.count();\n                if (numTextElementsUpdated >= OVERLOAD_UPDATED_LABEL_LIMIT) {\n                    logger.debug(\"Update label limit exceeded.\");\n                    break;\n                }\n            }\n        }\n    }\n\n    private prepareTextElementGroup(\n        textElementGroup: TextElementGroup,\n        tileKey: TileKey,\n        maxViewDistance?: number\n    ) {\n        if (textElementGroup.elements.length === 0) {\n            return;\n        }\n\n        const textElementSelection: TextElementFilter = (\n            textElementState: TextElementState\n        ): number | undefined => {\n            let { result, viewDistance } = checkReadyForPlacement(\n                textElementState.element,\n                textElementState.element.type === TextElementType.LineMarker\n                    ? textElementState.lineMarkerIndex\n                    : undefined,\n                this.m_viewState,\n                this.m_poiManager,\n                maxViewDistance\n            );\n\n            if (\n                result === PrePlacementResult.Ok &&\n                !this.m_textElementStateCache.deduplicateElement(\n                    this.m_viewState.zoomLevel,\n                    textElementState\n                )\n            ) {\n                result = PrePlacementResult.Duplicate;\n                viewDistance = undefined;\n            }\n\n            if (updateStats) {\n                updateStats.totalLabels++;\n                updateStats.results[result]++;\n            }\n            return viewDistance;\n        };\n\n        const [, found] = this.m_textElementStateCache.getOrSet(\n            textElementGroup,\n            tileKey,\n            textElementSelection\n        );\n\n        if (updateStats) {\n            ++updateStats.totalGroups;\n            if (!found) {\n                ++updateStats.newGroups;\n            }\n        }\n    }\n\n    private createSortedGroupsForSorting(\n        tileDataSource: DataSource,\n        storageLevel: number,\n        sortedTiles: Tile[],\n        sortedGroups: TextElementLists[]\n    ) {\n        if (sortedTiles.length === 0) {\n            return;\n        }\n\n        const tilesToRender: Tile[] = [];\n\n        for (const tile of sortedTiles) {\n            if (tileDataSource.shouldRenderText(storageLevel, tile.tileKey)) {\n                tilesToRender.push(tile);\n            }\n        }\n\n        const groupedPriorityLists: Map<number, TextElementLists> = new Map();\n\n        for (const tile of tilesToRender) {\n            for (const group of tile.textElementGroups.groups.values()) {\n                if (group.elements.length === 0) {\n                    continue;\n                }\n\n                const foundGroup = groupedPriorityLists.get(group.priority);\n                if (foundGroup === undefined) {\n                    groupedPriorityLists.set(\n                        group.priority,\n                        new TextElementLists([new TileTextElements(tile, group)])\n                    );\n                } else {\n                    foundGroup.lists.push(new TileTextElements(tile, group));\n                }\n            }\n        }\n\n        if (groupedPriorityLists.size === 0) {\n            return;\n        }\n\n        for (const g of groupedPriorityLists) {\n            const lists = g[1];\n            sortedGroups.push(lists);\n        }\n\n        sortedGroups.sort((a: TextElementLists, b: TextElementLists) => {\n            return b.priority - a.priority;\n        });\n\n        const printTextInfo = false;\n\n        if (PRINT_LABEL_DEBUG_INFO && printTextInfo) {\n            let outString = \"\";\n            for (const textElementLists of sortedGroups) {\n                let size = 0;\n                for (const tileTextElements of textElementLists.lists) {\n                    size += tileTextElements.group.elements.length;\n                }\n                outString += `priority ${textElementLists.priority} size: ${size}\\n`;\n            }\n            logger.log(outString);\n        }\n    }\n\n    private selectTextElementsToUpdateByDistance(textElementLists: TextElementLists) {\n        const farDistanceLimitRatio = Math.max(\n            this.m_options.maxDistanceRatioForTextLabels!,\n            this.m_options.maxDistanceRatioForPoiLabels!\n        );\n        const maxViewDistance = getMaxViewDistance(this.m_viewState, farDistanceLimitRatio);\n\n        for (const tileTextElements of textElementLists.lists) {\n            this.prepareTextElementGroup(\n                tileTextElements.group,\n                tileTextElements.tile.tileKey,\n                maxViewDistance\n            );\n        }\n    }\n\n    private placeTextElements(time: number, placeNewTextElements: boolean) {\n        const renderParams: RenderParams = {\n            numRenderedTextElements: 0,\n            fadeAnimationRunning: false,\n            time\n        };\n\n        const placeStartTime =\n            this.overloaded && this.m_viewState.isDynamic ? PerformanceTimer.now() : undefined;\n\n        if (placementStats) {\n            placementStats.clear();\n        }\n\n        if (this.m_textElementStateCache.size === 0) {\n            logger.debug(\"Text element cache empty.\");\n            return;\n        }\n\n        const placeNew = this.m_forceNewLabelsPass || placeNewTextElements;\n        if (this.m_forceNewLabelsPass) {\n            this.m_forceNewLabelsPass = false;\n        }\n\n        const maxNumPlacedTextElements = this.m_options.maxNumVisibleLabels;\n\n        // TODO: HARP-7648. Potential performance improvement. Place persistent labels + rejected\n        // candidates from previous frame if there's been no placement in this one.\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        let currentPriority: number = groupStates[0].priority;\n        let currentPriorityBegin: number = 0;\n\n        for (let i = 0; i < groupStates.length; ++i) {\n            const textElementGroupState = groupStates[i];\n            if (placementStats) {\n                ++placementStats.totalGroups;\n            }\n\n            const newPriority = textElementGroupState.priority;\n            if (placeNew && currentPriority !== newPriority) {\n                // Place all new labels of the previous priority before placing the persistent\n                // labels of this priority.\n                this.placeNewTextElements(currentPriorityBegin, i, renderParams);\n                if (isPlacementTimeExceeded(placeStartTime)) {\n                    break;\n                }\n                currentPriority = newPriority;\n                currentPriorityBegin = i;\n            }\n            if (\n                !this.placeTextElementGroup(\n                    textElementGroupState,\n                    renderParams,\n                    maxNumPlacedTextElements,\n                    Pass.PersistentLabels\n                )\n            ) {\n                break;\n            }\n\n            if (isPlacementTimeExceeded(placeStartTime)) {\n                break;\n            }\n        }\n\n        if (placeNew) {\n            // Place new text elements of the last priority.\n            this.placeNewTextElements(currentPriorityBegin, groupStates.length, renderParams);\n        }\n\n        if (placementStats) {\n            placementStats.numRenderedTextElements = renderParams.numRenderedTextElements;\n            placementStats.log();\n        }\n\n        if (renderParams.fadeAnimationRunning) {\n            this.m_isUpdatePending = true;\n        }\n    }\n\n    private placeNewTextElements(\n        beginGroupIndex: number,\n        endGroupIndex: number,\n        renderParams: RenderParams\n    ) {\n        const groupStates = this.m_textElementStateCache.sortedGroupStates;\n        for (let i = beginGroupIndex; i < endGroupIndex; ++i) {\n            if (\n                !this.placeTextElementGroup(\n                    groupStates[i],\n                    renderParams,\n                    this.m_options.maxNumVisibleLabels,\n                    Pass.NewLabels\n                )\n            ) {\n                break;\n            }\n        }\n    }\n\n    private placeOverlayTextElements() {\n        if (this.m_overlayTextElements === undefined || this.m_overlayTextElements.length === 0) {\n            return;\n        }\n\n        const screenSize = this.m_tmpVector.set(\n            this.m_screenProjector.width,\n            this.m_screenProjector.height\n        );\n        const screenXOrigin = -screenSize.width / 2.0;\n        const screenYOrigin = screenSize.height / 2.0;\n\n        // Place text elements one by one.\n        for (const textElement of this.m_overlayTextElements!) {\n            // Get the TextElementStyle.\n            const textElementStyle = this.m_textStyleCache.getTextElementStyle(textElement.style);\n            const textCanvas = textElementStyle.textCanvas;\n            if (textCanvas === undefined) {\n                continue;\n            }\n\n            const forceNewPassOnLoaded = false;\n            this.initializeGlyphs(textElement, textElementStyle, forceNewPassOnLoaded);\n\n            if (textElement.loadingState !== LoadingState.Initialized) {\n                continue;\n            }\n\n            const layer = textCanvas.getLayer(textElement.renderOrder ?? DEFAULT_TEXT_CANVAS_LAYER);\n\n            // Move onto the next TextElement if we cannot continue adding glyphs to this layer.\n            if (layer !== undefined) {\n                if (layer.storage.drawCount + textElement.glyphs!.length > layer.storage.capacity) {\n                    continue;\n                }\n            }\n\n            // Set the current style for the canvas.\n            textCanvas.textRenderStyle = textElement.renderStyle!;\n            textCanvas.textLayoutStyle = textElement.layoutStyle!;\n\n            // Place text.\n            let textPath;\n            if (!(textElement.type === TextElementType.PathLabel)) {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin + textElement.position.x * screenSize.width;\n                tempScreenPosition.y = screenYOrigin - textElement.position.y * screenSize.height;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n\n                tempPosition.x = tempScreenPosition.x;\n                tempPosition.y = tempScreenPosition.y;\n                tempPosition.z = 0.0;\n                addTextToCanvas(textElement, textCanvas, tempPosition);\n            } else {\n                // Adjust the label positioning.\n                tempScreenPosition.x = screenXOrigin;\n                tempScreenPosition.y = screenYOrigin;\n                if (textElement.xOffset !== undefined) {\n                    tempScreenPosition.x += textElement.xOffset;\n                }\n                if (textElement.yOffset !== undefined) {\n                    tempScreenPosition.y -= textElement.yOffset;\n                }\n\n                // Get the screen points that define the label's segments and create a path with\n                // them.\n                // TODO: HARP-7648. Optimize array allocations.\n                const screenPoints: THREE.Vector2[] = [];\n                for (const pt of textElement.path!) {\n                    const pX = tempScreenPosition.x + pt.x * screenSize.width;\n                    const pY = tempScreenPosition.y - pt.y * screenSize.height;\n                    screenPoints.push(new THREE.Vector2(pX, pY));\n                }\n                textPath = new SimplePath();\n                for (let i = 0; i < screenPoints.length - 1; ++i) {\n                    textPath.add(new THREE.LineCurve(screenPoints[i], screenPoints[i + 1]));\n                }\n                addTextToCanvas(textElement, textCanvas, tempPosition, textPath, true);\n            }\n        }\n    }\n\n    private getDistanceScalingFactor(\n        label: TextElement,\n        distance: number,\n        lookAtDistance: number\n    ): number {\n        // Distance scale is based on relation between camera focus point distance and\n        // the actual label distance. For labels close to camera look at point the scale\n        // remains unchanged, the farther is label from that point the smaller size it is\n        // rendered in screen space. This method is unaffected by near and far clipping planes\n        // distances, but may be improved by taking FOV into equation or customizing the\n        // focus point screen position based on horizon, actual ground, tilt ets.\n        let factor = lookAtDistance / distance;\n        // The label.distanceScale property defines the influence ratio at which\n        // distance affects the final scaling of label.\n        factor = 1.0 + (factor - 1.0) * label.distanceScale;\n        // Preserve the constraints\n        factor = Math.max(factor, this.m_options.labelDistanceScaleMin!);\n        factor = Math.min(factor, this.m_options.labelDistanceScaleMax!);\n        return factor;\n    }\n\n    private getDistanceFadingFactor(\n        label: TextElement,\n        state: TextElementState,\n        maxVisibilityDist: number\n    ): number {\n        let distanceFadeValue = 1.0;\n        const textDistance = state.viewDistance;\n\n        if (textDistance !== undefined && label.fadeFar !== undefined && label.fadeFar > 0.0) {\n            const fadeNear = label.fadeNear === undefined ? 0.0 : label.fadeNear;\n            const fadeFar = label.fadeFar;\n            if (fadeFar > fadeNear) {\n                distanceFadeValue =\n                    1.0 -\n                    THREE.MathUtils.clamp(\n                        (textDistance / maxVisibilityDist - fadeNear) / (fadeFar - fadeNear),\n                        0.0,\n                        1.0\n                    );\n            }\n        }\n        return distanceFadeValue;\n    }\n\n    private addPointLabel(\n        labelState: TextElementState,\n        position: THREE.Vector3,\n        screenPosition: THREE.Vector2,\n        textCanvas: TextCanvas | undefined,\n        renderParams: RenderParams\n    ): boolean {\n        const pointLabel: TextElement = labelState.element;\n        const textRenderState: RenderState | undefined = labelState.textRenderState;\n        const isLineMarker = pointLabel.type === TextElementType.LineMarker;\n\n        const iconRenderState = labelState.iconRenderState!;\n        assert(iconRenderState !== undefined);\n\n        // Find the label's original position.\n        tempScreenPosition.x = tempPoiScreenPosition.x = screenPosition.x;\n        tempScreenPosition.y = tempPoiScreenPosition.y = screenPosition.y;\n\n        // Scale the text depending on the label's distance to the camera \"zero\" plane.\n        const textDistance = pointToPlaneDistance(\n            position,\n            this.m_viewState.worldCenter,\n            this.m_cameraLookAt\n        );\n        if (\n            pointLabel.fadeFar !== undefined &&\n            (pointLabel.fadeFar <= 0.0 ||\n                pointLabel.fadeFar * this.m_viewState.maxVisibilityDist < textDistance)\n        ) {\n            // The label is farther away than fadeFar value, which means it is totally\n            // transparent.\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            return false;\n        }\n        labelState.setViewDistance(textDistance);\n\n        // Check if there is need to check for screen space for the label's icon.\n        const poiInfo = pointLabel.poiInfo;\n        let iconRejected = false;\n\n        // Check if icon should be rendered at this zoomLevel\n        const renderIcon =\n            poiInfo !== undefined &&\n            MathUtils.isClamped(\n                this.m_viewState.zoomLevel,\n                poiInfo.iconMinZoomLevel,\n                poiInfo.iconMaxZoomLevel\n            ) &&\n            poiInfo!.isValid !== false;\n\n        const distanceScaleFactor = this.getDistanceScalingFactor(\n            pointLabel,\n            textDistance,\n            this.m_viewState.lookAtDistance\n        );\n        const iconReady =\n            renderIcon && this.m_poiRenderer.prepareRender(pointLabel, this.m_viewState.env);\n        let iconInvisible = false;\n        if (iconReady) {\n            const result = placeIcon(\n                iconRenderState,\n                poiInfo!,\n                tempPoiScreenPosition,\n                distanceScaleFactor,\n                this.m_viewState.env,\n                this.m_screenCollisions\n            );\n            iconInvisible = result === PlacementResult.Invisible;\n            iconRejected = result === PlacementResult.Rejected;\n            if (iconInvisible) {\n                iconRenderState.reset();\n            }\n        } else if (renderIcon && poiInfo?.imageItem !== null) {\n            this.m_forceNewLabelsPass = true;\n            this.m_isUpdatePending = true;\n        }\n\n        const distanceFadeFactor = this.getDistanceFadingFactor(\n            pointLabel,\n            labelState,\n            this.m_viewState.maxVisibilityDist\n        );\n\n        // Render the label's text...\n        // textRenderState is always defined at this point.\n        if (textCanvas && shouldRenderPointText(labelState, this.m_viewState, this.m_options)) {\n            // For the new labels with rejected icons we don't need to go further.\n            const newLabel = !labelState.visible;\n\n            // Multi point (icons) features (line markers) will use single placement anchor, but\n            // single point labels (POIs, etc.) may use multi-placement algorithm.\n            const placeResult =\n                iconRejected && newLabel\n                    ? PlacementResult.Rejected\n                    : placePointLabel(\n                          labelState,\n                          tempScreenPosition,\n                          distanceScaleFactor,\n                          textCanvas,\n                          this.m_viewState.env,\n                          this.m_screenCollisions,\n                          tempPosition,\n                          !isLineMarker\n                      );\n            const textInvisible = placeResult === PlacementResult.Invisible;\n            if (textInvisible) {\n                if (placementStats) {\n                    placementStats.numPoiTextsInvisible++;\n                }\n                if (!renderIcon || iconInvisible) {\n                    labelState.reset();\n                    return false;\n                }\n                textRenderState!.reset();\n            }\n\n            const iconIsOptional = poiInfo?.iconIsOptional === true;\n            // Rejected icons are only considered to hide the text if they are valid, so a missing\n            // icon image will not keep the text from showing up.\n            const requiredIconRejected = iconRejected && iconReady && !iconIsOptional;\n            const textRejected = requiredIconRejected || placeResult === PlacementResult.Rejected;\n            if (!iconRejected && !iconInvisible) {\n                const textIsOptional = pointLabel.poiInfo?.textIsOptional === true;\n                iconRejected = textRejected && !textIsOptional;\n            }\n\n            if (textRejected) {\n                textRenderState!.startFadeOut(renderParams.time);\n            }\n\n            const textNeedsDraw =\n                !textInvisible &&\n                ((!textRejected && shouldRenderPoiText(labelState, this.m_viewState)) ||\n                    textRenderState!.isFading());\n\n            if (textNeedsDraw) {\n                if (!textRejected) {\n                    textRenderState!.startFadeIn(renderParams.time, this.m_options.disableFading);\n                }\n                renderParams.fadeAnimationRunning =\n                    renderParams.fadeAnimationRunning || textRenderState!.isFading();\n                if (\n                    addTextBufferToCanvas(\n                        labelState,\n                        textCanvas,\n                        tempPosition,\n                        distanceFadeFactor,\n                        distanceScaleFactor\n                    ) &&\n                    placementStats\n                ) {\n                    placementStats.numRenderedPoiTexts++;\n                }\n            }\n        }\n        // ... and render the icon (if any).\n        if (iconReady && !iconInvisible) {\n            if (iconRejected) {\n                iconRenderState.startFadeOut(renderParams.time);\n            } else {\n                iconRenderState!.startFadeIn(renderParams.time, this.m_options.disableFading);\n            }\n\n            renderParams.fadeAnimationRunning =\n                renderParams.fadeAnimationRunning || iconRenderState!.isFading();\n\n            const opacity = iconRenderState.opacity * distanceFadeFactor;\n            if (opacity > 0) {\n                // Same as for text, don't allocate screen space for an icon that's fading out so\n                // that any label blocked by it gets a chance to be placed as soon as any other\n                // surrounding new labels.\n                const allocateSpace = poiInfo!.reserveSpace !== false && !iconRejected;\n                this.m_poiRenderer.addPoi(\n                    poiInfo!,\n                    tempPoiScreenPosition,\n                    this.m_screenCollisions,\n                    labelState.renderDistance,\n                    distanceScaleFactor,\n                    allocateSpace,\n                    opacity,\n                    this.m_viewState.env\n                );\n\n                if (placementStats) {\n                    placementStats.numRenderedPoiIcons++;\n                }\n            }\n        }\n        renderParams.numRenderedTextElements++;\n        return true;\n    }\n\n    private addPoiLabel(\n        labelState: TextElementState,\n        textCanvas: TextCanvas | undefined,\n        renderParams: RenderParams\n    ): boolean {\n        const worldPosition = getWorldPosition(\n            labelState.element,\n            this.m_viewState.projection,\n            this.m_viewState.env,\n            this.m_tmpVector3\n        );\n\n        // Only process labels that are potentially within the frustum.\n        if (!this.labelPotentiallyVisible(worldPosition, tempScreenPosition)) {\n            return false;\n        }\n\n        // Add this POI as a point label.\n        return this.addPointLabel(\n            labelState,\n            worldPosition,\n            tempScreenPosition,\n            textCanvas,\n            renderParams\n        );\n    }\n\n    private addLineMarkerLabel(\n        labelState: TextElementState,\n        shieldGroups: number[][],\n        textCanvas: TextCanvas | undefined,\n        renderParams: RenderParams\n    ): void {\n        const lineMarkerLabel = labelState.element;\n\n        // Early exit if the line marker doesn't have the necessary data.\n        const poiInfo = lineMarkerLabel.poiInfo!;\n        if (!this.m_poiRenderer?.prepareRender(lineMarkerLabel, this.m_viewState.env)) {\n            return;\n        }\n\n        // Initialize the shield group for this lineMarker.\n        let shieldGroup: number[] | undefined;\n        if (poiInfo.shieldGroupIndex !== undefined) {\n            shieldGroup = shieldGroups[poiInfo.shieldGroupIndex];\n            if (shieldGroup === undefined) {\n                shieldGroup = [];\n                shieldGroups[poiInfo.shieldGroupIndex] = shieldGroup;\n            }\n        }\n\n        const lineTechnique = poiInfo.technique as LineMarkerTechnique;\n        const minDistanceSqr =\n            lineTechnique.minDistance !== undefined\n                ? lineTechnique.minDistance * lineTechnique.minDistance\n                : 0;\n\n        // Process markers (with shield groups).\n        if (minDistanceSqr > 0 && shieldGroup !== undefined) {\n            let numShieldsVisible = 0;\n            const point = labelState.position!;\n\n            // Only process potentially visible labels\n            if (this.labelPotentiallyVisible(point, tempScreenPosition)) {\n                // Find a suitable location for the lineMarker to be placed at.\n                let tooClose = false;\n                for (let j = 0; j < shieldGroup.length; j += 2) {\n                    const distanceSqr = Math2D.distSquared(\n                        shieldGroup[j],\n                        shieldGroup[j + 1],\n                        tempScreenPosition.x,\n                        tempScreenPosition.y\n                    );\n                    tooClose = distanceSqr < minDistanceSqr;\n                    if (tooClose) {\n                        break;\n                    }\n                }\n\n                // Place it as a point label if it's not to close to another marker in the\n                // same shield group.\n                if (!tooClose) {\n                    if (\n                        this.addPointLabel(\n                            labelState,\n                            point,\n                            tempScreenPosition,\n                            textCanvas,\n                            renderParams\n                        )\n                    ) {\n                        shieldGroup.push(tempScreenPosition.x, tempScreenPosition.y);\n                        numShieldsVisible++;\n                    }\n                }\n            }\n            if (numShieldsVisible === 0) {\n                // For road shields the shared textRenderState may only be reset if none of the\n                // icons can be rendered.\n                labelState.reset();\n            }\n        }\n        // Process markers (without shield groups).\n        else {\n            const point = labelState.position!;\n\n            // Only process potentially visible labels\n            if (this.labelPotentiallyVisible(point, tempScreenPosition)) {\n                this.addPointLabel(labelState, point, tempScreenPosition, textCanvas, renderParams);\n            }\n        }\n    }\n\n    private addPathLabel(\n        labelState: TextElementState,\n        screenPoints: THREE.Vector2[],\n        textCanvas: TextCanvas,\n        renderParams: RenderParams\n    ): boolean {\n        // TODO: HARP-7649. Add fade out transitions for path labels.\n        const textMaxDistance = getMaxViewDistance(\n            this.m_viewState,\n            this.m_options.maxDistanceRatioForTextLabels!\n        );\n        const pathLabel = labelState.element;\n\n        // Limit the text rendering of path labels in the far distance.\n        if (\n            !(\n                pathLabel.ignoreDistance === true ||\n                labelState.viewDistance === undefined ||\n                labelState.viewDistance < textMaxDistance\n            )\n        ) {\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.textRenderState!.reset();\n            return false;\n        }\n\n        if (\n            pathLabel.fadeFar !== undefined &&\n            (pathLabel.fadeFar <= 0.0 ||\n                pathLabel.fadeFar * this.m_viewState.maxVisibilityDist < labelState.renderDistance)\n        ) {\n            // The label is farther away than fadeFar value, which means it is totally\n            // transparent\n            if (placementStats) {\n                ++placementStats.tooFar;\n            }\n            labelState.textRenderState!.reset();\n            return false;\n        }\n\n        // Get the screen points that define the label's segments and create a path with\n        // them.\n        let textPath = new THREE.Path();\n        tempScreenPosition.copy(screenPoints[0]);\n        for (let i = 0; i < screenPoints.length - 1; ++i) {\n            textPath.add(new SimpleLineCurve(screenPoints[i], screenPoints[i + 1]));\n        }\n        // Flip the path if the label is gonna be rendered downwards.\n        if (textPath.getPoint(0.5).x - textPath.getPoint(0.51).x > 0) {\n            tempScreenPosition.copy(screenPoints[screenPoints.length - 1]);\n            textPath = new THREE.Path();\n            for (let i = screenPoints.length - 1; i > 0; --i) {\n                textPath.add(new SimpleLineCurve(screenPoints[i], screenPoints[i - 1]));\n            }\n        }\n\n        // Update the real rendering distance to have smooth fading and scaling\n        labelState.setViewDistance(\n            computeViewDistance(\n                pathLabel,\n                undefined,\n                this.m_viewState.worldCenter,\n                this.m_cameraLookAt\n            )\n        );\n        const textRenderDistance = -labelState.renderDistance;\n\n        // Scale the text depending on the label's distance to the camera.\n        const distanceScaleFactor = this.getDistanceScalingFactor(\n            pathLabel,\n            textRenderDistance,\n            this.m_viewState.lookAtDistance\n        );\n        const prevSize = textCanvas.textRenderStyle.fontSize.size;\n        textCanvas.textRenderStyle.fontSize.size *= distanceScaleFactor;\n\n        if (\n            placePathLabel(\n                labelState,\n                textPath,\n                tempScreenPosition,\n                textCanvas,\n                this.m_screenCollisions\n            ) !== PlacementResult.Ok\n        ) {\n            textCanvas.textRenderStyle.fontSize.size = prevSize;\n            if (placementStats) {\n                ++placementStats.numNotVisible;\n            }\n            labelState.textRenderState!.reset();\n            return false;\n        }\n\n        labelState.textRenderState!.startFadeIn(renderParams.time, this.m_options.disableFading);\n\n        let opacity = pathLabel.renderStyle!.opacity;\n\n        if (labelState.textRenderState!.isFading()) {\n            opacity *= labelState.textRenderState!.opacity;\n            renderParams.fadeAnimationRunning = true;\n        }\n\n        if (labelState.textRenderState!.opacity === 0) {\n            textCanvas.textRenderStyle.fontSize.size = prevSize;\n            return false;\n        }\n\n        const prevOpacity = textCanvas.textRenderStyle.opacity;\n        const prevBgOpacity = textCanvas.textRenderStyle.backgroundOpacity;\n        const distanceFadeFactor = this.getDistanceFadingFactor(\n            pathLabel,\n            labelState,\n            this.m_viewState.maxVisibilityDist\n        );\n        textCanvas.textRenderStyle.opacity = opacity * distanceFadeFactor;\n        textCanvas.textRenderStyle.backgroundOpacity =\n            textCanvas.textRenderStyle.opacity * pathLabel.renderStyle!.backgroundOpacity;\n\n        tempPosition.z = labelState.renderDistance;\n\n        addTextToCanvas(pathLabel, textCanvas, tempPosition, textPath);\n        renderParams.numRenderedTextElements++;\n\n        // Restore previous style values for text elements using the same style.\n        textCanvas.textRenderStyle.fontSize.size = prevSize;\n        textCanvas.textRenderStyle.opacity = prevOpacity;\n        textCanvas.textRenderStyle.backgroundOpacity = prevBgOpacity;\n        return true;\n    }\n\n    private checkIfOverloaded(dataSourceTileList: DataSourceTileList[]): boolean {\n        // Count the number of TextElements in the scene to see if we have to switch to\n        // \"overloadMode\".\n        let numTextElementsInScene = 0;\n\n        dataSourceTileList.forEach(renderListEntry => {\n            for (const tile of renderListEntry.renderedTiles.values()) {\n                numTextElementsInScene += tile.textElementGroups.count();\n            }\n        });\n        const newOverloaded = numTextElementsInScene > OVERLOAD_LABEL_LIMIT;\n\n        if (newOverloaded && !this.m_overloaded) {\n            logger.debug(\"Overloaded Mode enabled.\");\n        }\n        this.m_overloaded = newOverloaded;\n        return this.m_overloaded;\n    }\n\n    /**\n     * Project point to screen and check if it is on screen or within a fixed distance to the\n     * border.\n     *\n     * @param point center point of label.\n     * @param outPoint projected screen point of label.\n     */\n    private labelPotentiallyVisible(point: Vector3Like, outPoint: THREE.Vector2): boolean {\n        const maxDistance = THREE.MathUtils.clamp(this.m_options.maxPoiDistanceToBorder ?? 0, 0, 1);\n        const projectionResult = this.m_screenProjector.projectAreaToScreen(\n            point,\n            maxDistance,\n            maxDistance,\n            outPoint\n        );\n        return projectionResult !== undefined;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Maximum distance for text labels expressed as a ratio of distance to from the camera (0) to the\n * far plane (1.0). May be synchronized with fog value ?\n */\nconst DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS = 0.99;\n\n/**\n * Minimum scaling factor that may be applied to labels when their are distant from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MIN = 0.7;\n\n/**\n * Maximum scaling factor that may be applied to labels due to their distance from focus point.\n */\nconst DEFAULT_LABEL_DISTANCE_SCALE_MAX = 1.5;\n\n// Allowed distance to screen border for early rejection of POIs during placement. Its range is\n// [0..1] of screen size.\n// A value of 0 will lead to POI labels popping in at the border of the screen. A large value will\n// lead to many labels being placed outside the screen, with all the required actions for measuring\n// and loading glyphs impacting performance.\nconst DEFAULT_MAX_DISTANCE_TO_BORDER = 0.2;\n\nconst MIN_GLYPH_COUNT = 1024;\n\nconst MAX_GLYPH_COUNT = 32768;\n\nexport interface TextElementsRendererOptions {\n    /**\n     * The path to the font catalog file.\n     */\n    fontCatalog?: string;\n    /**\n     * Optional initial number of glyphs (characters) for labels. In situations with limited,\n     * available memory, decreasing this number may be beneficial.\n     *\n     * @default [[MIN_GLYPH_COUNT]]\n     */\n    minNumGlyphs?: number;\n    /**\n     * Optional limit of number of glyphs (characters) for labels. In situations with limited,\n     * available memory, decreasing this number may be beneficial.\n     *\n     * @default [[MAX_GLYPH_COUNT]]\n     */\n    maxNumGlyphs?: number;\n    /**\n     * Limits the number of {@link DataSource} labels visible, such as road names and POIs.\n     * On small devices, you can reduce this number to to increase performance.\n     * @default `undefined` (no limit).\n     */\n    maxNumVisibleLabels?: number;\n    /**\n     * The maximum distance for {@link TextElement} to be rendered, expressed as a fraction of\n     * the distance between the near and far plane [0, 1.0].\n     * @default [[DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS]].\n     */\n    maxDistanceRatioForTextLabels?: number;\n    /**\n     * The maximum distance for {@link TextElement} with icons to be rendered,\n     * expressed as a fraction of the distance\n     * between the near and far plane [0, 1.0].\n     * @default [[DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS]].\n     */\n    maxDistanceRatioForPoiLabels?: number;\n    /**\n     * The minimum scaling factor that may be applied to {@link TextElement}s due to their distance.\n     * If not defined the default value specified in {@link TextElementsRenderer} will be used.\n     * @default [[DEFAULT_LABEL_DISTANCE_SCALE_MIN]].\n     */\n    labelDistanceScaleMin?: number;\n    /**\n     * The maximum scaling factor that may be applied to {@link TextElement}s due to their distance.\n     * If not defined the default value specified in {@link TextElementsRenderer} will be used.\n     * @default [[DEFAULT_LABEL_DISTANCE_SCALE_MAX]].\n     */\n    labelDistanceScaleMax?: number;\n\n    /**\n     * Disable all fading animations for debugging and performance measurement.\n     * @default `false`\n     */\n    disableFading?: boolean;\n\n    /**\n     * Enable that new labels are delayed until movement is finished\n     * @default `true`\n     */\n    delayLabelsUntilMovementFinished?: boolean;\n\n    /**\n     * If `true`, a replacement glyph (\"?\") is rendered for every missing glyph.\n     * @default `false`\n     */\n    showReplacementGlyphs?: boolean;\n\n    /**\n     * The maximum distance to the screen border as a fraction of screen size [0..1].\n     * @default [[DEFAULT_MAX_DISTANCE_TO_BORDER]].\n     */\n    maxPoiDistanceToBorder?: number;\n\n    /**\n     * An optional canvas element that renders 2D collision debug information.\n     */\n    collisionDebugCanvas?: HTMLCanvasElement;\n}\n\n/**\n * Initializes undefined text renderer options to default values.\n * @param options - The options to be initialized.\n */\nexport function initializeDefaultOptions(options: TextElementsRendererOptions) {\n    if (options.minNumGlyphs === undefined) {\n        options.minNumGlyphs = MIN_GLYPH_COUNT;\n    }\n    if (options.maxNumGlyphs === undefined) {\n        options.maxNumGlyphs = MAX_GLYPH_COUNT;\n    }\n    if (options.labelDistanceScaleMin === undefined) {\n        options.labelDistanceScaleMin = DEFAULT_LABEL_DISTANCE_SCALE_MIN;\n    }\n    if (options.labelDistanceScaleMax === undefined) {\n        options.labelDistanceScaleMax = DEFAULT_LABEL_DISTANCE_SCALE_MAX;\n    }\n    if (options.maxDistanceRatioForTextLabels === undefined) {\n        options.maxDistanceRatioForTextLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n    if (options.maxDistanceRatioForPoiLabels === undefined) {\n        options.maxDistanceRatioForPoiLabels = DEFAULT_MAX_DISTANCE_RATIO_FOR_LABELS;\n    }\n\n    if (options.disableFading === undefined) {\n        options.disableFading = false;\n    }\n\n    if (options.delayLabelsUntilMovementFinished === undefined) {\n        options.delayLabelsUntilMovementFinished = true;\n    }\n\n    if (options.showReplacementGlyphs === undefined) {\n        options.showReplacementGlyphs = false;\n    }\n\n    if (options.maxPoiDistanceToBorder === undefined) {\n        options.maxPoiDistanceToBorder = DEFAULT_MAX_DISTANCE_TO_BORDER;\n    }\n}\n","/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    ColorUtils,\n    getPropertyValue,\n    isPoiTechnique,\n    LineMarkerTechnique,\n    MapEnv,\n    PlacementToken,\n    PoiTechnique,\n    TextStyleDefinition,\n    TextTechnique\n} from \"@here/harp-datasource-protocol\";\nimport {\n    DefaultTextStyle,\n    FontStyle,\n    FontUnit,\n    FontVariant,\n    HorizontalAlignment,\n    HorizontalPlacement,\n    resolvePlacementAndAlignment,\n    TextCanvas,\n    TextLayoutParameters,\n    TextLayoutStyle,\n    TextPlacement,\n    TextPlacements,\n    TextRenderParameters,\n    TextRenderStyle,\n    VerticalAlignment,\n    VerticalPlacement,\n    WrappingMode\n} from \"@here/harp-text-canvas\";\nimport { getOptionValue, LoggerManager } from \"@here/harp-utils\";\n\nimport { ColorCache } from \"../ColorCache\";\nimport { evaluateColorProperty } from \"../DecodedTileHelpers\";\nimport { Tile } from \"../Tile\";\nimport { DEFAULT_FONT_CATALOG_NAME, TextCanvases } from \"./TextElementsRenderer\";\n\nconst logger = LoggerManager.instance.create(\"TextStyleCache\");\n\nconst defaultTextRenderStyle = new TextRenderStyle({\n    fontSize: {\n        unit: FontUnit.Pixel,\n        size: 32,\n        backgroundSize: 8\n    },\n    color: ColorCache.instance.getColor(\"#6d7477\"),\n    opacity: 1.0,\n    backgroundColor: ColorCache.instance.getColor(\"#f7fbfd\"),\n    backgroundOpacity: 0.5\n});\n\n// By default text layout provides no options for placement, but single alignment.\nconst defaultTextLayoutStyle = new TextLayoutStyle({\n    verticalAlignment: VerticalAlignment.Center,\n    horizontalAlignment: HorizontalAlignment.Center,\n    placements: []\n});\n\nconst DEFAULT_STYLE_NAME = \"default\";\n\n/**\n * {@link TextElementsRenderer} representation of a\n * {@link @here/harp-datasource-protocol#Theme}'s TextStyle.\n */\nexport interface TextElementStyle {\n    name: string;\n    fontCatalog?: string;\n    renderParams: TextRenderParameters;\n    layoutParams: TextLayoutParameters;\n    textCanvas?: TextCanvas;\n}\n\nexport class TextStyleCache {\n    private readonly m_textStyles: Map<string, TextElementStyle> = new Map();\n    private m_defaultStyle: TextElementStyle = {\n        name: DEFAULT_STYLE_NAME,\n        fontCatalog: undefined,\n        renderParams: defaultTextRenderStyle.params,\n        layoutParams: defaultTextLayoutStyle.params\n    };\n\n    constructor() {\n        this.updateDefaultTextStyle();\n    }\n\n    updateTextStyles(\n        textStyleDefinitions?: TextStyleDefinition[],\n        defaultTextStyleDefinition?: TextStyleDefinition\n    ) {\n        this.m_textStyles.clear();\n        textStyleDefinitions?.forEach(element => {\n            this.m_textStyles.set(\n                element.name!,\n                this.createTextElementStyle(element, element.name!)\n            );\n        });\n        this.updateDefaultTextStyle(defaultTextStyleDefinition, textStyleDefinitions);\n    }\n\n    updateTextCanvases(textCanvases: TextCanvases) {\n        // Initialize default text style.\n        this.initializeTextCanvas(this.m_defaultStyle, textCanvases);\n\n        for (const [, style] of this.m_textStyles) {\n            this.initializeTextCanvas(style, textCanvases);\n        }\n    }\n\n    /**\n     * Retrieves a {@link TextElementStyle} for {@link @here/harp-datasource-protocol#Theme}'s\n     * [[TextStyle]] id.\n     */\n    getTextElementStyle(styleId?: string): TextElementStyle {\n        let result;\n        if (styleId === undefined) {\n            result = this.m_defaultStyle;\n        } else {\n            result = this.m_textStyles.get(styleId);\n            if (result === undefined) {\n                result = this.m_defaultStyle;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the appropriate {@link @here/harp-text-canvas#TextRenderStyle}\n     * to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     */\n    createRenderStyle(\n        tile: Tile,\n        technique: TextTechnique | PoiTechnique | LineMarkerTechnique\n    ): TextRenderStyle {\n        const mapView = tile.mapView;\n        const zoomLevel = mapView.zoomLevel;\n        const discreteZoomLevel = Math.floor(zoomLevel);\n\n        // Environment with $zoom forced to integer to achieve stable interpolated values.\n        const discreteZoomEnv = new MapEnv({ $zoom: discreteZoomLevel }, mapView.env);\n\n        const defaultRenderParams = this.m_defaultStyle.renderParams;\n\n        // Sets opacity to 1.0 if default and technique attribute are undefined.\n        const defaultOpacity = getOptionValue(defaultRenderParams.opacity, 1.0);\n        // Interpolate opacity but only on discreet zoom levels (step interpolation).\n        let opacity = getPropertyValue(\n            getOptionValue(technique.opacity, defaultOpacity),\n            discreteZoomEnv\n        );\n\n        let color: THREE.Color | undefined;\n        // Store color (RGB) in cache and multiply opacity value with the color alpha channel.\n        if (technique.color !== undefined) {\n            let hexColor = evaluateColorProperty(technique.color, discreteZoomEnv);\n            if (hexColor !== undefined) {\n                if (ColorUtils.hasAlphaInHex(hexColor)) {\n                    const alpha = ColorUtils.getAlphaFromHex(hexColor);\n                    opacity = opacity * alpha;\n                    hexColor = ColorUtils.removeAlphaFromHex(hexColor);\n                }\n                color = ColorCache.instance.getColor(hexColor);\n            }\n        }\n\n        // Sets background size to 0.0 if default and technique attribute is undefined.\n        const defaultBackgroundSize = getOptionValue(\n            defaultRenderParams.fontSize!.backgroundSize,\n            0\n        );\n        const backgroundSize = getPropertyValue(\n            getOptionValue(technique.backgroundSize, defaultBackgroundSize),\n            discreteZoomEnv\n        );\n\n        const hasBackgroundDefined =\n            technique.backgroundColor !== undefined &&\n            technique.backgroundSize !== undefined &&\n            backgroundSize > 0;\n\n        // Sets background opacity to 1.0 if default and technique value is undefined while\n        // background size and color is specified, otherwise set value in default render\n        // params or 0.0 if neither set. Makes label opaque when backgroundColor and\n        // backgroundSize are set.\n        const defaultBackgroundOpacity = getOptionValue(defaultRenderParams.backgroundOpacity, 0.0);\n        let backgroundOpacity = getPropertyValue(\n            getOptionValue(\n                technique.backgroundOpacity,\n                hasBackgroundDefined ? 1.0 : defaultBackgroundOpacity\n            ),\n            discreteZoomEnv\n        );\n\n        let backgroundColor: THREE.Color | undefined;\n        // Store background color (RGB) in cache and multiply backgroundOpacity by its alpha.\n        if (technique.backgroundColor !== undefined) {\n            let hexBgColor = evaluateColorProperty(technique.backgroundColor, discreteZoomEnv);\n            if (hexBgColor !== undefined) {\n                if (ColorUtils.hasAlphaInHex(hexBgColor)) {\n                    const alpha = ColorUtils.getAlphaFromHex(hexBgColor);\n                    backgroundOpacity = backgroundOpacity * alpha;\n                    hexBgColor = ColorUtils.removeAlphaFromHex(hexBgColor);\n                }\n                backgroundColor = ColorCache.instance.getColor(hexBgColor);\n            }\n        }\n\n        const renderParams = {\n            fontName: getOptionValue(technique.fontName, defaultRenderParams.fontName),\n            fontSize: {\n                unit: FontUnit.Pixel,\n                size: getPropertyValue(\n                    getOptionValue(technique.size, defaultRenderParams.fontSize!.size),\n                    discreteZoomEnv\n                ),\n                backgroundSize\n            },\n            fontStyle:\n                technique.fontStyle === \"Regular\" ||\n                technique.fontStyle === \"Bold\" ||\n                technique.fontStyle === \"Italic\" ||\n                technique.fontStyle === \"BoldItalic\"\n                    ? FontStyle[technique.fontStyle]\n                    : defaultRenderParams.fontStyle,\n            fontVariant:\n                technique.fontVariant === \"Regular\" ||\n                technique.fontVariant === \"AllCaps\" ||\n                technique.fontVariant === \"SmallCaps\"\n                    ? FontVariant[technique.fontVariant]\n                    : defaultRenderParams.fontVariant,\n            rotation: getOptionValue(technique.rotation, defaultRenderParams.rotation),\n            color: getOptionValue(\n                color,\n                getOptionValue(defaultRenderParams.color, DefaultTextStyle.DEFAULT_COLOR)\n            ),\n            backgroundColor: getOptionValue(\n                backgroundColor,\n                getOptionValue(\n                    defaultRenderParams.backgroundColor,\n                    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR\n                )\n            ),\n            opacity,\n            backgroundOpacity\n        };\n\n        const themeRenderParams = this.getTextElementStyle(technique.style).renderParams;\n        const renderStyle = new TextRenderStyle({\n            ...themeRenderParams,\n            ...renderParams\n        });\n\n        return renderStyle;\n    }\n\n    /**\n     * Create the appropriate {@link @here/harp-text-canvas#TextLayoutStyle}\n     * to use for a label. Depends heavily on the label's\n     * [[Technique]] and the current zoomLevel.\n     *\n     * @param tile - The {@link Tile} to process.\n     * @param technique - Label's technique.\n     */\n    createLayoutStyle(\n        tile: Tile,\n        technique: TextTechnique | PoiTechnique | LineMarkerTechnique\n    ): TextLayoutStyle {\n        const mapView = tile.mapView;\n        const floorZoomLevel = Math.floor(tile.mapView.zoomLevel);\n\n        const discreteZoomEnv = new MapEnv({ $zoom: floorZoomLevel }, mapView.env);\n\n        const defaultLayoutParams = this.m_defaultStyle.layoutParams;\n\n        const hAlignment = getPropertyValue(technique.hAlignment, discreteZoomEnv) as string | null;\n        const vAlignment = getPropertyValue(technique.vAlignment, discreteZoomEnv) as string | null;\n\n        // Text alternative placements are currently supported only for PoiTechnique.\n        const textPlacements = isPoiTechnique(technique)\n            ? (getPropertyValue((technique as PoiTechnique).placements, discreteZoomEnv) as\n                  | string\n                  | null)\n            : null;\n\n        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(\n            hAlignment,\n            vAlignment,\n            textPlacements\n        );\n\n        const wrapping = getPropertyValue(technique.wrappingMode, discreteZoomEnv) as string | null;\n\n        const wrappingMode =\n            wrapping === \"None\" || wrapping === \"Character\" || wrapping === \"Word\"\n                ? WrappingMode[wrapping]\n                : defaultLayoutParams.wrappingMode;\n\n        const layoutParams = {\n            tracking:\n                getPropertyValue(technique.tracking, discreteZoomEnv) ??\n                defaultLayoutParams.tracking,\n            leading:\n                getPropertyValue(technique.leading, discreteZoomEnv) ?? defaultLayoutParams.leading,\n            maxLines:\n                getPropertyValue(technique.maxLines, discreteZoomEnv) ??\n                defaultLayoutParams.maxLines,\n            lineWidth:\n                getPropertyValue(technique.lineWidth, discreteZoomEnv) ??\n                defaultLayoutParams.lineWidth,\n            canvasRotation:\n                getPropertyValue(technique.canvasRotation, discreteZoomEnv) ??\n                defaultLayoutParams.canvasRotation,\n            lineRotation:\n                getPropertyValue(technique.lineRotation, discreteZoomEnv) ??\n                defaultLayoutParams.lineRotation,\n            wrappingMode,\n            horizontalAlignment,\n            verticalAlignment,\n            placements\n        };\n\n        const themeLayoutParams = this.getTextElementStyle(technique.style);\n        const layoutStyle = new TextLayoutStyle({\n            ...themeLayoutParams,\n            ...layoutParams\n        });\n\n        return layoutStyle;\n    }\n\n    private updateDefaultTextStyle(\n        defaultTextStyleDefinition?: TextStyleDefinition,\n        textStyleDefinitions?: TextStyleDefinition[]\n    ) {\n        this.m_defaultStyle.fontCatalog = undefined;\n\n        const style =\n            textStyleDefinitions?.find(definition => {\n                return definition.name === DEFAULT_STYLE_NAME;\n            }) ??\n            defaultTextStyleDefinition ??\n            textStyleDefinitions?.[0];\n        if (style) {\n            this.m_defaultStyle = this.createTextElementStyle(style, DEFAULT_STYLE_NAME);\n        }\n        this.m_defaultStyle.textCanvas = undefined;\n    }\n\n    private initializeTextCanvas(style: TextElementStyle, textCanvases: TextCanvases): void {\n        if (style.textCanvas) {\n            return;\n        }\n        if (style.fontCatalog !== undefined) {\n            const styledTextCanvas = textCanvases.get(style.fontCatalog);\n            style.textCanvas = styledTextCanvas;\n            if (textCanvases.has(style.fontCatalog) && !styledTextCanvas) {\n                logger.info(`fontCatalog(${style.fontCatalog}), not yet loaded`);\n                return;\n            }\n        }\n        // specified canvas not found\n        if (style.textCanvas === undefined) {\n            if (\n                style.fontCatalog !== undefined &&\n                style.fontCatalog !== DEFAULT_FONT_CATALOG_NAME\n            ) {\n                logger.warn(\n                    `FontCatalog '${style.fontCatalog}' set in TextStyle\n                     '${style.name}' not found`\n                );\n            }\n\n            // find another canvas to use then\n            let alternativeTextCanvas = textCanvases.get(DEFAULT_FONT_CATALOG_NAME);\n            if (!alternativeTextCanvas && textCanvases.size > 0) {\n                for (const [, canvas] of textCanvases) {\n                    if (canvas) {\n                        alternativeTextCanvas = canvas;\n                        break;\n                    }\n                }\n            }\n\n            // if an alternative canvas is found, use it\n            if (alternativeTextCanvas) {\n                style.textCanvas = alternativeTextCanvas;\n                if (style.fontCatalog !== undefined) {\n                    logger.info(\n                        `fontCatalog: '${style.fontCatalog}' not found,\n                      using default fontCatalog(${style.textCanvas?.name}).`\n                    );\n                }\n            }\n        }\n    }\n\n    private createTextElementStyle(\n        style: TextStyleDefinition,\n        styleName: string\n    ): TextElementStyle {\n        const { horizontalAlignment, verticalAlignment, placements } = parseAlignmentAndPlacements(\n            style.hAlignment,\n            style.vAlignment,\n            style.placements\n        );\n        return {\n            name: styleName,\n            fontCatalog: getOptionValue(style.fontCatalogName, this.m_defaultStyle.fontCatalog),\n            renderParams: {\n                fontName: style.fontName,\n                fontSize: {\n                    unit: FontUnit.Pixel,\n                    size: 32,\n                    backgroundSize: style.backgroundSize ?? 8\n                },\n                fontStyle:\n                    style.fontStyle === \"Regular\" ||\n                    style.fontStyle === \"Bold\" ||\n                    style.fontStyle === \"Italic\" ||\n                    style.fontStyle === \"BoldItalic\"\n                        ? FontStyle[style.fontStyle]\n                        : undefined,\n                fontVariant:\n                    style.fontVariant === \"Regular\" ||\n                    style.fontVariant === \"AllCaps\" ||\n                    style.fontVariant === \"SmallCaps\"\n                        ? FontVariant[style.fontVariant]\n                        : undefined,\n                rotation: style.rotation,\n                color:\n                    style.color !== undefined\n                        ? ColorCache.instance.getColor(style.color)\n                        : undefined,\n                backgroundColor:\n                    style.backgroundColor !== undefined\n                        ? ColorCache.instance.getColor(style.backgroundColor)\n                        : undefined,\n                opacity: style.opacity,\n                backgroundOpacity: style.backgroundOpacity\n            },\n            layoutParams: {\n                tracking: style.tracking,\n                leading: style.leading,\n                maxLines: style.maxLines,\n                lineWidth: style.lineWidth,\n                canvasRotation: style.canvasRotation,\n                lineRotation: style.lineRotation,\n                wrappingMode:\n                    style.wrappingMode === \"None\" ||\n                    style.wrappingMode === \"Character\" ||\n                    style.wrappingMode === \"Word\"\n                        ? WrappingMode[style.wrappingMode]\n                        : WrappingMode.Word,\n                verticalAlignment,\n                horizontalAlignment,\n                placements\n            }\n        };\n    }\n}\n\nfunction parseAlignmentAndPlacements(\n    hAlignment: string | null | undefined,\n    vAlignment: string | null | undefined,\n    placementsTokens: string | null | undefined\n): {\n    horizontalAlignment: HorizontalAlignment;\n    verticalAlignment: VerticalAlignment;\n    placements: TextPlacements;\n} {\n    // Currently supported only for PoiTechnique.\n    const placements: TextPlacements | undefined = placementsTokens\n        ? parseTechniquePlacements(placementsTokens)\n        : undefined;\n\n    return resolvePlacementAndAlignment(\n        parseTechniqueHAlignValue(hAlignment),\n        parseTechniqueVAlignValue(vAlignment),\n        placements\n    );\n}\n\nfunction parseTechniqueHAlignValue(hAlignment: string | undefined | null): HorizontalAlignment {\n    return hAlignment === \"Left\" || hAlignment === \"Center\" || hAlignment === \"Right\"\n        ? HorizontalAlignment[hAlignment]\n        : defaultTextLayoutStyle.horizontalAlignment;\n}\n\nfunction parseTechniqueVAlignValue(vAlignment: string | undefined | null): VerticalAlignment {\n    return vAlignment === \"Above\" || vAlignment === \"Center\" || vAlignment === \"Below\"\n        ? VerticalAlignment[vAlignment]\n        : defaultTextLayoutStyle.verticalAlignment;\n}\n\nfunction parseTechniquePlacements(placementsString: string | undefined | null): TextPlacements {\n    // Parse placement properties if available.\n    const placements: TextPlacements = [];\n    const placementsTokens = placementsString\n        ? placementsString!.toUpperCase().replace(\" \", \"\").split(\",\")\n        : [];\n    placementsTokens.forEach(p => {\n        const val = parseTechniquePlacementValue(p);\n        if (val !== undefined) {\n            placements.push(val);\n        }\n    });\n    return placements;\n}\n\nfunction parseTechniquePlacementValue(p: string): TextPlacement | undefined {\n    // May be only literal of single or two characters.\n    if (p.length < 1 || p.length > 2) {\n        return undefined;\n    }\n    // If no value is specified for vertical/horizontal placement it is by default center.\n    const textPlacement: TextPlacement = {\n        h: HorizontalPlacement.Center,\n        v: VerticalPlacement.Center\n    };\n    // Firstly try to find vertical placement.\n    let modifier = p.charAt(0);\n    let found: boolean = true;\n    switch (modifier) {\n        // Top / north\n        case PlacementToken.Top:\n        case PlacementToken.North:\n            textPlacement.v = VerticalPlacement.Top;\n            break;\n        // Bottom / south\n        case PlacementToken.Bottom:\n        case PlacementToken.South:\n            textPlacement.v = VerticalPlacement.Bottom;\n            break;\n        default:\n            found = false;\n            if (p.length === 2) {\n                // For 2 characters tag both vertical/horizontal should be defined.\n                return undefined;\n            }\n    }\n    if (found && p.length === 1) {\n        return textPlacement;\n    }\n    modifier = p.length === 1 ? p.charAt(0) : p.charAt(1);\n    switch (modifier) {\n        // Right / east\n        case PlacementToken.Right:\n        case PlacementToken.East:\n            textPlacement.h = HorizontalPlacement.Right;\n            break;\n        // Left / west\n        case PlacementToken.Left:\n        case PlacementToken.West:\n            textPlacement.h = HorizontalPlacement.Left;\n            break;\n        default:\n            // Either for single character or multi-char tag, we must surrender.\n            return undefined;\n    }\n    return textPlacement;\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n    IndexedTechniqueParams,\n    LineMarkerTechnique,\n    PoiTechnique,\n    TextTechnique\n} from \"@here/harp-datasource-protocol\";\nimport { TextLayoutStyle, TextRenderStyle } from \"@here/harp-text-canvas\";\n\nimport { Tile } from \"../Tile\";\n\nexport class TileTextStyleCache {\n    private textRenderStyles: TextRenderStyle[] = [];\n    private textLayoutStyles: TextLayoutStyle[] = [];\n    private readonly tile: Tile;\n\n    constructor(tile: Tile) {\n        this.tile = tile;\n    }\n\n    clear() {\n        this.textRenderStyles.length = 0;\n        this.textLayoutStyles.length = 0;\n    }\n\n    getRenderStyle(\n        technique: (TextTechnique | PoiTechnique | LineMarkerTechnique) & IndexedTechniqueParams\n    ): TextRenderStyle {\n        let style = this.textRenderStyles[technique._index];\n        if (style === undefined) {\n            style = this.textRenderStyles[\n                technique._index\n            ] = this.tile.mapView.textElementsRenderer.styleCache.createRenderStyle(\n                this.tile,\n                technique\n            );\n        }\n        return style;\n    }\n\n    getLayoutStyle(\n        technique: (TextTechnique | PoiTechnique | LineMarkerTechnique) & IndexedTechniqueParams\n    ): TextLayoutStyle {\n        let style = this.textLayoutStyles[technique._index];\n        if (style === undefined) {\n            style = this.textLayoutStyles[\n                technique._index\n            ] = this.tile.mapView.textElementsRenderer.styleCache.createLayoutStyle(\n                this.tile,\n                technique\n            );\n        }\n        return style;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"@here/harp-utils\";\n\nimport { PrePlacementResult } from \"./Placement\";\n\nexport class UpdateStats {\n    tiles: number = 0;\n    totalGroups: number = 0;\n    newGroups: number = 0;\n    totalLabels: number = 0;\n    results = new Array<number>(PrePlacementResult.Count);\n\n    constructor(private readonly m_logger: IChannel) {\n        this.results.fill(0);\n    }\n\n    clear() {\n        this.tiles = 0;\n        this.totalGroups = 0;\n        this.newGroups = 0;\n        this.totalLabels = 0;\n        this.results.fill(0);\n    }\n\n    log() {\n        this.m_logger.debug(\"Tiles\", this.tiles);\n        this.m_logger.debug(\"Total groups\", this.totalGroups);\n        this.m_logger.debug(\"New groups\", this.newGroups);\n        this.m_logger.debug(\"Total labels\", this.totalLabels);\n        this.m_logger.debug(\"Placed labels\", this.results[PrePlacementResult.Ok]);\n        this.m_logger.debug(\"Invisible\", this.results[PrePlacementResult.Invisible]);\n        this.m_logger.debug(\"Poi not ready\", this.results[PrePlacementResult.NotReady]);\n        this.m_logger.debug(\"Too far\", this.results[PrePlacementResult.TooFar]);\n        this.m_logger.debug(\"Duplicate\", this.results[PrePlacementResult.Duplicate]);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Message sent by web worker that requests to resolve actual\n * URLs of it's dependencies.\n *\n * Main thread is expected.\n */\nexport interface WorkerBootstrapRequest {\n    type: \"worker-bootstrap-request\";\n\n    /// Names of dependencies, usually NPM package names.\n    dependencies: string[];\n}\n\nexport interface WorkerBootstrapResponse {\n    type: \"worker-bootstrap-response\";\n\n    /// Actual URL scripts requested in [[WorkerBootstrapRequest]].\n    resolvedDependencies: string[];\n}\n\nexport function isWorkerBootstrapRequest(message: any): message is WorkerBootstrapRequest {\n    return (\n        message &&\n        message.type === \"worker-bootstrap-request\" &&\n        Array.isArray(message.dependencies)\n    );\n}\n\nexport function isWorkerBootstrapResponse(message: any): message is WorkerBootstrapResponse {\n    return (\n        message &&\n        message.type === \"worker-bootstrap-response\" &&\n        Array.isArray(message.resolvedDependencies)\n    );\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport \"@here/harp-fetch\";\n\nimport { getUrlOrigin, LoggerManager } from \"@here/harp-utils\";\n\nimport { isWorkerBootstrapRequest, WorkerBootstrapResponse } from \"./WorkerBootstrapDefs\";\n\nconst logger = LoggerManager.instance.create(\"WorkerLoader\");\n\n/**\n * Set of `Worker` loading and initialization helpers:\n *  - starting Worker from URL with fallback to XHR+blob {@link WorkerLoader.startWorker}\n *  - waiting for proper worker initialization, see {@link WorkerLoader.waitWorkerInitialized}\n */\nexport class WorkerLoader {\n    static directlyFallbackToBlobBasedLoading: boolean = false;\n    static sourceLoaderCache = new Map<string, Promise<string>>();\n    static dependencyUrlMapping: { [name: string]: string } = {};\n\n    /**\n     * Starts worker by first attempting load from `scriptUrl` using native `Worker` constructor.\n     * Then waits (using [[waitWorkerInitialized]]) for first message that indicates successful\n     * initialization.\n     * If `scriptUrl`'s origin is different than `baseUrl`, then in case of error falls back to\n     * [[startWorkerBlob]].\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     * By default, this method timeouts after 10 seconds (configurable using `timeout` argument).\n     *\n     * This method is needed as browsers in general forbid to load worker if it's not on 'same\n     * origin' regardless of Content-Security-Policy.\n     *\n     * For blob-based fallback work, one need to ensure that Content Security Policy (CSP) allows\n     * loading web worker code from `Blob`s. By default browsers, allow 'blob:' for workers, but\n     * this may change.\n     *\n     * Following snippet setups CSP, so workers can be started from blob urls:\n     *\n     *     <head>\n     *         <meta http-equiv=\"Content-Security-Policy\" content=\"child-src blob:\">\n     *     </head>\n     *\n     * Tested on:\n     *   * Chrome 67 / Linux, Window, OSX, Android\n     *   * Firefox 60 / Linux, Windows, OSX\n     *   * Edge 41 / Windows\n     *   * Safari 11 / OSX\n     *   * Samsung Internet 7.2\n     *\n     * See\n     *  * https://benohead.com/cross-domain-cross-browser-web-workers/\n     *  * MapBox\n     *    * https://stackoverflow.com/questions/21913673/execute-web-worker-from-different-origin\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/2658\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/559\n     *    * https://github.com/mapbox/mapbox-gl-js/issues/6058\n     *\n     * Findings:\n     *\n     * * Chrome reports CSP by exception when constructing [[Worker]] instance.\n     * * Firefox reports CSP errors when loading in first event:\n     *   https://bugzilla.mozilla.org/show_bug.cgi?id=1241888\n     * * Firefox 62, Chrome 67 obeys `<meta http-equiv=\"Content-Security-Policy\">` with\n     *   `worker-src blob:` but doesn't obey `worker-src URL` when used\n     * * Chrome 67 doesn't obey CSP `worker-src URL` despite it's documented as supported\n     *   (https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src)\n     *\n     * @param scriptUrl - web worker script URL\n     * @param timeout - timeout in milliseconds, in which worker should set initial message\n     *    (default 10 seconds)\n     */\n    static startWorker(scriptUrl: string, timeout: number = 10000): Promise<Worker> {\n        if (scriptUrl.startsWith(\"blob:\")) {\n            return this.startWorkerImmediately(scriptUrl, timeout);\n        }\n\n        if (this.directlyFallbackToBlobBasedLoading) {\n            return this.startWorkerBlob(scriptUrl, timeout);\n        }\n        return this.startWorkerImmediately(scriptUrl, timeout).catch(error => {\n            if (typeof window !== \"undefined\") {\n                const pageUrl = window.location.href;\n                const fullScriptUrl = new URL(scriptUrl, pageUrl).href;\n                if (getUrlOrigin(fullScriptUrl) === getUrlOrigin(pageUrl)) {\n                    throw error;\n                }\n                logger.log(\n                    \"#startWorker: cross-origin worker construction failed, trying load with blob\"\n                );\n                this.directlyFallbackToBlobBasedLoading = true;\n                return WorkerLoader.startWorkerBlob(scriptUrl, timeout);\n            } else {\n                throw error;\n            }\n        });\n    }\n\n    /**\n     * Start worker, loading it immediately from `scriptUrl`. Waits (using\n     * [[waitWorkerInitialized]]) for successful worker start.\n     *\n     * @param scriptUrl - web worker script URL\n     */\n    static startWorkerImmediately(scriptUrl: string, timeout: number): Promise<Worker> {\n        try {\n            const worker = new Worker(scriptUrl);\n            return this.waitWorkerInitialized(worker, timeout);\n        } catch (error) {\n            return Promise.reject(error);\n        }\n    }\n\n    /**\n     * Start worker \"via blob\" by first loading worker script code with [[fetch]], creating `Blob`\n     * and attempting to start worker from blob url. Waits (using [[waitWorkerInitialized]]) for\n     * successful worker start.\n     *\n     * @param scriptUrl - web worker script URL\n     */\n    static startWorkerBlob(scriptUrl: string, timeout: number): Promise<Worker> {\n        return this.fetchScriptSourceToBlobUrl(scriptUrl).then(blobUrl => {\n            return this.startWorkerImmediately(blobUrl, timeout);\n        });\n    }\n\n    /**\n     * Fetch script source as `Blob` url.\n     *\n     * Reuses results, if there are many simultaneous requests.\n     *\n     * @param scriptUrl - web worker script URL\n     * @return promise that resolves to url of a `Blob` with script source code\n     */\n    static fetchScriptSourceToBlobUrl(scriptUrl: string): Promise<string> {\n        let loadingPromise = this.sourceLoaderCache.get(scriptUrl);\n        if (loadingPromise !== undefined) {\n            return loadingPromise;\n        }\n        loadingPromise = fetch(scriptUrl)\n            .then(response => response.text())\n            .catch(error => {\n                throw new Error(\n                    `WorkerLoader#fetchScriptSourceToBlob: failed to load worker script: ${error}`\n                );\n            })\n            .then(scriptSource => {\n                this.sourceLoaderCache.delete(scriptUrl);\n                const blob = new Blob([scriptSource], { type: \"application/javascript\" });\n                return URL.createObjectURL(blob);\n            });\n        this.sourceLoaderCache.set(scriptUrl, loadingPromise);\n        return loadingPromise;\n    }\n\n    /**\n     * Waits for successful Web Worker start.\n     *\n     * Expects that worker script sends initial message.\n     *\n     * If first event is `message` then assumes that worker has been loaded sussesfully and promise\n     * resolves to `worker` object passed as argument.\n     *\n     * If first event is 'error', then it is assumed that worker failed to load and promise is\n     * rejected.\n     *\n     * (NOTE: The initial 'message' - if received - is immediately replayed using worker's\n     * `dispatchEvent`, so application code can also consume it as confirmation of successful\n     * worker initialization.\n     *\n     * We must resolve/reject promise at some time, so it is expected that any sane application will\n     * be able to load worker code in some amount of time.\n     *\n     * @param worker - [[Worker]] instance to be checked\n     * @param timeout - timeout in milliseconds, in which worker should set initial message\n     * @returns `Promise` that resolves to `worker` on success\n     */\n    static waitWorkerInitialized(worker: Worker, timeout: number): Promise<Worker> {\n        return new Promise<Worker>((resolve, reject) => {\n            const firstMessageCallback = (event: MessageEvent) => {\n                const message = event.data;\n                if (isWorkerBootstrapRequest(message)) {\n                    const dependencies = message.dependencies;\n                    const resolvedDependencies: string[] = [];\n                    for (const dependency of dependencies) {\n                        const resolved = this.dependencyUrlMapping[dependency];\n                        if (!resolved) {\n                            cleanup();\n                            reject(\n                                new Error(\n                                    `#waitWorkerInitialized: Unable to resolve '${dependency}'` +\n                                        ` as needed by worker script.`\n                                )\n                            );\n                            return;\n                        }\n                        resolvedDependencies.push(resolved);\n                    }\n                    const response: WorkerBootstrapResponse = {\n                        type: \"worker-bootstrap-response\",\n                        resolvedDependencies\n                    };\n                    worker.postMessage(response);\n                    return;\n                }\n\n                cleanup();\n                resolve(worker);\n\n                // We've just consumed first message from worker before client has any chance to\n                // even call `addEventListener` on it, so here after resolve, we wait next tick and\n                // replay message so user has chance to intercept it in its own handler.\n                setTimeout(() => {\n                    worker.dispatchEvent(event);\n                }, 0);\n            };\n            const errorCallback = (error: ErrorEvent) => {\n                cleanup();\n                // Error events do not carry any useful information on tested browsers, so we assume\n                // that any error before 'firstMessageCallback' as failed Worker initialization.\n                let message = \"Error during worker initialization\";\n                if (error.message) {\n                    message = message + `: ${error.message}`;\n                }\n                if (typeof error.filename === \"string\" && typeof error.lineno === \"number\") {\n                    message = message + ` in ${error.filename}:${error.lineno}`;\n                }\n                reject(new Error(message));\n            };\n            const cleanup = () => {\n                clearTimeout(timerId);\n                worker.removeEventListener(\"message\", firstMessageCallback);\n                worker.removeEventListener(\"error\", errorCallback);\n            };\n\n            worker.addEventListener(\"error\", errorCallback);\n            worker.addEventListener(\"message\", firstMessageCallback);\n            const timerId = setTimeout(() => {\n                cleanup();\n                reject(new Error(\"Timeout exceeded when waiting for first message from worker.\"));\n            }, timeout);\n        });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Materials defining the appearance of map objects.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/CirclePointsMaterial\";\nexport * from \"./lib/CopyMaterial\";\nexport * from \"./lib/DisplacementFeature\";\nexport * from \"./lib/EdgeMaterial\";\nexport * from \"./lib/GroundAtmosphereMaterial\";\nexport * from \"./lib/HighPrecisionLineMaterial\";\nexport * from \"./lib/HighPrecisionPointMaterial\";\nexport * from \"./lib/IconMaterial\";\nexport * from \"./lib/LuminosityHighPassShader\";\nexport * from \"./lib/MapMeshMaterialsDefs\";\nexport * from \"./lib/MapMeshMaterials\";\nexport * from \"./lib/MSAAMaterial\";\nexport * from \"./lib/RawShaderMaterial\";\nexport * from \"./lib/SepiaShader\";\nexport * from \"./lib/SkyAtmosphereMaterial\";\nexport * from \"./lib/SolidLineMaterial\";\nexport * from \"./lib/Utils\";\nexport * from \"./lib/VignetteShader\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport {\n    RawShaderMaterial,\n    RawShaderMaterialParameters,\n    RendererMaterialParameters\n} from \"./RawShaderMaterial\";\nimport { enforceBlending } from \"./Utils\";\n\nconst vertexShader: string = `\nuniform float size;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nattribute vec3 position;\n\nvoid main() {\n    vec3 transformed = vec3(position);\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\n\n    gl_Position = projectionMatrix * mvPosition;\n    gl_PointSize = size;\n}\n`;\n\nconst fragmentShader: string = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuseColor;\nuniform float opacity;\n\nvoid main() {\n    float alpha = opacity;\n\n    float radius = 0.5;\n    vec2 coords = gl_PointCoord.xy - vec2(0.5);\n    float len = length(coords);\n    float falloff = fwidth(len);\n    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);\n    alpha *= threshold;\n\n    gl_FragColor = vec4(diffuseColor, alpha);\n}`;\n\n/**\n * Parameters used when constructing a new {@link HighPrecisionPointMaterial}.\n */\nexport interface CirclePointsMaterialParameters\n    extends THREE.ShaderMaterialParameters,\n        RendererMaterialParameters {\n    /**\n     * Point size.\n     */\n    size?: number;\n\n    /**\n     * Point color.\n     */\n    color?: THREE.Color;\n}\n\n/**\n * Material designed to render circle points. Note that it is always transparent since the circle\n * shape is created with an alpha channel to benefit an antialising that a mere `discard` could\n * not bring.\n */\nexport class CirclePointsMaterial extends RawShaderMaterial {\n    static readonly DEFAULT_CIRCLE_SIZE = 1;\n\n    /**\n     * Constructs a new `CirclePointsMaterial`.\n     *\n     * @param parameters - The constructor's parameters. Always required except when cloning another\n     */\n    constructor(parameters?: CirclePointsMaterialParameters) {\n        const defaultColor = new THREE.Color();\n        const defaultOpacity = 1.0;\n        let sizeValue, colorValue, opacityValue;\n        let shaderParameters: RawShaderMaterialParameters | undefined;\n        if (parameters) {\n            const { size, color, opacity, ...shaderParams } = parameters;\n            sizeValue = size;\n            colorValue = color;\n            opacityValue = opacity;\n\n            shaderParams.name = \"CirclePointsMaterial\";\n            shaderParams.vertexShader = vertexShader;\n            shaderParams.fragmentShader = fragmentShader;\n            shaderParams.uniforms = THREE.UniformsUtils.merge([\n                {\n                    size: new THREE.Uniform(CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),\n                    // HARP-17373: Original uniform name 'diffuse' due to shader compilation\n                    // errors with Metal in Safari 15 on MacOS Monterrey and iPadOS 15.\n                    diffuseColor: new THREE.Uniform(defaultColor),\n                    opacity: new THREE.Uniform(defaultOpacity)\n                },\n                THREE.UniformsLib.fog\n            ]);\n            shaderParams.depthTest = false;\n            shaderParams.extensions = {\n                ...shaderParams.extensions,\n                derivatives: true\n            };\n            shaderParameters = shaderParams;\n        }\n        super(shaderParameters);\n\n        // Blending needs to always be enabled to support smooth edges\n        enforceBlending(this);\n\n        this.type = \"CirclePointsMaterial\";\n        this.setOpacity(defaultOpacity);\n\n        if (sizeValue !== undefined) {\n            this.size = sizeValue;\n        }\n        if (colorValue !== undefined) {\n            this.color = colorValue;\n        }\n        if (opacityValue !== undefined) {\n            this.setOpacity(opacityValue);\n        }\n    }\n\n    /**\n     * Gets the circle screen size.\n     */\n    get size(): number {\n        return this.uniforms.size.value;\n    }\n\n    /**\n     * Sets the circle screen size.\n     */\n    set size(size: number) {\n        this.uniforms.size.value = size;\n    }\n\n    get color(): THREE.Color {\n        return this.uniforms.diffuseColor.value as THREE.Color;\n    }\n\n    set color(value: THREE.Color) {\n        this.uniforms.diffuseColor.value.copy(value);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\n/**\n * The base shader to use for {@link @here/harp-mapview#MapView}'s\n * composing passes, like {@link MSAAMaterial}.\n */\nexport const CopyShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        opacity: { value: 1.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform float opacity;\n    uniform sampler2D tDiffuse;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        gl_FragColor = opacity * texel;\n    }`\n};\n\n/**\n * The material is used for composing.\n */\nexport class CopyMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `CopyMaterial`.\n     *\n     * @param uniforms - The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms: { [uniformName: string]: THREE.IUniform }) {\n        super({\n            name: \"CopyMaterial\",\n            uniforms,\n            vertexShader: CopyShader.vertexShader,\n            fragmentShader: CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: false,\n            blending: THREE.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { HiddenThreeJSMaterialProperties } from \"./MapMeshMaterials\";\n\n/**\n * Parameters used when constructing a new implementor of {@link DisplacementFeature}.\n */\nexport interface DisplacementFeatureParameters {\n    /**\n     * Texture used for vertex displacement along their normals.\n     */\n    displacementMap?: THREE.Texture;\n}\n\n/**\n * Interface to be implemented by materials that use displacement maps to overlay geometry\n * on elevation data.\n */\nexport interface DisplacementFeature extends HiddenThreeJSMaterialProperties {\n    displacementMap: THREE.Texture | null;\n}\n\n/**\n * Determines whether a given material supports displacement maps for elevation overlay.\n * @param material - The material to check.\n * @returns Whether the given material supports displacement maps for elevation overlay.\n */\nexport function hasDisplacementFeature(material: any): material is DisplacementFeature {\n    return \"displacementMap\" in material;\n}\n\n/**\n * Sets the displacement map to the given material.\n * @param displacementMap - Texture representing the elevation data used to overlay the object.\n * @param material - The Material to be updated.\n */\nexport function setDisplacementMapToMaterial(\n    displacementMap: THREE.DataTexture | null,\n    material: THREE.Mesh[\"material\"]\n) {\n    if (hasDisplacementFeature(material) && material.displacementMap !== displacementMap) {\n        material.displacementMap = displacementMap;\n        material.needsUpdate = true;\n        if (material.displacementMap !== null) {\n            material.displacementMap.needsUpdate = true;\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { DisplacementFeature, DisplacementFeatureParameters } from \"./DisplacementFeature\";\nimport {\n    ExtrusionFeature,\n    ExtrusionFeatureParameters,\n    FadingFeature,\n    FadingFeatureParameters\n} from \"./MapMeshMaterials\";\nimport { ExtrusionFeatureDefs } from \"./MapMeshMaterialsDefs\";\nimport {\n    RawShaderMaterial,\n    RawShaderMaterialParameters,\n    RendererMaterialParameters\n} from \"./RawShaderMaterial\";\nimport { enforceBlending, setShaderDefine, setShaderMaterialDefine } from \"./Utils\";\n\nconst vertexSource: string = `\n#define EDGE_DEPTH_OFFSET 0.0001\n\n#ifdef USE_COLOR\nattribute vec4 color;\n#else\nuniform vec3 color;\n#endif\n\n// SHADER_NAME may be defined by THREE.JS own shaders in which case these attributes & uniforms are\n// already defined\n#ifndef SHADER_NAME\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat3 normalMatrix;\n#endif\n\nuniform vec3 edgeColor;\nuniform float edgeColorMix;\n\n#ifdef USE_DISPLACEMENTMAP\nattribute vec3 normal;\nattribute vec2 uv;\nuniform sampler2D displacementMap;\n#endif\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_vertex>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\nvoid main() {\n\n    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);\n\n    vec3 transformed = vec3( position );\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_vertex>\n    #endif\n\n    #ifdef USE_DISPLACEMENTMAP\n    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\n    gl_Position = projectionMatrix * mvPosition;\n    // After projection gl_Position contains clip space coordinates of each vertex\n    // before perspective division (1 / w), thus only vertexes with -w < z < w should\n    // be displayed and offset. We offset only those edges which z coordinate in NDC\n    // space is between: -inf < z < 1\n    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;\n    gl_Position.z -= depthOffset;\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nvarying vec3 vColor;\n\n#ifdef USE_EXTRUSION\n#include <extrusion_pars_fragment>\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\nvoid main() {\n    float alphaValue = 1.0;\n    gl_FragColor = vec4(vColor, alphaValue);\n\n    #ifdef USE_EXTRUSION\n    #include <extrusion_fragment>\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n}`;\n\n/**\n * Parameters used when constructing a new {@link EdgeMaterial}.\n */\nexport interface EdgeMaterialParameters\n    extends FadingFeatureParameters,\n        DisplacementFeatureParameters,\n        ExtrusionFeatureParameters,\n        RendererMaterialParameters {\n    /**\n     * Edge color.\n     */\n    color?: number | string;\n    /**\n     * Color mix value. Mixes between vertexColors and edgeColor.\n     */\n    colorMix?: number;\n\n    /**\n     * Defines whether vertex coloring is used.\n     * @defaultValue false\n     */\n    vertexColors?: boolean;\n}\n\n/**\n * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid\n * colors, vertex colors, color mixing and distance fading.\n */\nexport class EdgeMaterial\n    extends RawShaderMaterial\n    implements FadingFeature, ExtrusionFeature, DisplacementFeature {\n    static DEFAULT_COLOR: number = 0x000000;\n    static DEFAULT_COLOR_MIX: number = 0.0;\n\n    /**\n     * Constructs a new `EdgeMaterial`.\n     *\n     * @param params - `EdgeMaterial` parameters. Always required except when cloning another\n     * material.\n     */\n    constructor(params?: EdgeMaterialParameters) {\n        let shaderParams: RawShaderMaterialParameters | undefined;\n        if (params) {\n            const defines: { [key: string]: any } = {};\n            const hasExtrusion =\n                params.extrusionRatio !== undefined &&\n                params.extrusionRatio >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN &&\n                params.extrusionRatio < ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n            if (params.displacementMap) {\n                setShaderDefine(defines, \"USE_DISPLACEMENTMAP\", true);\n            }\n            if (hasExtrusion) {\n                setShaderDefine(defines, \"USE_EXTRUSION\", true);\n            }\n            if (params.vertexColors === true) {\n                setShaderDefine(defines, \"USE_COLOR\", true);\n            }\n            shaderParams = {\n                name: \"EdgeMaterial\",\n                vertexShader: vertexSource,\n                fragmentShader: fragmentSource,\n                uniforms: {\n                    color: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),\n                    edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),\n                    edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),\n                    fadeNear: new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR),\n                    fadeFar: new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR),\n                    extrusionRatio: new THREE.Uniform(ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),\n                    displacementMap: new THREE.Uniform(\n                        params.displacementMap ?? new THREE.Texture()\n                    )\n                },\n                depthWrite: false,\n                defines,\n                rendererCapabilities: params.rendererCapabilities\n            };\n        }\n        super(shaderParams);\n        enforceBlending(this);\n\n        FadingFeature.patchGlobalShaderChunks();\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                // Color may be set directly on object (omitting class setter), because we already\n                // know that is does no require any special handling nor material update\n                // (see: set color()).\n                this.color.set(params.color as any);\n            }\n            if (params.colorMix !== undefined) {\n                this.colorMix = params.colorMix;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n            if (params.extrusionRatio !== undefined) {\n                this.extrusionRatio = params.extrusionRatio;\n            }\n        }\n    }\n\n    /**\n     * The color of the object that is rendered\n     * together with this edge.\n     *\n     * @remarks\n     * The final color of the edge is computed by\n     * interpolating the {@link edgeColor} with this color\n     * using the {@link colorMix} factor.\n     *\n     * Note that {@link objectColor} is used only\n     * when the geometry associated with this material\n     * does not have a vertex color buffer.\n     *\n     */\n    get objectColor(): THREE.Color {\n        return this.uniforms.color.value as THREE.Color;\n    }\n\n    set objectColor(value: THREE.Color) {\n        this.uniforms.color.value.copy(value);\n    }\n\n    /**\n     * Edge color.\n     */\n    get color(): THREE.Color {\n        return this.uniforms.edgeColor.value as THREE.Color;\n    }\n\n    set color(value: THREE.Color) {\n        this.uniforms.edgeColor.value.copy(value);\n    }\n\n    get lineWidth(): number {\n        return this.linewidth;\n    }\n\n    /**\n     * Only lineWidth of 0 and 1 is supported.\n     * lineWidth <= 0 will result in not visible lines, everything else into lines\n     * visible with lineWidth 1\n     */\n    set lineWidth(value: number) {\n        this.linewidth = value;\n        if (this.linewidth <= 0) {\n            this.visible = false;\n        } else {\n            this.visible = true;\n        }\n    }\n\n    /**\n     * Color mix value. Mixes between vertexColors and edgeColor.\n     */\n    get colorMix(): number {\n        return this.uniforms.edgeColorMix.value as number;\n    }\n\n    set colorMix(value: number) {\n        if (this.uniforms.edgeColorMix.value === value) {\n            return;\n        }\n        this.uniforms.edgeColorMix.value = value;\n    }\n\n    get fadeNear(): number {\n        return this.uniforms.fadeNear.value as number;\n    }\n\n    set fadeNear(value: number) {\n        this.uniforms.fadeNear.value = value;\n    }\n\n    get fadeFar(): number {\n        return this.uniforms.fadeFar.value as number;\n    }\n\n    set fadeFar(value: number) {\n        if (this.uniforms.fadeFar.value === value) {\n            return;\n        }\n        this.uniforms.fadeFar.value = value;\n        setShaderMaterialDefine(this, \"USE_FADING\", value > 0.0);\n    }\n\n    get extrusionRatio(): number {\n        return this.uniforms.extrusionRatio.value as number;\n    }\n\n    set extrusionRatio(value: number) {\n        if (this.uniforms.extrusionRatio.value === value) {\n            return;\n        }\n        this.uniforms.extrusionRatio.value = value;\n        // NOTE: We could also disable shader extrusion chunks when it hits\n        // ExtrusionFeatureDefs.DEFAULT_RATIO_MAX value, but this would cause shader re-compile.\n        const useExtrusion = value >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;\n        setShaderMaterialDefine(this, \"USE_EXTRUSION\", useExtrusion);\n    }\n\n    get displacementMap(): THREE.Texture | null {\n        return this.uniforms.displacementMap.value;\n    }\n\n    set displacementMap(map: THREE.Texture | null) {\n        if (this.uniforms.displacementMap.value === map) {\n            return;\n        }\n        this.uniforms.displacementMap.value = map;\n        const useDisplacementMap = map !== null;\n        if (useDisplacementMap) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n        }\n        setShaderMaterialDefine(this, \"USE_DISPLACEMENTMAP\", useDisplacementMap);\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport {\n    RawShaderMaterial,\n    RawShaderMaterialParameters,\n    RendererMaterialParameters\n} from \"./RawShaderMaterial\";\nimport AtmosphereShaderChunks from \"./ShaderChunks/AtmosphereChunks\";\nimport { setShaderDefine, setShaderMaterialDefine } from \"./Utils\";\n\nconst EQUATORIAL_RADIUS: number = 6378137.0;\n\n/**\n * `GroundAtmosphereShader`.\n *\n * Describes shading of atmosphere as seen from outer space.\n */\nexport const GroundAtmosphereShader: THREE.Shader = {\n    uniforms: {\n        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),\n        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),\n        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),\n        // Environment settings:\n        // atmosphere inner and outer radius, camera height\n        u_atmosphereEnv: new THREE.Uniform(\n            new THREE.Vector3(\n                // Maximum inner radius\n                EQUATORIAL_RADIUS * 1.001,\n                // Maximum outer radius\n                EQUATORIAL_RADIUS * 1.025,\n                // Camera height\n                0\n            )\n        ),\n        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),\n\n        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),\n        offset: new THREE.Uniform(33.0),\n        exponent: new THREE.Uniform(0.6),\n        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)), // scene.fog.color\n        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)), // scene.fog.near\n        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far\n    },\n\n    vertexShader: `\n\n    #define IMPROVE_INTERSECT_PRECISION 1\n    #define IMPROVE_DOT_PRECISION 1\n\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n\n    // Base mandatory uniforms\n    uniform mat4 u_modelViewProjection;\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_hsvCorrection;\n\n    const float Pi = 3.141592653589793;\n    const float Kr = 0.0025;\n    const float Km = 0.0015;\n    const float Kr4PI = Kr * 4.0 * Pi;\n    const float Km4PI = Km * 4.0 * Pi;\n    const float ESun = 25.0; // should be 15.0\n    const float KmESun = Km * ESun;\n    const float KrESun = Kr * ESun;\n    const vec3 InvWavelength = vec3(\n        1.0 / pow(0.650, 4.0), // Red\n        1.0 / pow(0.570, 4.0), // Green\n        1.0 / pow(0.475, 4.0)); // Blue\n\n    const int nSamples = 2;\n    const float fSamples = 2.0;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n    varying vec3 v_vertToOrigin;\n\n    ${AtmosphereShaderChunks.atmosphere_vertex_utils}\n\n    //\n    // Computes rayleight and mia atmosphere factors for ground.\n    //\n    // Code based on GPU Gems article.\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n    //\n    // Further modifications by HERE.\n    //\n    AtmosphereColor computeGroundAtmosphere(vec3 v3Pos, vec3 vLightDir)\n    {\n        // Retrieve environment variables\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        // All that may be moved to const or define(s) at further optimizations:\n        float fScale = 1.0 / (fOuterRadius - fInnerRadius);\n        float fScaleOverScaleDepth = fScale / RayleighScaleDepth;\n        float fCameraHeight2 = fCameraHeight * fCameraHeight;\n        float fOuterRadius2 = fOuterRadius * fOuterRadius;\n\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = v3Pos - u_eyePositionWorld;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n#if !defined(IMPROVE_DOT_PRECISION)\n        vec3 v3Dir = normalize(v3Pos);\n#endif\n\n#ifdef CAMERA_IN_SPACE\n\n        // Calculate first point of camera ray and sphere intersection.\n        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);\n        // Make far relative to first atmosphere intersection, setting it to\n        // the length of ray passed through atmosphere\n        fFar -= fNear;\n\n        // Compute the ray's starting position within the atmosphere, then\n        // calculate its scattering offset\n        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;\n        float fDepth = exp((fInnerRadius - fOuterRadius) / RayleighScaleDepth);\n\n#else // CAMERA_IN_ATMOSPHERE\n\n        // The ray starts already in atmosphere\n        vec3 v3Start = u_eyePositionWorld;\n        // Virtually fNear is just at eye position, so ray passing through atmosphere does not shorten\n        // fFar -= 0.0;\n        float fDepth = exp((fInnerRadius - fCameraHeight) / RayleighScaleDepth);\n#endif\n\n#if defined(IMPROVE_DOT_PRECISION)\n        float fCameraAngle = dot(-v3Ray, v3Pos) / length(v3Pos);\n#else\n        float fCameraAngle = dot(-v3Ray, v3Dir);\n#endif\n        float fCameraScale = scale(fCameraAngle);\n\n#ifdef DYNAMIC_LIGHT\n        // When we want the atmosphere to be uniform over the globe so it is set to 1.0.\n        #if defined(IMPROVE_DOT_PRECISION)\n            // The light angle for given light source may be calculated as:\n            // angle = dot(vLightDir, v3Dir) / length(v3Dir);\n            // where v3Dir holds normalized vertex position, but for precision issues we v3Pos (un-normalized)\n            float fLightAngle = dot(vLightDir, v3Pos) / length(v3Pos);\n        #else\n            float fLightAngle = dot(vLightDir, v3Dir);\n        #endif\n#else\n        float fLightAngle = 1.0;\n#endif\n        float fLightScale = scale(fLightAngle);\n\n        float fCameraOffset = fDepth * fCameraScale;\n        float fTemp = (fLightScale + fCameraScale);\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3BaseColor = vec3(0.0);\n        vec3 v3Attenuate = vec3(0.0);\n        for(int i = 0; i < nSamples; i++)\n        {\n            float fHeight = length(v3SamplePoint);\n            float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n            float fScatter = fDepth * fTemp - fCameraOffset;\n            // Compute color factors\n            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\n            v3BaseColor += v3Attenuate * (fDepth * fScaledLength);\n            // Move to the next point\n            v3SamplePoint += v3SampleRay;\n        }\n\n        AtmosphereColor color;\n        color.mie = v3BaseColor * (InvWavelength * KrESun + KmESun);\n        // Calculate the attenuation factor for the ground\n        color.rayleigh = v3Attenuate;\n\n        return color;\n    }\n\n    void main(void)\n    {\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        AtmosphereColor atmColor = computeGroundAtmosphere(position.xyz, vLightDir);\n        v_mieColor = atmColor.mie;\n        v_rayleighColor = atmColor.rayleigh;\n        v_vertToCamera = u_eyePositionWorld - position.xyz;\n        v_vertToOrigin = normalize(position.xyz);\n\n        gl_Position = u_modelViewProjection * position;\n    }\n    `,\n\n    fragmentShader: `\n\n    // Exposure correction gives more subtle gradients on the ground.\n    #define CORRECT_EXPOSURE 1\n    #define FADE_DEPTH 1\n    #define NIGHT_LOCAL 1\n\n    precision highp float;\n    precision highp int;\n\n    #ifdef CORRECT_COLOR\n    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness\n    #endif\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    const float g = -0.95;\n    const float g2 = g * g;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n    varying vec3 v_vertToOrigin;\n\n    ${AtmosphereShaderChunks.atmosphere_fragment_utils}\n\n    void main(void)\n    {\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        // GPU gems mix of ground solution, with custom alpha settings\n        vec3 cRgb = v_mieColor + 0.25 * v_rayleighColor;\n\n        // Not needed for HDR frame buffer\n    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)\n        // Interesting results with exposure factor: 2.0, 3.5, 4.0\n        cRgb = correctExposure(cRgb, 3.0);\n    #endif\n\n    #ifdef CORRECT_COLOR\n        cRgb = correctColor(cRgb, u_hsvCorrection);\n    #endif\n\n        // Base atmosphere opacity\n        float fAtmosphereAlpha = 1.0;\n\n        // Factor based on the distance of camera atmosphere and ground, results are:\n        // 0.0 = camera on the ground surface,\n        // 1.0 = at the outer edge of the atmosphere.\n        float fDepthFactor = clamp((fCameraHeight - fInnerRadius) /\n            (fOuterRadius - fInnerRadius), 0.0, 1.0);\n    #ifdef FADE_DEPTH\n        // Fade alpha based on the distance of camera between atmosphere layers\n        #ifdef FADE_DEPTH_LINEAR\n            fAtmosphereAlpha *= fDepthFactor;\n        #else\n            fAtmosphereAlpha *= pow(fDepthFactor, 1.5);\n        #endif\n    #endif\n\n#if defined(FADE_NIGHT) || defined(DARKEN_NIGHT)\n    #ifdef DYNAMIC_LIGHT\n        // Adjust factor based on time of day, results are:\n        // 0.0 = night,\n        // 1.0 = day.\n        #ifdef NIGHT_GLOBAL\n            // Global night fade based on camera and light orientation\n            float fNightFactor = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);\n            fNightFactor = pow(fNightFactor, 0.5);\n        #else // NIGHT_LOCAL\n            float fNightFactor =\n                clamp(dot(v_vertToOrigin, vLightDir) / length(v_vertToOrigin), 0.0, 1.0);\n            fNightFactor = pow(fNightFactor, 0.8);\n        #endif\n    #else\n        float fNightFactor = 1.0;\n    #endif\n#endif\n\n    #ifdef FADE_NIGHT\n        // Adjust alpha for night side of the globe\n        fAtmosphereAlpha *= fNightFactor;\n    #endif\n\n    #ifdef DARKEN_NIGHT\n        // Change the brightness depending on night / day side.\n        // NOTE: Darkening should be rather applied in HSV space, without loss on saturation,\n        // but it is much more GPU consuming.\n        const float minBrightness = 0.5;\n        float fDarkenFactor = clamp(fNightFactor, minBrightness, 1.0);\n        cRgb *= fDarkenFactor;\n    #endif\n\n    #ifdef EXPOSURE_DEPTH\n        // Control exposure depending from ground distance\n        float exposureBoost = 3.0 - fDepthFactor;\n        cRgb = correctExposure(cRgb, exposureBoost);\n    #endif\n\n        // Experimental fading out of focus point - similar to fresnel effect in top view.\n        // This fade is handy to better expose cartographic/map features in screen center.\n        float fFocusFactor = 1.0 - clamp(dot(normalize(v_vertToCamera), v_vertToOrigin), 0.0, 1.0) + 0.1;\n        fFocusFactor = pow(fFocusFactor, 2.5);\n        fAtmosphereAlpha *= fFocusFactor;\n\n        // Integrate all features\n        gl_FragColor = vec4(cRgb, fAtmosphereAlpha);\n    }\n    `\n};\n\nexport interface GroundAtmosphereMaterialParameters extends RendererMaterialParameters {}\n\nexport class GroundAtmosphereMaterial extends RawShaderMaterial {\n    /**\n     * Constructs a new `GroundAtmosphereMaterial`.\n     *\n     * @param params - `GroundAtmosphereMaterial` parameters. Always required except when cloning\n     * another material.\n     */\n    constructor(params?: GroundAtmosphereMaterialParameters) {\n        let shaderParams: RawShaderMaterialParameters | undefined;\n        if (params) {\n            const defines: { [key: string]: any } = {};\n            defines.CAMERA_IN_SPACE = \"\";\n\n            shaderParams = {\n                name: \"GroundAtmosphereMaterial\",\n                vertexShader: GroundAtmosphereShader.vertexShader,\n                fragmentShader: GroundAtmosphereShader.fragmentShader,\n                uniforms: GroundAtmosphereShader.uniforms,\n                transparent: true,\n                depthTest: false,\n                depthWrite: false,\n                side: THREE.FrontSide,\n                blending: THREE.NormalBlending,\n                fog: false,\n                rendererCapabilities: params.rendererCapabilities\n            };\n        }\n        super(shaderParams);\n    }\n\n    setDynamicLighting(enableLighting: boolean) {\n        setShaderMaterialDefine(this, \"DYNAMIC_LIGHT\", enableLighting);\n    }\n\n    /**\n     * Set maximum outer radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025\n     */\n    set outerRadius(radius: number) {\n        this.uniforms.u_atmosphereEnv.value.y = radius;\n    }\n\n    get outerRadius(): number {\n        return this.uniforms.u_atmosphereEnv.value.y;\n    }\n\n    /**\n     * Set maximum inner radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.001.\n     */\n    set innerRadius(radius: number) {\n        this.uniforms.u_atmosphereEnv.value.x = radius;\n    }\n\n    get innerRadius(): number {\n        return this.uniforms.u_atmosphereEnv.value.x;\n    }\n\n    /**\n     * Updates the uniform data of a material used to render an atmosphere.\n     *\n     * This includes only uniforms that may change frame by frame, other uniforms are\n     * accessed with convenient material setters and getters.\n     *\n     * @param shaderMaterial - Material which uniforms will be updated.\n     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.\n     * @param lightDirection - The light directional vector in world space.\n     * @param camera - Camera used in rendering.\n     */\n    updateUniforms(\n        shaderMaterial: THREE.ShaderMaterial,\n        object: THREE.Object3D,\n        camera: THREE.Camera,\n        lightDirection: THREE.Vector3\n    ): void {\n        const cameraInfo = this.getCameraInfo(object, camera);\n\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (\n                shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_atmosphereEnv &&\n                shaderMaterial.uniforms.u_hsvCorrection &&\n                shaderMaterial.uniforms.u_eyePositionWorld &&\n                shaderMaterial.uniforms.u_modelViewProjection &&\n                shaderMaterial.uniforms.u_lightDirectionWorld\n            ) {\n                const eyePos = cameraInfo.eyePos;\n                const mvp = cameraInfo.modelViewProjection;\n                const cameraHeight = cameraInfo.eyeHeight;\n\n                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);\n                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);\n\n                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;\n                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();\n\n                const cameraInSpace = cameraHeight > this.outerRadius;\n                const needsUpdate0 = setShaderDefine(\n                    shaderMaterial.defines,\n                    \"CAMERA_IN_SPACE\",\n                    cameraInSpace\n                );\n                const needsUpdate1 = setShaderDefine(\n                    shaderMaterial.defines,\n                    \"CAMERA_IN_ATMOSPHERE\",\n                    !cameraInSpace\n                );\n                shaderMaterial.needsUpdate =\n                    shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;\n            } else {\n                throw Error(\"Atmosphere material has missing uniforms\");\n            }\n        } else {\n            throw Error(\"Wrong object used, only Material objects are supported\");\n        }\n    }\n\n    /*\n     * Calculate camera position used in vertex shader of atmosphere materials.\n     *\n     * @param object -\n     * @param camera - Camera used to get the eye position.\n     */\n    private getCameraInfo(\n        object: THREE.Object3D,\n        camera: THREE.Camera,\n        reverse: boolean = false\n    ): { modelViewProjection: THREE.Matrix4; eyePos: THREE.Vector3; eyeHeight: number } {\n        if (reverse) {\n            const modelMatrix = new THREE.Matrix4().identity();\n            const viewMatrix = new THREE.Matrix4().copy(object.matrixWorld).invert().transpose();\n            const projectionMatrix = camera.projectionMatrix;\n\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n\n            const eyePos = new THREE.Vector3();\n            object.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            camera.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        } else {\n            const modelMatrix = object.matrixWorld;\n            const viewMatrix = camera.matrixWorldInverse;\n            const projectionMatrix = camera.projectionMatrix;\n\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n\n            const eyePos = new THREE.Vector3();\n            camera.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            object.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            // Normally we would return simply camera position, but since camera is not moving in\n            // the globe view only the world, we need to calculate eye relative to object position.\n            eyePos.sub(objectPos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { RawShaderMaterial, RawShaderMaterialParameters } from \"./RawShaderMaterial\";\nimport linesShaderChunk from \"./ShaderChunks/LinesChunks\";\n\nconst vertexSource: string = `\n#ifdef USE_COLOR\nattribute vec4 color;\nvarying vec3 vColor;\n#endif\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 position;        // high part\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuseColor;\nuniform float opacity;\n\n#ifdef USE_COLOR\nvarying vec3 color;\n#endif\n\nvoid main() {\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( diffuseColor * vColor, opacity );\n    #else\n    gl_FragColor = vec4( diffuseColor, opacity );\n    #endif\n}`;\n\n/**\n * Parameters used when constructing a new {@link HighPrecisionLineMaterial}.\n */\nexport interface HighPrecisionLineMaterialParameters extends RawShaderMaterialParameters {\n    /**\n     * Line color.\n     */\n    color?: number | string | THREE.Color;\n    /**\n     * Line opacity.\n     */\n    opacity?: number;\n}\n\n/**\n * Material designed to render high precision lines (ideal for position-sensible data).\n */\nexport class HighPrecisionLineMaterial extends RawShaderMaterial {\n    static DEFAULT_COLOR: number = 0x000050;\n    static DEFAULT_OPACITY: number = 1.0;\n\n    isHighPrecisionLineMaterial: boolean;\n\n    /**\n     * Constructs a new `HighPrecisionLineMaterial`.\n     *\n     * @param params - `HighPrecisionLineMaterial` parameters.  Always required except when cloning\n     * another material.\n     */\n    constructor(params?: HighPrecisionLineMaterialParameters) {\n        Object.assign(THREE.ShaderChunk, linesShaderChunk);\n\n        const shaderParams: RawShaderMaterialParameters | undefined = params\n            ? {\n                  name: \"HighPrecisionLineMaterial\",\n                  vertexShader: vertexSource,\n                  fragmentShader: fragmentSource,\n                  uniforms: {\n                      // HARP-17373: Original uniform name 'diffuse' due to shader compilation\n                      // errors with Metal in Safari 15 on MacOS Monterrey and iPadOS 15.\n                      diffuseColor: new THREE.Uniform(\n                          new THREE.Color(HighPrecisionLineMaterial.DEFAULT_COLOR)\n                      ),\n                      opacity: new THREE.Uniform(HighPrecisionLineMaterial.DEFAULT_OPACITY),\n                      u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n                      u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n                      u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n                  },\n                  rendererCapabilities: params.rendererCapabilities\n              }\n            : undefined;\n        Object.assign(shaderParams, params);\n        super(shaderParams);\n\n        this.type = \"HighPrecisionLineMaterial\";\n        this.isHighPrecisionLineMaterial = true;\n\n        // Apply initial parameter values.\n        if (params) {\n            if (params.color !== undefined) {\n                this.color.set(params.color as any);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n        }\n\n        this.updateTransparencyFeature();\n    }\n\n    /**\n     * Line color.\n     */\n    get color(): THREE.Color {\n        return this.uniforms.diffuseColor.value as THREE.Color;\n    }\n\n    set color(value: THREE.Color) {\n        this.uniforms.diffuseColor.value.copy(value);\n    }\n\n    private updateTransparencyFeature() {\n        this.transparent = this.opacity < 1.0 ? true : false;\n    }\n}\n\nexport function isHighPrecisionLineMaterial(\n    material: object | undefined\n): material is HighPrecisionLineMaterial {\n    return (\n        material !== undefined &&\n        (material as HighPrecisionLineMaterial).isHighPrecisionLineMaterial === true\n    );\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport linesShaderChunk from \"./ShaderChunks/LinesChunks\";\n\nconst vertexSource: string = `\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\nuniform float size;\n\n// uniforms to implement double-precision\nuniform mat4 u_mvp;             // combined modelView and projection matrix\nuniform vec3 u_eyepos;          // eye position major\nuniform vec3 u_eyepos_lowpart;  // eye position minor ((double) eyepos - (float) eyepos)\n\n// vertex attributes\nattribute vec3 positionLow;     // low part\n\n#include <high_precision_vert_func>\n\nvoid main() {\n    #ifdef USE_COLOR\n    vColor = color.rgb;\n    #endif\n\n    vec3 pos = subtractDblEyePos(position);\n    gl_Position = u_mvp * vec4(pos, 1.0);\n\n    // ignore sizeAttenuation for now!\n    gl_PointSize = size;\n}`;\n\n/**\n * Parameters used when constructing a new {@link HighPrecisionPointMaterial}.\n */\nexport interface HighPrecisionPointMaterialParameters extends THREE.PointsMaterialParameters {\n    /**\n     * Point color.\n     */\n    color?: number | string | THREE.Color;\n    /**\n     * Point opacity.\n     */\n    opacity?: number;\n    /**\n     * Point scale.\n     */\n    scale?: number;\n    /**\n     * UV transformation matrix.\n     */\n    uvTransform?: THREE.Matrix3;\n}\n\n/**\n * Material designed to render high precision points (ideal for position-sensible data).\n */\nexport class HighPrecisionPointMaterial extends THREE.PointsMaterial {\n    static DEFAULT_COLOR: number = 0x000050;\n    static DEFAULT_OPACITY: number = 1.0;\n    static DEFAULT_SIZE: number = 1.0;\n    static DEFAULT_SCALE: number = 1.0;\n\n    isHighPrecisionPointMaterial: boolean;\n    uniforms: { [uniform: string]: THREE.IUniform };\n    vertexShader?: string;\n    fragmentShader?: string;\n\n    /**\n     * Constructs a new `HighPrecisionPointMaterial`.\n     *\n     * @param params - `HighPrecisionPointMaterial` parameters.\n     */\n    constructor(params?: HighPrecisionPointMaterialParameters) {\n        Object.assign(THREE.ShaderChunk, linesShaderChunk);\n\n        const shaderParams = params;\n        super(shaderParams);\n\n        this.type = \"HighPrecisionPointMaterial\";\n        this.vertexShader = vertexSource;\n        this.fragmentShader = THREE.ShaderChunk.points_frag;\n        this.fog = false;\n\n        this.uniforms = {\n            // HARP-17373: Original uniform name 'diffuse' due to shader compilation\n            // errors with Metal in Safari 15 on MacOS Monterrey and iPadOS 15.\n            diffuseColor: new THREE.Uniform(\n                new THREE.Color(HighPrecisionPointMaterial.DEFAULT_COLOR)\n            ),\n            opacity: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_OPACITY),\n            size: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SIZE),\n            scale: new THREE.Uniform(HighPrecisionPointMaterial.DEFAULT_SCALE),\n            map: new THREE.Uniform(new THREE.Texture()),\n            uvTransform: new THREE.Uniform(new THREE.Matrix3()),\n            u_mvp: new THREE.Uniform(new THREE.Matrix4()),\n            u_eyepos: new THREE.Uniform(new THREE.Vector3()),\n            u_eyepos_lowpart: new THREE.Uniform(new THREE.Vector3())\n        };\n\n        this.isHighPrecisionPointMaterial = true;\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.color !== undefined) {\n                this.color.set(params.color as any);\n            }\n            if (params.opacity !== undefined) {\n                this.opacity = params.opacity;\n            }\n            if (params.size !== undefined) {\n                this.size = params.size;\n            }\n            if (params.scale !== undefined) {\n                this.scale = params.scale;\n            }\n            if (params.uvTransform !== undefined) {\n                this.uvTransform = params.uvTransform;\n            }\n            if (params.map !== undefined) {\n                this.map = params.map;\n            }\n        }\n    }\n\n    /**\n     *  Point scale.\n     */\n    get scale(): number {\n        return this.uniforms.scale.value;\n    }\n\n    set scale(value: number) {\n        this.uniforms.scale.value = value;\n    }\n\n    /**\n     * UV transformation matrix.\n     */\n    get uvTransform(): THREE.Matrix3 {\n        return this.uniforms.uvTransform.value;\n    }\n\n    set uvTransform(value: THREE.Matrix3) {\n        this.uniforms.uvTransform.value = value;\n    }\n}\n\nexport function isHighPrecisionPointMaterial(\n    material: object | undefined\n): material is HighPrecisionPointMaterial {\n    return (\n        material !== undefined &&\n        (material as HighPrecisionPointMaterial).isHighPrecisionPointMaterial === true\n    );\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport {\n    RawShaderMaterial,\n    RawShaderMaterialParameters,\n    RendererMaterialParameters\n} from \"./RawShaderMaterial\";\n\nconst vertexSource: string = `\nattribute vec4 position;\nattribute vec4 color;\nattribute vec2 uv;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n    vUv = uv;\n    vColor = color;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D map;\n\nvarying vec4 vColor;\nvarying vec2 vUv;\n\nvoid main() {\n\n    vec4 color = texture2D(map, vUv.xy);\n    color *= vColor;\n    if (color.a < 0.05) {\n        discard;\n    }\n    gl_FragColor = color;\n}`;\n\n/**\n * Parameters used when constructing a new {@link IconMaterial}.\n */\nexport interface IconMaterialParameters extends RendererMaterialParameters {\n    /**\n     * Texture map.\n     */\n    map: THREE.Texture;\n}\n\n/**\n * 2D material for icons, similar to [[TextMaterial]]. Uses component in texture coordinates to\n * apply opacity.\n */\nexport class IconMaterial extends RawShaderMaterial {\n    /**\n     * Constructs a new `IconMaterial`.\n     *\n     * @param params - `IconMaterial` parameters. Always required except when cloning another\n     * material.\n     */\n    constructor(params?: IconMaterialParameters) {\n        const shaderParams: RawShaderMaterialParameters | undefined = params\n            ? {\n                  name: \"IconMaterial\",\n                  vertexShader: vertexSource,\n                  fragmentShader: fragmentSource,\n                  uniforms: {\n                      map: new THREE.Uniform(params.map)\n                  },\n                  depthTest: false,\n                  depthWrite: false,\n                  transparent: true,\n\n                  vertexColors: true,\n                  premultipliedAlpha: true,\n                  rendererCapabilities: params.rendererCapabilities\n              }\n            : undefined;\n        super(shaderParams);\n    }\n\n    /**\n     * Icon texture map/atlas.\n     */\n    get map(): THREE.Texture {\n        return this.uniforms.map.value;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * The shader used in the [[UnrealBloomPass]] for the bloom/glow effect.\n */\nexport const LuminosityHighPassShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        luminosityThreshold: { value: 1.0 },\n        smoothWidth: { value: 1.0 },\n        defaultColor: { value: new THREE.Color(0x000000) },\n        defaultOpacity: { value: 0.0 }\n    },\n    vertexShader: `\n    varying vec2 vUv;\n    void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    }`,\n    fragmentShader: `\n    uniform sampler2D tDiffuse;\n    uniform vec3 defaultColor;\n    uniform float defaultOpacity;\n    uniform float luminosityThreshold;\n    uniform float smoothWidth;\n    varying vec2 vUv;\n    void main() {\n        vec4 texel = texture2D( tDiffuse, vUv );\n        vec3 luma = vec3( 0.299, 0.587, 0.114 );\n        float v = dot( texel.xyz, luma );\n        vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n        float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n        gl_FragColor = mix( outputColor, texel, alpha );\n    }`\n};\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { CopyShader } from \"./CopyMaterial\";\n\n/**\n * The material to use for the quad of the {@link @here/harp-mapview#MSAARenderPass}\n * in the composing.\n */\nexport class MSAAMaterial extends THREE.ShaderMaterial {\n    /**\n     * The constructor of `MSAAMaterial`.\n     *\n     * @param uniforms - The [[CopyShader]]'s uniforms.\n     */\n    constructor(uniforms: { [uniformName: string]: THREE.IUniform }) {\n        super({\n            uniforms,\n            vertexShader: CopyShader.vertexShader,\n            fragmentShader: CopyShader.fragmentShader,\n            premultipliedAlpha: true,\n            transparent: true,\n            blending: THREE.AdditiveBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ViewRanges } from \"@here/harp-datasource-protocol/lib/ViewRanges\";\nimport { applyMixinsWithoutProperties, assert, chainCallbacks } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { DisplacementFeature, DisplacementFeatureParameters } from \"./DisplacementFeature\";\nimport { ExtrusionFeatureDefs } from \"./MapMeshMaterialsDefs\";\nimport extrusionShaderChunk from \"./ShaderChunks/ExtrusionChunks\";\nimport fadingShaderChunk from \"./ShaderChunks/FadingChunks\";\nimport { simpleLightingShadowChunk } from \"./ShaderChunks/ShadowChunks\";\nimport { disableBlending, enableBlending, insertShaderInclude, setShaderDefine } from \"./Utils\";\n\nconst emptyTexture = new THREE.Texture();\n\n/**\n * The MapMeshMaterials [[MapMeshBasicMaterial]] and [[MapMeshStandardMaterial]] are the standard\n * [[THREE.MeshBasicMaterial]] and [[THREE.MeshStandardMaterial]], with the addition functionality\n * of fading out the geometry between a fadeNear and fadeFar value.\n *\n * The implementation is designed around a mixin class {@link FadingFeatureMixin}, which requires\n * a bit of care when adding the FadingFeature to the existing mesh classes, but it is safe to use\n * and also reduces code duplication.\n */\n\n/**\n * Parameters used when constructing a new implementor of {@link FadingFeature}.\n */\nexport interface FadingFeatureParameters {\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects start fading out.\n     */\n    fadeNear?: number;\n\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects are transparent.\n     */\n    fadeFar?: number;\n}\n\n/**\n * Parameter used to control patching the standard material shader to ensure that the materials\n * color isn't affected by the light direction, only valid for techniques that are \"fill\"\n */\nexport interface ShadowFeatureParameters {\n    /**\n     * Whether the diffuse light component is removed (i.e. the materials color is therefore just\n     * the ambient + shadow).\n     */\n    removeDiffuseLight?: boolean;\n}\n\n/**\n * Parameters used when constructing a new implementor of {@link ExtrusionFeature}.\n */\nexport interface ExtrusionFeatureParameters {\n    /**\n     * Ratio of the extruded objects, where `1.0` is the default value\n     */\n    extrusionRatio?: number;\n\n    /**\n     * Enable z-fighting workaround that doesn't animate buildings with `height <\n     * [[ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT]]`.\n     *\n     * Should be applied to `polygon` materials using this feature.\n     */\n    zFightingWorkaround?: boolean;\n}\n\n/**\n * Used internally.\n *\n * @hidden\n */\nexport interface UniformsType {\n    [index: string]: THREE.IUniform;\n}\n\n/**\n * Type of callback used internally by THREE.js for shader creation.\n *\n * @hidden\n */\ntype CompileCallback = (shader: THREE.Shader, renderer: any) => void;\n\n/**\n * Material properties used from THREE, which may not be defined in the type.\n */\nexport interface HiddenThreeJSMaterialProperties {\n    /**\n     * Informs THREE.js to re-compile material shader (due to change in code or defines).\n     */\n    needsUpdate?: boolean;\n\n    /**\n     * Hidden ThreeJS value that is made public here. Required to add new uniforms to subclasses of\n     * [[THREE.MeshBasicMaterial]]/[[THREE.MeshStandardMaterial]], basically all materials that are\n     * not THREE.ShaderMaterial.\n     * @deprecated Changes to this property are ignored.\n     */\n    uniformsNeedUpdate?: boolean;\n\n    /**\n     * Available in all materials in ThreeJS.\n     */\n    transparent?: boolean;\n\n    /**\n     * Used internally for material shader defines.\n     */\n    defines?: any;\n\n    /**\n     * Defines callback available in THREE.js materials.\n     *\n     * Called before shader program compilation to generate vertex & fragment shader output code.\n     */\n    onBeforeCompile?: CompileCallback;\n}\n\n/**\n * Used internally.\n *\n * @hidden\n */\nexport interface MixinShaderProperties {\n    /**\n     * Used internally for material shader defines.\n     */\n    shaderDefines?: any;\n\n    /**\n     * Used internally for shader uniforms, holds references to material internal shader.uniforms.\n     *\n     * Holds a reference to material's internal shader uniforms map. New custom feature based\n     * uniforms are injected using this reference, but also internal THREE.js shader uniforms\n     * will be available via this map after [[Material#onBeforeCompile]] callback is run with\n     * feature enabled.\n     * @see needsUpdate\n     */\n    shaderUniforms?: UniformsType;\n}\n\n/**\n * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into\n * [0..maxVisibilityRange].\n *\n * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.\n *\n * @param distance - Distance from the camera (range: [0, 1]).\n * @param visibilityRange - object describing maximum and minimum visibility range - distances\n * from camera at which objects won't be rendered anymore.\n */\nfunction cameraToWorldDistance(distance: number, visibilityRange: ViewRanges): number {\n    return distance * visibilityRange.maximum;\n}\n\n/**\n * Provides common interface from mixin to internal material defines and shader uniforms.\n *\n * Call this function just after [THREE.Material] is constructed, so in derived classes after\n * super c-tor call.\n * @param mixin - The mixin that will add features to [[THREE.Material]].\n * @param material - The material that mixin feature is being applied.\n */\nfunction linkMixinWithMaterial(\n    mixin: MixinShaderProperties,\n    material: HiddenThreeJSMaterialProperties\n) {\n    // Some materials (MeshBasicMaterial) have no defines property created in c-tor.\n    // In such case create it manually, such defines will be also injected to the shader\n    // via generic THREE.js code - see THREE/WebGLProgram.js.\n    if (material.defines === undefined) {\n        material.defines = {};\n    }\n    // Link internal THREE.js material defines with mixin reference.\n    // Those defines are usually created in Material c-tor, if not we have fallback above.\n    mixin.shaderDefines = material.defines;\n\n    // Prepare map for holding uniforms references from the actual shader, but check if\n    // it was not already created with other mixin feature.\n    if (mixin.shaderUniforms === undefined) {\n        mixin.shaderUniforms = {};\n    }\n    // Shader uniforms may not be linked at this stage, they are injected available via Shader\n    // object in onBeforeCompile callback, see: linkMixinWithShader().\n}\n\n/**\n * Links mixin [[MixinShaderProperties.shaderUniforms]] with actual material shader uniforms.\n *\n * Function injects features (mixin) specific shader uniforms to material's shader, it also\n * updates uniforms references so [[MixinShaderProperties.shaderUniforms]] will contain full\n * uniforms map (both feature specific and internal ones).\n * This function should be called before material's shader is pre-compiled, so the new uniforms\n * from the mixin feature are known to shader processor. The best place to use is\n * [[Material.onBeforeCompile]].\n * @param mixin - The mixin feature being applied to the material.\n * @param shader - The actual shader linked to the [[THREE.Material]].\n */\nfunction linkMixinWithShader(mixin: MixinShaderProperties, shader: THREE.Shader) {\n    Object.assign(shader.uniforms, mixin.shaderUniforms);\n    mixin.shaderUniforms = shader.uniforms;\n}\n\n/**\n * Base interface for all objects that should fade in the distance. The implementation of the actual\n * FadingFeature is done with the help of the mixin class {@link FadingFeatureMixin} and a set of\n * supporting functions in the namespace of the same name.\n */\nexport interface FadingFeature extends HiddenThreeJSMaterialProperties, MixinShaderProperties {\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects start fading out.\n     */\n    fadeNear?: number;\n\n    /**\n     * Distance to the camera (range: `[0.0, 1.0]`) from which the objects are transparent. A value\n     * of <= 0.0 disables fading.\n     */\n    fadeFar?: number;\n}\n\n/**\n * Base interface for all objects that should have animated extrusion effect.\n *\n * @remarks\n * The implementation of the actual ExtrusionFeature is done with\n * the help of the mixin class {@link ExtrusionFeatureMixin}\n * and a set of supporting functions in the namespace of the same name.\n */\nexport interface ExtrusionFeature extends HiddenThreeJSMaterialProperties, MixinShaderProperties {\n    /**\n     * Ratio of the extruded objects, where `1.0` is the default value. Minimum suggested value\n     * is `0.01`\n     */\n    extrusionRatio?: number;\n}\n\n/**\n * Determines whether a given material supports extrusion.\n * @param material The material to check.\n * @returns Whether the given material supports extrusion.\n */\nexport function hasExtrusionFeature(material: any): material is ExtrusionFeature {\n    return \"extrusionRatio\" in material;\n}\n\n// See https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/eslint-plugin/docs/rules/no-redeclare.md#ignoredeclarationmerge\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nnamespace DisplacementFeature {\n    /**\n     * Checks if feature is enabled (displacement map defined).\n     *\n     * @param displacementMaterial -\n     */\n    export function isEnabled(displacementMaterial: DisplacementFeature) {\n        return displacementMaterial.displacementMap !== null;\n    }\n\n    /**\n     * Update the internals of the `DisplacementFeature` depending on the value of\n     * [[displacementMap]].\n     *\n     * @param displacementMaterial - DisplacementFeature\n     */\n    export function updateDisplacementFeature(\n        displacementMaterial: DisplacementFeature & MixinShaderProperties\n    ): void {\n        assert(displacementMaterial.shaderDefines !== undefined);\n        assert(displacementMaterial.shaderUniforms !== undefined);\n\n        const useDisplacementMap = isEnabled(displacementMaterial);\n        // Whenever displacement feature state changes (between enabled/disabled) material will be\n        // re-compiled, forcing new shader chunks to be added (or removed).\n        const needsUpdate = setShaderDefine(\n            displacementMaterial.shaderDefines,\n            \"USE_DISPLACEMENTMAP\",\n            useDisplacementMap\n        );\n        displacementMaterial.needsUpdate = needsUpdate;\n\n        // Update texture after change.\n        if (useDisplacementMap) {\n            const texture = displacementMaterial.displacementMap!;\n            texture.needsUpdate = true;\n            displacementMaterial.shaderUniforms!.displacementMap.value = texture;\n        } else if (needsUpdate) {\n            displacementMaterial.shaderUniforms!.displacementMap.value = emptyTexture;\n        }\n    }\n\n    /**\n     * This function should be called on implementors of DisplacementFeature in the\n     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to\n     * apply displacement maps.\n     *\n     * @param displacementMaterial - Material to add uniforms to.\n     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    export function onBeforeCompile(\n        displacementMaterial: DisplacementFeature & MixinShaderProperties,\n        shader: THREE.Shader\n    ) {\n        if (!isEnabled(displacementMaterial)) {\n            return;\n        }\n        assert(displacementMaterial.shaderUniforms !== undefined);\n\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are required for this material, we use one define working as a flag,\n        // which enables/disables some chunks of shader code.\n        linkMixinWithShader(displacementMaterial, shader);\n\n        // Append the displacement map chunk to the vertex shader.\n        shader.vertexShader = shader.vertexShader.replace(\n            \"#include <skinbase_vertex>\",\n            `#include <skinbase_vertex>\n#ifndef USE_ENVMAP\n    vec3 objectNormal = vec3( normal );\n#endif`\n        );\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"uv2_pars_vertex\",\n            \"displacementmap_pars_vertex\"\n        );\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"skinning_vertex\",\n            \"displacementmap_vertex\",\n            true\n        );\n    }\n}\n\nexport class DisplacementFeatureMixin implements DisplacementFeature, MixinShaderProperties {\n    needsUpdate?: boolean;\n    uniformsNeedUpdate?: boolean;\n    defines?: any;\n    shaderDefines?: any;\n    shaderUniforms?: UniformsType;\n    onBeforeCompile?: CompileCallback;\n    private m_displacementMap: THREE.Texture | null = null;\n\n    // This is here to keep tslint from reporting a missing property, the getter that's actually\n    // used by materials is added in [[addDisplacementProperties]].\n    get displacementMap(): THREE.Texture | null {\n        return this.m_displacementMap;\n    }\n\n    // This is here to keep tslint from reporting a missing property, the setter that's actually\n    // used by materials is added in [[addDisplacementProperties]].\n    set displacementMap(map: THREE.Texture | null) {\n        this.setDisplacementMap(map);\n    }\n\n    protected getDisplacementMap(): THREE.Texture | null {\n        return this.m_displacementMap;\n    }\n\n    protected setDisplacementMap(map: THREE.Texture | null): void {\n        if (map !== this.m_displacementMap) {\n            this.m_displacementMap = map;\n            DisplacementFeature.updateDisplacementFeature(this);\n        }\n    }\n\n    /**\n     * The mixin class should call this method to register the property [[displacementMap]]\n     */\n    protected addDisplacementProperties(): void {\n        Object.defineProperty(this, \"displacementMap\", {\n            get: () => {\n                return this.getDisplacementMap();\n            },\n            set: val => {\n                this.setDisplacementMap(val);\n            }\n        });\n    }\n\n    /**\n     * Apply the displacementMap value from the parameters to the respective properties.\n     */\n    protected applyDisplacementParameters(params?: DisplacementFeatureParameters) {\n        linkMixinWithMaterial(this, this);\n\n        assert(this.shaderDefines !== undefined);\n        assert(this.shaderUniforms !== undefined);\n\n        // Create uniforms with default values, this ensures they are always set created,\n        // so no need for checks in setters.\n        const uniforms = this.shaderUniforms!;\n        uniforms.displacementMap = new THREE.Uniform(emptyTexture);\n        uniforms.displacementScale = new THREE.Uniform(1);\n        uniforms.displacementBias = new THREE.Uniform(0);\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.displacementMap !== undefined) {\n                this.setDisplacementMap(params.displacementMap);\n            }\n        }\n\n        this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shader: THREE.Shader) => {\n            DisplacementFeature.onBeforeCompile(this, shader);\n        });\n\n        // Require material update at least once, because of new shader chunks added.\n        this.needsUpdate = DisplacementFeature.isEnabled(this);\n    }\n\n    /**\n     * Copy displacementMap from other DisplacementFeature.\n     *\n     * @param source - The material to copy property values from.\n     */\n    protected copyDisplacementParameters(source: DisplacementFeature) {\n        this.setDisplacementMap(source.displacementMap);\n        return this;\n    }\n}\n\n/**\n * Namespace with support functions for implementors of `FadingFeature`.\n */\nexport namespace FadingFeature {\n    export const DEFAULT_FADE_NEAR: number = -1.0;\n    export const DEFAULT_FADE_FAR: number = -1.0;\n\n    /**\n     * Checks if feature is enabled based on feature params.\n     *\n     * Fading feature will be disabled if fadeFar is undefined or fadeFar <= 0.0.\n     * This function is crucial for shader switching (chunks injection), whenever feature state\n     * changes between enabled/disabled. Current approach is to keep feature on (once enabled)\n     * whenever fading params are reasonable, even if it causes full fade in, no transparency.\n     *\n     * @param fadingMaterial - FadingFeature.\n     */\n    export function isEnabled(fadingMaterial: FadingFeature) {\n        // NOTE: We could also check if full fade is not achieved, then feature could be\n        // disabled, but causing material re-compile.\n        return (\n            fadingMaterial.fadeNear !== undefined &&\n            fadingMaterial.fadeFar !== undefined &&\n            fadingMaterial.fadeFar > 0\n        );\n    }\n\n    /**\n     * Checks if feature is defined based on feature params.\n     *\n     * Fading feature will be defined if fadeNear and fadeFar are defined, their values\n     * are not checked for reasonable values.\n     *\n     * @param fadingMaterial FadingFeature.\n     */\n    export function isDefined(fadingMaterial: FadingFeature) {\n        return fadingMaterial.fadeNear !== undefined && fadingMaterial.fadeFar !== undefined;\n    }\n\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    export function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, fadingShaderChunk);\n        }\n    }\n\n    /**\n     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The\n     * fading feature will be disabled if fadeFar <= 0.0.\n     *\n     * @param fadingMaterial - FadingFeature\n     */\n    export function updateFadingFeature(fadingMaterial: FadingFeature): void {\n        assert(fadingMaterial.shaderDefines !== undefined);\n        assert(fadingMaterial.shaderUniforms !== undefined);\n\n        // Update entire material to add/remove shader fading chunks, this happens when we\n        // enable/disable fading after material creation. Feature is marked via dummy define, which\n        // informs about fading feature state, even if such define is not required to control\n        // feature state, it makes it easy to check for shader changes.\n        const useFading = isEnabled(fadingMaterial);\n        const needsUpdate = setShaderDefine(\n            fadingMaterial.shaderDefines,\n            \"FADING_MATERIAL\",\n            useFading\n        );\n        // Enable/disable entire feature with material re-compile, this will also cause\n        // new uniforms injection.\n        fadingMaterial.needsUpdate = needsUpdate;\n\n        // Check if shader uniforms references are already set in onBeforeCompile callback.\n        assert(\n            fadingMaterial.shaderUniforms!.fadeNear !== undefined &&\n                fadingMaterial.shaderUniforms!.fadeFar !== undefined\n        );\n\n        // Update shader internal uniforms only if fading is enabled.\n        if (useFading) {\n            fadingMaterial.shaderUniforms!.fadeNear.value = fadingMaterial.fadeNear;\n            fadingMaterial.shaderUniforms!.fadeFar.value = fadingMaterial.fadeFar;\n            if (needsUpdate) {\n                enableBlending(fadingMaterial as THREE.Material);\n            }\n        }\n        // Perform one time update of uniforms to defaults when feature disabled (for clarity).\n        else if (needsUpdate) {\n            fadingMaterial.shaderUniforms!.fadeNear.value = FadingFeature.DEFAULT_FADE_NEAR;\n            fadingMaterial.shaderUniforms!.fadeFar.value = FadingFeature.DEFAULT_FADE_FAR;\n            disableBlending(fadingMaterial as THREE.Material);\n        }\n    }\n\n    /**\n     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control fading based on view distance.\n     *\n     * @param fadingMaterial - Material to add uniforms to.\n     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    export function onBeforeCompile(fadingMaterial: FadingFeature, shader: THREE.Shader) {\n        if (!isEnabled(fadingMaterial)) {\n            return;\n        }\n        assert(fadingMaterial.shaderUniforms !== undefined);\n\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them.\n        //\n        // The object \"defines\" are not required for this material, so the fading shader chunks\n        // have no #ifdef preprocessed chunks. Feature utilized one define just to denote feature\n        // attached and easy control its state, but this define may be stripped out if needed.\n        linkMixinWithShader(fadingMaterial, shader);\n\n        // Append the new fading shader cod directly after the fog code. This is done by adding an\n        // include directive for the fading code.\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"fog_pars_vertex\",\n            \"fading_pars_vertex\"\n        );\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"fog_vertex\",\n            \"fading_vertex\",\n            true\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_pars_fragment\",\n            \"fading_pars_fragment\"\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_fragment\",\n            \"fading_fragment\",\n            true\n        );\n    }\n\n    /**\n     * As three.js is rendering the transparent objects last (internally), regardless of their\n     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In\n     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the\n     * fade distance value is less than 1.\n     *\n     * @param object - [[THREE.Object3D]] to prepare for rendering.\n     * @param viewRanges - The visibility ranges (clip planes and maximum visible distance) for\n     * actual camera setup.\n     * @param fadeNear - The fadeNear value to set in the material.\n     * @param fadeFar - The fadeFar value to set in the material.\n     * @param updateUniforms - If `true`, the fading uniforms are set. Not required if material is\n     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].\n     * @param additionalCallback - If defined, this function will be called before the function will\n     *          return.\n     */\n    export function addRenderHelper(\n        object: THREE.Object3D,\n        viewRanges: ViewRanges,\n        fadeNear: number | undefined,\n        fadeFar: number | undefined,\n        updateUniforms: boolean,\n        additionalCallback?: (\n            renderer: THREE.WebGLRenderer,\n            material: THREE.Material & FadingFeature\n        ) => void\n    ) {\n        object.onBeforeRender = chainCallbacks(\n            object.onBeforeRender,\n            (\n                renderer: THREE.WebGLRenderer,\n                scene: THREE.Scene,\n                camera: THREE.Camera,\n                geometry: THREE.BufferGeometry,\n                material: THREE.Material & FadingFeature,\n                group: THREE.Group\n            ) => {\n                const fadingMaterial = material as FadingFeature;\n\n                fadingMaterial.fadeNear =\n                    fadeNear === undefined || fadeNear === FadingFeature.DEFAULT_FADE_NEAR\n                        ? FadingFeature.DEFAULT_FADE_NEAR\n                        : cameraToWorldDistance(fadeNear, viewRanges);\n\n                fadingMaterial.fadeFar =\n                    fadeFar === undefined || fadeFar === FadingFeature.DEFAULT_FADE_FAR\n                        ? FadingFeature.DEFAULT_FADE_FAR\n                        : cameraToWorldDistance(fadeFar, viewRanges);\n\n                if (additionalCallback !== undefined) {\n                    additionalCallback(renderer, material);\n                }\n            }\n        );\n    }\n}\n\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and\n * `fadeFar`. There is some special handling for the fadeNear/fadeFar properties, which get some\n * setters and getters in a way that works well with the mixin.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class FadingFeatureMixin implements FadingFeature {\n    needsUpdate?: boolean;\n    uniformsNeedUpdate?: boolean;\n    defines?: any;\n    shaderDefines?: any;\n    shaderUniforms?: UniformsType;\n    onBeforeCompile?: CompileCallback;\n    private m_fadeNear: number = FadingFeature.DEFAULT_FADE_NEAR;\n    private m_fadeFar: number = FadingFeature.DEFAULT_FADE_FAR;\n\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    protected getFadeNear(): number {\n        return this.m_fadeNear;\n    }\n\n    /**\n     * @see [[FadingFeature#fadeNear]]\n     */\n    protected setFadeNear(value: number) {\n        const needsUpdate = value !== this.m_fadeNear;\n        if (needsUpdate) {\n            this.m_fadeNear = value;\n            FadingFeature.updateFadingFeature(this);\n        }\n    }\n\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    protected getFadeFar(): number {\n        return this.m_fadeFar;\n    }\n\n    /**\n     * @see [[FadingFeature#fadeFar]]\n     */\n    protected setFadeFar(value: number) {\n        const needsUpdate = value !== this.m_fadeFar;\n        if (needsUpdate) {\n            this.m_fadeFar = value;\n            FadingFeature.updateFadingFeature(this);\n        }\n    }\n\n    /**\n     * The mixin classes should call this method to register the properties [[fadeNear]] and\n     * [[fadeFar]].\n     */\n    protected addFadingProperties(): void {\n        Object.defineProperty(this, \"fadeNear\", {\n            get: () => {\n                return this.getFadeNear();\n            },\n            set: val => {\n                this.setFadeNear(val);\n            }\n        });\n        Object.defineProperty(this, \"fadeFar\", {\n            get: () => {\n                return this.getFadeFar();\n            },\n            set: val => {\n                this.setFadeFar(val);\n            }\n        });\n    }\n\n    /**\n     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.\n     *\n     * @param params - `FadingMeshBasicMaterial` parameters.\n     */\n    protected applyFadingParameters(params?: FadingFeatureParameters) {\n        // Prepare maps for holding uniforms and defines references from the actual material.\n        linkMixinWithMaterial(this, this);\n\n        assert(this.shaderDefines !== undefined);\n        assert(this.shaderUniforms !== undefined);\n\n        // Create uniforms with default values, this ensures they are always set created,\n        // so no need for checks in setters.\n        this.shaderUniforms!.fadeNear = new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR);\n        this.shaderUniforms!.fadeFar = new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR);\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.fadeNear !== undefined) {\n                this.setFadeNear(params.fadeNear);\n            }\n            if (params.fadeFar !== undefined) {\n                this.setFadeFar(params.fadeFar);\n            }\n        }\n\n        this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shader: THREE.Shader) => {\n            FadingFeature.onBeforeCompile(this, shader);\n        });\n        // Update (re-compile) shader code to include new shader chunks only if feature is enabled.\n        this.needsUpdate = FadingFeature.isEnabled(this);\n    }\n\n    /**\n     * Copy fadeNear/fadeFar values from other FadingFeature.\n     *\n     * @param source - The material to copy property values from.\n     */\n    protected copyFadingParameters(source: FadingFeature) {\n        this.setFadeNear(\n            source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear\n        );\n        this.setFadeFar(\n            source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar\n        );\n        return this;\n    }\n}\n\nexport namespace ExtrusionFeature {\n    /**\n     * Checks if feature is enabled based on {@link ExtrusionFeature} properties.\n     *\n     * @param extrusionMaterial -\n     */\n    export function isEnabled(extrusionMaterial: ExtrusionFeature) {\n        return (\n            extrusionMaterial.extrusionRatio !== undefined &&\n            extrusionMaterial.extrusionRatio >= ExtrusionFeatureDefs.DEFAULT_RATIO_MIN\n        );\n    }\n\n    /**\n     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.\n     */\n    export function patchGlobalShaderChunks() {\n        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {\n            Object.assign(THREE.ShaderChunk, extrusionShaderChunk);\n        }\n    }\n\n    /**\n     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].\n     *\n     * @param ExtrusionMaterial - ExtrusionFeature\n     */\n    export function updateExtrusionFeature(extrusionMaterial: ExtrusionFeature): void {\n        assert(extrusionMaterial.shaderDefines !== undefined);\n        assert(extrusionMaterial.shaderUniforms !== undefined);\n\n        // Setup shader define that when changed will force material re-compile.\n        const useExtrusion = isEnabled(extrusionMaterial);\n        // Use shader define as marker if feature is enabled/disabled, this is not necessary\n        // required, but material requires update (re-compile) anyway to add/remove shader chunks.\n        const needsUpdate = setShaderDefine(\n            extrusionMaterial.shaderDefines,\n            \"EXTRUSION_MATERIAL\",\n            useExtrusion\n        );\n        // Enable/disable entire feature with material re-compile.\n        extrusionMaterial.needsUpdate = needsUpdate;\n\n        // Update uniform with new value\n        if (useExtrusion) {\n            extrusionMaterial.shaderUniforms!.extrusionRatio.value =\n                extrusionMaterial.extrusionRatio;\n        }\n        // Reset uniform to default, one time only, when feature is disabled (just for clarity).\n        else if (needsUpdate) {\n            extrusionMaterial.shaderUniforms!.extrusionRatio.value =\n                ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n        }\n    }\n\n    /**\n     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`\n     * callback of that material. It adds the required code to the shaders and declares the new\n     * uniforms that control extrusion.\n     *\n     * @param extrusionMaterial - Material to add uniforms to.\n     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the\n     *                  special includes to.\n     */\n    export function onBeforeCompile(extrusionMaterial: ExtrusionFeature, shader: THREE.Shader) {\n        if (!isEnabled(extrusionMaterial)) {\n            return;\n        }\n        assert(extrusionMaterial.shaderUniforms !== undefined);\n\n        // The vertex and fragment shaders have been constructed dynamically. The uniforms and\n        // the shader includes are now appended to them. No defines are required to preprocess\n        // shader chunks, but we utilize one just to note the feature is enabled/disabled\n        // (easier debugging), this define may be easily stripped out or replaced with simple\n        // boolean flag.\n        linkMixinWithShader(extrusionMaterial, shader);\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"common\",\n            \"extrusion_pars_vertex\"\n        );\n\n        shader.vertexShader = insertShaderInclude(\n            shader.vertexShader,\n            \"begin_vertex\",\n            \"extrusion_vertex\",\n            true\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_pars_fragment\",\n            \"extrusion_pars_fragment\"\n        );\n\n        shader.fragmentShader = shader.fragmentShader.replace(\n            \"#include <normal_fragment_begin>\",\n            \"#include <extrusion_normal_fragment_begin>\"\n        );\n\n        shader.fragmentShader = insertShaderInclude(\n            shader.fragmentShader,\n            \"fog_fragment\",\n            \"extrusion_fragment\",\n            true\n        );\n    }\n}\n\n/**\n * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.\n *\n * @remarks\n * There is some special handling for the extrusionRatio property, which is animated via\n * {@link @here/harp-mapview#AnimatedExtrusionHandler} that is\n * using [[extrusionRatio]] setter and getter to update\n * extrusion in a way that works well with the mixin and EdgeMaterial.\n */\nexport class ExtrusionFeatureMixin implements ExtrusionFeature {\n    needsUpdate?: boolean;\n    uniformsNeedUpdate?: boolean;\n    defines?: any;\n    shaderDefines?: any;\n    shaderUniforms?: UniformsType;\n    onBeforeCompile?: CompileCallback;\n    private m_extrusion: number = ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    protected getExtrusionRatio(): number {\n        return this.m_extrusion;\n    }\n\n    /**\n     * @see [[ExtrusionFeature#extrusion]]\n     */\n    protected setExtrusionRatio(value: number) {\n        const needsUpdate = value !== this.m_extrusion;\n        if (needsUpdate) {\n            this.m_extrusion = value;\n            ExtrusionFeature.updateExtrusionFeature(this);\n        }\n    }\n\n    /**\n     * The mixin class should call this method to register the property [[extrusionRatio]]\n     */\n    protected addExtrusionProperties(): void {\n        Object.defineProperty(this, \"extrusionRatio\", {\n            get: () => {\n                return this.getExtrusionRatio();\n            },\n            set: val => {\n                this.setExtrusionRatio(val);\n            }\n        });\n    }\n\n    /**\n     * Apply the extrusionRatio value from the parameters to the respective properties.\n     */\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // Prepare maps for holding uniforms and defines references from the actual material.\n        linkMixinWithMaterial(this, this);\n\n        assert(this.shaderDefines !== undefined);\n        assert(this.shaderUniforms !== undefined);\n\n        if (params && params.zFightingWorkaround === true) {\n            this.shaderDefines.ZFIGHTING_WORKAROUND = \"\";\n        }\n\n        // Create uniform with default value, this ensures that it is always created,\n        // so no need for checks in setters.\n        this.shaderUniforms!.extrusionRatio = new THREE.Uniform(\n            ExtrusionFeatureDefs.DEFAULT_RATIO_MAX\n        );\n\n        // Apply initial parameter values.\n        if (params !== undefined) {\n            if (params.extrusionRatio !== undefined) {\n                this.setExtrusionRatio(params.extrusionRatio);\n            }\n        }\n\n        this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, (shader: THREE.Shader) => {\n            ExtrusionFeature.onBeforeCompile(this, shader);\n        });\n\n        this.needsUpdate = ExtrusionFeature.isEnabled(this);\n    }\n\n    /**\n     * Copy extrusionRatio values from other ExtrusionFeature.\n     *\n     * @param source - The material to copy property values from.\n     */\n    protected copyExtrusionParameters(source: ExtrusionFeature) {\n        if (source.extrusionRatio !== undefined) {\n            this.setExtrusionRatio(source.extrusionRatio);\n        }\n        return this;\n    }\n}\n\n/**\n * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and\n * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is\n * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]\n * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are\n * updated to world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class MapMeshBasicMaterial\n    extends THREE.MeshBasicMaterial\n    implements FadingFeature, ExtrusionFeature, DisplacementFeature {\n    /**\n     * Constructs a new `FadingMeshBasicMaterial`.\n     *\n     * @param params - `FadingMeshBasicMaterial` parameters.\n     */\n    constructor(\n        params?: THREE.MeshBasicMaterialParameters &\n            FadingFeatureParameters &\n            ExtrusionFeatureParameters &\n            DisplacementFeatureParameters\n    ) {\n        super(params);\n\n        FadingFeature.patchGlobalShaderChunks();\n\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters({ ...params, zFightingWorkaround: true });\n\n        this.addDisplacementProperties();\n        this.applyDisplacementParameters(params);\n    }\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    clone(): this {\n        return new MapMeshBasicMaterial().copy(this);\n    }\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    copy(source: this): any {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        this.copyDisplacementParameters(source);\n        return this;\n    }\n\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n\n    get fadeNear(): number {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n\n    set fadeNear(value: number) {\n        // to be overridden\n    }\n\n    get fadeFar(): number {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n\n    set fadeFar(value: number) {\n        // to be overridden\n    }\n\n    get extrusionRatio(): number {\n        return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n\n    set extrusionRatio(value: number) {\n        // to be overridden\n    }\n\n    get displacementMap(): THREE.Texture | null {\n        return null;\n    }\n\n    set displacementMap(value: THREE.Texture | null) {\n        // to be overridden\n    }\n\n    setDisplacementMap(value: THREE.Texture | null) {\n        // to be overridden\n    }\n\n    protected addFadingProperties(): void {\n        // to be overridden\n    }\n\n    protected applyFadingParameters(params?: FadingFeatureParameters) {\n        // to be overridden\n    }\n\n    protected copyFadingParameters(source: FadingFeature) {\n        // to be overridden\n    }\n\n    protected addExtrusionProperties(): void {\n        // to be overridden\n    }\n\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // to be overridden\n    }\n\n    protected copyExtrusionParameters(source: FadingFeature) {\n        // to be overridden\n    }\n\n    protected addDisplacementProperties(): void {\n        // to be overridden\n    }\n\n    protected applyDisplacementParameters(params?: DisplacementFeatureParameters) {\n        // to be overridden\n    }\n\n    protected copyDisplacementParameters(source: DisplacementFeature) {\n        // to be overridden\n    }\n    // Mixin declarations end -----------------------------------------------------------\n}\n\nexport class MapMeshDepthMaterial extends THREE.MeshDepthMaterial implements ExtrusionFeature {\n    constructor(params?: THREE.MeshDepthMaterialParameters & ExtrusionFeatureParameters) {\n        super(params);\n\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        this.addExtrusionProperties();\n\n        // We need to set these to false, because otherwise three.js complains that there are\n        // outputs of the vertex shader not used in the pixel shader, the properties in question\n        // are `vExtrusionRatio` and `vExtrusionAxis`.\n        this.applyExtrusionParameters({ ...params, zFightingWorkaround: false });\n    }\n\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in{@link ExtrusionFeatureMixin}, see below:\n    //\n    // applyMixinsWithoutProperties(...);\n    //\n\n    // Mixin declarations start ---------------------------------------------------------\n    get extrusionRatio(): number {\n        return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n\n    set extrusionRatio(value: number) {\n        // to be overridden\n    }\n\n    protected addExtrusionProperties(): void {\n        // to be overridden\n    }\n\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // to be overridden\n    }\n\n    protected copyExtrusionParameters(source: FadingFeature) {\n        // to be overridden\n    }\n    // Mixin declarations end -----------------------------------------------------------\n}\n\n/**\n * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and\n * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also\n * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,\n * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to\n * world space distances.\n *\n * @see [[Tile#addRenderHelper]]\n */\nexport class MapMeshStandardMaterial\n    extends THREE.MeshStandardMaterial\n    implements FadingFeature, ExtrusionFeature, DisplacementFeature {\n    uniformsNeedUpdate?: boolean;\n\n    /**\n     * Constructs a new `FadingMeshStandardMaterial`.\n     *\n     * @param params - `FadingMeshStandardMaterial` parameters.\n     */\n    constructor(\n        params?: THREE.MeshStandardMaterialParameters &\n            FadingFeatureParameters &\n            ExtrusionFeatureParameters &\n            ShadowFeatureParameters\n    ) {\n        super(params);\n\n        FadingFeature.patchGlobalShaderChunks();\n\n        this.addFadingProperties();\n        this.applyFadingParameters(params);\n\n        ExtrusionFeature.patchGlobalShaderChunks();\n\n        this.addExtrusionProperties();\n        this.applyExtrusionParameters({ ...params, zFightingWorkaround: true });\n\n        if (params?.removeDiffuseLight === true) {\n            this.onBeforeCompile = chainCallbacks(this.onBeforeCompile, shaderParameters => {\n                const shader = shaderParameters as THREE.Shader;\n                shader.fragmentShader = THREE.ShaderChunk.meshphysical_frag.replace(\n                    \"#include <lights_physical_pars_fragment>\",\n                    simpleLightingShadowChunk\n                );\n            });\n        }\n    }\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    clone(): this {\n        return new MapMeshStandardMaterial().copy(this);\n    }\n\n    // overrides with THREE.js base classes are not recognized by tslint.\n    copy(source: this): any {\n        super.copy(source);\n        this.copyFadingParameters(source);\n        this.copyExtrusionParameters(source);\n        return this;\n    }\n\n    // Only here to make the compiler happy, these methods will be overriden: The actual\n    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:\n    //\n    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);\n    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);\n    //\n    // Mixin declarations start ---------------------------------------------------------\n\n    get fadeNear(): number {\n        return FadingFeature.DEFAULT_FADE_NEAR;\n    }\n\n    set fadeNear(value: number) {\n        // to be overridden\n    }\n\n    get fadeFar(): number {\n        return FadingFeature.DEFAULT_FADE_FAR;\n    }\n\n    set fadeFar(value: number) {\n        // to be overridden\n    }\n\n    get extrusionRatio(): number {\n        return ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;\n    }\n\n    set extrusionRatio(value: number) {\n        // to be overridden\n    }\n\n    /**\n     * This is needed to simplify the lighting calculation, currently there is no support for\n     * switching this at runtime. It is required here to be a property because the parameters\n     * are applied to this material, and if this isn't here, three.js will complain that the\n     * property is missing.\n     * @internal\n     */\n    get removeDiffuseLight(): boolean {\n        return false;\n    }\n\n    /** @internal */\n    set removeDiffuseLight(val: boolean) {\n        // Stays empty.\n    }\n\n    protected addFadingProperties(): void {\n        // to be overridden\n    }\n\n    protected applyFadingParameters(params?: FadingFeatureParameters) {\n        // to be overridden\n    }\n\n    protected copyFadingParameters(source: FadingFeature) {\n        // to be overridden\n    }\n\n    protected addExtrusionProperties(): void {\n        // to be overridden\n    }\n\n    protected applyExtrusionParameters(params?: ExtrusionFeatureParameters) {\n        // to be overridden\n    }\n\n    protected copyExtrusionParameters(source: FadingFeature) {\n        // to be overridden\n    }\n    // Mixin declarations end -----------------------------------------------------------\n}\n\n/**\n * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual\n * implementations of the mixed in functions.\n */\napplyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshDepthMaterial, [ExtrusionFeatureMixin]);\napplyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport namespace ExtrusionFeatureDefs {\n    /**\n     * Minimum ratio value for extrusion effect\n     */\n    export const DEFAULT_RATIO_MIN: number = 0.0;\n    /**\n     * Maximum ratio value for extrusion effect\n     */\n    export const DEFAULT_RATIO_MAX: number = 1;\n\n    /**\n     * Buildings height used whenever no height-data is present or height is very small.\n     *\n     * Used to avoid z-fighting between ground plane and building.\n     */\n    export const MIN_BUILDING_HEIGHT = 0.1;\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { convertFragmentShaderToWebGL2, convertVertexShaderToWebGL2 } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nimport { getShaderMaterialDefine, setShaderMaterialDefine } from \"./Utils\";\n\n/**\n * [[RawShaderMaterial]] parameters.\n */\nexport interface RendererMaterialParameters {\n    rendererCapabilities: THREE.WebGLCapabilities;\n}\n\nexport interface RawShaderMaterialParameters\n    extends RendererMaterialParameters,\n        THREE.ShaderMaterialParameters {}\n\n/**\n * Base class for all raw shader materials. Ensures WebGL2 compatibility for WebGL1 shaders.\n */\nexport class RawShaderMaterial extends THREE.RawShaderMaterial {\n    /**\n     * The constructor of `RawShaderMaterial`.\n     *\n     * @param params - `RawShaderMaterial` parameters.  Always required except when cloning\n     * another material.\n     */\n    constructor(params?: RawShaderMaterialParameters) {\n        const isWebGL2 = params?.rendererCapabilities.isWebGL2 === true;\n\n        const shaderParams: THREE.ShaderMaterialParameters | undefined = params\n            ? {\n                  ...params,\n                  glslVersion: isWebGL2 ? THREE.GLSL3 : THREE.GLSL1,\n                  vertexShader:\n                      isWebGL2 && params.vertexShader\n                          ? convertVertexShaderToWebGL2(params.vertexShader)\n                          : params.vertexShader,\n                  fragmentShader:\n                      isWebGL2 && params.fragmentShader\n                          ? convertFragmentShaderToWebGL2(params.fragmentShader)\n                          : params.fragmentShader\n              }\n            : undefined;\n        // Remove properties that are not in THREE.ShaderMaterialParameters, otherwise THREE.js\n        // will log warnings.\n        if (shaderParams) {\n            delete (shaderParams as any).rendererCapabilities;\n        }\n        super(shaderParams);\n        this.invalidateFog();\n        this.setOpacity(shaderParams?.opacity);\n    }\n\n    invalidateFog() {\n        if (this.defines !== undefined && this.fog !== getShaderMaterialDefine(this, \"USE_FOG\")) {\n            setShaderMaterialDefine(this, \"USE_FOG\", this.fog);\n        }\n    }\n\n    /**\n     * To set the material's opacity property value and also update the opacity value of the uniforms if needed.\n     * @param opacity If undefined, the value is not set\n     */\n    setOpacity(opacity?: number) {\n        if (opacity !== undefined) {\n            // The base constructor may set the opacity property before,\n            // therefore we don't check unequality of the current and new opacity value:\n            this.opacity = opacity;\n            if (this.uniforms?.opacity) {\n                this.uniforms.opacity.value = opacity;\n            }\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\n/**\n * `SepiaShader`.\n */\nexport const SepiaShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        amount: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float amount;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 color = texture2D( tDiffuse, vUv );\n            vec3 c = color.rgb;\n            color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\n            color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\n            color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\n            gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\n        }`\n};\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport default {\n    atmosphere_vertex_utils: `\n\n    const float RayleighScaleDepth = 0.25;\n\n    struct AtmosphereColor\n    {\n        vec3 mie;\n        vec3 rayleigh;\n    };\n\n    float scale(float cosAngle)\n    {\n        float x = 1.0 - cosAngle;\n        return RayleighScaleDepth  * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n    }\n\n    float getNearSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {\n        // Solve simple square equation for the x0 (first point of intersection).\n#if defined(IMPROVE_INTERSECT_PRECISION)\n        // To improve precision instead of simple projection: b = 2.0 * dot(vPos, v3Ray),\n        // we change the equation that gives better results especially around the poles.\n        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);\n#else\n        float fB = 2.0 * dot(v3Pos, v3Ray);\n#endif\n        float fC = fCameraHeight2 - fOuterRadius2;\n        // det = b^2 - 4*a*c, where a = 1\n        float fDet = max(0.0, fB * fB - 4.0 * fC);\n        // Intersection points distances are defined as follows:\n        // x0 = (-b - sqrt(det)) / 2*a ^ x1 = (-b + sqrt(det)) / 2*a\n        // we search for x0:\n        return 0.5 * (-fB - sqrt(fDet));\n    }\n\n    float getFarSphereIntersect(vec3 v3Pos, vec3 v3Ray, float fCameraHeight2, float fOuterRadius2) {\n        // Solve simple square equation for the x1 (second point of intersection).\n#if defined(IMPROVE_INTERSECT_PRECISION)\n        float fB = 2.0 * length(v3Pos) * dot(normalize(v3Pos), v3Ray);\n#else\n        float fB = 2.0 * dot(v3Pos, v3Ray);\n#endif\n        float fC = fCameraHeight2 - fOuterRadius2;\n        // det = b^2 - 4*a*c, where a = 1\n        float fDet = max(0.0, fB * fB - 4.0 * fC);\n        // Compute second intersection distance:\n        // x1 = (-b + sqrt(det)) / 2*a\n        return 0.5 * (-fB + sqrt(fDet));\n    }\n    `,\n    atmosphere_fragment_utils: `\n\n    // Branch free RGB to HSV conversion.\n    // Based on article:\n    // http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv\n    // and optimized OpenGL SL algorithm\n    // http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n    vec3 rgb2Hsv(vec3 c)\n    {\n        const vec4 RGB_HSV_CONV = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        // Ternary operator may be used explicitly if compiler can use fast conditional move.\n        // vec4 p = c.g < c.b ? vec4(c.bg, RGB_HSV_CONV.wz) : vec4(c.gb, RGB_HSV_CONV.xy);\n        vec4 p = mix(vec4(c.bg, RGB_HSV_CONV.wz), vec4(c.gb, RGB_HSV_CONV.xy), step(c.b, c.g));\n        // vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    }\n\n    // Branch free HSV to RGB conversion\n    vec3 hsv2Rgb(vec3 c)\n    {\n        const vec4 HSV_RGB_CONV = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + HSV_RGB_CONV.xyz) * 6.0 - HSV_RGB_CONV.www);\n        return c.z * mix(HSV_RGB_CONV.xxx, clamp(p - HSV_RGB_CONV.xxx, 0.0, 1.0), c.y);\n    }\n\n    vec3 correctExposure(vec3 rgb, float exposure)\n    {\n        const vec3 fullColor = vec3(1.0);\n        return fullColor - exp(-exposure * rgb);\n    }\n\n    vec3 correctColor(vec3 rgb, vec3 hsvShift)\n    {\n        const float e = 0.0000001;\n        // Convert rgb color to hsv\n        vec3 hsv = rgb2Hsv(rgb);\n        // Shift hue value with angle wrapping\n        hsv.x = mod(hsv.x + hsvShift.x, 1.0);\n        // Shift and clamp saturation\n        hsv.y = clamp(hsv.y + hsvShift.y, 0.0, 1.0);\n        // Change value if it is significant (greater then epsilon)\n        hsv.z = hsv.z > e ? clamp(hsv.z + hsvShift.z, 0.0, 1.0) : 0.0;\n        // Convert shifted hsv back to rgb\n        return hsv2Rgb(hsv);\n    }\n    `\n};\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ExtrusionFeatureDefs } from \"../MapMeshMaterialsDefs\";\n\nconst MIN_BUILDING_HEIGHT_SQUARED =\n    ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT * ExtrusionFeatureDefs.MIN_BUILDING_HEIGHT;\n\nexport default {\n    extrusion_pars_vertex: `\n// Add define so we can check for it in the outline effect (see Outline.ts).\n#define HAS_EXTRUSION_PARS_VERTEX\n// Extrusion axis (xyz: vector, w: factor).\nattribute vec4 extrusionAxis;\nuniform float extrusionRatio;\n#ifdef FLAT_SHADED\nvarying vec4 vExtrusionAxis;\n#endif\n#ifdef ZFIGHTING_WORKAROUND\nvarying float vExtrusionRatio;\n#endif\n`,\n    extrusion_vertex: `\n#define HAS_EXTRUSION_VERTEX\n#ifdef ZFIGHTING_WORKAROUND\n// Cancel extrusionRatio (meaning, force to 1) if extrusionAxisLen < MIN_BUILDING_HEIGHT.\nconst float MIN_BUILDING_HEIGHT_SQUARED = ${MIN_BUILDING_HEIGHT_SQUARED};\nfloat extrusionAxisLenSquared = dot(extrusionAxis.xyz, extrusionAxis.xyz);\nvExtrusionRatio = (extrusionAxisLenSquared < MIN_BUILDING_HEIGHT_SQUARED) ? 1.0 : extrusionRatio;\n#else\nfloat vExtrusionRatio = extrusionRatio;\n#endif\ntransformed = transformed + extrusionAxis.xyz * (vExtrusionRatio - 1.0);\n#ifdef FLAT_SHADED\nvExtrusionAxis = vec4(normalMatrix * extrusionAxis.xyz, extrusionAxis.w);\n#endif\n`,\n    // Modified version of THREE <normal_fragment_begin> shader chunk which, for flat shaded\n    // geometries, computes the normal either with the extrusion axis or fragment derivatives based\n    // on the extrusion factor (1.0 = ceiling, 0.0 = footprint).\n    extrusion_normal_fragment_begin: `\n#ifdef FLAT_SHADED\n    // Flattened this divergent path to prevent undefined behaviour in the following derivatives\n    // functions. For more info:\n    // http://www.aclockworkberry.com/shader-derivative-functions/#Derivatives_and_branches\n\n    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n    vec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));\n    vec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));\n    vec3 normal = cross( fdx, fdy );\n    if (vExtrusionAxis.w > 0.999999) {\n        normal = vExtrusionAxis.xyz;\n    }\n    normal = normalize(normal);\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t\tbitangent = bitangent * (float(gl_FrontFacing) * 2.0 - 1.0);\n\t\t#endif\n\t#endif\n#endif\n// non perturbed normal for clearcoat among others\nvec3 geometryNormal = normal;\n`,\n    extrusion_pars_fragment: `\n#ifdef ZFIGHTING_WORKAROUND\nvarying float vExtrusionRatio;\n#else\nuniform float extrusionRatio;\n#endif\nvarying vec4 vExtrusionAxis;\n`,\n    extrusion_fragment: `\n#ifndef ZFIGHTING_WORKAROUND\nfloat vExtrusionRatio = extrusionRatio;\n#endif\ngl_FragColor.a *= smoothstep( 0.0, 0.25, vExtrusionRatio );\n`\n};\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * The shader chunks have their lines \"#ifdef USE_FADING\" commented out, because currently the\n * mesh materials use individually created shader strings based on the materials settings.\n * @see [[FadingMeshBasicMaterial]]\n **/\n\nexport default {\n    fading_pars_vertex: `\nvarying float fadingDepth;\n`,\n\n    fading_vertex: `\nfadingDepth = -mvPosition.z;\n`,\n\n    fading_pars_fragment: `\nvarying float fadingDepth;\nuniform float fadeNear;\nuniform float fadeFar;\n`,\n\n    fading_fragment: `\n\n// lerp with \"hard\" edges\n//float fadingFactor = 1.0 - clamp((fadingDepth - fadeNear) / (fadeFar - fadeNear), 0.0, 1.0);\n\n// smooth transitions\nfloat fadingFactor = smoothstep( fadeNear, fadeFar, fadingDepth );\n\ngl_FragColor.a *= 1.0 - fadingFactor;\n\n// debugging color:\n// gl_FragColor = vec4(1., fadingFactor, fadingFactor, 1.0);\n`\n};\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Lists supported line caps types/modes.\n */\nexport enum LineCapsModes {\n    CAPS_NONE = 0,\n    CAPS_SQUARE,\n    CAPS_ROUND,\n    CAPS_TRIANGLE_IN,\n    CAPS_TRIANGLE_OUT\n}\n\nexport default {\n    extrude_line_vert_func: `\nvec3 extrudeLine(\n        in vec3 vertexPosition,\n        in float linePosition,\n        in float extrusionWidth,\n        in vec4 bitangent,\n        in vec3 tangent,\n        in float tanHalfAngle,\n        inout vec2 uv\n    ) {\n    vec3 result = vertexPosition;\n    // Retrieve the angle between this segment and the previous one (stored in the bitangent w\n    // component).\n    float angle = bitangent.w;\n    // Extrude according to the angle between segments to properly render narrow joints...\n    if (angle != 0.0) {\n        result += uv.y * extrusionWidth * bitangent.xyz / cos(angle / 2.0);\n        uv.x = linePosition + uv.x * extrusionWidth * uv.y * tanHalfAngle;\n    }\n    // ... or extrude in a simple manner for segments that keep the same direction.\n    else {\n        result += uv.y * extrusionWidth * bitangent.xyz + uv.x * extrusionWidth * tangent;\n        uv.x = linePosition + uv.x * extrusionWidth;\n    }\n    uv.y *= extrusionWidth;\n    return result;\n}\n`,\n    round_edges_and_add_caps: `\n#define CAPS_NONE ${LineCapsModes.CAPS_NONE}\n#define CAPS_SQUARE ${LineCapsModes.CAPS_SQUARE}\n#define CAPS_ROUND ${LineCapsModes.CAPS_ROUND}\n#define CAPS_TRIANGLE_IN ${LineCapsModes.CAPS_TRIANGLE_IN}\n#define CAPS_TRIANGLE_OUT ${LineCapsModes.CAPS_TRIANGLE_OUT}\n\nfloat roundEdgesAndAddCaps(in vec4 coords, in vec3 range) {\n    // Compute the line's width to length ratio.\n    float widthRatio = range.y / range.x;\n\n    // Compute the inner segment distance (same for all cap mode).\n    float dist = abs(coords.y);\n    float segmentBeginMask = clamp(ceil(coords.z - coords.x), 0.0, 1.0);\n    float segmentEndMask = clamp(ceil(coords.x - coords.w), 0.0, 1.0);\n    dist = max(dist, segmentBeginMask * length(vec2((coords.x - coords.z) / widthRatio, coords.y)));\n    dist = max(dist, segmentEndMask * length(vec2((coords.x - coords.w) / widthRatio, coords.y)));\n\n    #if CAPS_MODE != CAPS_ROUND\n    // Compute the caps mask.\n    float capRangeMask = clamp(1.0 - ceil(range.z - drawRange.y), 0.0, 1.0);\n    float beginCapMask = clamp(ceil(drawRange.x - coords.x), 0.0, 1.0);\n    float endCapMask = clamp(ceil(coords.x - drawRange.y), 0.0, 1.0);\n    float capMask = capRangeMask * max(beginCapMask, endCapMask);\n\n    // Compute the outer segment distance (specific for each cap mode).\n    float capDist = max(coords.x - drawRange.y, drawRange.x - coords.x) / widthRatio;\n    #if CAPS_MODE == CAPS_NONE\n    dist = mix(dist, max(abs(coords.y), (capDist + 0.1) / 0.1), capMask);\n    #elif CAPS_MODE == CAPS_SQUARE\n    dist = mix(dist, max(abs(coords.y), capDist), capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_OUT\n    dist = mix(dist, abs(coords.y) + capDist, capMask);\n    #elif CAPS_MODE == CAPS_TRIANGLE_IN\n    dist = mix(dist, max(abs(coords.y), (capDist - abs(coords.y)) + capDist), capMask);\n    #endif\n    #endif // CAPS_MODE != CAPS_ROUND\n\n    return dist;\n}\n`,\n    tile_clip_func: `\nvoid tileClip(vec2 tilePos, vec2 tileSize) {\n    if (tileSize.x > 0.0 && (tilePos.x < -tileSize.x / 2.0 || tilePos.x > tileSize.x / 2.0))\n        discard;\n    if (tileSize.y > 0.0 && (tilePos.y < -tileSize.y / 2.0 || tilePos.y > tileSize.y / 2.0))\n        discard;\n}\n`,\n    high_precision_vert_func: `\nvec3 subtractDblEyePos( const in vec3 pos ) {\n    vec3 t1 = positionLow - u_eyepos_lowpart;\n    vec3 e = t1 - positionLow;\n    vec3 t2 = ((-u_eyepos_lowpart - e) + (positionLow - (t1 - e))) + pos - u_eyepos;\n    vec3 high_delta = t1 + t2;\n    vec3 low_delta = t2 - (high_delta - t1);\n    return (high_delta + low_delta);\n}\n`\n};\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * This shader chunk replaces the default lighting in the standard material, the problem with this\n * is that the final pixel color is the addition of the material color and the light, this means\n * that the final map's rendered color is vastly different from that configured by the designers.\n * This chunk removes the extra highlight by providing just two colors, the material color when not\n * in shadow and a reduced color value when in shadow (currently 50% of the material's color).\n */\nexport const simpleLightingShadowChunk = `\n    struct PhysicalMaterial {\n        vec3\tdiffuseColor;\n        float\tspecularRoughness;\n        vec3\tspecularColor;\n    };\n\n    #define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n    void RE_Direct_Physical( const in IncidentLight directLight,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight ) {\n        // directLight.color is the light color * shadow, internally three.js uses a step function, so\n        // this value is either the light color or black. in order to lighten up the shadows, we\n        // take add 50% of the color to grey (to give us either pure white or grey) and multiply this to\n        // the material's diffuse color.\n        #if defined(USE_SHADOWMAP)\n            reflectedLight.directDiffuse = (0.5 * directLight.color +\n                vec3(0.5,0.5,0.5)) * material.diffuseColor;\n        #else\n            reflectedLight.directDiffuse = material.diffuseColor;\n        #endif\n    }\n\n    void RE_IndirectDiffuse_Physical( const in vec3 irradiance,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight ) {\n            // Disable influence of indirect light (it is handled in the RE_Direct_Physical function)\n    }\n\n    void RE_IndirectSpecular_Physical( const in vec3 radiance,\n        const in vec3 irradiance,\n        const in vec3 clearcoatRadiance,\n        const in GeometricContext geometry,\n        const in PhysicalMaterial material,\n        inout ReflectedLight reflectedLight) {\n            // Disable specular reflection of light.\n    }\n\n    #define RE_Direct               RE_Direct_Physical\n    #define RE_IndirectDiffuse      RE_IndirectDiffuse_Physical\n    #define RE_IndirectSpecular     RE_IndirectSpecular_Physical\n`;\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport {\n    RawShaderMaterial,\n    RawShaderMaterialParameters,\n    RendererMaterialParameters\n} from \"./RawShaderMaterial\";\nimport AtmosphereShaderChunks from \"./ShaderChunks/AtmosphereChunks\";\nimport { setShaderDefine, setShaderMaterialDefine } from \"./Utils\";\n\nconst EQUATORIAL_RADIUS: number = 6378137.0;\n\n/**\n * `SkyAtmosphereShader`.\n *\n * Describes shading of atmosphere as seen from outer space.\n */\nexport const SkyAtmosphereShader: THREE.Shader = {\n    uniforms: {\n        u_eyePositionWorld: new THREE.Uniform(new THREE.Vector3()),\n        u_lightDirectionWorld: new THREE.Uniform(new THREE.Vector3(0, 1, 0)),\n        u_modelViewProjection: new THREE.Uniform(new THREE.Matrix4()),\n        // Environment settings:\n        // atmosphere inner and outer radius, camera height\n        u_atmosphereEnv: new THREE.Uniform(\n            new THREE.Vector3(\n                // Maximum inner radius\n                EQUATORIAL_RADIUS,\n                // Maximum outer radius\n                EQUATORIAL_RADIUS * 1.025,\n                // Camera height\n                0.0\n            )\n        ),\n        u_hsvCorrection: new THREE.Uniform(new THREE.Vector3(0, 0, 0)),\n\n        topColor: new THREE.Uniform(new THREE.Color(0x0077ff)),\n        bottomColor: new THREE.Uniform(new THREE.Color(0xffffff)),\n        offset: new THREE.Uniform(33.0),\n        exponent: new THREE.Uniform(0.6),\n        fogColor: new THREE.Uniform(new THREE.Color(0x0077ff)), // scene.fog.color\n        fogNear: new THREE.Uniform(new THREE.Color(0x0077ff)), // scene.fog.near\n        fogFar: new THREE.Uniform(new THREE.Color(0xffffff)) // scene.fog.far\n    },\n\n    vertexShader: `\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n\n    uniform mat4 u_modelViewProjection;\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_hsvCorrection;\n\n    const float Pi = 3.141592653589793;\n    const float Kr = 0.0025;\n    const float Kr4PI = Kr * 4.0 * Pi;\n    const float Km = 0.0015;\n    const float Km4PI = Km * 4.0 * Pi;\n    const float ESun = 15.0; // should be 15.0\n    const float KmESun = Km * ESun;\n    const float KrESun = Kr * ESun;\n    const vec3 InvWavelength = vec3(\n        5.60204474633241,  // Red = 1.0 / Math.pow(0.650, 4.0)\n        9.473284437923038, // Green = 1.0 / Math.pow(0.570, 4.0)\n        19.643802610477206); // Blue = 1.0 / Math.pow(0.475, 4.0)\n\n    const int nSamples = 2;\n    const float fSamples = 2.0;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n\n    ${AtmosphereShaderChunks.atmosphere_vertex_utils}\n\n    //\n    // Computes rayleight and mia atmosphere factors for sky.\n    //\n    // Code based on GPU Gems article.\n    //\n    // Author: Sean O'Neil\n    //\n    // Copyright (c) 2004 Sean O'Neil\n    //\n    // https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n    //\n    // Further modifications by HERE\n    //\n    AtmosphereColor computeSkyAtmosphere(vec3 v3Pos, vec3 vLightDir)\n    {\n        // Unpack attributes\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        // All that may be const or define(s) at further optimization:\n        float fScale = 1.0 / (fOuterRadius - fInnerRadius);\n        float fScaleOverScaleDepth = (fScale / RayleighScaleDepth);\n        float fCameraHeight2 = fCameraHeight * fCameraHeight;\n        float fOuterRadius2 = fOuterRadius * fOuterRadius;\n\n        // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n        vec3 v3Ray = v3Pos - u_eyePositionWorld;\n        float fFar = length(v3Ray);\n        v3Ray /= fFar;\n\n    #ifdef CAMERA_IN_SPACE\n\n        // Calculate the closest intersection of the ray with the outer\n        // atmosphere, this is the first point of the ray passing through the atmosphere dome.\n        float fNear = getNearSphereIntersect(u_eyePositionWorld, v3Ray, fCameraHeight2, fOuterRadius2);\n        // Make far relative to first atmosphere intersection\n        fFar -= fNear;\n\n        // Compute the ray's starting position within the atmosphere, then\n        // calculate its scattering offset\n        vec3 v3Start = u_eyePositionWorld + v3Ray * fNear;\n\n        float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n        float fStartDepth = exp(-1.0 / RayleighScaleDepth );\n        float fStartOffset = fStartDepth * scale(fStartAngle);\n\n    #else // CAMERA_IN_ATMOSPHERE\n\n        // The ray starts already in atmosphere\n        vec3 v3Start = u_eyePositionWorld;\n        float height = length(v3Start);\n        float depth = exp(fScaleOverScaleDepth * (fInnerRadius - fCameraHeight));\n        float fStartAngle = dot(v3Ray, v3Start) / height;\n        float fStartOffset = depth * scale(fStartAngle);\n\n    #endif\n\n        // Initialize the scattering loop variables\n        float fSampleLength = fFar / fSamples;\n        float fScaledLength = fSampleLength * fScale;\n        vec3 v3SampleRay = v3Ray * fSampleLength;\n        vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n        // Now loop through the sample rays\n        vec3 v3BaseColor = vec3(0.0);\n        vec3 v3Attenuate = vec3(0.0);\n        for(int i=0; i < nSamples; i++)\n        {\n            float height = length(v3SamplePoint);\n            float depth = exp(fScaleOverScaleDepth * (fInnerRadius - height));\n            float fLightAngle = dot(vLightDir, v3SamplePoint) / height;\n            float fCameraAngle = dot(v3Ray, v3SamplePoint) / height;\n            float fScatter = (fStartOffset + depth * (scale(fLightAngle) - scale(fCameraAngle)));\n            v3Attenuate = exp(-fScatter * (InvWavelength * Kr4PI + Km4PI));\n            v3BaseColor += v3Attenuate * (depth * fScaledLength);\n            v3SamplePoint += v3SampleRay;\n        }\n\n        // Scale the Mie and Rayleigh colors and set up output of the function\n        AtmosphereColor color;\n        color.mie = v3BaseColor * KmESun;\n        color.rayleigh = v3BaseColor * (InvWavelength * KrESun);\n        return color;\n    }\n\n    void main(void)\n    {\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        AtmosphereColor atmColor = computeSkyAtmosphere(position.xyz, vLightDir);\n        v_mieColor = atmColor.mie;\n        v_rayleighColor = atmColor.rayleigh;\n        v_vertToCamera = u_eyePositionWorld - position.xyz;\n\n        gl_Position = u_modelViewProjection * position;\n    }\n    `,\n\n    fragmentShader: `\n    // Because of harsh light distribution the exposure correction is always enabled for the sky.\n    #define CORRECT_EXPOSURE 1\n\n    precision highp float;\n    precision highp int;\n\n    #ifdef CORRECT_COLOR\n    uniform vec3 u_hsvCorrection; // Hue, saturation, brightness\n    #endif\n\n    uniform vec3 u_atmosphereEnv; // Atmosphere inner and outer radius, camera height\n    uniform vec3 u_eyePositionWorld;\n    uniform vec3 u_lightDirectionWorld;\n\n    const float g = -0.95;\n    const float g2 = g * g;\n\n    varying vec3 v_rayleighColor;\n    varying vec3 v_mieColor;\n    varying vec3 v_vertToCamera;\n\n    ${AtmosphereShaderChunks.atmosphere_fragment_utils}\n\n    void main(void)\n    {\n        float fInnerRadius = u_atmosphereEnv.x;\n        float fOuterRadius = u_atmosphereEnv.y;\n        float fCameraHeight = u_atmosphereEnv.z;\n\n        #ifdef DYNAMIC_LIGHT\n            vec3 vLightDir = u_lightDirectionWorld;\n            // Alter alpha based on time of day (0.0 = night , 1.0 = day)\n            float fNightAlpha = clamp(dot(normalize(u_eyePositionWorld), vLightDir), 0.0, 1.0);\n        #else\n            vec3 vLightDir = u_eyePositionWorld;\n            float fNightAlpha = 1.0;\n        #endif\n        vLightDir = normalize(vLightDir);\n\n        // NOTE:\n        // For better precision normalization may be added on fragment (for mobile devices)\n        // while in vertex shader may be left un-normalized\n        // dot(vLightDir, normalize(v_vertToCamera)) / length(v_vertToCamera);\n        float fCosAngle = dot(vLightDir, v_vertToCamera) / length(v_vertToCamera);\n        float fRayleighPhase = 0.75 * (1.0 + fCosAngle * fCosAngle);\n        float fMiePhase = 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCosAngle * fCosAngle) / pow(1.0 + g2 - 2.0 * g * fCosAngle, 1.5);\n\n        vec3 cRgb = fRayleighPhase * v_rayleighColor + fMiePhase * v_mieColor;\n\n        // Sky produces very harsh lighting effect so exposure correction is always enabled.\n    #if !defined(HDR_FRAME_BUFFER) && defined(CORRECT_EXPOSURE)\n        // Exposure factor may be exposed to uniform variable.\n        cRgb = correctExposure(cRgb, 2.0);\n    #endif\n\n    #ifdef CORRECT_COLOR\n        cRgb = correctColor(cRgb, u_hsvCorrection);\n    #endif\n\n        // Alter alpha based on how close the viewer is to the ground (1.0 = on ground, 0.0 = at edge of atmosphere)\n        float fAtmosphereAlpha = clamp((fOuterRadius - fCameraHeight) /\n            (fOuterRadius - fInnerRadius), 0.0, 1.0);\n        fAtmosphereAlpha *= pow(fNightAlpha, 0.5);\n\n        gl_FragColor = vec4(cRgb, mix(cRgb.b, 1.0, fAtmosphereAlpha));\n    }\n    `\n};\n\nexport interface SkyAtmosphereMaterialParameters extends RendererMaterialParameters {}\n\nexport class SkyAtmosphereMaterial extends RawShaderMaterial {\n    /**\n     * Constructs a new `SkyAtmosphereMaterial`.\n     *\n     * @param params - `SkyAtmosphereMaterial` parameters. Always required except when cloning\n     * another material.\n     */\n    constructor(params?: SkyAtmosphereMaterialParameters) {\n        let shaderParams: RawShaderMaterialParameters | undefined;\n\n        if (params) {\n            // Import shader chunks\n            const defines: { [key: string]: any } = {};\n            defines.CAMERA_IN_SPACE = \"\";\n\n            shaderParams = {\n                name: \"SkyAtmosphereMaterial\",\n                vertexShader: SkyAtmosphereShader.vertexShader,\n                fragmentShader: SkyAtmosphereShader.fragmentShader,\n                uniforms: SkyAtmosphereShader.uniforms,\n                transparent: true,\n                depthTest: true,\n                depthWrite: false,\n                side: THREE.BackSide,\n                blending: THREE.NormalBlending,\n                fog: false,\n                rendererCapabilities: params.rendererCapabilities\n            };\n        }\n        super(shaderParams);\n    }\n\n    setDynamicLighting(enableLighting: boolean) {\n        setShaderMaterialDefine(this, \"DYNAMIC_LIGHT\", enableLighting);\n    }\n\n    /**\n     * Set maximum outer radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]] * 1.025\n     */\n    set outerRadius(radius: number) {\n        this.uniforms.u_atmosphereEnv.value.y = radius;\n    }\n\n    get outerRadius(): number {\n        return this.uniforms.u_atmosphereEnv.value.y;\n    }\n\n    /**\n     * Set maximum inner radius of atmosphere.\n     *\n     * @default [[EarthConstants.EQUATORIAL_RADIUS]].\n     */\n    set innerRadius(radius: number) {\n        this.uniforms.u_atmosphereEnv.value.x = radius;\n    }\n\n    get innerRadius(): number {\n        return this.uniforms.u_atmosphereEnv.value.x;\n    }\n\n    /**\n     * Updates the uniform data of a material used to render an atmosphere.\n     *\n     * This includes only uniforms that may change frame by frame, other uniforms are\n     * accessed with convenient material setters and getters.\n     *\n     * @param shaderMaterial - Material which uniforms will be updated.\n     * @param matrixWorldInverse - Inverse of world matrix used to position the atmosphere dome.\n     * @param lightDirection - The light directional vector in world space.\n     * @param camera - Camera used in rendering.\n     */\n    updateUniforms(\n        shaderMaterial: THREE.ShaderMaterial,\n        object: THREE.Object3D,\n        camera: THREE.Camera,\n        lightDirection: THREE.Vector3\n    ): void {\n        const cameraInfo = this.getCameraInfo(object, camera);\n\n        if (shaderMaterial !== undefined && shaderMaterial.isMaterial) {\n            if (\n                shaderMaterial.uniforms &&\n                shaderMaterial.uniforms.u_atmosphereEnv &&\n                shaderMaterial.uniforms.u_hsvCorrection &&\n                shaderMaterial.uniforms.u_eyePositionWorld &&\n                shaderMaterial.uniforms.u_modelViewProjection &&\n                shaderMaterial.uniforms.u_lightDirectionWorld\n            ) {\n                const eyePos = cameraInfo.eyePos;\n                const mvp = cameraInfo.modelViewProjection;\n                const cameraHeight = cameraInfo.eyeHeight;\n\n                shaderMaterial.uniforms.u_eyePositionWorld.value.copy(eyePos);\n                shaderMaterial.uniforms.u_modelViewProjection.value.copy(mvp);\n\n                shaderMaterial.uniforms.u_atmosphereEnv.value.z = cameraHeight;\n                shaderMaterial.uniforms.u_lightDirectionWorld.value = lightDirection.clone();\n\n                const cameraInSpace = cameraHeight > this.outerRadius;\n                const needsUpdate0 = setShaderDefine(\n                    shaderMaterial.defines,\n                    \"CAMERA_IN_SPACE\",\n                    cameraInSpace\n                );\n                const needsUpdate1 = setShaderDefine(\n                    shaderMaterial.defines,\n                    \"CAMERA_IN_ATMOSPHERE\",\n                    !cameraInSpace\n                );\n                shaderMaterial.needsUpdate =\n                    shaderMaterial.needsUpdate || needsUpdate0 || needsUpdate1;\n            } else {\n                throw Error(\"Atmosphere material has missing uniforms\");\n            }\n        } else {\n            throw Error(\"Wrong object used, only Material objects are supported\");\n        }\n    }\n\n    /*\n     * Calculate camera position used in vertex shader of atmosphere materials.\n     *\n     * @param object -\n     * @param camera - Camera used to get the eye position.\n     */\n    private getCameraInfo(\n        object: THREE.Object3D,\n        camera: THREE.Camera,\n        reverse: boolean = false\n    ): { modelViewProjection: THREE.Matrix4; eyePos: THREE.Vector3; eyeHeight: number } {\n        if (reverse) {\n            const modelMatrix = new THREE.Matrix4().identity();\n            const viewMatrix = new THREE.Matrix4().copy(object.matrixWorld).invert().transpose();\n            const projectionMatrix = camera.projectionMatrix;\n\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n\n            const eyePos = new THREE.Vector3();\n            object.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            camera.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        } else {\n            const modelMatrix = object.matrixWorld;\n            const viewMatrix = camera.matrixWorldInverse;\n            const projectionMatrix = camera.projectionMatrix;\n\n            const mvpMatrix = new THREE.Matrix4();\n            // MVP = Projection * View * Model\n            mvpMatrix.multiplyMatrices(viewMatrix, modelMatrix);\n            mvpMatrix.multiplyMatrices(projectionMatrix, mvpMatrix);\n\n            const eyePos = new THREE.Vector3();\n            camera.getWorldPosition(eyePos);\n            const objectPos = new THREE.Vector3();\n            object.getWorldPosition(objectPos);\n            const eyeHeight = objectPos.distanceTo(eyePos);\n            // Normally we would return simply camera position, but since camera is not moving in\n            // the globe view only the world, we need to calculate eye relative to object position.\n            eyePos.sub(objectPos);\n            return {\n                modelViewProjection: mvpMatrix,\n                eyePos,\n                eyeHeight\n            };\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LineCaps, LineDashes } from \"@here/harp-datasource-protocol\";\nimport * as THREE from \"three\";\n\nimport { DisplacementFeature, DisplacementFeatureParameters } from \"./DisplacementFeature\";\nimport { FadingFeature, FadingFeatureParameters } from \"./MapMeshMaterials\";\nimport {\n    RawShaderMaterial,\n    RawShaderMaterialParameters,\n    RendererMaterialParameters\n} from \"./RawShaderMaterial\";\nimport linesShaderChunk, { LineCapsModes } from \"./ShaderChunks/LinesChunks\";\nimport {\n    enforceBlending,\n    getShaderMaterialDefine,\n    setShaderDefine,\n    setShaderMaterialDefine\n} from \"./Utils\";\n\nconst LineCapsDefinesMapping: { [key in LineCaps]: number } = {\n    None: LineCapsModes.CAPS_NONE,\n    Square: LineCapsModes.CAPS_SQUARE,\n    Round: LineCapsModes.CAPS_ROUND,\n    TriangleIn: LineCapsModes.CAPS_TRIANGLE_IN,\n    TriangleOut: LineCapsModes.CAPS_TRIANGLE_OUT\n};\n\nconst DefinesLineCapsMapping: { [key: number]: LineCaps } = Object.keys(\n    LineCapsDefinesMapping\n).reduce((r, lineCapsName) => {\n    const defineKey = lineCapsName as keyof typeof LineCapsDefinesMapping;\n    const defineValue: number = LineCapsDefinesMapping[defineKey];\n    r[defineValue] = defineKey;\n    return r;\n}, ({} as any) as { [key: number]: LineCaps });\n\nexport enum LineDashesModes {\n    DASHES_SQUARE = 0,\n    DASHES_ROUND,\n    DASHES_DIAMOND\n}\n\nconst LineDashesDefinesMapping: { [key in LineDashes]: number } = {\n    Square: LineDashesModes.DASHES_SQUARE,\n    Round: LineDashesModes.DASHES_ROUND,\n    Diamond: LineDashesModes.DASHES_DIAMOND\n};\n\nconst DefinesLineDashesMapping: { [key: number]: LineDashes } = Object.keys(\n    LineDashesDefinesMapping\n).reduce((r, lineDashesName) => {\n    const defineKey = lineDashesName as keyof typeof LineDashesDefinesMapping;\n    const defineValue: number = LineDashesDefinesMapping[defineKey];\n    r[defineValue] = defineKey;\n    return r;\n}, ({} as any) as { [key: number]: LineDashes });\n\n/**\n * The vLength contains the actual line length, it's needed for the creation of line caps by\n * detecting line ends. `vLength == vExtrusionCoord.x + lineWidth * 2`\n */\n/**\n * The vExtrusionStrength relies on the edges of the lines. Represents how far the current point was\n * extruded on the edges because of the current angle. Needed for preventing line caps artifacts on\n * sharp line edges. For example, on sharp edges, some vertices can be extruded much further than\n * the full line length.\n */\n\nconst tmpColor = new THREE.Color();\nconst vertexSource: string = `\n#define SEGMENT_OFFSET 0.1\n\nattribute vec3 extrusionCoord;\nattribute vec3 position;\nattribute vec4 biTangent;\nattribute vec3 tangent;\nattribute vec2 uv;\nattribute vec3 normal;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float extrusionWidth;\nuniform float outlineWidth;\nuniform float offset;\nuniform vec2 drawRange;\n\n#ifdef USE_DISPLACEMENTMAP\nuniform sampler2D displacementMap;\n#endif\n\n#ifdef USE_TILE_CLIP\nvarying vec3 vPosition;\n#endif\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nattribute vec3 color;\nvarying vec3 vColor;\n#endif\n\n#ifdef USE_FADING\n#include <fading_pars_vertex>\n#endif\n\n#include <fog_pars_vertex>\n\n#include <extrude_line_vert_func>\n\nvoid main() {\n    // Calculate the segment.\n    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;\n    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;\n\n    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.\n    float linePos = mix(segment.x, segment.y, segmentPos);\n    vec2 extrusionDir = sign(extrusionCoord.xy);\n    // Precompute to avoid computing multiple times\n    float tanHalfAngle = tan(biTangent.w / 2.0);\n    float extrusionFactor = extrusionDir.y * tanHalfAngle;\n\n    // Calculate the extruded vertex position (and scale the extrusion direction).\n    vec3 pos = extrudeLine(\n        position, linePos, extrusionWidth + outlineWidth, biTangent, tangent, tanHalfAngle,\n        extrusionDir);\n\n    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).\n    vRange = vec3(extrusionCoord.z, extrusionWidth, extrusionFactor);\n    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);\n\n    // Adjust the segment to fit the drawRange.\n    float capDist = (extrusionWidth + outlineWidth) / extrusionCoord.z;\n    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {\n        vCoords.zw += 1.0;\n    }\n    if (vCoords.z < drawRange.x) {\n        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);\n    }\n    if (vCoords.w > drawRange.y) {\n        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);\n    }\n\n    // Transform position.\n    #ifdef USE_DISPLACEMENTMAP\n    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;\n    #endif\n\n    // Shift the line based on the offset, where the bitangent is the cross product of the average\n    // of the two direction vectors (the previous and next segment directions) and the normal of\n    // the line (facing into the sky). The w component is the angle between the two segments.\n    // Note, we need to take the angle into consideration, so we use trigonometry to calculate how\n    // much we need to extend the offset. Note, orthough this looks complicated we are doing this\n    // in the vertex shader, so it should not cause a performance issue.\n    pos += biTangent.xyz * offset * sqrt(1.0 + pow(abs(tanHalfAngle), 2.0));\n\n    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n    // Pass extruded position to fragment shader.\n    #ifdef USE_TILE_CLIP\n    vPosition = pos;\n    #endif\n\n    #ifdef USE_COLOR\n    // Pass vertex color to fragment shader.\n    vColor = color;\n    #endif\n\n    #ifdef USE_FADING\n    #include <fading_vertex>\n    #endif\n\n    #include <fog_vertex>\n}`;\n\nconst fragmentSource: string = `\nprecision highp float;\nprecision highp int;\n\nuniform vec3 diffuseColor;\nuniform vec3 outlineColor;\nuniform float opacity;\nuniform float extrusionWidth;\nuniform float outlineWidth;\nuniform vec2 tileSize;\nuniform vec2 drawRange;\n\n#ifdef USE_DASHED_LINE\nuniform float dashSize;\nuniform float gapSize;\nuniform vec3 dashColor;\n\n#define DASHES_SQUARE ${LineDashesModes.DASHES_SQUARE}\n#define DASHES_ROUND ${LineDashesModes.DASHES_ROUND}\n#define DASHES_DIAMOND ${LineDashesModes.DASHES_DIAMOND}\n#endif\n\n#ifdef USE_TILE_CLIP\nvarying vec3 vPosition;\n#endif\n\nvarying vec3 vRange;\nvarying vec4 vCoords;\n#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif\n\n#include <round_edges_and_add_caps>\n#include <tile_clip_func>\n\n#ifdef USE_FADING\n#include <fading_pars_fragment>\n#endif\n\n#include <fog_pars_fragment>\n\nvoid main() {\n    float alpha = opacity;\n    vec3 outputDiffuse = diffuseColor;\n\n    #ifdef USE_TILE_CLIP\n    tileClip(vPosition.xy, tileSize);\n    #endif\n\n    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).\n    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);\n    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).\n    float distToEdge = distToCenter - (extrusionWidth + outlineWidth) / extrusionWidth;\n\n    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope\n    // of distToChange increases (i.e. the line is further away).\n    float width = fwidth(distToEdge);\n\n    float s = opacity < 0.98\n        ? clamp((distToEdge + width) / (2.0 * width), 0.0, 1.0) // prefer a boxstep\n        : smoothstep(-width, width, distToEdge);\n\n    if (opacity < 0.98 && 1.0 - s < opacity) {\n        // drop the fragment when the line is using opacity.\n        discard;\n    }\n\n    alpha *= 1.0 - s;\n\n    #ifdef USE_DASHED_LINE\n    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).\n    float d = dashSize / vRange.x;\n    float g = gapSize / vRange.x;\n    float distToDashOrigin = mod(vCoords.x, d + g) / d;\n\n    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the\n    // dashBlendFactor similarly on how we did it for the line opacity.\n    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);\n    #if DASHES_MODE == DASHES_ROUND\n    distToDashEdge = 0.5 - distance(vec2(distToCenter * 0.5, distToDashEdge), vec2(0.0, 0.5));\n    #elif DASHES_MODE == DASHES_DIAMOND\n    distToDashEdge -= distToCenter * 0.5;\n    #endif\n    float dashWidth = fwidth(distToDashEdge);\n    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);\n\n    #ifdef USE_DASH_COLOR\n    outputDiffuse = mix(diffuseColor, dashColor, dashBlendFactor);\n    #endif\n    #endif\n\n    #ifdef USE_OUTLINE\n    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and\n    // compute the outlineBlendFactor (used to mix line and outline colors).\n    float distToOutline = distToCenter - 1.0;\n    float outlineWidth = fwidth(distToOutline);\n    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);\n\n    // Mix the colors using the different computed factors.\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);\n    outputDiffuse = mix(\n      mix(\n        mix(outlineColor, diffuseColor, colorBlendFactor),\n        outputDiffuse,\n        dashBlendFactor\n      ),\n      outlineColor,\n      outlineBlendFactor\n    );\n    #else\n    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);\n    #endif\n    #endif\n\n    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)\n    // Multiply the alpha by the dashBlendFactor.\n    #if defined(USE_OUTLINE)\n    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);\n    #else\n    alpha *= 1.0 - dashBlendFactor;\n    #endif\n    #endif\n\n    #ifdef USE_COLOR\n    gl_FragColor = vec4( outputDiffuse * vColor, alpha );\n    #else\n    gl_FragColor = vec4( outputDiffuse, alpha );\n    #endif\n\n    #include <fog_fragment>\n\n    #ifdef USE_FADING\n    #include <fading_fragment>\n    #endif\n\n\n}`;\n\n/**\n * Parameters used when constructing a new {@link SolidLineMaterial}.\n */\nexport interface SolidLineMaterialParameters\n    extends FadingFeatureParameters,\n        DisplacementFeatureParameters,\n        RendererMaterialParameters {\n    /**\n     * Line color.\n     */\n    color?: number | string;\n\n    /**\n     * Line outline color.\n     */\n    outlineColor?: number | string;\n\n    /**\n     * Enables/Disable depth test.\n     */\n    depthTest?: boolean;\n\n    /**\n     * Enables/Disable depth write.\n     */\n    depthWrite?: boolean;\n\n    /**\n     * `SolidLineMaterial` extends the ThreeJS `RawShaderMaterial` that does not update fog at\n     * runtime, so instead of recompiling everything we pass it in the constructor.\n     */\n    fog?: boolean;\n\n    /**\n     * Line width.\n     */\n    lineWidth?: number;\n\n    /**\n     * Outline width.\n     */\n    outlineWidth?: number;\n\n    /**\n     * Line opacity.\n     */\n    opacity?: number;\n\n    /**\n     * Describes line caps type (`\"None\"`, `\"Round\"`, `\"Square\"`, `\"TriangleOut\"`, `\"TriangleIn\"`).\n     * Default is `\"Round\"`.\n     */\n    caps?: LineCaps;\n\n    /**\n     * Describes the starting drawing position for the line (in the range [0...1]).\n     * Default is `0.0`.\n     */\n    drawRangeStart?: number;\n\n    /**\n     * Describes the ending drawing position for the line (in the range [0...1]).\n     * Default is `1.0`.\n     */\n    drawRangeEnd?: number;\n\n    /**\n     * Describes line dash type (`\"Round\"`, `\"Square\"`, `\"Diamond\"`).\n     * Default is `\"Square\"`.\n     */\n    dashes?: LineDashes;\n\n    /**\n     * Line dashes color.\n     */\n    dashColor?: number | string;\n\n    /**\n     * Size of the dashed segments.\n     */\n    dashSize?: number;\n\n    /**\n     * Size of the gaps between dashed segments.\n     */\n    gapSize?: number;\n\n    /**\n     * How much to offset in world units.\n     */\n    offset?: number;\n}\n\n/**\n * Material designed to render solid variable-width lines.\n */\nexport class SolidLineMaterial\n    extends RawShaderMaterial\n    implements DisplacementFeature, FadingFeature {\n    static DEFAULT_COLOR: number = 0xff0000;\n    static DEFAULT_WIDTH: number = 1.0;\n    static DEFAULT_OUTLINE_WIDTH: number = 0.0;\n    static DEFAULT_OPACITY: number = 1.0;\n    static DEFAULT_DRAW_RANGE_START: number = 0.0;\n    static DEFAULT_DRAW_RANGE_END: number = 1.0;\n    static DEFAULT_DASH_SIZE: number = 1.0;\n    static DEFAULT_GAP_SIZE: number = 1.0;\n    static DEFAULT_OFFSET: number = 0.0;\n\n    /**\n     * Constructs a new `SolidLineMaterial`.\n     *\n     * @param params - `SolidLineMaterial` parameters. Always required except when cloning another\n     * material.\n     */\n    constructor(params?: SolidLineMaterialParameters) {\n        Object.assign(THREE.ShaderChunk, linesShaderChunk);\n\n        FadingFeature.patchGlobalShaderChunks();\n\n        // Setup default defines.\n        const defines: { [key: string]: any } = {\n            CAPS_MODE: LineCapsModes.CAPS_ROUND,\n            DASHES_MODE: LineDashesModes.DASHES_SQUARE\n        };\n\n        // Prepare defines based on params passed in, before super class c-tor, this ensures\n        // proper set for shader compilation, without need to re-compile.\n        let fogParam = true;\n        let opacityParam = 1.0;\n        let displacementMap;\n\n        let shaderParams: RawShaderMaterialParameters | undefined;\n        if (params) {\n            fogParam = params.fog === true;\n            if (fogParam) {\n                setShaderDefine(defines, \"USE_FOG\", true);\n            }\n            opacityParam = params.opacity !== undefined ? params.opacity : opacityParam;\n            displacementMap = params.displacementMap;\n            if (displacementMap !== undefined) {\n                setShaderDefine(defines, \"USE_DISPLACEMENTMAP\", true);\n            }\n            const hasOutline = params.outlineWidth !== undefined && params.outlineWidth > 0;\n            if (hasOutline) {\n                setShaderDefine(defines, \"USE_OUTLINE\", true);\n            }\n            shaderParams = {\n                name: \"SolidLineMaterial\",\n                vertexShader: vertexSource,\n                fragmentShader: fragmentSource,\n                uniforms: THREE.UniformsUtils.merge([\n                    {\n                        // HARP-17373: Original uniform name 'diffuse' due to shader compilation\n                        // errors with Metal in Safari 15 on MacOS Monterrey and iPadOS 15.\n                        diffuseColor: new THREE.Uniform(\n                            new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)\n                        ),\n                        dashColor: new THREE.Uniform(\n                            new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)\n                        ),\n                        outlineColor: new THREE.Uniform(\n                            new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)\n                        ),\n                        extrusionWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),\n                        outlineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),\n                        offset: new THREE.Uniform(SolidLineMaterial.DEFAULT_OFFSET),\n                        opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),\n                        tileSize: new THREE.Uniform(new THREE.Vector2()),\n                        fadeNear: new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR),\n                        fadeFar: new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR),\n                        displacementMap: new THREE.Uniform(\n                            displacementMap !== undefined ? displacementMap : new THREE.Texture()\n                        ),\n                        drawRange: new THREE.Uniform(\n                            new THREE.Vector2(\n                                SolidLineMaterial.DEFAULT_DRAW_RANGE_START,\n                                SolidLineMaterial.DEFAULT_DRAW_RANGE_END\n                            )\n                        ),\n                        dashSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_DASH_SIZE),\n                        gapSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_GAP_SIZE)\n                    },\n                    // We need the fog uniforms available when we use `fog` setter as the internal\n                    // recompilation cannot add or remove uniforms.\n                    THREE.UniformsLib.fog\n                ]),\n                defines,\n                // No need to pass overridden `fog` and `opacity` params they will be set\n                // after super c-tor call.\n                fog: fogParam,\n                opacity: opacityParam,\n                rendererCapabilities: params.rendererCapabilities\n            };\n        }\n\n        super(shaderParams);\n\n        // Required to satisfy compiler error if fields has no initializer or are not definitely\n        // assigned in the constructor, this also mimics ShaderMaterial set of defaults\n        // for overridden props.\n        this.fog = fogParam;\n        this.setOpacity(opacityParam);\n\n        // initialize the stencil pass\n        this.stencilFunc = THREE.NotEqualStencilFunc;\n        this.stencilZPass = THREE.ReplaceStencilOp;\n        this.stencilRef = 1;\n        this.stencilWrite = false;\n\n        enforceBlending(this);\n        this.extensions.derivatives = true;\n\n        // Apply initial parameter values.\n        if (params) {\n            if (params.color !== undefined) {\n                tmpColor.set(params.color as any);\n                this.color = tmpColor;\n            }\n            if (params.outlineColor !== undefined) {\n                tmpColor.set(params.outlineColor as any);\n                this.outlineColor = tmpColor;\n            }\n            if (params.lineWidth !== undefined) {\n                this.lineWidth = params.lineWidth;\n            }\n            if (params.outlineWidth !== undefined) {\n                this.outlineWidth = params.outlineWidth;\n            }\n            if (params.opacity !== undefined) {\n                this.setOpacity(params.opacity);\n            }\n            if (params.depthTest !== undefined) {\n                this.depthTest = params.depthTest;\n            }\n            if (params.depthWrite !== undefined) {\n                this.depthWrite = params.depthWrite;\n            }\n            if (params.fadeNear !== undefined) {\n                this.fadeNear = params.fadeNear;\n            }\n            if (params.fadeFar !== undefined) {\n                this.fadeFar = params.fadeFar;\n            }\n            if (params.displacementMap !== undefined) {\n                this.displacementMap = params.displacementMap;\n            }\n            if (params.caps !== undefined) {\n                this.caps = params.caps;\n            }\n            if (params.drawRangeStart !== undefined) {\n                this.drawRangeStart = params.drawRangeStart;\n            }\n            if (params.drawRangeEnd !== undefined) {\n                this.drawRangeEnd = params.drawRangeEnd;\n            }\n            if (params.dashes !== undefined) {\n                this.dashes = params.dashes;\n            }\n            if (params.dashColor !== undefined) {\n                tmpColor.set(params.dashColor as any);\n                this.dashColor = tmpColor;\n            }\n            if (params.dashSize !== undefined) {\n                this.dashSize = params.dashSize;\n            }\n            if (params.gapSize !== undefined) {\n                this.gapSize = params.gapSize;\n            }\n            if (params.fog !== undefined) {\n                this.fog = params.fog;\n                this.invalidateFog();\n            }\n            this.offset = params.offset ?? 0;\n        }\n    }\n\n    /**\n     * Sets the offset used to shift the line in world space perpendicular to the direction.\n     */\n    set offset(offset: number) {\n        this.uniforms.offset.value = offset;\n    }\n\n    /**\n     * @return The offset to shift the line in world space perpendicular to the direction.\n     */\n    get offset(): number {\n        return this.uniforms.offset.value as number;\n    }\n\n    /**\n     * The method to call to recompile a material to enable/disable outline effect\n     *\n     * @param enable - Whether we want to use outline.\n     */\n    set outline(enable: boolean) {\n        setShaderMaterialDefine(this, \"USE_OUTLINE\", enable);\n    }\n\n    /**\n     * Checks if outline is enabled.\n     */\n    get outline(): boolean {\n        return getShaderMaterialDefine(this, \"USE_OUTLINE\") === true;\n    }\n\n    /** @override */\n    setOpacity(opacity: number) {\n        super.setOpacity(opacity);\n        if (opacity !== undefined) {\n            this.stencilWrite = opacity < 0.98;\n        }\n    }\n\n    /**\n     * Line color.\n     */\n    get color(): THREE.Color {\n        return this.uniforms.diffuseColor.value as THREE.Color;\n    }\n\n    set color(value: THREE.Color) {\n        this.uniforms.diffuseColor.value.copy(value);\n    }\n\n    /**\n     * Outline color.\n     *\n     * @note The width of outline ([[outlineWidth]]) need to be also set to enable outlining.\n     */\n    get outlineColor(): THREE.Color {\n        return this.uniforms.outlineColor.value as THREE.Color;\n    }\n\n    set outlineColor(value: THREE.Color) {\n        this.uniforms.outlineColor.value.copy(value);\n    }\n\n    /**\n     * Dash color.\n     *\n     * @note The property [[gapSize]] need to be set to enable dashed line.\n     */\n    get dashColor(): THREE.Color {\n        return this.uniforms.dashColor.value as THREE.Color;\n    }\n\n    set dashColor(value: THREE.Color) {\n        this.uniforms.dashColor.value.copy(value);\n        setShaderMaterialDefine(this, \"USE_DASH_COLOR\", true);\n    }\n\n    /**\n     * Line width.\n     */\n    get lineWidth(): number {\n        return (this.uniforms.extrusionWidth.value as number) * 2;\n    }\n\n    set lineWidth(value: number) {\n        this.uniforms.extrusionWidth.value = value / 2;\n    }\n\n    /**\n     * Outline width.\n     */\n    get outlineWidth(): number {\n        return this.uniforms.outlineWidth.value as number;\n    }\n\n    set outlineWidth(value: number) {\n        this.uniforms.outlineWidth.value = value;\n        this.outline = value > 0.0;\n    }\n\n    /**\n     * Size of the dashed segments.\n     *\n     * @note Ths [[gapSize]] need to be also set to enable dashed line.\n     * @see gapSize.\n     */\n    get dashSize(): number {\n        return this.uniforms.dashSize.value as number;\n    }\n\n    set dashSize(value: number) {\n        this.uniforms.dashSize.value = value;\n    }\n\n    /**\n     * Size of the gaps between dashed segments.\n     *\n     * @note You may also need to set [[dashSize]].\n     * @see dashSize.\n     */\n    get gapSize(): number {\n        return this.uniforms.gapSize.value as number;\n    }\n\n    set gapSize(value: number) {\n        this.uniforms.gapSize.value = value;\n        setShaderMaterialDefine(this, \"USE_DASHED_LINE\", value > 0.0);\n\n        if (this.uniforms?.gapSize?.value === 0) {\n            this.stencilWrite = this.opacity < 0.98;\n        }\n    }\n\n    /**\n     * Caps mode.\n     */\n    get caps(): LineCaps {\n        let result: LineCaps = \"Round\";\n        const capsMode = getShaderMaterialDefine(this, \"CAPS_MODE\");\n        // Sanity check if material define is numerical and has direct mapping to LineCaps type.\n        if (typeof capsMode === \"number\" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {\n            result = DefinesLineCapsMapping[capsMode];\n        }\n        return result;\n    }\n\n    set caps(value: LineCaps) {\n        // Line caps mode may be set directly from theme, thus we need to check value\n        // for correctness and provide string to define mapping in fragment shader.\n        if (LineCapsDefinesMapping.hasOwnProperty(value)) {\n            setShaderMaterialDefine(this, \"CAPS_MODE\", LineCapsDefinesMapping[value]);\n        }\n    }\n\n    /**\n     * Dashes mode.\n     */\n    get dashes(): LineDashes {\n        let result: LineDashes = \"Square\";\n        const dashesMode = getShaderMaterialDefine(this, \"DASHES_MODE\");\n        // Sanity check if material define is numerical and has direct mapping to LineDashes type.\n        if (typeof dashesMode === \"number\" && DefinesLineDashesMapping.hasOwnProperty(dashesMode)) {\n            result = DefinesLineDashesMapping[dashesMode];\n        }\n        return result;\n    }\n\n    set dashes(value: LineDashes) {\n        // Line dashes mode may be set directly from theme, thus we need to check value\n        // for correctness and provide string to define mapping in fragment shader.\n        if (LineDashesDefinesMapping.hasOwnProperty(value)) {\n            setShaderMaterialDefine(this, \"DASHES_MODE\", LineDashesDefinesMapping[value]);\n        }\n    }\n\n    get fadeNear(): number {\n        return this.uniforms.fadeNear.value as number;\n    }\n\n    set fadeNear(value: number) {\n        this.uniforms.fadeNear.value = value;\n    }\n\n    get fadeFar(): number {\n        return this.uniforms.fadeFar.value as number;\n    }\n\n    set fadeFar(value: number) {\n        this.uniforms.fadeFar.value = value;\n        setShaderMaterialDefine(this, \"USE_FADING\", value > 0.0);\n    }\n\n    get displacementMap(): THREE.Texture | null {\n        return this.uniforms.displacementMap.value;\n    }\n\n    set displacementMap(map: THREE.Texture | null) {\n        if (this.uniforms.displacementMap.value === map) {\n            return;\n        }\n        this.uniforms.displacementMap.value = map;\n        const useDisplacementMap = map !== null;\n        if (useDisplacementMap) {\n            this.uniforms.displacementMap.value.needsUpdate = true;\n        }\n        setShaderMaterialDefine(this, \"USE_DISPLACEMENTMAP\", useDisplacementMap);\n    }\n\n    get drawRangeStart(): number {\n        return this.uniforms.drawRange.value.x as number;\n    }\n\n    set drawRangeStart(value: number) {\n        this.uniforms.drawRange.value.x = value;\n    }\n\n    get drawRangeEnd(): number {\n        return this.uniforms.drawRange.value.y as number;\n    }\n\n    set drawRangeEnd(value: number) {\n        this.uniforms.drawRange.value.y = value;\n    }\n\n    set clipTileSize(tileSize: THREE.Vector2) {\n        this.uniforms.tileSize.value.copy(tileSize);\n        const useTileClip = tileSize.x > 0 && tileSize.y > 0;\n        setShaderMaterialDefine(this, \"USE_TILE_CLIP\", useTileClip);\n    }\n\n    get clipTileSize(): THREE.Vector2 {\n        return this.uniforms.tileSize.value as THREE.Vector2;\n    }\n\n    copy(other: SolidLineMaterial): this {\n        super.copy(other);\n        this.invalidateFog();\n        this.setOpacity(other.opacity);\n        return this;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { assert } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\n/**\n * Values for boolean shader defines\n */\nexport const DEFINE_BOOL_TRUE = \"\";\nexport const DEFINE_BOOL_FALSE = undefined;\n\n/**\n * Insert shader includes after another shader include.\n *\n * @param shaderContent - Original string.\n * @param shaderName - String to append to.\n * @param insertedShaderName - String to append after string `shaderA`.\n * @param addTab - If `true`, a tab character will be inserted before `shaderB`.\n */\nexport function insertShaderInclude(\n    shaderContent: string,\n    shaderName: string,\n    insertedShaderName: string,\n    addTab?: boolean\n): string {\n    const tabChar = addTab === true ? \"\\t\" : \"\";\n\n    const result = shaderContent.replace(\n        `#include <${shaderName}>`,\n        `#include <${shaderName}>\n${tabChar}#include <${insertedShaderName}>`\n    );\n    return result;\n}\n\nexport interface ForcedBlending {\n    /**\n     * This material has `blending` always enabled regardless of `opacity` setting.s\n     */\n    forcedBlending?: true;\n}\n\n/**\n * THREE.js is enabling blending only when transparent is `true` or when a blend mode\n * different than `NormalBlending` is set.\n * Since we don't want to set transparent to true and mess up the render order we set\n * `CustomBlending` with the same parameters as the `NormalBlending`.\n\n * @param material - `Material` that should use blending\n * @note This function should not be used in frame update after material has been passed to WebGL.\n * In such cases use [[enableBlending]] instead.\n */\nexport function enforceBlending(\n    material: (THREE.Material | THREE.ShaderMaterialParameters) & ForcedBlending\n) {\n    if (material.transparent) {\n        // Nothing to do\n        return;\n    }\n\n    enableBlending(material);\n    material.forcedBlending = true;\n}\n\n/**\n * Enable alpha blending using THREE.CustomBlending setup.\n *\n * Function enables blending using one of predefined modes, for both color and alpha components:\n * - Src: [[THREE.SrcAlphaFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * - Src: [[THREE.OneFactor]], Dst: [[THREE.OneMinusSrcAlphaFactor]]\n * The second blending equation is used when [[THREE.Material.premultipliedAlpha]] is enabled\n * for this material.\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @param material - The material or material parameters to modify.\n */\nexport function enableBlending(\n    material: (THREE.Material | THREE.ShaderMaterialParameters) & ForcedBlending\n) {\n    if (material.transparent === true || material.forcedBlending === true) {\n        // Nothing to do\n        return;\n    }\n\n    material.blending = THREE.CustomBlending;\n    if (material.premultipliedAlpha === true) {\n        material.blendSrc = THREE.OneFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    } else {\n        material.blendSrc = THREE.SrcAlphaFactor;\n        material.blendDst = THREE.OneMinusSrcAlphaFactor;\n        material.blendSrcAlpha = THREE.OneFactor;\n        material.blendDstAlpha = THREE.OneMinusSrcAlphaFactor;\n    }\n}\n\n/**\n * Disable alpha blending using THREE.CustomBlending mode, switches to [[THREE.NormalBlending]].\n *\n * @note Blending mode change does not require material update.\n * @see THREE.Material.needsUpdate.\n * @see enableBlending.\n * @param material - The material or material parameters to modify.\n */\nexport function disableBlending(\n    material: (THREE.Material | THREE.ShaderMaterialParameters) & ForcedBlending\n) {\n    if (material.transparent === true || material.forcedBlending === true) {\n        // Nothing to do\n        return;\n    }\n\n    material.blending = THREE.NormalBlending;\n}\n\n/**\n * Setup material shader _define_ using two allowable semantics.\n *\n * Function accepts two types of values for shader preprocessor _define_:\n * - [[boolean]], simple [[true]] or [[false]] which causes _define_ to be set with empty string,\n * such defines may be handled in the shader using __#ifdef__ semantics:\n * ```\n * #ifdef SOME_DEFINE && !defined(OTHER_DEFINE)\n * // do something\n * #endif\n * ```\n *\n * - [[number]] which sets _define_ to explicit value. You may use it to enable/disable some\n * code or even set compile time constants affecting shaders math:\n * ```\n * #if SOME_DEFINE_SWITCH && OTHER_DEFINE_SWITCH == 0\n * gl_FragColor = vec4(1, 1, 1, DEFINE_ALPHA)\n * #endif\n * ```\n * @note Setting _define_ with `false` value is not the same as setting is with number value of `0`.\n *\n * @param material - The [[THREE.ShaderMaterial]] which shader _define_ will be set.\n * @param key - Name of shader _define_ as used in shader, i.e. `USE_FOG`, `COLOR_ALPHA`, etc.\n * @param value - The value to be set as number or boolean specifying if preprocessor define\n * should be defined or not.\n * @returns [[true]] if material has been forced to update (re-compile) due to define changes,\n * return [[false]] whenever define has not been changed.\n */\nexport function setShaderMaterialDefine(\n    material: THREE.ShaderMaterial,\n    key: string,\n    value: boolean | number\n): boolean {\n    assert(\n        material.defines !== undefined,\n        \"Do not use this function in ShaderMaterial derived c-tor.\"\n    );\n    const semanticValue = getShaderMaterialDefine(material, key);\n    const needsUpdate = value !== semanticValue;\n    // Nothing to change - early exit\n    if (!needsUpdate) {\n        return false;\n    }\n    setShaderDefine(material.defines, key, value);\n    material.needsUpdate = needsUpdate;\n    return true;\n}\n\n/**\n * Acquire value of [[THREE.ShaderMaterial]] GPU shader preprocessor define.\n *\n * The semantic used in entire engine assumes that preprocessor defines may have only binary\n * (defined / not defined) or numerical values, this ensures consistency in the shaders and\n * materials code.\n * @note If _define_ with [[key]] is _undefined_ function returns [[false]], if defined but\n * not numerical value it returns [[true]], otherwise returns number.\n * @see setShaderMaterialDefine.\n *\n * @param material - The material which shader defines are accessed.\n * @param key - The _define_ name (identifier).\n * @param fallbackValue - The value returned when material `defines` are not initialized yet,\n * specified by default as [[false]], provide your own default if you expect numeric value.\n */\nexport function getShaderMaterialDefine(\n    material: THREE.ShaderMaterial,\n    key: string,\n    fallbackValue: boolean | number = false\n): boolean | number {\n    if (material.defines === undefined) {\n        return fallbackValue;\n    }\n    return getShaderDefine(material.defines, key);\n}\n\n/**\n * Sets new value of 'define' regardless of current value set.\n *\n * Update `defines` map with new key and value, if key is already occupied it overrides its value.\n * Helper function that may be used to setup [[THREE.ShaderMaterialParameters]] before\n * material is create (i.e. in c-tor).\n *\n * @param defines - Shader `defines` stored in key-value map.\n * @param key - The key used to identify _define_.\n * @param value - The value to be stored.\n * @returns [[true]] if define has actually changed, false is stayed the same.\n * @see setShaderMaterialDefine.\n */\nexport function setShaderDefine(\n    defines: { [key: string]: any },\n    key: string,\n    value: boolean | number\n): boolean {\n    let updated = false;\n    if (typeof value === \"number\") {\n        updated = defines[key] !== value;\n        defines[key] = value;\n    } else if (value === true) {\n        updated = defines[key] !== DEFINE_BOOL_TRUE;\n        defines[key] = DEFINE_BOOL_TRUE;\n    } else if (value === false && defines[key] !== undefined) {\n        // Sets to DEFINE_BOOL_FALSE === undefined\n        delete defines[key];\n        updated = true;\n    }\n    return updated;\n}\n\n/**\n * Acquire shader 'define' value from `defines` map.\n *\n * If there is no value under [[key]] specified, function returns false, otherwise result is\n * true or numeric value if there is a number stored.\n * @param defines - The `defines` map.\n * @param key - The identifier of the _define_.\n */\nexport function getShaderDefine(defines: { [key: string]: any }, key: string): boolean | number {\n    const currentValue = defines[key];\n    const semanticValue =\n        currentValue === DEFINE_BOOL_FALSE\n            ? false\n            : currentValue === DEFINE_BOOL_TRUE\n            ? true\n            : currentValue;\n    return semanticValue;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\n/**\n * `VignetteShader`.\n */\nexport const VignetteShader: THREE.Shader = {\n    uniforms: {\n        tDiffuse: { value: null },\n        offset: { value: 1.0 },\n        darkness: { value: 1.0 }\n    },\n    vertexShader: `\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }`,\n    fragmentShader: `\n        uniform float offset;\n        uniform float darkness;\n        uniform sampler2D tDiffuse;\n        varying vec2 vUv;\n        void main() {\n            vec4 texel = texture2D( tDiffuse, vUv );\n            vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\n            gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\n        }`\n};\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { VectorTileDataSourceParameters } from \"@here/harp-vectortile-datasource\";\n\nexport {\n    APIFormat,\n    AuthenticationMethod,\n    GeoJsonDataProvider\n} from \"@here/harp-vectortile-datasource\";\n\n/**\n * HERE OMV Data source.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\n/**\n * @deprecated Use {@link @here/harp-vectortile-datasource#VectorTileDataSourceParameters}\n *             instad.\n */\nexport type OmvDataSourceParameters = VectorTileDataSourceParameters;\n\nexport * from \"./lib/OmvDataSource\";\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { VectorTileDataSource } from \"@here/harp-vectortile-datasource\";\n\n/**\n * `OmvDataSource` is used for the visualization of vector tiles\n * provided in the OMV format.\n *\n * @example\n * ```typescript\n *    const dataSource = new OmvDataSource({\n *        baseUrl: \"https://vector.hereapi.com/v2/vectortiles/base/mc\",\n *        authenticationCode: apikey\n *    });\n *    mapView.addDataSource(dataSource);\n *   ```\n */\nexport class OmvDataSource extends VectorTileDataSource {}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * SDF based text rendering for TypeScript.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/rendering/FontCatalog\";\nexport * from \"./lib/rendering/GlyphData\";\nexport * from \"./lib/rendering/TextStyle\";\nexport * from \"./lib/rendering/TextBufferObject\";\nexport * from \"./lib/TextCanvas\";\n\nexport * from \"./lib/utils/ContextualArabicConverter\";\nexport * from \"./lib/utils/MaterialUtils\";\nexport * from \"./lib/utils/TypesettingUtils\";\nexport * from \"./lib/utils/UnicodeUtils\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { FontCatalog } from \"./rendering/FontCatalog\";\nimport { GlyphData } from \"./rendering/GlyphData\";\nimport { TextBufferObject } from \"./rendering/TextBufferObject\";\nimport { QUAD_VERTEX_MEMORY_FOOTPRINT, TextGeometry } from \"./rendering/TextGeometry\";\nimport { SdfTextMaterial } from \"./rendering/TextMaterials\";\nimport { FontVariant, TextLayoutStyle, TextRenderStyle } from \"./rendering/TextStyle\";\nimport { LineTypesetter } from \"./typesetting/LineTypesetter\";\nimport { PathTypesetter, PathTypesettingParameters } from \"./typesetting/PathTypesetter\";\nimport { TypesettingParameters } from \"./typesetting/Typesetter\";\nimport { createSdfTextMaterial } from \"./utils/MaterialUtils\";\n\nconst tempTextPosition = new THREE.Vector3();\nconst tempTextBounds = {\n    array: [new THREE.Box2()],\n    offset: 0\n};\nlet tempVertexBuffer = new Float32Array();\n\ninterface TextPlacementParameters {\n    input: string | GlyphData[];\n    layer: TextCanvasLayer;\n    textPath?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n    textPathOverflow?: boolean;\n    bounds?: THREE.Box2;\n    individualBounds?: THREE.Box2[];\n    computeTextBuffer?: boolean;\n    letterCaseArray?: boolean[];\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`measureText` function call.\n */\nexport interface MeasurementParameters {\n    /**\n     * Path where text should be placed on. Overrides the original position parameter.\n     */\n    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow?: boolean;\n\n    /**\n     * Output per-character bounds.\n     */\n    outputCharacterBounds?: THREE.Box2[];\n\n    /**\n     * Array containing info on whether the glyphs are upper or lower case. Needed to support\n     * `SmallCaps`.\n     */\n    letterCaseArray?: boolean[];\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`addText` function call.\n */\nexport interface AdditionParameters {\n    /**\n     * Path where text should be placed on. Overrides the original position parameter.\n     */\n    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow?: boolean;\n\n    /**\n     * Layer where text will be added.\n     */\n    layer?: number;\n\n    /**\n     * If `true`, the input position parameter will be updated to contain the position of the last\n     * glyph added.\n     */\n    updatePosition?: boolean;\n\n    /**\n     * Object containing additional data intended to be retrieved during picking.\n     */\n    pickingData?: any;\n\n    /**\n     * Array containing info on whether the glyphs are upper or lower case. Needed to support\n     * `SmallCaps`.\n     */\n    letterCaseArray?: boolean[];\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`createTextBufferObject` function call.\n */\nexport interface TextBufferCreationParameters {\n    /**\n     * Path where text should be placed on. Overrides the original position parameter.\n     */\n    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow?: boolean;\n\n    /**\n     * Output text bounding-box.\n     */\n    outputBounds?: boolean;\n\n    /**\n     * Output per-character bounds.\n     */\n    outputCharacterBounds?: boolean;\n\n    /**\n     * Array containing info on whether the glyphs are upper or lower case. Needed to support\n     * `SmallCaps`.\n     */\n    letterCaseArray?: boolean[];\n\n    /**\n     * If `true`, both the [[TextRenderStyle]] and [[TextLayoutStyle]] used to generate the\n     * [[TextBufferObject]] will be stored in it.\n     */\n    storeStyles?: boolean;\n}\n\n/**\n * Optional parameters passed on [[TextCanvas]].`addTextBufferObject` function call.\n */\nexport interface TextBufferAdditionParameters {\n    layer?: number;\n    position?: THREE.Vector3;\n    scale?: number;\n    rotation?: number;\n    color?: THREE.Color;\n    opacity?: number;\n    backgroundColor?: THREE.Color;\n    backgroundOpacity?: number;\n    pickingData?: any;\n}\n\n/**\n * Default's [[TextCanvas]] layer identifier.\n */\nexport const DEFAULT_TEXT_CANVAS_LAYER = 0;\n\n/**\n * [[TextCanvas]] rendering layer.\n */\nexport interface TextCanvasLayer {\n    id: number;\n    storage: TextGeometry;\n}\n\n/**\n * [[TextCanvas]] construction parameters.\n */\nexport interface TextCanvasParameters {\n    /**\n     * WebGLRenderer internally used by this `TextCanvas`.\n     */\n    renderer: THREE.WebGLRenderer;\n\n    /**\n     * Initial [[FontCatalog]].\n     */\n    fontCatalog: FontCatalog;\n\n    /**\n     * Minimum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    minGlyphCount: number;\n\n    /**\n     * Maximum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    maxGlyphCount: number;\n\n    /**\n     * Material used to render text.\n     */\n    material?: THREE.Material;\n\n    /**\n     * Material used to render text background.\n     */\n    backgroundMaterial?: THREE.Material;\n\n    /**\n     * Optional Canvas Name\n     */\n    name?: string;\n}\n\n/**\n * Describes estimated usage of memory on heap and GPU.\n */\nexport interface MemoryUsage {\n    heapSize: number;\n    gpuSize: number;\n}\n\n/**\n * three.js text rendering engine which can manage and render high-quality, transformable, stylable\n * and properly layout SDF and MSDF text.\n */\nexport class TextCanvas {\n    private static readonly defaultTextRenderStyle: TextRenderStyle = new TextRenderStyle();\n    private static readonly defaultTextLayoutStyle: TextLayoutStyle = new TextLayoutStyle();\n    /**\n     * Minimum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    readonly minGlyphCount: number;\n\n    /**\n     * Maximum amount of glyphs each [[TextCanvas]] layer can store.\n     */\n    readonly maxGlyphCount: number;\n\n    readonly name?: string;\n\n    private readonly m_renderer: THREE.WebGLRenderer;\n    private m_fontCatalog: FontCatalog;\n\n    private readonly m_currentTextRenderStyle: TextRenderStyle;\n    private readonly m_currentTextLayoutStyle: TextLayoutStyle;\n\n    private m_material: SdfTextMaterial | THREE.Material;\n    private m_bgMaterial: SdfTextMaterial | THREE.Material;\n    private m_ownsMaterial: boolean;\n    private m_ownsBgMaterial: boolean;\n\n    private readonly m_defaultLayer: TextCanvasLayer;\n    private readonly m_layers: TextCanvasLayer[];\n\n    private readonly m_lineTypesetter: LineTypesetter;\n    private readonly m_pathTypesetter: PathTypesetter;\n\n    /**\n     * Constructs a new `TextCanvas`.\n     *\n     * @param params - `TextCanvas` construction parameters.\n     *\n     * @returns New `TextCanvas`.\n     */\n    constructor(params: TextCanvasParameters) {\n        this.m_renderer = params.renderer;\n        this.m_fontCatalog = params.fontCatalog;\n        this.minGlyphCount = params.minGlyphCount;\n        this.maxGlyphCount = params.maxGlyphCount;\n        this.name = params.name;\n\n        if (params.material === undefined) {\n            this.m_ownsMaterial = true;\n            this.m_material = createSdfTextMaterial({\n                fontCatalog: params.fontCatalog,\n                rendererCapabilities: this.m_renderer.capabilities\n            });\n        } else {\n            this.m_ownsMaterial = false;\n            this.m_material = params.material;\n        }\n        if (params.backgroundMaterial === undefined) {\n            this.m_ownsBgMaterial = true;\n            this.m_bgMaterial = createSdfTextMaterial({\n                fontCatalog: params.fontCatalog,\n                isBackground: true,\n                rendererCapabilities: this.m_renderer.capabilities\n            });\n        } else {\n            this.m_ownsBgMaterial = false;\n            this.m_bgMaterial = params.backgroundMaterial;\n        }\n\n        this.m_defaultLayer = {\n            id: DEFAULT_TEXT_CANVAS_LAYER,\n            storage: new TextGeometry(\n                new THREE.Scene(),\n                this.m_material,\n                this.m_bgMaterial,\n                this.minGlyphCount,\n                this.maxGlyphCount\n            )\n        };\n        this.m_layers = [this.m_defaultLayer];\n\n        this.m_currentTextRenderStyle = new TextRenderStyle().copy(\n            TextCanvas.defaultTextRenderStyle\n        );\n        this.m_currentTextLayoutStyle = new TextLayoutStyle().copy(\n            TextCanvas.defaultTextLayoutStyle\n        );\n\n        this.m_lineTypesetter = new LineTypesetter();\n        this.m_pathTypesetter = new PathTypesetter();\n    }\n\n    /**\n     * Currently active [[FontCatalog]].\n     */\n    get fontCatalog(): FontCatalog {\n        return this.m_fontCatalog;\n    }\n\n    set fontCatalog(value: FontCatalog) {\n        this.m_fontCatalog = value;\n\n        const material = this.m_material as THREE.RawShaderMaterial;\n        material.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        material.uniforms.sdfParams.value = new THREE.Vector4(\n            this.m_fontCatalog.textureSize.x,\n            this.m_fontCatalog.textureSize.y,\n            this.m_fontCatalog.size,\n            this.m_fontCatalog.distanceRange\n        );\n        material.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n\n        const bgMaterial = this.m_bgMaterial as THREE.RawShaderMaterial;\n        bgMaterial.uniforms.sdfTexture.value = this.m_fontCatalog.texture;\n        bgMaterial.uniforms.sdfParams.value = new THREE.Vector4(\n            this.m_fontCatalog.textureSize.x,\n            this.m_fontCatalog.textureSize.y,\n            this.m_fontCatalog.size,\n            this.m_fontCatalog.distanceRange\n        );\n        bgMaterial.defines.MSDF = this.m_fontCatalog.type === \"msdf\" ? 1.0 : 0.0;\n    }\n\n    /**\n     * Currently active text rendering material.\n     */\n    get material(): THREE.Material {\n        return this.m_material;\n    }\n\n    set material(value: THREE.Material) {\n        if (this.m_ownsMaterial) {\n            this.m_material.dispose();\n            this.m_ownsMaterial = false;\n        }\n\n        this.m_material = value;\n        for (const layer of this.m_layers) {\n            layer.storage.mesh.material = this.m_material;\n        }\n    }\n\n    /**\n     * Currently active text background rendering material.\n     */\n    get backgroundMaterial(): THREE.Material {\n        return this.m_bgMaterial;\n    }\n\n    set backgroundMaterial(value: THREE.Material) {\n        if (this.m_ownsBgMaterial) {\n            this.m_bgMaterial.dispose();\n            this.m_ownsBgMaterial = false;\n        }\n\n        this.m_bgMaterial = value;\n        for (const layer of this.m_layers) {\n            layer.storage.backgroundMesh.material = this.m_bgMaterial;\n        }\n    }\n\n    /**\n     * Currently active text rendering style.\n     */\n    get textRenderStyle(): TextRenderStyle {\n        return this.m_currentTextRenderStyle;\n    }\n\n    set textRenderStyle(style: TextRenderStyle) {\n        this.m_currentTextRenderStyle.copy(style);\n    }\n\n    /**\n     * Currently active text layout style.\n     */\n    get textLayoutStyle(): TextLayoutStyle {\n        return this.m_currentTextLayoutStyle;\n    }\n\n    set textLayoutStyle(style: TextLayoutStyle) {\n        this.m_currentTextLayoutStyle.copy(style);\n    }\n\n    /**\n     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).\n     */\n    clear() {\n        for (const layer of this.m_layers) {\n            layer.storage.clear();\n        }\n        this.m_currentTextRenderStyle.copy(TextCanvas.defaultTextRenderStyle);\n        this.m_currentTextLayoutStyle.copy(TextCanvas.defaultTextLayoutStyle);\n    }\n\n    /**\n     * Renders the content of this `TextCanvas`.\n     *\n     * @param camera - Orthographic camera.\n     * @param lowerLayerId - Optional Id the first layer to be rendered has to be equal or above\n     * @param higherLayerId - Optional Id the last layer to be rendered has to be below\n     * @param target - Optional render target.\n     * @param clear - Optional render target clear operation.\n     */\n    render(\n        camera: THREE.OrthographicCamera,\n        lowerLayerId?: number,\n        higherLayerId?: number,\n        target?: THREE.WebGLRenderTarget,\n        clear?: boolean\n    ) {\n        this.m_fontCatalog.update(this.m_renderer);\n        let oldTarget: THREE.RenderTarget | null = null;\n        if (target !== undefined) {\n            oldTarget = this.m_renderer.getRenderTarget();\n            this.m_renderer.setRenderTarget(target);\n        }\n        if (clear === true) {\n            this.m_renderer.clear(true);\n        }\n        for (let i = 0; i < this.m_layers.length; i++) {\n            const layer = this.m_layers[i];\n            if (layer.id >= (lowerLayerId ?? 0)) {\n                if (higherLayerId === undefined || layer.id < higherLayerId) {\n                    layer.storage.update();\n                    this.m_renderer.render(layer.storage.scene, camera);\n                } else {\n                    break;\n                }\n            }\n        }\n        if (target !== undefined) {\n            this.m_renderer.setRenderTarget(oldTarget);\n        }\n    }\n\n    /**\n     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the\n     * input `layerId`, it just returns this one instead.\n     *\n     * @param layerId - Desired layer identifier.\n     *\n     * @returns Created [[TextCanvasLayer]].\n     */\n    addLayer(layerId: number): TextCanvasLayer {\n        let result = this.getLayer(layerId);\n        if (result === undefined) {\n            result = {\n                id: layerId,\n                storage: new TextGeometry(\n                    new THREE.Scene(),\n                    this.m_material,\n                    this.m_bgMaterial,\n                    this.minGlyphCount,\n                    this.maxGlyphCount\n                )\n            };\n\n            this.m_layers.push(result);\n            this.m_layers.sort((a: TextCanvasLayer, b: TextCanvasLayer) => {\n                return a.id - b.id;\n            });\n        }\n        return result;\n    }\n\n    /**\n     * Retrieves a specific `TextCanvas` rendering layer.\n     *\n     * @param layerId - Desired layer identifier.\n     *\n     * @returns Selected [[TextCanvasLayer]].\n     */\n    getLayer(layerId: number): TextCanvasLayer | undefined {\n        return this.m_layers.find(layer => layer.id === layerId);\n    }\n\n    /**\n     * Retrieves all `TextCanvas` rendering layers.\n     *\n     * @returns Array of [[TextCanvasLayer]]s.\n     */\n    getAllLayers(): TextCanvasLayer[] {\n        return this.m_layers;\n    }\n\n    /**\n     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and\n     * [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param outputBounds - Output text bounding box.\n     * @param params - Optional measurement parameters.\n     *\n     * @returns Result of the measurement. If `false`, some error occurred during execution and the\n     * input text couldn't be properly measured.\n     */\n    measureText(\n        text: string | GlyphData[],\n        outputBounds: THREE.Box2,\n        params?: MeasurementParameters\n    ): boolean {\n        tempTextPosition.set(0, 0, 0);\n\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let outputCharacterBounds;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            outputCharacterBounds = params.outputCharacterBounds;\n            if (params.path !== undefined) {\n                const pathOrigin = params.path.getPoint(0);\n                if (pathOrigin === null) {\n                    return false;\n                }\n                tempTextPosition.set(pathOrigin.x, pathOrigin.y, 0.0);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n\n        return this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: outputBounds,\n            individualBounds: outputCharacterBounds,\n            letterCaseArray: upperCaseArray\n        });\n    }\n\n    /**\n     * Adds the input text to this `TextCanvas` in the specified screen position. The current\n     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.\n     *\n     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param position - Screen position.\n     * @param params - Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addText(\n        text: string | GlyphData[],\n        position: THREE.Vector3,\n        params?: AdditionParameters\n    ): boolean {\n        tempTextPosition.copy(position);\n\n        let path;\n        let pathOverflow;\n        let upperCaseArray;\n        let targetLayer = this.m_defaultLayer;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            if (params.path !== undefined) {\n                tempTextPosition.set(0, 0, tempTextPosition.z);\n            }\n            if (params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n\n        const result = this.placeText({\n            input: text,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            layer: targetLayer,\n            letterCaseArray: upperCaseArray\n        });\n        if (result && params !== undefined) {\n            if (params.updatePosition === true) {\n                position.copy(tempTextPosition);\n            }\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(\n                    prevDrawCount,\n                    targetLayer.storage.drawCount,\n                    params.pickingData\n                );\n            }\n        } else if (!result) {\n            (targetLayer.storage as any).m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the\n     * result of performing the `addText` function for the input text in the screen origin.\n     *\n     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.\n     * @param params - Optional creation parameters.\n     *\n     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be\n     * retrieved from the current [[FontCatalog]]).\n     */\n    createTextBufferObject(\n        text: string | GlyphData[],\n        params?: TextBufferCreationParameters\n    ): TextBufferObject | undefined {\n        tempTextPosition.set(0, 0, 0);\n\n        let glyphArray;\n        let upperCaseArray: boolean[] | undefined;\n        const smallCapsEnabled =\n            this.m_currentTextRenderStyle.fontVariant === FontVariant.SmallCaps;\n        if (typeof text !== \"string\") {\n            glyphArray = text;\n            if (params !== undefined && params.letterCaseArray) {\n                upperCaseArray = params.letterCaseArray;\n            }\n        } else {\n            upperCaseArray = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(\n                text,\n                this.m_currentTextRenderStyle,\n                smallCapsEnabled ? upperCaseArray : undefined\n            );\n            if (glyphArray === undefined) {\n                return undefined;\n            }\n        }\n\n        let path;\n        let pathOverflow;\n        let textBounds;\n        let characterBounds;\n        let renderStyle;\n        let layoutStyle;\n        if (params !== undefined) {\n            path = params.path;\n            pathOverflow = params.pathOverflow;\n            if (params.outputBounds === true) {\n                textBounds = new THREE.Box2();\n            }\n            if (params.outputCharacterBounds === true) {\n                characterBounds = [];\n            }\n            if (params.storeStyles === true) {\n                renderStyle = this.m_currentTextRenderStyle.clone();\n                layoutStyle = this.m_currentTextLayoutStyle.clone();\n            }\n        }\n\n        this.placeText({\n            input: text,\n            layer: this.m_defaultLayer,\n            computeTextBuffer: true,\n            textPath: path,\n            textPathOverflow: pathOverflow,\n            bounds: textBounds,\n            individualBounds: characterBounds,\n            letterCaseArray: upperCaseArray\n        });\n\n        return new TextBufferObject(\n            glyphArray,\n            new Float32Array(tempVertexBuffer),\n            textBounds,\n            characterBounds,\n            renderStyle,\n            layoutStyle\n        );\n    }\n\n    /**\n     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can\n     * be provided to override the attributes stored in the buffer.\n     *\n     * @param textBufferObject - [[TextBufferObject]] to add.\n     * @param params - Optional addition parameters.\n     *\n     * @returns Result of the addition. If `false`, some error occurred during execution and the\n     * input text couldn't be properly added.\n     */\n    addTextBufferObject(\n        textBufferObject: TextBufferObject,\n        params?: TextBufferAdditionParameters\n    ): boolean {\n        let targetLayer = this.m_defaultLayer;\n        let position;\n        let scale;\n        let rotation;\n        let color;\n        let opacity;\n        let bgColor;\n        let bgOpacity;\n\n        if (params !== undefined) {\n            if (params.layer !== undefined) {\n                let tempLayer = this.getLayer(params.layer);\n                if (tempLayer === undefined) {\n                    tempLayer = this.addLayer(params.layer);\n                }\n                targetLayer = tempLayer;\n            }\n            position = params.position?.clone();\n            scale = params.scale;\n            rotation = params.rotation;\n            color = params.color;\n            opacity = params.opacity;\n            bgColor = params.backgroundColor;\n            bgOpacity = params.backgroundOpacity;\n        }\n        const prevDrawCount = targetLayer.storage.drawCount;\n\n        const result = targetLayer.storage.addTextBufferObject(\n            textBufferObject,\n            position,\n            scale,\n            rotation,\n            color,\n            opacity,\n            bgColor,\n            bgOpacity\n        );\n        if (result && params !== undefined) {\n            if (params.pickingData !== undefined) {\n                targetLayer.storage.addPickingData(\n                    prevDrawCount,\n                    targetLayer.storage.drawCount,\n                    params.pickingData\n                );\n            }\n        } else if (!result) {\n            (targetLayer.storage as any).m_drawCount = prevDrawCount;\n        }\n        return result;\n    }\n\n    /**\n     * Executes the `pickCallback` for all previously stored picking data for text covering the\n     * specified screen position.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pickText(position: THREE.Vector2, callback: (pickData: any | undefined) => void): void {\n        for (const layer of this.m_layers) {\n            layer.storage.pick(position, callback);\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.\n     *\n     * @param info - The info object to increment with the values from this `TextCanvas`.\n     */\n    getMemoryUsage(info: MemoryUsage) {\n        this.m_fontCatalog.updateMemoryUsage(info);\n\n        for (const layer of this.m_layers) {\n            layer.storage.updateMemoryUsage(info);\n        }\n    }\n\n    // Places all glyphs for input text. Depending on parameters, it can store the resulting glyphs\n    // in the current [[TextGeometry]] (or into a separate buffer) or compute the bounding box for\n    // the input (as a whole or on a per-character basis).\n    private placeText(params: TextPlacementParameters): boolean {\n        if (params.input.length === 0 || this.m_currentTextLayoutStyle.maxLines! === 0) {\n            if (params.bounds !== undefined) {\n                params.bounds.min.set(0, 0);\n                params.bounds.max.set(0, 0);\n            }\n            if (params.individualBounds !== undefined) {\n                params.individualBounds.length = 0;\n            }\n            return true;\n        }\n\n        let glyphArray;\n        let smallCapsTransformations: boolean[] | undefined;\n        const smallCapsEnabled =\n            this.m_currentTextRenderStyle.fontVariant === FontVariant.SmallCaps;\n        if (typeof params.input !== \"string\") {\n            glyphArray = params.input;\n            if (params.letterCaseArray) {\n                smallCapsTransformations = params.letterCaseArray;\n            }\n        } else {\n            smallCapsTransformations = [];\n            glyphArray = this.m_fontCatalog.getGlyphs(\n                params.input,\n                this.m_currentTextRenderStyle,\n                smallCapsEnabled ? smallCapsTransformations : undefined\n            );\n            if (glyphArray === undefined) {\n                return false;\n            }\n        }\n\n        let glyphBounds;\n        if (params.individualBounds !== undefined) {\n            tempTextBounds.array = params.individualBounds;\n            tempTextBounds.offset = 0;\n            glyphBounds = tempTextBounds;\n        }\n        if (params.bounds !== undefined) {\n            params.bounds.min.set(Infinity, Infinity);\n            params.bounds.max.set(-Infinity, -Infinity);\n        }\n        if (params.computeTextBuffer === true) {\n            tempVertexBuffer = new Float32Array(glyphArray.length * QUAD_VERTEX_MEMORY_FOOTPRINT);\n        }\n\n        const isPath = params.textPath !== undefined;\n        const typesettingParams: TypesettingParameters | PathTypesettingParameters = {\n            glyphs: glyphArray,\n            fontCatalog: this.m_fontCatalog,\n            textRenderStyle: this.m_currentTextRenderStyle,\n            textLayoutStyle: this.m_currentTextLayoutStyle,\n            position: tempTextPosition,\n            geometry: params.layer.storage,\n            smallCapsArray: smallCapsEnabled ? smallCapsTransformations : undefined,\n            globalBounds: params.bounds,\n            individualBounds: glyphBounds,\n            vertexBuffer: params.computeTextBuffer === true ? tempVertexBuffer : undefined\n        };\n\n        let result = true;\n        if (isPath) {\n            Object.assign(typesettingParams as PathTypesettingParameters, {\n                path: params.textPath,\n                pathOverflow: params.textPathOverflow === true\n            });\n            result = this.m_pathTypesetter.arrangeGlyphs(\n                typesettingParams as PathTypesettingParameters\n            );\n        } else {\n            result = this.m_lineTypesetter.arrangeGlyphs(typesettingParams);\n        }\n        if (glyphBounds !== undefined) {\n            glyphBounds.array.length = glyphBounds.offset;\n        }\n\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { MemoryUsage } from \"../TextCanvas\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { GlyphData } from \"./GlyphData\";\nimport { GlyphTextureCache } from \"./GlyphTextureCache\";\nimport { FontStyle, FontVariant, TextRenderStyle } from \"./TextStyle\";\n\nconst ASSETS_PATH = \"_Assets/\";\nconst BOLD_ASSETS_PATH = \"_BoldAssets/\";\nconst ITALIC_ASSETS_PATH = \"_ItalicAssets/\";\nconst BOLD_ITALIC_ASSETS_PATH = \"_BoldItalicAssets/\";\nconst REPLACEMENT_PATH = \"_Assets/Extra/\";\n\ninterface SrcGlyphData {\n    id: number;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    xoffset: number;\n    yoffset: number;\n    xadvance: number;\n    page: number;\n    chnl: number;\n}\n\n/**\n * Metrics defining the placement and rendering of all glyphs in a given [[Font]].\n */\nexport interface FontMetrics {\n    size: number;\n    distanceRange: number;\n    base: number;\n    lineHeight: number;\n    lineGap: number;\n    capHeight: number;\n    xHeight: number;\n}\n\n/**\n * Description of all assets, charset and metrics that define a font inside a [[FontCatalog]].\n */\nexport interface Font {\n    name: string;\n    metrics: FontMetrics;\n    charset: string;\n    bold?: string;\n    italic?: string;\n    boldItalic?: string;\n}\n\n/**\n * Description of a continuous range of Unicode code points (as well as information on which fonts\n * supports it).\n */\nexport interface UnicodeBlock {\n    name: string;\n    min: number;\n    max: number;\n    fonts: string[];\n}\n\n/**\n * Collection of font assets used to render glyphs when using a [[TextCanvas]].\n *\n * @summary A `FontCatalog` works as a stack of SDF bitmap fonts (using the BMFont format) designed\n * to cover the widest Unicode code point range possible. In order to manage all these assets\n * elegantly, the assets inside the `FontCatalog` are stored on a per-Unicode-Block basis, and\n * assets for a block are only loaded once a glyph belonging to that block is requested.\n *\n * Bitmap information coming from all different fonts is then stored in a unified WebGL GPU Texture\n * resource, which can be sampled to render all currently loaded glyphs.\n *\n */\nexport class FontCatalog {\n    /**\n     * Loads a `FontCatalog`.\n     *\n     * @param url - Asset url.\n     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     *\n     * @returns `FontCatalog` Promise.\n     */\n    static async load(path: string, maxCodePointCount: number): Promise<FontCatalog> {\n        const url = new URL(path, window.location.href);\n        const fontCatalog = await FontCatalog.loadJSON(url.href);\n\n        const replacementDirUrl = new URL(`${fontCatalog.name}${REPLACEMENT_PATH}`, url);\n        const replacementJson = await FontCatalog.loadJSON(\n            replacementDirUrl.href + \"Specials.json\"\n        );\n        const replacementTexture = await FontCatalog.loadTexture(\n            replacementDirUrl.href + \"Specials.png\"\n        );\n        replacementTexture.wrapS = THREE.ClampToEdgeWrapping;\n        replacementTexture.wrapT = THREE.ClampToEdgeWrapping;\n        replacementTexture.minFilter = THREE.NearestFilter;\n        replacementTexture.needsUpdate = true;\n\n        const replacementFont = fontCatalog.fonts.find((font: Font) => font.name === \"Extra\");\n        const replacementGlyph = new GlyphData(\n            65533,\n            \"Specials\",\n            replacementJson.chars[0].width,\n            replacementJson.chars[0].height,\n            replacementJson.chars[0].xadvance,\n            replacementJson.chars[0].xoffset,\n            replacementJson.chars[0].yoffset,\n            0.0,\n            0.0,\n            1.0,\n            1.0,\n            replacementTexture,\n            replacementFont!,\n            true\n        );\n\n        const fontCatalogInfo = new FontCatalog(\n            url.href.substr(0, url.href.lastIndexOf(\"/\")),\n            fontCatalog.name,\n            fontCatalog.type,\n            fontCatalog.size,\n            fontCatalog.maxWidth,\n            fontCatalog.maxHeight,\n            fontCatalog.distanceRange,\n            fontCatalog.fonts,\n            fontCatalog.supportedBlocks,\n            maxCodePointCount,\n            replacementGlyph\n        );\n        return fontCatalogInfo;\n    }\n\n    static async loadTexture(url: string): Promise<THREE.Texture> {\n        return await new Promise(resolve => {\n            new THREE.TextureLoader().load(url, resolve);\n        });\n    }\n\n    static async loadJSON(url: string): Promise<any> {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(`${url} Status Text:  ${response.statusText}`);\n        }\n        const rawJSON = await response.text();\n        return JSON.parse(rawJSON);\n    }\n\n    private readonly m_glyphTextureCache: GlyphTextureCache;\n\n    private readonly m_loadingJson: Map<string, Promise<any>>;\n    private readonly m_loadingPages: Map<string, Promise<THREE.Texture>>;\n    private readonly m_loadingGlyphs: Map<string, Promise<GlyphData>>;\n    private readonly m_loadedJson: Map<string, any>;\n    private readonly m_loadedPages: Map<string, THREE.Texture>;\n    private readonly m_loadedGlyphs: Map<string, Map<number, GlyphData>>;\n\n    /** If `true`, a replacement glyph is returned for every missing glyph. */\n    public showReplacementGlyphs = false;\n\n    /**\n     * @hidden\n     * Creates a new FontCatalog.\n     *\n     * @param url - FontCatalog's URL.\n     * @param name - FontCatalog's name.\n     * @param type - FontCatalog's type (sdf or msdf).\n     * @param size - FontCatalog's glyph size (pixels).\n     * @param maxWidth - FontCatalog's maximum glyph width (pixels).\n     * @param maxHeight - FontCatalog's maximum glyph height (pixels).\n     * @param distanceRange - Distance range used to generate the SDF bitmaps.\n     * @param fonts - Array of supported fonts.\n     * @param unicodeBlocks - Array of supported Unicode blocks.\n     * @param maxCodePointCount - Maximum number of unique code points bitmaps this `FontCatalog`'s\n     * internal texture can store simultaneously.\n     * @param m_replacementGlyph - [[GlyphData]] to be used whenever a Unicode code point is not\n     * supported by this `FontCatalog`.\n     *\n     * @returns New FontCatalog.\n     */\n    private constructor(\n        readonly url: string,\n        readonly name: string,\n        readonly type: string,\n        readonly size: number,\n        readonly maxWidth: number,\n        readonly maxHeight: number,\n        readonly distanceRange: number,\n        readonly fonts: Font[],\n        readonly unicodeBlocks: UnicodeBlock[],\n        readonly maxCodePointCount: number,\n        private readonly m_replacementGlyph: GlyphData\n    ) {\n        this.m_glyphTextureCache = new GlyphTextureCache(\n            maxCodePointCount,\n            this.maxWidth + 1,\n            this.maxHeight + 1\n        );\n\n        this.m_loadingJson = new Map<string, Promise<any>>();\n        this.m_loadingPages = new Map<string, Promise<THREE.Texture>>();\n        this.m_loadingGlyphs = new Map<string, Promise<GlyphData>>();\n        this.m_loadedJson = new Map<string, any>();\n        this.m_loadedPages = new Map<string, THREE.Texture>();\n        this.m_loadedGlyphs = new Map<string, Map<number, GlyphData>>();\n    }\n\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.fonts.length = 0;\n        this.unicodeBlocks.length = 0;\n        this.m_glyphTextureCache.dispose();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n\n    /**\n     * Removes all loaded (and loading) assets.\n     */\n    clear() {\n        this.m_glyphTextureCache.clear();\n        this.m_loadingJson.clear();\n        this.m_loadingPages.clear();\n        this.m_loadingGlyphs.clear();\n        this.m_loadedJson.clear();\n        this.m_loadedPages.clear();\n        this.m_loadedGlyphs.clear();\n    }\n\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer - WebGLRenderer.\n     */\n    update(renderer: THREE.WebGLRenderer): void {\n        this.m_glyphTextureCache.update(renderer);\n    }\n\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture(): THREE.Texture {\n        return this.m_glyphTextureCache.texture;\n    }\n\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize(): THREE.Vector2 {\n        return this.m_glyphTextureCache.textureSize;\n    }\n\n    /**\n     * Current internal loading state.\n     */\n    get isLoading(): boolean {\n        return (\n            this.m_loadingJson.size > 0 ||\n            this.m_loadingPages.size > 0 ||\n            this.m_loadingGlyphs.size > 0\n        );\n    }\n\n    /**\n     * Loads the description file for a specific [[UnicodeBlock]]. This speeds up consequent calls\n     * to `FontCatalog`.loadCharset() that require glyphs from this block to be loaded.\n     *\n     * @param block - Requested [[UnicodeBlock]].\n     * @param font - [[Font]] to retrieve this Unicode block from.\n     * @param fontStyle - [[FontStyle]] assets to load.\n     * @param loadPages - If `true`, all pages in this Unicode block will also be loaded.\n     *\n     * @returns Loaded Unicode Block json.\n     */\n    async loadBlock(\n        block: UnicodeBlock,\n        font: Font,\n        fontStyle: FontStyle,\n        loadPages?: boolean\n    ): Promise<any> {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        let json = this.m_loadedJson.get(jsonPath);\n        if (json === undefined) {\n            let jsonPromise = this.m_loadingJson.get(jsonPath);\n            if (jsonPromise === undefined) {\n                try {\n                    jsonPromise = FontCatalog.loadJSON(jsonPath);\n                    this.m_loadingJson.set(jsonPath, jsonPromise);\n                    json = await jsonPromise;\n                    this.m_loadingJson.delete(jsonPath);\n                    this.m_loadedJson.set(jsonPath, json);\n                } catch (e) {\n                    // eslint-disable-next-line no-console\n                    console.error(e);\n                    this.m_loadingJson.delete(jsonPath);\n                }\n            } else {\n                json = await jsonPromise;\n            }\n        }\n\n        const pagePromises: Array<Promise<THREE.Texture>> = [];\n        if (loadPages === true) {\n            for (const page of json.pages) {\n                pagePromises.push(this.loadPage(`${assetsPath}/${page}`));\n            }\n        }\n        await Promise.all(pagePromises);\n\n        return json;\n    }\n\n    /**\n     * Releases the description file for a specific [[UnicodeBlock]] (and all downloaded pages).\n     * Safe to call when no assets for this block have been loaded.\n     *\n     * @param block - Requested [[UnicodeBlock]].\n     * @param font - [[Font]] to remove this Unicode block from.\n     * @param fontStyle - [[FontStyle]] assets to remove.\n     */\n    removeBlock(block: UnicodeBlock, font: Font, fontStyle: FontStyle): void {\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const jsonPath = `${assetsPath}/${block.name.replace(/ /g, \"_\")}.json`;\n        const json = this.m_loadedJson.get(jsonPath);\n        if (json !== undefined) {\n            for (const page of json.pages) {\n                const pagePath = `${assetsPath}/${page}`;\n                this.m_loadingPages.delete(pagePath);\n                this.m_loadedPages.delete(pagePath);\n            }\n            this.m_loadingJson.delete(jsonPath);\n            this.m_loadedJson.delete(jsonPath);\n        }\n    }\n\n    /**\n     * Loads all the required glyphs needed to render the input text. Character repetition will not\n     * be considered, and only styled assets (with applied font selection, style and variants) will\n     * be loaded.\n     *\n     * @param input - Input text.\n     * @param style - Specific [[TextRenderStyle]] for which glyphs will be loaded.\n     *\n     * @returns Promise containing an array of all loaded [[GlyphData]] for the input text.\n     */\n    async loadCharset(input: string, style: TextRenderStyle): Promise<GlyphData[]> {\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const shouldTransform =\n            style.fontVariant === FontVariant.AllCaps ||\n            style.fontVariant === FontVariant.SmallCaps;\n\n        const charset = (shouldTransform ? input.toUpperCase() : input).replace(\n            /[\\s\\S](?=([\\s\\S]+))/g,\n            (c, s) => {\n                return s.indexOf(c) + 1 ? \"\" : c;\n            }\n        );\n        const glyphPromises: Array<Promise<GlyphData>> = [];\n        for (const char of charset) {\n            const codePoint = char.codePointAt(0)!;\n            const font = this.getFont(codePoint, fontName);\n            const fontHash = `${font.name}_${fontStyle}`;\n            const glyphHash = `${fontHash}_${codePoint}`;\n\n            let fontGlyphMap = this.m_loadedGlyphs.get(fontHash);\n            if (fontGlyphMap === undefined) {\n                fontGlyphMap = new Map();\n                this.m_loadedGlyphs.set(fontHash, fontGlyphMap);\n            }\n\n            const glyph = fontGlyphMap.get(codePoint);\n            if (glyph === undefined) {\n                let glyphPromise = this.m_loadingGlyphs.get(glyphHash);\n                if (glyphPromise === undefined) {\n                    if (!font.charset.includes(String.fromCodePoint(codePoint))) {\n                        const replacementGlyph = this.createReplacementGlyph(codePoint, char, font);\n                        fontGlyphMap!.set(codePoint, replacementGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, replacementGlyph);\n                        continue;\n                    }\n\n                    let charUnicodeBlock: UnicodeBlock | undefined;\n                    for (const block of this.unicodeBlocks) {\n                        if (codePoint >= block.min && codePoint <= block.max) {\n                            charUnicodeBlock = block;\n                            break;\n                        }\n                    }\n\n                    glyphPromise = this.loadAssets(codePoint, fontStyle, charUnicodeBlock!, font);\n                    this.m_loadingGlyphs.set(glyphHash, glyphPromise);\n                    glyphPromise.then((loadedGlyph: GlyphData) => {\n                        this.m_loadingGlyphs.delete(glyphHash);\n                        fontGlyphMap!.set(codePoint, loadedGlyph);\n                        this.m_glyphTextureCache.add(glyphHash, loadedGlyph);\n                    });\n                }\n                glyphPromises.push(glyphPromise);\n            } else if (!this.m_glyphTextureCache.has(glyphHash)) {\n                glyphPromises.push(Promise.resolve(glyph));\n                this.m_glyphTextureCache.add(glyphHash, glyph);\n            }\n        }\n\n        return Promise.all(glyphPromises);\n    }\n\n    /**\n     * Retrieves the loaded [[GlyphData]] for a specific character.\n     * Returns `undefined` if the assets for this glyph haven't been loaded yet.\n     *\n     * @param codePoint - Character's Unicode code point.\n     * @param font - [[Font]] to get this glyph from.\n     * @param fontStyle - Specific [[FontStyle]] to get glyphs for.\n     *\n     * @returns [[GlyphData]] for this code point.\n     */\n    getGlyph(codePoint: number, font: Font, fontStyle: FontStyle): GlyphData | undefined {\n        const fontGlyphMap = this.m_loadedGlyphs.get(`${font.name}_${fontStyle}`);\n        if (fontGlyphMap === undefined) {\n            return undefined;\n        }\n        return fontGlyphMap.get(codePoint);\n    }\n\n    /**\n     * Retrieves the loaded [[GlyphData]] for the specified text.\n     * Returns `undefined` if the assets for these glyphs haven't been loaded yet.\n     *\n     * @param input - Input text.\n     * @param style - Specific [[TextRenderStyle]] to get glyphs for.\n     * @param letterCaseArray - Array containing the original letter case for the requested glyphs.\n     *\n     * @returns Array containing [[GlyphData]] for each character of the input text.\n     */\n    getGlyphs(\n        input: string,\n        style: TextRenderStyle,\n        letterCaseArray?: boolean[]\n    ): GlyphData[] | undefined {\n        const result = [];\n        const fontName = style.fontName;\n        const fontStyle = style.fontStyle;\n        const fontVariant = style.fontVariant;\n        const shouldTransform =\n            fontVariant === FontVariant.AllCaps || fontVariant === FontVariant.SmallCaps;\n        for (const character of input) {\n            const transformedCharacter = shouldTransform ? character.toUpperCase() : character;\n            for (const char of transformedCharacter) {\n                const codePoint = char.codePointAt(0)!;\n                const font = this.getFont(codePoint, fontName);\n                const glyphData = this.getGlyph(codePoint, font, fontStyle);\n                if (\n                    glyphData !== undefined &&\n                    (!glyphData.isReplacement || this.showReplacementGlyphs)\n                ) {\n                    result.push(glyphData);\n                    if (letterCaseArray !== undefined) {\n                        letterCaseArray.push(char !== character);\n                    }\n                } else {\n                    return undefined;\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the best matched font for a specific character.\n     *\n     * @param codePoint - Character's Unicode code point.\n     * @param fontName - Font name suggestion.\n     *\n     * @returns Best matched font.\n     */\n    getFont(codePoint: number, fontName?: string): Font {\n        let selectedFontName: string = this.fonts[0].name;\n        for (const block of this.unicodeBlocks) {\n            if (codePoint >= block.min && codePoint <= block.max) {\n                selectedFontName =\n                    fontName !== undefined &&\n                    block.fonts.find(element => {\n                        return element === fontName;\n                    }) !== undefined\n                        ? fontName\n                        : block.fonts[0];\n                break;\n            }\n        }\n\n        return this.fonts.find(element => {\n            return element.name === selectedFontName;\n        })!;\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `FontCatalog`.\n     *\n     * @param info - The info object to increment with the values from this `FontCatalog`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        let numBytes = 0;\n\n        for (const block of this.unicodeBlocks) {\n            numBytes += (block.max - block.min) * 2;\n        }\n\n        // Always stored in RGBA internally.\n        let textureBytes =\n            this.m_glyphTextureCache.textureSize.x * this.m_glyphTextureCache.textureSize.y * 4;\n\n        for (const page in this.m_loadedPages.entries) {\n            if (this.m_loadedPages.get(page) !== undefined) {\n                const loadedPage = this.m_loadedPages.get(page);\n                if (loadedPage !== undefined) {\n                    textureBytes += loadedPage.image.width * loadedPage.image.height * 4;\n                }\n            }\n        }\n\n        info.heapSize += numBytes + textureBytes;\n        info.gpuSize += textureBytes;\n    }\n\n    private createReplacementGlyph(codePoint: number, char: string, font: Font): GlyphData {\n        const replacementGlyph = this.m_replacementGlyph.clone();\n        (replacementGlyph as any).codePoint = codePoint;\n        (replacementGlyph as any).character = char;\n        (replacementGlyph as any).font = font;\n        // Glyphs for ASCII control characters and such are not really replacement glyphs.\n        (replacementGlyph as any).isReplacement = UnicodeUtils.isPrintable(codePoint);\n        return replacementGlyph;\n    }\n\n    private async loadAssets(\n        codePoint: number,\n        fontStyle: FontStyle,\n        block: UnicodeBlock,\n        font: Font\n    ): Promise<GlyphData> {\n        const json = await this.loadBlock(block, font, fontStyle);\n        if (json === undefined) {\n            return this.m_replacementGlyph;\n        }\n\n        const sourceGlyphData = (json.chars as SrcGlyphData[]).find(char => char.id === codePoint);\n        const assetsPath = this.getAssetsPath(fontStyle, font);\n        const texturePath = `${assetsPath}/${json.pages[sourceGlyphData!.page]}`;\n        const texture = await this.loadPage(texturePath);\n\n        const glyphData = new GlyphData(\n            sourceGlyphData!.id,\n            block.name,\n            sourceGlyphData!.width,\n            sourceGlyphData!.height,\n            sourceGlyphData!.xadvance,\n            sourceGlyphData!.xoffset,\n            sourceGlyphData!.yoffset,\n            sourceGlyphData!.x / texture!.image.width,\n            1.0 - (sourceGlyphData!.y + sourceGlyphData!.height) / texture!.image.height,\n            (sourceGlyphData!.x + sourceGlyphData!.width) / texture!.image.width,\n            1.0 - sourceGlyphData!.y / texture!.image.height,\n            texture!,\n            font\n        );\n\n        return glyphData;\n    }\n\n    private async loadPage(pagePath: string): Promise<THREE.Texture> {\n        let page = this.m_loadedPages.get(pagePath);\n        if (page === undefined) {\n            let pagePromise = this.m_loadingPages.get(pagePath);\n            if (pagePromise === undefined) {\n                pagePromise = FontCatalog.loadTexture(pagePath);\n                this.m_loadingPages.set(pagePath, pagePromise);\n                page = await pagePromise;\n                page.wrapS = THREE.ClampToEdgeWrapping;\n                page.wrapT = THREE.ClampToEdgeWrapping;\n                page.minFilter = THREE.NearestFilter;\n                page.needsUpdate = true;\n                if (this.m_loadingPages.delete(pagePath)) {\n                    this.m_loadedPages.set(pagePath, page);\n                }\n                this.m_loadingPages.delete(pagePath);\n            } else {\n                page = await pagePromise;\n            }\n        }\n        return page;\n    }\n\n    private getAssetsPath(fontStyle: FontStyle, font: Font) {\n        let fontStylePath = ASSETS_PATH;\n        switch (fontStyle) {\n            case FontStyle.Bold:\n                if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n            case FontStyle.Italic:\n                if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                }\n                break;\n            case FontStyle.BoldItalic:\n                if (font.boldItalic !== undefined) {\n                    fontStylePath = BOLD_ITALIC_ASSETS_PATH;\n                } else if (font.italic !== undefined) {\n                    fontStylePath = ITALIC_ASSETS_PATH;\n                } else if (font.bold !== undefined) {\n                    fontStylePath = BOLD_ASSETS_PATH;\n                }\n                break;\n        }\n        return `${this.url}/${this.name}${fontStylePath}${font.name!}`;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { Font } from \"./FontCatalog\";\n\n/**\n * Structure containing all the required information necessary to render a BMFont glyph using\n * [[TextCanvas]].\n */\nexport class GlyphData {\n    /**\n     * Unicode character represented by this glyph.\n     */\n    readonly character: string;\n\n    /**\n     * Glyph' direction.\n     */\n    readonly direction: UnicodeUtils.Direction;\n\n    /**\n     * Array containing the positions for all corners of this glyph.\n     */\n    positions: THREE.Vector3[] = [];\n\n    /**\n     * Array containing the source texture coordinates for all corners of this glyph.\n     * Used to sample the original texture atlas pages.\n     */\n    sourceTextureCoordinates: THREE.Vector2[] = [];\n\n    /**\n     * Array containing the dynamic texture coordinates for all corners of this glyph.\n     * Used to sample the dynamic texture atlas page.\n     */\n    dynamicTextureCoordinates: THREE.Vector2[] = [];\n\n    /**\n     * Source texture atlas' page copy index.\n     */\n    copyIndex: number = 0;\n\n    /**\n     * Flag indicating if glyph can be currently rendered.\n     */\n    isInCache: boolean = false;\n\n    /**\n     * Creates a new `GlyphData` object.\n     *\n     * @param codePoint - Unicode code point.\n     * @param block - Unicode block.\n     * @param width - Glyph' width.\n     * @param height - Glyph' height.\n     * @param advanceX - Amount of pixel to move after placing this glyph.\n     * @param offsetX - Horizontal offset from the glyph' origin.\n     * @param offsetY - Vertical offset from the glyph' origin.\n     * @param u0 - Glyph' left texture coordinate.\n     * @param v0 - Glyph' bottom texture coordinate.\n     * @param u1 - Glyph' right texture coordinate.\n     * @param v1 - Glyph' top texture coordinate.\n     * @param texture - Glyph' source texture atlas page.\n     * @param font - Glyph' font.\n     * @param isReplacement - `true` if glyph is a replacement for a missing glyph.\n     *\n     * @returns New `GlyphData`.\n     */\n    constructor(\n        readonly codePoint: number,\n        readonly block: string,\n        readonly width: number,\n        readonly height: number,\n        readonly advanceX: number,\n        readonly offsetX: number,\n        readonly offsetY: number,\n        u0: number,\n        v0: number,\n        u1: number,\n        v1: number,\n        readonly texture: THREE.Texture,\n        readonly font: Font,\n        readonly isReplacement: boolean = false\n    ) {\n        this.character = String.fromCodePoint(codePoint);\n        this.direction = UnicodeUtils.getDirection(codePoint, block);\n\n        const left = this.offsetX;\n        const right = left + this.width;\n        const top = font.metrics.lineHeight - this.offsetY;\n        const bottom = top - this.height;\n\n        this.positions.push(\n            new THREE.Vector3(left, bottom, 1.0),\n            new THREE.Vector3(right, bottom, 1.0),\n            new THREE.Vector3(left, top, 1.0),\n            new THREE.Vector3(right, top, 1.0)\n        );\n\n        this.sourceTextureCoordinates.push(\n            new THREE.Vector2(u0, v0),\n            new THREE.Vector2(u1, v0),\n            new THREE.Vector2(u0, v1),\n            new THREE.Vector2(u1, v1)\n        );\n\n        this.dynamicTextureCoordinates.push(\n            new THREE.Vector2(0.0, 0.0),\n            new THREE.Vector2(1.0, 0.0),\n            new THREE.Vector2(0.0, 1.0),\n            new THREE.Vector2(1.0, 1.0)\n        );\n    }\n\n    /**\n     * Clone this `GlyphData`.\n     *\n     * @returns Cloned `GlyphData`.\n     */\n    clone(): GlyphData {\n        return new GlyphData(\n            this.codePoint,\n            this.block,\n            this.width,\n            this.height,\n            this.advanceX,\n            this.offsetX,\n            this.offsetY,\n            this.sourceTextureCoordinates[0].x,\n            this.sourceTextureCoordinates[0].y,\n            this.sourceTextureCoordinates[3].x,\n            this.sourceTextureCoordinates[3].y,\n            this.texture,\n            this.font,\n            this.isReplacement\n        );\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { LRUCache } from \"@here/harp-lrucache\";\nimport * as THREE from \"three\";\n\nimport { Font, FontMetrics } from \"./FontCatalog\";\nimport { GlyphData } from \"./GlyphData\";\nimport { GlyphClearMaterial, GlyphCopyMaterial } from \"./TextMaterials\";\n\n/**\n * Maximum number of texture atlas pages we can copy from in a single go. This amount is determined\n * by the maximum number of texture units available on a pixel shader for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_IMAGE_UNITS\n */\nconst MAX_NUM_COPY_PAGES = 8;\n\n/**\n * Maximum texture size supported. This amount is determined by the maximum texture size supported\n * for all devices:\n * https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE\n */\nconst MAX_TEXTURE_SIZE = 4096;\n\n/**\n * @hidden\n * Information stored for every entry in a [[GlyphTextureCache]].\n */\nexport interface GlyphCacheEntry {\n    glyphData: GlyphData;\n    location: THREE.Vector2;\n}\n\n/**\n * @hidden\n * Unified glyph SDF bitmap storage for all fonts in a [[FontCatalog]].\n * Implemented as an abstraction layer on top of an LRUCache and WebGLRenderTarget.\n */\nexport class GlyphTextureCache {\n    private readonly m_cacheWidth: number;\n    private readonly m_cacheHeight: number;\n    private readonly m_textureSize: THREE.Vector2;\n    private readonly m_entryCache: LRUCache<string, GlyphCacheEntry>;\n\n    private readonly m_scene: THREE.Scene;\n    private readonly m_camera: THREE.OrthographicCamera;\n    private readonly m_rt: THREE.WebGLRenderTarget;\n\n    private readonly m_copyTextureSet: Set<THREE.Texture>;\n    private readonly m_copyTransform: THREE.Matrix3;\n    private readonly m_copyPositions: THREE.Vector2[];\n    private m_copyMaterial?: GlyphCopyMaterial;\n    private m_copyVertexBuffer: THREE.InterleavedBuffer;\n    private readonly m_copyPositionAttribute: THREE.InterleavedBufferAttribute;\n    private readonly m_copyUVAttribute: THREE.InterleavedBufferAttribute;\n    private readonly m_copyGeometry: THREE.BufferGeometry;\n    private m_copyMesh: THREE.Mesh;\n    private m_copyGeometryDrawCount: number;\n\n    private m_clearMaterial?: GlyphClearMaterial;\n    private m_clearPositionAttribute: THREE.BufferAttribute;\n    private readonly m_clearGeometry: THREE.BufferGeometry;\n    private m_clearMesh: THREE.Mesh;\n    private m_clearGeometryDrawCount: number;\n\n    /**\n     * Creates a `GlyphTextureCache` object.\n     *\n     * @param capacity - Cache's maximum glyph capacity.\n     * @param entryWidth - Maximum entry width.\n     * @param entryHeight - Maximum entry height.\n     *\n     * @returns New `GlyphTextureCache`.\n     */\n    constructor(\n        readonly capacity: number,\n        readonly entryWidth: number,\n        readonly entryHeight: number\n    ) {\n        const nRows = Math.floor(Math.sqrt(capacity));\n        this.m_cacheHeight = nRows * nRows < capacity ? nRows + 1 : nRows;\n        this.m_cacheWidth = nRows * this.m_cacheHeight < capacity ? nRows + 1 : nRows;\n\n        this.m_textureSize = new THREE.Vector2(\n            this.m_cacheWidth * entryWidth,\n            this.m_cacheHeight * entryHeight\n        );\n        if (this.m_textureSize.y > MAX_TEXTURE_SIZE || this.m_textureSize.x > MAX_TEXTURE_SIZE) {\n            // eslint-disable-next-line no-console\n            console.warn(\n                \"GlyphTextureCache texture size (\" +\n                    this.m_textureSize.x +\n                    \", \" +\n                    this.m_textureSize.y +\n                    \") exceeds WebGL's widely supported MAX_TEXTURE_SIZE (\" +\n                    MAX_TEXTURE_SIZE +\n                    \").\\n\" +\n                    \"This could result in rendering errors on some devices.\\n\" +\n                    \"Please consider reducing its capacity or input assets size.\"\n            );\n        }\n\n        this.m_entryCache = new LRUCache<string, GlyphCacheEntry>(capacity);\n        this.initCacheEntries();\n\n        this.m_scene = new THREE.Scene();\n        this.m_camera = new THREE.OrthographicCamera(\n            0,\n            this.m_textureSize.x,\n            this.m_textureSize.y,\n            0\n        );\n        this.m_camera.position.z = 1;\n        this.m_camera.updateMatrixWorld(false);\n        this.m_rt = new THREE.WebGLRenderTarget(this.m_textureSize.x, this.m_textureSize.y, {\n            wrapS: THREE.ClampToEdgeWrapping,\n            wrapT: THREE.ClampToEdgeWrapping,\n            depthBuffer: false,\n            stencilBuffer: false\n        });\n\n        this.m_copyTextureSet = new Set<THREE.Texture>();\n        this.m_copyTransform = new THREE.Matrix3();\n        this.m_copyPositions = [];\n        this.m_copyPositions.push(\n            new THREE.Vector2(),\n            new THREE.Vector2(),\n            new THREE.Vector2(),\n            new THREE.Vector2()\n        );\n\n        this.m_copyVertexBuffer = new THREE.InterleavedBuffer(new Float32Array(capacity * 20), 5);\n        this.m_copyVertexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_copyPositionAttribute = new THREE.InterleavedBufferAttribute(\n            this.m_copyVertexBuffer,\n            3,\n            0\n        );\n        this.m_copyUVAttribute = new THREE.InterleavedBufferAttribute(\n            this.m_copyVertexBuffer,\n            2,\n            3\n        );\n        this.m_copyGeometry = new THREE.BufferGeometry();\n        this.m_copyGeometry.setAttribute(\"position\", this.m_copyPositionAttribute);\n        this.m_copyGeometry.setAttribute(\"uv\", this.m_copyUVAttribute);\n\n        const copyIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        copyIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_copyGeometry.setIndex(copyIndexBuffer);\n        this.m_copyMesh = new THREE.Mesh(this.m_copyGeometry);\n        this.m_copyMesh.frustumCulled = false;\n        this.m_copyGeometryDrawCount = 0;\n\n        this.m_clearPositionAttribute = new THREE.BufferAttribute(\n            new Float32Array(capacity * 8),\n            2\n        );\n        this.m_clearPositionAttribute.setUsage(THREE.DynamicDrawUsage);\n        this.m_clearGeometry = new THREE.BufferGeometry();\n        this.m_clearGeometry.setAttribute(\"position\", this.m_clearPositionAttribute);\n        const clearIndexBuffer = new THREE.BufferAttribute(new Uint32Array(capacity * 6), 1);\n        clearIndexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_clearGeometry.setIndex(clearIndexBuffer);\n        this.m_clearMesh = new THREE.Mesh(this.m_clearGeometry);\n        this.m_clearMesh.frustumCulled = false;\n        this.m_clearGeometryDrawCount = 0;\n\n        this.m_scene.add(this.m_clearMesh, this.m_copyMesh);\n    }\n\n    /**\n     * Release all allocated resources.\n     */\n    dispose(): void {\n        this.m_entryCache.clear();\n        this.m_scene.remove(this.m_clearMesh, this.m_copyMesh);\n        this.m_rt.dispose();\n        this.m_clearMaterial?.dispose();\n        this.m_copyMaterial?.dispose();\n        this.m_copyTextureSet.clear();\n        this.m_clearGeometry.dispose();\n        this.m_copyGeometry.dispose();\n    }\n\n    /**\n     * Internal WebGL Texture.\n     */\n    get texture(): THREE.Texture {\n        return this.m_rt.texture;\n    }\n\n    /**\n     * Internal WebGL Texture size.\n     */\n    get textureSize(): THREE.Vector2 {\n        return this.m_textureSize;\n    }\n\n    /**\n     * Add a new entry to the GlyphTextureCache. If the limit of entries is hit, the least requested\n     * entry will be replaced.\n     *\n     * @param hash - Entry's hash.\n     * @param glyph - Entry's glyph data.\n     */\n    add(hash: string, glyph: GlyphData): void {\n        const entry = this.m_entryCache.get(hash);\n        if (entry !== undefined) {\n            return;\n        }\n\n        const oldestEntry = this.m_entryCache.oldest;\n        if (oldestEntry === null) {\n            throw new Error(\"GlyphTextureCache is uninitialized!\");\n        }\n        this.clearCacheEntry(oldestEntry.value);\n        this.copyGlyphToCache(hash, glyph, oldestEntry.value.location);\n    }\n\n    /**\n     * Checks if an entry is in the cache.\n     *\n     * @param hash - Entry's hash.\n     *\n     * @returns Test result.\n     */\n    has(hash: string): boolean {\n        return this.m_entryCache.has(hash);\n    }\n\n    /**\n     * Retrieves an entry from the cache.\n     *\n     * @param hash - Entry's hash.\n     *\n     * @returns Retrieval result.\n     */\n    get(hash: string): GlyphCacheEntry | undefined {\n        return this.m_entryCache.get(hash);\n    }\n\n    /**\n     * Clears the internal LRUCache.\n     */\n    clear(): void {\n        this.m_copyGeometryDrawCount = 0;\n        this.m_clearGeometryDrawCount = 0;\n        this.m_entryCache.clear();\n        this.m_copyTextureSet.clear();\n        this.initCacheEntries();\n    }\n\n    /**\n     * Updates the internal WebGLRenderTarget.\n     * The update will copy the newly introduced glyphs since the previous update.\n     *\n     * @param renderer - WebGLRenderer.\n     */\n    update(renderer: THREE.WebGLRenderer): void {\n        let oldRenderTarget: THREE.RenderTarget | null = null;\n\n        const willClearGeometry = this.m_clearGeometryDrawCount > 0;\n        const willCopyGeometry = this.m_copyGeometryDrawCount > 0;\n\n        if (willClearGeometry || willCopyGeometry) {\n            oldRenderTarget = renderer.getRenderTarget();\n            renderer.setRenderTarget(this.m_rt);\n        }\n\n        if (willClearGeometry) {\n            if (!this.m_clearMaterial) {\n                this.m_clearMaterial = new GlyphClearMaterial({\n                    rendererCapabilities: renderer.capabilities\n                });\n                this.m_clearMesh.material = this.m_clearMaterial;\n            }\n\n            if (this.m_clearGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n            }\n            this.m_clearPositionAttribute.needsUpdate = true;\n            this.m_clearPositionAttribute.updateRange.offset = 0;\n            this.m_clearPositionAttribute.updateRange.count = this.m_clearGeometryDrawCount * 8;\n            this.m_clearGeometry.index.needsUpdate = true;\n            this.m_clearGeometry.index.updateRange.offset = 0;\n            this.m_clearGeometry.index.updateRange.count = this.m_clearGeometryDrawCount * 6;\n            this.m_clearGeometry.setDrawRange(0, this.m_clearGeometryDrawCount * 6);\n\n            this.m_clearMesh.visible = true;\n            this.m_copyMesh.visible = false;\n\n            renderer.render(this.m_scene, this.m_camera);\n            this.m_clearGeometryDrawCount = 0;\n            this.m_clearMesh.visible = false;\n        }\n\n        if (willCopyGeometry) {\n            if (!this.m_copyMaterial) {\n                this.m_copyMaterial = new GlyphCopyMaterial({\n                    rendererCapabilities: renderer.capabilities\n                });\n                this.m_copyMesh.material = this.m_copyMaterial;\n            }\n\n            if (this.m_copyGeometry.index === null) {\n                throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n            }\n            this.m_copyVertexBuffer.needsUpdate = true;\n            this.m_copyVertexBuffer.updateRange.offset = 0;\n            this.m_copyVertexBuffer.updateRange.count = this.m_copyGeometryDrawCount * 20;\n            this.m_copyGeometry.index.needsUpdate = true;\n            this.m_copyGeometry.index.updateRange.offset = 0;\n            this.m_copyGeometry.index.updateRange.count = this.m_copyGeometryDrawCount * 6;\n            this.m_copyGeometry.setDrawRange(0, this.m_copyGeometryDrawCount * 6);\n\n            this.m_copyMesh.visible = true;\n            const srcPages = Array.from(this.m_copyTextureSet);\n            const nCopies = Math.ceil(this.m_copyTextureSet.size / MAX_NUM_COPY_PAGES);\n            for (let copyIndex = 0; copyIndex < nCopies; copyIndex++) {\n                const pageOffset = copyIndex * MAX_NUM_COPY_PAGES;\n                this.m_copyMaterial.uniforms.pageOffset.value = pageOffset;\n                for (let i = 0; i < MAX_NUM_COPY_PAGES; i++) {\n                    const pageIndex = pageOffset + i;\n                    if (pageIndex < this.m_copyTextureSet.size) {\n                        this.m_copyMaterial.uniforms[\"page\" + i].value = srcPages[pageIndex];\n                    }\n                }\n\n                renderer.render(this.m_scene, this.m_camera);\n            }\n            this.m_copyTextureSet.clear();\n            this.m_copyGeometryDrawCount = 0;\n        }\n        if (willClearGeometry || willCopyGeometry) {\n            renderer.setRenderTarget(oldRenderTarget);\n        }\n    }\n\n    private initCacheEntries() {\n        const dummyMetrics: FontMetrics = {\n            size: 0,\n            distanceRange: 0,\n            base: 0,\n            lineHeight: 0,\n            lineGap: 0,\n            capHeight: 0,\n            xHeight: 0\n        };\n        const dummyFont: Font = {\n            name: \"\",\n            metrics: dummyMetrics,\n            charset: \"\"\n        };\n\n        const dummyGlyphData = new GlyphData(\n            0,\n            \"\",\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            THREE.Texture.DEFAULT_IMAGE,\n            dummyFont\n        );\n\n        for (let i = 0; i < this.m_cacheHeight; i++) {\n            for (let j = 0; j < this.m_cacheWidth; j++) {\n                const dummyEntry: GlyphCacheEntry = {\n                    glyphData: dummyGlyphData,\n                    location: new THREE.Vector2(j, i)\n                };\n                this.m_entryCache.set(`Dummy_${i * this.m_cacheHeight + j}`, dummyEntry);\n            }\n        }\n    }\n\n    private copyGlyphToCache(hash: string, glyph: GlyphData, cacheLocation: THREE.Vector2) {\n        this.m_copyTextureSet.add(glyph.texture);\n        let copyTextureIndex = 0;\n        for (const value of this.m_copyTextureSet.values()) {\n            if (value === glyph.texture) {\n                break;\n            }\n            copyTextureIndex++;\n        }\n        glyph.copyIndex = copyTextureIndex;\n\n        this.m_copyTransform.set(\n            1.0,\n            0.0,\n            cacheLocation.x * this.entryWidth - glyph.offsetX,\n            0.0,\n            1.0,\n            cacheLocation.y * this.entryHeight - glyph.positions[0].y,\n            0.0,\n            0.0,\n            0.0\n        );\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositions[i].set(glyph.positions[i].x, glyph.positions[i].y);\n            this.m_copyPositions[i].applyMatrix3(this.m_copyTransform);\n        }\n\n        if (this.m_copyGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_copyGeometryDrawCount * 4;\n        const baseIndex = this.m_copyGeometryDrawCount * 6;\n\n        for (let i = 0; i < 4; ++i) {\n            this.m_copyPositionAttribute.setXYZ(\n                baseVertex + i,\n                this.m_copyPositions[i].x,\n                this.m_copyPositions[i].y,\n                glyph.copyIndex\n            );\n            this.m_copyUVAttribute.setXY(\n                baseVertex + i,\n                glyph.sourceTextureCoordinates[i].x,\n                glyph.sourceTextureCoordinates[i].y\n            );\n        }\n\n        if (this.m_copyGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache copy geometry index is uninitialized!\");\n        }\n        this.m_copyGeometry.index.setX(baseIndex, baseVertex);\n        this.m_copyGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_copyGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_copyGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n\n        ++this.m_copyGeometryDrawCount;\n\n        const u0 = this.m_copyPositions[0].x / this.m_textureSize.x;\n        const v0 = this.m_copyPositions[0].y / this.m_textureSize.y;\n        const u1 = this.m_copyPositions[3].x / this.m_textureSize.x;\n        const v1 = this.m_copyPositions[3].y / this.m_textureSize.y;\n        glyph.dynamicTextureCoordinates[0].set(u0, v0);\n        glyph.dynamicTextureCoordinates[1].set(u1, v0);\n        glyph.dynamicTextureCoordinates[2].set(u0, v1);\n        glyph.dynamicTextureCoordinates[3].set(u1, v1);\n\n        glyph.isInCache = true;\n        this.m_entryCache.set(hash, {\n            glyphData: glyph,\n            location: cacheLocation\n        });\n    }\n\n    private clearCacheEntry(entry: GlyphCacheEntry) {\n        entry.glyphData.isInCache = false;\n        this.m_copyPositions[0].set(\n            entry.location.x * this.entryWidth,\n            entry.location.y * this.entryHeight\n        );\n        this.m_copyPositions[1].set(\n            (entry.location.x + 1) * this.entryWidth,\n            entry.location.y * this.entryHeight\n        );\n        this.m_copyPositions[2].set(\n            entry.location.x * this.entryWidth,\n            (entry.location.y + 1) * this.entryHeight\n        );\n        this.m_copyPositions[3].set(\n            (entry.location.x + 1) * this.entryWidth,\n            (entry.location.y + 1) * this.entryHeight\n        );\n\n        if (this.m_clearGeometryDrawCount >= this.capacity) {\n            return;\n        }\n        const baseVertex = this.m_clearGeometryDrawCount * 4;\n        const baseIndex = this.m_clearGeometryDrawCount * 6;\n\n        for (let i = 0; i < 4; ++i) {\n            this.m_clearPositionAttribute.setXY(\n                baseVertex + i,\n                this.m_copyPositions[i].x,\n                this.m_copyPositions[i].y\n            );\n        }\n\n        if (this.m_clearGeometry.index === null) {\n            throw new Error(\"GlyphTextureCache clear geometry index is uninitialized!\");\n        }\n        this.m_clearGeometry.index.setX(baseIndex, baseVertex);\n        this.m_clearGeometry.index.setX(baseIndex + 1, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 2, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 3, baseVertex + 2);\n        this.m_clearGeometry.index.setX(baseIndex + 4, baseVertex + 1);\n        this.m_clearGeometry.index.setX(baseIndex + 5, baseVertex + 3);\n\n        ++this.m_clearGeometryDrawCount;\n    }\n}\n","/*\n * Copyright (C) 2018-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GlyphData } from \"./GlyphData\";\nimport { TextLayoutStyle, TextRenderStyle } from \"./TextStyle\";\n\n/**\n * Object containing vertex buffer data generated by [[TextCanvas]].\n */\nexport class TextBufferObject {\n    /**\n     * Constructs a new `TextBufferObject`.\n     *\n     * @param glyphs - Input glyphs.\n     * @param buffer - Buffer containing the data generated by [[TextCanvas]].\n     * @param bounds - Optional text bounds.\n     * @param characterBounds - Optional character bounds.\n     * @param textRenderStyle - [[TextRenderStyle]] applied by [[TextCanvas]].\n     * @param textLayoutStyle - [[TextLayoutStyle]] applied by [[TextCanvas]].\n     *\n     * @returns New `TextBufferObject`.\n     */\n    constructor(\n        readonly glyphs: GlyphData[],\n        readonly buffer: Float32Array,\n        readonly bounds?: THREE.Box2,\n        readonly characterBounds?: THREE.Box2[],\n        readonly textRenderStyle?: TextRenderStyle,\n        readonly textLayoutStyle?: TextLayoutStyle\n    ) {}\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport * as THREE from \"three\";\n\nimport { MemoryUsage } from \"../TextCanvas\";\nimport { GlyphData } from \"./GlyphData\";\nimport { TextBufferObject } from \"./TextBufferObject\";\nimport { TextRenderStyle } from \"./TextStyle\";\n\nexport const MAX_CAPACITY = 65536;\nexport const VERTEX_BUFFER_STRIDE = 16;\nexport const INDEX_BUFFER_STRIDE = 1;\nexport const VERTICES_PER_QUAD = 4;\nexport const INDICES_PER_QUAD = 6;\nexport const QUAD_VERTEX_MEMORY_FOOTPRINT = VERTICES_PER_QUAD * VERTEX_BUFFER_STRIDE;\nexport const QUAD_INDEX_MEMORY_FOOTPRINT = INDICES_PER_QUAD * INDEX_BUFFER_STRIDE;\n\n/**\n * Number of bytes for float in an Float32Array.\n */\nconst NUM_BYTES_PER_FLOAT = 4;\n\n/**\n * Number of bytes for integer number in an UInt32Array.\n */\nconst NUM_BYTES_PER_INT32 = 4;\n\n/**\n * Interface containing user-supplied picking data, as well as the [[TextGeometry]] range it's\n * assigned to.\n */\ninterface PickingData {\n    start: number;\n    end: number;\n    data: any;\n}\n\n/**\n * Procedural geometry that holds vertex attribute data for all glyphs in a [[TextCanvas]].\n */\nexport class TextGeometry {\n    /**\n     * Count of currently drawn glyphs.\n     */\n    get drawCount(): number {\n        return this.m_drawCount;\n    }\n\n    /**\n     * Mesh used to render foreground glyphs.\n     */\n    get mesh(): THREE.Mesh {\n        return this.m_mesh;\n    }\n\n    /**\n     * Mesh used to render background glyphs.\n     */\n    get backgroundMesh(): THREE.Mesh {\n        return this.m_bgMesh;\n    }\n\n    /**\n     * Maximum glyph capacity.\n     */\n    readonly capacity: number;\n\n    private m_currentCapacity: number;\n    private m_drawCount: number;\n    private m_updateOffset: number;\n\n    private m_vertexBuffer: THREE.InterleavedBuffer;\n    private m_positionAttribute: THREE.InterleavedBufferAttribute;\n    private m_uvAttribute: THREE.InterleavedBufferAttribute;\n    private m_colorAttribute: THREE.InterleavedBufferAttribute;\n    private m_bgColorAttribute: THREE.InterleavedBufferAttribute;\n    private m_indexBuffer: THREE.BufferAttribute;\n\n    private m_geometry: THREE.BufferGeometry;\n    private m_mesh: THREE.Mesh;\n    private m_bgMesh: THREE.Mesh;\n\n    private m_pickingDataArray: PickingData[] = [];\n\n    /**\n     * Creates a new `TextGeometry`.\n     *\n     * @param material - Material used to render foreground glyphs.\n     * @param backgroundMaterial - Material used to render background glyphs.\n     * @param initialSize - Initial amount of glyphs that can be stored.\n     * @param capacity - Maximum glyph capacity.\n     *\n     * @returns New `TextGeometry`.\n     */\n    constructor(\n        readonly scene: THREE.Scene,\n        material: THREE.Material,\n        backgroundMaterial: THREE.Material,\n        initialSize: number,\n        capacity: number\n    ) {\n        this.capacity = Math.min(capacity, MAX_CAPACITY);\n        this.m_currentCapacity = Math.min(initialSize, capacity);\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(\n            new Float32Array(this.m_currentCapacity * QUAD_VERTEX_MEMORY_FOOTPRINT),\n            VERTEX_BUFFER_STRIDE\n        );\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n\n        this.m_indexBuffer = new THREE.BufferAttribute(\n            new Uint32Array(this.m_currentCapacity * QUAD_INDEX_MEMORY_FOOTPRINT),\n            INDEX_BUFFER_STRIDE\n        );\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n\n        this.m_mesh = new THREE.Mesh(this.m_geometry, material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, backgroundMaterial);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n\n    /**\n     * Release all allocated resources.\n     */\n    dispose() {\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_geometry.dispose();\n    }\n\n    /**\n     * Clear the geometry.\n     */\n    clear() {\n        this.m_drawCount = 0;\n        this.m_updateOffset = 0;\n        this.m_pickingDataArray.length = 0;\n    }\n\n    /**\n     * Update the GPU resources to reflect the latest additions to the geometry.\n     */\n    update() {\n        if (this.drawCount > this.m_updateOffset) {\n            this.m_vertexBuffer.needsUpdate = true;\n            this.m_vertexBuffer.updateRange.offset =\n                this.m_updateOffset * QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_vertexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * QUAD_VERTEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.needsUpdate = true;\n            this.m_indexBuffer.updateRange.offset =\n                this.m_updateOffset * QUAD_INDEX_MEMORY_FOOTPRINT;\n            this.m_indexBuffer.updateRange.count =\n                (this.m_drawCount - this.m_updateOffset) * QUAD_INDEX_MEMORY_FOOTPRINT;\n        }\n        this.m_updateOffset = this.m_drawCount;\n        this.m_geometry.setDrawRange(0, this.m_drawCount * INDICES_PER_QUAD);\n    }\n\n    /**\n     * Add a new glyph to the `TextGeometry`.\n     *\n     * @param glyphData - [[GlyphData]] holding the glyph description.\n     * @param corners - Transformed glyph corners.\n     * @param weight - Foreground glyph sampling weight.\n     * @param bgWeight - Foreground glyph sampling weight.\n     * @param mirrored - If `true`, UVs will be horizontally mirrored (needed for RTL punctuation).\n     * @param style - Currently set [[TextRenderStyle]].\n     *\n     * @returns Result of the addition.\n     */\n    add(\n        glyphData: GlyphData,\n        corners: THREE.Vector3[],\n        weight: number,\n        bgWeight: number,\n        mirrored: boolean,\n        style: TextRenderStyle\n    ): boolean {\n        if (this.m_drawCount >= this.capacity) {\n            return false;\n        } else if (this.m_drawCount >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n\n        const baseVertex = this.m_drawCount * VERTICES_PER_QUAD;\n        const baseIndex = this.m_drawCount * INDICES_PER_QUAD;\n\n        for (let i = 0; i < VERTICES_PER_QUAD; ++i) {\n            this.m_positionAttribute.setXYZW(\n                baseVertex + i,\n                corners[i].x,\n                corners[i].y,\n                corners[i].z,\n                (mirrored ? -1.0 : 1.0) * style.rotation\n            );\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            this.m_uvAttribute.setXYZW(\n                baseVertex + i,\n                glyphData.dynamicTextureCoordinates[mirroredUVIdx].x,\n                glyphData.dynamicTextureCoordinates[mirroredUVIdx].y,\n                weight,\n                bgWeight\n            );\n            this.m_colorAttribute.setXYZW(\n                baseVertex + i,\n                style.color.r,\n                style.color.g,\n                style.color.b,\n                style.opacity\n            );\n            this.m_bgColorAttribute.setXYZW(\n                baseVertex + i,\n                style.backgroundColor.r,\n                style.backgroundColor.g,\n                style.backgroundColor.b,\n                style.backgroundOpacity\n            );\n        }\n\n        this.m_indexBuffer.setX(baseIndex, baseVertex);\n        this.m_indexBuffer.setX(baseIndex + 1, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 2, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 3, baseVertex + 2);\n        this.m_indexBuffer.setX(baseIndex + 4, baseVertex + 1);\n        this.m_indexBuffer.setX(baseIndex + 5, baseVertex + 3);\n\n        ++this.m_drawCount;\n        return true;\n    }\n\n    /**\n     * Add a new glyph to a text buffer.\n     *\n     * @param buffer - Target buffer where glyph attributes will be stored.\n     * @param offset - Offset of the target buffer.\n     * @param glyphData - [[GlyphData]] holding the glyph description.\n     * @param corners - Transformed glyph corners.\n     * @param weight - Foreground glyph sampling weight.\n     * @param bgWeight - Foreground glyph sampling weight.\n     * @param mirrored - If `true`, UVs will be mirrored (needed for RTL punctuation).\n     * @param style - Currently set [[TextRenderStyle]].\n     */\n    addToBuffer(\n        buffer: Float32Array,\n        offset: number,\n        glyphData: GlyphData,\n        corners: THREE.Vector3[],\n        weight: number,\n        bgWeight: number,\n        mirrored: boolean,\n        style: TextRenderStyle\n    ): void {\n        for (let i = 0; i < VERTICES_PER_QUAD; ++i) {\n            const vertexOffset = offset + VERTEX_BUFFER_STRIDE * i;\n            buffer[vertexOffset] = corners[i].x;\n            buffer[vertexOffset + 1] = corners[i].y;\n            buffer[vertexOffset + 2] = corners[i].z;\n            buffer[vertexOffset + 3] = (mirrored ? -1.0 : 1.0) * style.rotation;\n\n            const mirroredUVIdx = mirrored ? ((i + 1) % 2) + Math.floor(i / 2) * 2 : i;\n            buffer[vertexOffset + 4] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].x;\n            buffer[vertexOffset + 5] = glyphData.dynamicTextureCoordinates[mirroredUVIdx].y;\n            buffer[vertexOffset + 6] = weight;\n            buffer[vertexOffset + 7] = bgWeight;\n\n            buffer[vertexOffset + 8] = style.color.r;\n            buffer[vertexOffset + 9] = style.color.g;\n            buffer[vertexOffset + 10] = style.color.b;\n            buffer[vertexOffset + 11] = style.opacity;\n\n            buffer[vertexOffset + 12] = style.backgroundColor.r;\n            buffer[vertexOffset + 13] = style.backgroundColor.g;\n            buffer[vertexOffset + 14] = style.backgroundColor.b;\n            buffer[vertexOffset + 15] = style.backgroundOpacity;\n        }\n    }\n\n    /**\n     * Add a previously computed [[TextBufferObject]] to the `TextGeometry`. Extra parameters can\n     * be passed to override the passed attribute data.\n     *\n     * @param textBufferObject - [[TextBufferObject]] containing computed glyphs.\n     * @param position - Override position value.\n     * @param scale - Override scale value.\n     * @param rotation - Override rotation value.\n     * @param color - Override color value.\n     * @param opacity - Override opacity value.\n     * @param bgColor - Override background color value.\n     * @param bgOpacity - Override background opacity value.\n     *\n     * @returns Result of the addition.\n     */\n    addTextBufferObject(\n        textBufferObject: TextBufferObject,\n        position?: THREE.Vector3,\n        scale?: number,\n        rotation?: number,\n        color?: THREE.Color,\n        opacity?: number,\n        bgColor?: THREE.Color,\n        bgOpacity?: number\n    ): boolean {\n        if (this.m_drawCount + textBufferObject.glyphs.length >= this.capacity) {\n            return false;\n        } else if (this.m_drawCount + textBufferObject.glyphs.length >= this.m_currentCapacity) {\n            const newSize = Math.min(this.m_currentCapacity * 2, this.capacity);\n            this.resizeBuffers(newSize);\n        }\n\n        const s = scale ?? 1.0;\n        const r = rotation ?? 0.0;\n        const cosR = Math.cos(r);\n        const sinR = Math.sin(r);\n        const offsetX = position !== undefined ? position.x : 0.0;\n        const offsetY = position !== undefined ? position.y : 0.0;\n        // Ignore z for rendering\n        const offsetZ = 0.0;\n\n        const buffer = textBufferObject.buffer;\n\n        const rot = buffer[3];\n        const rotSign = rot < 0 ? -1.0 : 1.0;\n\n        const red = color !== undefined ? color.r : buffer[8];\n        const green = color !== undefined ? color.g : buffer[9];\n        const blue = color !== undefined ? color.b : buffer[10];\n        const alpha = opacity !== undefined ? opacity : buffer[11];\n        const bgRed = bgColor !== undefined ? bgColor.r : buffer[12];\n        const bgGreen = bgColor !== undefined ? bgColor.g : buffer[13];\n        const bgBlue = bgColor !== undefined ? bgColor.b : buffer[14];\n        const bgAlpha = bgOpacity !== undefined ? bgOpacity : buffer[15];\n\n        const targetOffset = this.m_drawCount * VERTICES_PER_QUAD;\n        for (let i = 0; i < textBufferObject.glyphs.length; ++i) {\n            const srcOffset = i * QUAD_VERTEX_MEMORY_FOOTPRINT;\n\n            const glyph = textBufferObject.glyphs[i];\n            if (!glyph.isInCache) {\n                return false;\n            }\n\n            const mirrored = buffer[srcOffset + 4] > buffer[srcOffset + VERTEX_BUFFER_STRIDE + 4];\n            const w = buffer[srcOffset + 6];\n            const bw = buffer[srcOffset + 7];\n\n            for (let j = 0; j < VERTICES_PER_QUAD; ++j) {\n                const x = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE];\n                const y = buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 1];\n                this.m_positionAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    x * s * cosR + y * s * -sinR + offsetX,\n                    x * s * sinR + y * s * cosR + offsetY,\n                    buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 2] + offsetZ,\n                    buffer[srcOffset + j * VERTEX_BUFFER_STRIDE + 3] + rotSign * r\n                );\n                const mirroredUVIdx = mirrored ? ((j + 1) % 2) + Math.floor(j / 2) * 2 : j;\n                this.m_uvAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    glyph.dynamicTextureCoordinates[mirroredUVIdx].x,\n                    glyph.dynamicTextureCoordinates[mirroredUVIdx].y,\n                    w,\n                    (bw - w) / s + w\n                );\n                this.m_colorAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    red,\n                    green,\n                    blue,\n                    alpha\n                );\n                this.m_bgColorAttribute.setXYZW(\n                    targetOffset + i * VERTICES_PER_QUAD + j,\n                    bgRed,\n                    bgGreen,\n                    bgBlue,\n                    bgAlpha\n                );\n            }\n\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 1,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 1\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 2,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 2\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 3,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 2\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 4,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 1\n            );\n            this.m_indexBuffer.setX(\n                (this.m_drawCount + i) * INDICES_PER_QUAD + 5,\n                (this.m_drawCount + i) * VERTICES_PER_QUAD + 3\n            );\n        }\n\n        this.m_drawCount += textBufferObject.glyphs.length;\n        return true;\n    }\n\n    /**\n     * Adds picking data for glyphs from the specified start until the last glyph added.\n     *\n     * @param startIdx - First glyph index that this picking data is associated to.\n     * @param endIdx - Last glyph index that this picking data is associated to.\n     * @param pickingData - Picking data to be added.\n     */\n    addPickingData(startIdx: number, endIdx: number, pickingData: any): boolean {\n        if (this.m_pickingDataArray.length >= this.m_currentCapacity) {\n            return false;\n        }\n\n        this.m_pickingDataArray.push({\n            start: Math.min(startIdx, this.capacity),\n            end: Math.min(endIdx, this.capacity),\n            data: pickingData\n        });\n\n        return true;\n    }\n\n    /**\n     * Fill the picking results for the pixel with the given screen coordinate. If multiple glyphs\n     * are found, the order of the results is unspecified.\n     *\n     * @param screenPosition - Screen coordinate of picking position.\n     * @param pickCallback - Callback to be called for every picked element.\n     */\n    pick(screenPosition: THREE.Vector2, pickCallback: (pickData: any | undefined) => void) {\n        for (const pickingData of this.m_pickingDataArray) {\n            if (pickingData === undefined) {\n                return;\n            }\n\n            for (let i = pickingData.start; i < pickingData.end; ++i) {\n                const positionIndex = i * VERTICES_PER_QUAD;\n\n                const minX = Math.min(\n                    this.m_positionAttribute.getX(positionIndex + 2),\n                    this.m_positionAttribute.getX(positionIndex + 1)\n                );\n                if (screenPosition.x < minX) {\n                    continue;\n                }\n\n                const maxX = Math.max(\n                    this.m_positionAttribute.getX(positionIndex + 2),\n                    this.m_positionAttribute.getX(positionIndex + 1)\n                );\n                if (screenPosition.x > maxX) {\n                    continue;\n                }\n\n                const minY = Math.min(\n                    this.m_positionAttribute.getY(positionIndex + 2),\n                    this.m_positionAttribute.getY(positionIndex + 1)\n                );\n                if (screenPosition.y < minY) {\n                    continue;\n                }\n\n                const maxY = Math.max(\n                    this.m_positionAttribute.getY(positionIndex + 2),\n                    this.m_positionAttribute.getY(positionIndex + 1)\n                );\n                if (screenPosition.y > maxY) {\n                    continue;\n                }\n\n                pickCallback(pickingData.data);\n                break;\n            }\n        }\n    }\n\n    /**\n     * Update the info with the memory footprint caused by objects owned by the `TextGeometry`.\n     *\n     * @param info - The info object to increment with the values from this `TextGeometry`.\n     */\n    updateMemoryUsage(info: MemoryUsage) {\n        const numBytes =\n            this.m_vertexBuffer.count * NUM_BYTES_PER_FLOAT +\n            this.m_indexBuffer.count * NUM_BYTES_PER_INT32;\n        info.heapSize += numBytes;\n        info.gpuSize += numBytes;\n    }\n\n    private resizeBuffers(size: number) {\n        this.m_currentCapacity = size;\n\n        const newVertexBuffer = new Float32Array(size * QUAD_VERTEX_MEMORY_FOOTPRINT);\n        newVertexBuffer.set(this.m_vertexBuffer.array);\n        this.m_vertexBuffer = new THREE.InterleavedBuffer(newVertexBuffer, VERTEX_BUFFER_STRIDE);\n        this.m_vertexBuffer.setUsage(THREE.DynamicDrawUsage);\n        this.m_positionAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 0);\n        this.m_uvAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 4);\n        this.m_colorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 8);\n        this.m_bgColorAttribute = new THREE.InterleavedBufferAttribute(this.m_vertexBuffer, 4, 12);\n\n        const newIndexBuffer = new Uint32Array(size * QUAD_INDEX_MEMORY_FOOTPRINT);\n        newIndexBuffer.set(this.m_indexBuffer.array);\n        this.m_indexBuffer = new THREE.BufferAttribute(newIndexBuffer, INDEX_BUFFER_STRIDE);\n        this.m_indexBuffer.setUsage(THREE.DynamicDrawUsage);\n\n        this.m_geometry.dispose();\n        this.m_geometry = new THREE.BufferGeometry();\n        this.m_geometry.setAttribute(\"position\", this.m_positionAttribute);\n        this.m_geometry.setAttribute(\"uv\", this.m_uvAttribute);\n        this.m_geometry.setAttribute(\"color\", this.m_colorAttribute);\n        this.m_geometry.setAttribute(\"bgColor\", this.m_bgColorAttribute);\n        this.m_geometry.setIndex(this.m_indexBuffer);\n\n        this.m_pickingDataArray.length = this.m_currentCapacity;\n\n        this.scene.remove(this.m_bgMesh, this.m_mesh);\n        this.m_mesh = new THREE.Mesh(this.m_geometry, this.m_mesh.material);\n        this.m_bgMesh = new THREE.Mesh(this.m_geometry, this.m_bgMesh.material);\n        this.m_mesh.renderOrder = Number.MAX_SAFE_INTEGER;\n        this.m_bgMesh.renderOrder = Number.MAX_SAFE_INTEGER - 1;\n        this.m_mesh.frustumCulled = false;\n        this.m_bgMesh.frustumCulled = false;\n        this.scene.add(this.m_bgMesh, this.m_mesh);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { convertFragmentShaderToWebGL2, convertVertexShaderToWebGL2 } from \"@here/harp-utils\";\nimport * as THREE from \"three\";\n\nconst SdfShaderChunks = {\n    sdf_attributes: `\n        attribute vec4 position;\n        attribute vec4 uv;\n        attribute vec4 color;\n        attribute vec4 bgColor;\n        `,\n    sdf_varying: `\n        varying vec4 vColor;\n        varying float vWeight;\n        varying vec2 vUv;\n        varying float vRotation;\n        `,\n    sdf_varying_computation: `\n        #if BG_TEXT\n        vColor = bgColor;\n        vWeight = uv.w;\n        #else\n        vColor = color;\n        vWeight = uv.z;\n        #endif\n        vUv = vec2(uv.xy);\n        vRotation = position.w;\n        `,\n    sdf_frag_uniforms: `\n        uniform sampler2D sdfTexture;\n        uniform vec4 sdfParams;\n        `,\n    sdf_sampling_functions: `\n        float median(float r, float g, float b) {\n            return max(min(r, g), min(max(r, g), b));\n        }\n\n        float getDistance(vec2 uvOffset) {\n            vec3 texSample = texture2D(sdfTexture, vUv.xy + uvOffset).rgb;\n            #if MSDF\n            return median(texSample.r, texSample.g, texSample.b);\n            #else\n            return texSample.r;\n            #endif\n        }\n\n        float getOpacity(vec2 uvOffset, float weight) {\n            vec2 uv = vUv + uvOffset;\n            vec2 rotatedUVs = abs(vec2(\n                cos(vRotation) * uv.x - sin(vRotation) * uv.y,\n                sin(vRotation) * uv.x + cos(vRotation) * uv.y));\n\n            float dx = dFdx(rotatedUVs.x) * sdfParams.x;\n            float dy = dFdy(rotatedUVs.y) * sdfParams.y;\n            float toPixels = sdfParams.w * inversesqrt( dx * dx + dy * dy );\n\n            float dist = getDistance(uvOffset) + min(weight, 0.5 - 1.0 / sdfParams.w) - 0.5;\n            return clamp(dist * toPixels + 0.5, 0.0, 1.0);\n        }\n        `\n};\nObject.assign(THREE.ShaderChunk, SdfShaderChunks);\n\nconst clearVertexSource: string = `\n    attribute vec2 position;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\n\nconst clearFragmentSource: string = `\n    precision highp float;\n    precision highp int;\n\n    void main() {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }`;\n\nconst copyVertexSource: string = `\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vUv;\n\n    void main() {\n        vUv = vec3(uv.xy, position.z);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xy, 0.0, 1.0);\n    }`;\n\nconst copyFragmentSource: string = `\n    precision highp float;\n    precision highp int;\n\n    uniform float pageOffset;\n    uniform sampler2D page0;\n    uniform sampler2D page1;\n    uniform sampler2D page2;\n    uniform sampler2D page3;\n    uniform sampler2D page4;\n    uniform sampler2D page5;\n    uniform sampler2D page6;\n    uniform sampler2D page7;\n\n    varying vec3 vUv;\n\n    void main() {\n        vec4 texSample = vec4(0.0);\n        if (vUv.z < pageOffset || vUv.z > (pageOffset + 7.0)) discard;\n        else if (vUv.z < pageOffset + 1.0) texSample = texture2D(page0, vUv.xy);\n        else if (vUv.z < pageOffset + 2.0) texSample = texture2D(page1, vUv.xy);\n        else if (vUv.z < pageOffset + 3.0) texSample = texture2D(page2, vUv.xy);\n        else if (vUv.z < pageOffset + 4.0) texSample = texture2D(page3, vUv.xy);\n        else if (vUv.z < pageOffset + 5.0) texSample = texture2D(page4, vUv.xy);\n        else if (vUv.z < pageOffset + 6.0) texSample = texture2D(page5, vUv.xy);\n        else if (vUv.z < pageOffset + 7.0) texSample = texture2D(page6, vUv.xy);\n        else texSample = texture2D(page7, vUv.xy);\n\n        gl_FragColor = texSample;\n    }`;\n\nconst sdfTextVertexSource: string = `\n    #include <sdf_attributes>\n    #include <sdf_varying>\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        #include <sdf_varying_computation>\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.xyz, 1.0);\n    }`;\n\nconst sdfTextFragmentSource: string = `\n    precision highp float;\n    precision highp int;\n\n    #include <sdf_varying>\n    #include <sdf_frag_uniforms>\n    #include <sdf_sampling_functions>\n\n    void main() {\n        vec4 color = vColor;\n        color.a *= getOpacity(vec2(0.0), vWeight);\n        if (color.a < 0.05) {\n            discard;\n        }\n        gl_FragColor = color;\n    }`;\n\ninterface RendererMaterialParameters {\n    rendererCapabilities: THREE.WebGLCapabilities;\n}\n\ninterface RawShaderMaterialParameters extends THREE.ShaderMaterialParameters {\n    rendererCapabilities: THREE.WebGLCapabilities;\n}\n\nclass RawShaderMaterial extends THREE.RawShaderMaterial {\n    /**\n     * The constructor of `RawShaderMaterial`.\n     *\n     * @param params - `RawShaderMaterial` parameters.  Always required except when cloning\n     * another material.\n     */\n    constructor(params?: RawShaderMaterialParameters) {\n        const isWebGL2 = params?.rendererCapabilities.isWebGL2 === true;\n\n        const shaderParams: THREE.ShaderMaterialParameters | undefined = params\n            ? {\n                  ...params,\n                  glslVersion: isWebGL2 ? THREE.GLSL3 : THREE.GLSL1,\n                  vertexShader:\n                      isWebGL2 && params.vertexShader\n                          ? convertVertexShaderToWebGL2(params.vertexShader)\n                          : params.vertexShader,\n                  fragmentShader:\n                      isWebGL2 && params.fragmentShader\n                          ? convertFragmentShaderToWebGL2(params.fragmentShader)\n                          : params.fragmentShader\n              }\n            : undefined;\n        // Remove properties that are not in THREE.ShaderMaterialParameters, otherwise THREE.js\n        // will log warnings.\n        if (shaderParams) {\n            delete (shaderParams as any).rendererCapabilities;\n        }\n        super(shaderParams);\n    }\n}\n\n/**\n * @hidden\n * Material used for clearing glyphs from a [[GlyphTextureCache]].\n */\nexport class GlyphClearMaterial extends RawShaderMaterial {\n    /**\n     * Creates a new `GlyphClearMaterial`.\n     * @param params - Material parameters. Always required except when cloning another\n     * material.\n     * @returns New `GlyphClearMaterial`.\n     */\n    constructor(params?: RendererMaterialParameters) {\n        const shaderParams: RawShaderMaterialParameters | undefined = params\n            ? {\n                  name: \"GlyphClearMaterial\",\n                  vertexShader: clearVertexSource,\n                  fragmentShader: clearFragmentSource,\n                  uniforms: {},\n                  depthTest: false,\n                  depthWrite: false,\n                  rendererCapabilities: params.rendererCapabilities\n              }\n            : undefined;\n        super(shaderParams);\n    }\n}\n\n/**\n * @hidden\n * Material used for copying glyphs into a [[GlyphTextureCache]].\n */\nexport class GlyphCopyMaterial extends RawShaderMaterial {\n    /**\n     * Creates a new `GlyphCopyMaterial`.\n     * @param params - Material parameters. Always required except when cloning another\n     * material.\n     * @returns New `GlyphCopyMaterial`.\n     */\n    constructor(params?: RawShaderMaterialParameters) {\n        const shaderParams: RawShaderMaterialParameters | undefined = params\n            ? {\n                  name: \"GlyphCopyMaterial\",\n                  vertexShader: copyVertexSource,\n                  fragmentShader: copyFragmentSource,\n                  uniforms: {\n                      pageOffset: new THREE.Uniform(0.0),\n                      page0: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                      page1: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                      page2: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                      page3: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                      page4: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                      page5: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                      page6: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE),\n                      page7: new THREE.Uniform(THREE.Texture.DEFAULT_IMAGE)\n                  },\n                  depthTest: false,\n                  depthWrite: false,\n                  rendererCapabilities: params.rendererCapabilities\n              }\n            : undefined;\n        super(shaderParams);\n    }\n}\n\n/**\n * @hidden\n * Material parameters passed on [[SdfTextMaterial]] creation.\n */\nexport interface SdfTextMaterialParameters extends RendererMaterialParameters {\n    texture: THREE.Texture;\n    textureSize: THREE.Vector2;\n    size: number;\n    distanceRange: number;\n    isMsdf: boolean;\n    isBackground: boolean;\n    vertexSource?: string;\n    fragmentSource?: string;\n}\n\n/**\n * Material designed to render transformable, high quality SDF text.\n */\nexport class SdfTextMaterial extends RawShaderMaterial {\n    /**\n     * Creates a new `SdfTextMaterial`.\n     *\n     * @param params - Material parameters. Always required except when cloning another\n     * material.\n     * @returns New `SdfTextMaterial`.\n     */\n    constructor(params?: SdfTextMaterialParameters) {\n        const shaderParams: RawShaderMaterialParameters | undefined = params\n            ? {\n                  name: \"SdfTextMaterial\",\n                  vertexShader:\n                      params.vertexSource !== undefined ? params.vertexSource : sdfTextVertexSource,\n                  fragmentShader:\n                      params.fragmentSource !== undefined\n                          ? params.fragmentSource\n                          : sdfTextFragmentSource,\n                  uniforms: {\n                      sdfTexture: new THREE.Uniform(params.texture),\n                      sdfParams: new THREE.Uniform(\n                          new THREE.Vector4(\n                              params.textureSize.x,\n                              params.textureSize.y,\n                              params.size,\n                              params.distanceRange\n                          )\n                      )\n                  },\n                  defines: {\n                      MSDF: params.isMsdf ? 1.0 : 0.0,\n                      BG_TEXT: params.isBackground ? 1.0 : 0.0\n                  },\n                  depthTest: true,\n                  depthWrite: false,\n                  side: THREE.DoubleSide,\n                  transparent: true,\n                  rendererCapabilities: params.rendererCapabilities\n              }\n            : undefined;\n        super(shaderParams);\n        this.extensions.derivatives = true;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\n/**\n * Unit of measurement used to specify a font's size.\n */\nexport enum FontUnit {\n    Em,\n    Pixel,\n    Point,\n    Percent\n}\n\n/**\n * Pair of unit and size specifying a font's size.\n */\nexport interface FontSize {\n    unit: FontUnit;\n    size: number;\n    backgroundSize: number;\n}\n\n/**\n * Style to be used when rendering glyphs.\n */\nexport enum FontStyle {\n    Regular,\n    Bold,\n    Italic,\n    BoldItalic\n}\n\n/**\n * Variant to be used when rendering.\n */\nexport enum FontVariant {\n    Regular,\n    AllCaps,\n    SmallCaps\n}\n\n/**\n * Vertical alignment to be used when placing text.\n */\nexport enum VerticalAlignment {\n    Above = 0.0,\n    Center = -0.5,\n    Below = -1.0\n}\n\n/**\n * Horizontal alignment to be used when placing text.\n */\nexport enum HorizontalAlignment {\n    Left = 0.0,\n    Center = -0.5,\n    Right = -1.0\n}\n\n/**\n * Vertical position of text area relative to the placement context (point, line).\n */\nexport enum VerticalPlacement {\n    Top = 0.0,\n    Center = -0.5,\n    Bottom = -1.0\n}\n\n/**\n * Horizontal position of text element relative to the placement context (point, line).\n *\n * @note [[HorizontalPlacement]] value is exactly opposite to [[HorizontalAlignment]] value,\n * cause when you place text on the right side of point (or icon) it will be left-aligned.\n */\nexport enum HorizontalPlacement {\n    Left = -1.0,\n    Center = -0.5,\n    Right = 0.0\n}\n\nexport interface TextPlacement {\n    v: VerticalPlacement;\n    h: HorizontalPlacement;\n}\n\nexport type TextPlacements = TextPlacement[];\n\n/**\n * Text wrapping rule used when `lineWidth` is reached.\n */\nexport enum WrappingMode {\n    None,\n    Character,\n    Word\n}\n\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[HorizontalAlignment]] from [[HorizontalPlacement]].\n * Horizontal alignments are exactly opposite to the placements.\n */\nexport function hAlignFromPlacement(hP: HorizontalPlacement): HorizontalAlignment {\n    return (hP as unknown) as HorizontalAlignment;\n}\n\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[VerticalAlignment]] from [[VerticalPlacement]].\n */\nexport function vAlignFromPlacement(vP: VerticalPlacement): VerticalAlignment {\n    return (vP as unknown) as VerticalAlignment;\n}\n\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[HorizontalPlacement]] from [[HorizontalAlignment]].\n * Horizontal placements are exactly opposite to the alignment values.\n */\nexport function hPlacementFromAlignment(hA: HorizontalAlignment): HorizontalPlacement {\n    return (hA as unknown) as HorizontalPlacement;\n}\n\n/**\n * @hidden\n * @internal\n * Utility function that gets deduced [[VerticalPlacement]] from [[VerticalAlignment]].\n */\nexport function vPlacementFromAlignment(vA: VerticalAlignment): VerticalPlacement {\n    return (vA as unknown) as VerticalPlacement;\n}\n\n/**\n * Namespace containing default values for all members of [[TextRenderParameters]] and\n * [[TextLayoutParameters]].\n */\nexport namespace DefaultTextStyle {\n    export const DEFAULT_FONT_NAME: string = \"\";\n    export const DEFAULT_FONT_SIZE: FontSize = {\n        unit: Object.freeze(FontUnit.Pixel),\n        size: Object.freeze(16.0),\n        backgroundSize: Object.freeze(0.0)\n    };\n    export const DEFAULT_FONT_STYLE: FontStyle = FontStyle.Regular;\n    export const DEFAULT_FONT_VARIANT: FontVariant = FontVariant.Regular;\n    export const DEFAULT_ROTATION: number = 0.0;\n    export const DEFAULT_COLOR: THREE.Color = new THREE.Color(0x000000);\n    export const DEFAULT_OPACITY: number = 1.0;\n    export const DEFAULT_BACKGROUND_COLOR: THREE.Color = new THREE.Color(0x000000);\n    export const DEFAULT_BACKGROUND_OPACITY: number = 0.0;\n\n    export const DEFAULT_TRACKING: number = 0.0;\n    export const DEFAULT_LEADING: number = 0.0;\n    export const DEFAULT_MAX_LINES: number = Infinity;\n    export const DEFAULT_LINE_WIDTH: number = Infinity;\n    export const DEFAULT_CANVAS_ROTATION: number = 0.0;\n    export const DEFAULT_LINE_ROTATION: number = 0.0;\n    export const DEFAULT_WRAPPING_MODE: WrappingMode = WrappingMode.Word;\n    export const DEFAULT_VERTICAL_ALIGNMENT: VerticalAlignment = VerticalAlignment.Above;\n    export const DEFAULT_HORIZONTAL_ALIGNMENT: HorizontalAlignment = HorizontalAlignment.Left;\n    export const DEFAULT_PLACEMENTS: TextPlacement[] = [];\n}\n\n/**\n * [[TextCanvas]] text rendering parameters.\n */\nexport interface TextRenderParameters {\n    fontName?: string;\n    fontSize?: FontSize;\n    fontStyle?: FontStyle;\n    fontVariant?: FontVariant;\n    rotation?: number;\n    color?: THREE.Color;\n    backgroundColor?: THREE.Color;\n    opacity?: number;\n    backgroundOpacity?: number;\n}\n\n/**\n * [[TextCanvas]] text rendering style.\n */\nexport class TextRenderStyle {\n    private m_params: TextRenderParameters;\n\n    /**\n     * Creates a new `TextRenderStyle`.\n     *\n     * @param params - Input [[TextRenderParameters]].\n     *\n     * @returns New `TextRenderStyle`.\n     */\n    constructor(params: TextRenderParameters = {}) {\n        this.m_params = {\n            fontName:\n                params.fontName !== undefined\n                    ? params.fontName\n                    : DefaultTextStyle.DEFAULT_FONT_NAME,\n            fontSize:\n                params.fontSize !== undefined\n                    ? { ...params.fontSize }\n                    : {\n                          unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,\n                          size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,\n                          backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize\n                      },\n            fontStyle:\n                params.fontStyle !== undefined\n                    ? params.fontStyle\n                    : DefaultTextStyle.DEFAULT_FONT_STYLE,\n            fontVariant:\n                params.fontVariant !== undefined\n                    ? params.fontVariant\n                    : DefaultTextStyle.DEFAULT_FONT_VARIANT,\n            rotation:\n                params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,\n            color:\n                params.color !== undefined\n                    ? params.color.clone()\n                    : DefaultTextStyle.DEFAULT_COLOR.clone(),\n            opacity:\n                params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,\n            backgroundColor:\n                params.backgroundColor !== undefined\n                    ? params.backgroundColor.clone()\n                    : DefaultTextStyle.DEFAULT_BACKGROUND_COLOR.clone(),\n            backgroundOpacity:\n                params.backgroundOpacity !== undefined\n                    ? params.backgroundOpacity\n                    : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY\n        };\n    }\n\n    /**\n     * Current [[TextRenderParameters]] for this style.\n     */\n    get params(): TextRenderParameters {\n        return this.m_params;\n    }\n\n    set params(value: TextRenderParameters) {\n        this.m_params = { ...this.m_params, ...value };\n    }\n\n    /**\n     * Name of the preferred [[Font]] to be used when rendering.\n     */\n    get fontName(): string {\n        return this.m_params.fontName!;\n    }\n\n    set fontName(value: string) {\n        this.m_params.fontName = value;\n    }\n\n    /**\n     * Collection of unit and sizes to apply for the currently active [[Font]].\n     */\n    get fontSize(): FontSize {\n        return this.m_params.fontSize!;\n    }\n\n    set fontSize(value: FontSize) {\n        this.m_params.fontSize = { ...value };\n    }\n\n    /**\n     * Glyph style to apply for the currently active [[Font]].\n     */\n    get fontStyle(): FontStyle {\n        return this.m_params.fontStyle!;\n    }\n\n    set fontStyle(value: FontStyle) {\n        this.m_params.fontStyle = value;\n    }\n\n    /**\n     * Glyph variant to apply for the currently active [[Font]].\n     */\n    get fontVariant(): FontVariant {\n        return this.m_params.fontVariant!;\n    }\n\n    set fontVariant(value: FontVariant) {\n        this.m_params.fontVariant = value;\n    }\n\n    /**\n     * Glyph local rotation (radians).\n     */\n    get rotation(): number {\n        return this.m_params.rotation!;\n    }\n\n    set rotation(value: number) {\n        this.m_params.rotation = value;\n    }\n\n    /**\n     * Glyph color.\n     */\n    get color(): THREE.Color {\n        return this.m_params.color!;\n    }\n\n    set color(value: THREE.Color) {\n        this.m_params.color!.copy(value);\n    }\n\n    /**\n     * Glyph background color.\n     */\n    get backgroundColor(): THREE.Color {\n        return this.m_params.backgroundColor!;\n    }\n\n    set backgroundColor(value: THREE.Color) {\n        this.m_params.backgroundColor!.copy(value);\n    }\n\n    /**\n     * Glyph opacity.\n     */\n    get opacity(): number {\n        return this.m_params.opacity!;\n    }\n\n    set opacity(value: number) {\n        this.m_params.opacity = value;\n    }\n\n    /**\n     * Glyph background opacity.\n     */\n    get backgroundOpacity(): number {\n        return this.m_params.backgroundOpacity!;\n    }\n\n    set backgroundOpacity(value: number) {\n        this.m_params.backgroundOpacity = value;\n    }\n\n    /**\n     * Clone this [[TextRenderStyle]].\n     *\n     * @param params - Input [[TextRenderParameters]].\n     *\n     * @returns Cloned [[TextRenderStyle]].\n     */\n    clone(params: TextRenderParameters = {}): TextRenderStyle {\n        return new TextRenderStyle({ ...this.m_params, ...params });\n    }\n\n    /**\n     * Copy other [[TextRenderStyle]] properties into this object instance.\n     *\n     * @param source - The source object to be copied.\n     *\n     * @returns reference to `this` object.\n     */\n    copy(source: TextRenderStyle): TextRenderStyle {\n        // Given that all source and this params are always defined:\n        this.m_params.fontName = source.fontName;\n        this.m_params.fontSize = { ...source.fontSize };\n        this.m_params.fontStyle = source.fontStyle;\n        this.m_params.fontVariant = source.fontVariant;\n        this.m_params.rotation = source.rotation;\n        this.m_params.color!.copy(source.color);\n        this.m_params.backgroundColor!.copy(source.backgroundColor);\n        this.m_params.opacity = source.opacity;\n        this.m_params.backgroundOpacity = source.backgroundOpacity;\n        return this;\n    }\n}\n\n/**\n * [[TextCanvas]] text layout parameters.\n */\nexport interface TextLayoutParameters {\n    tracking?: number;\n    leading?: number;\n    maxLines?: number;\n    lineWidth?: number;\n    canvasRotation?: number;\n    lineRotation?: number;\n    wrappingMode?: WrappingMode;\n    verticalAlignment?: VerticalAlignment;\n    horizontalAlignment?: HorizontalAlignment;\n    placements?: TextPlacements;\n}\n\n/**\n * [[TextCanvas]] text rendering style.\n */\nexport class TextLayoutStyle {\n    private m_params: TextLayoutParameters;\n\n    /**\n     * Creates a new `TextLayoutStyle`.\n     *\n     * @param params - Input [[TextLayoutParameters]].\n     *\n     * @returns New `TextLayoutStyle`.\n     */\n    constructor(params: TextLayoutParameters = {}) {\n        // Solve alignment and placement dependencies and fallbacks.\n        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(\n            params.horizontalAlignment,\n            params.verticalAlignment,\n            params.placements\n        );\n        this.m_params = {\n            tracking:\n                params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,\n            leading:\n                params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,\n            maxLines:\n                params.maxLines !== undefined\n                    ? params.maxLines\n                    : DefaultTextStyle.DEFAULT_MAX_LINES,\n            lineWidth:\n                params.lineWidth !== undefined\n                    ? params.lineWidth\n                    : DefaultTextStyle.DEFAULT_LINE_WIDTH,\n            canvasRotation:\n                params.canvasRotation !== undefined\n                    ? params.canvasRotation\n                    : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,\n            lineRotation:\n                params.lineRotation !== undefined\n                    ? params.lineRotation\n                    : DefaultTextStyle.DEFAULT_LINE_ROTATION,\n            wrappingMode:\n                params.wrappingMode !== undefined\n                    ? params.wrappingMode\n                    : DefaultTextStyle.DEFAULT_WRAPPING_MODE,\n            verticalAlignment,\n            horizontalAlignment,\n            placements\n        };\n    }\n\n    /**\n     * Current [[TextLayoutParameters]] for this style.\n     */\n    get params(): TextLayoutParameters {\n        return this.m_params;\n    }\n\n    set params(value: TextLayoutParameters) {\n        this.m_params = { ...this.m_params, ...value };\n    }\n\n    /**\n     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].\n     */\n    get tracking(): number {\n        return this.m_params.tracking!;\n    }\n\n    set tracking(value: number) {\n        this.m_params.tracking = value;\n    }\n\n    /**\n     * Inter-line spacing (pixels). Scaled by [[FontSize]].\n     */\n    get leading(): number {\n        return this.m_params.leading!;\n    }\n\n    set leading(value: number) {\n        this.m_params.leading = value;\n    }\n\n    /**\n     * Maximum number of lines to be considered when using [[TextCanvas]].\n     */\n    get maxLines(): number {\n        return this.m_params.maxLines!;\n    }\n\n    set maxLines(value: number) {\n        this.m_params.maxLines = value;\n    }\n\n    /**\n     * Maximum line width (pixels).\n     */\n    get lineWidth(): number {\n        return this.m_params.lineWidth!;\n    }\n\n    set lineWidth(value: number) {\n        this.m_params.lineWidth = value;\n    }\n\n    /**\n     * [[TextCanvas]] rotation (radians).\n     */\n    get canvasRotation(): number {\n        return this.m_params.canvasRotation!;\n    }\n\n    set canvasRotation(value: number) {\n        this.m_params.canvasRotation = value;\n    }\n\n    /**\n     * Line typesetting rotation (radians).\n     */\n    get lineRotation(): number {\n        return this.m_params.lineRotation!;\n    }\n\n    set lineRotation(value: number) {\n        this.m_params.lineRotation = value;\n    }\n\n    /**\n     * Wrapping (line-breaking) mode.\n     */\n    get wrappingMode(): WrappingMode {\n        return this.m_params.wrappingMode!;\n    }\n\n    set wrappingMode(value: WrappingMode) {\n        this.m_params.wrappingMode = value;\n    }\n\n    /**\n     * Text position regarding the baseline.\n     */\n    get verticalAlignment(): VerticalAlignment {\n        return this.m_params.verticalAlignment!;\n    }\n\n    set verticalAlignment(value: VerticalAlignment) {\n        this.m_params.verticalAlignment = value;\n    }\n\n    /**\n     * Text position inside a line.\n     */\n    get horizontalAlignment(): HorizontalAlignment {\n        return this.m_params.horizontalAlignment!;\n    }\n\n    set horizontalAlignment(value: HorizontalAlignment) {\n        this.m_params.horizontalAlignment = value;\n    }\n\n    /**\n     * Text placement options relative to label anchor (origin).\n     *\n     * @note [[TextPlacement]]s options may override alignment settings.\n     */\n    get placements(): TextPlacements {\n        return this.m_params.placements!;\n    }\n\n    set placements(value: TextPlacements) {\n        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(\n            this.horizontalAlignment,\n            this.verticalAlignment,\n            value\n        );\n        this.m_params.horizontalAlignment = horizontalAlignment;\n        this.m_params.verticalAlignment = verticalAlignment;\n        this.m_params.placements = placements;\n    }\n\n    /**\n     * Clone this [[TextLayoutStyle]].\n     *\n     * @param params - Input [[TextLayoutParameters]].\n     *\n     * @returns Cloned [[TextLayoutStyle]].\n     */\n    clone(params: TextLayoutParameters = {}): TextLayoutStyle {\n        return new TextLayoutStyle({ ...this.m_params, ...params });\n    }\n\n    /**\n     * Copy other [[TextLayoutStyle]] properties into this object instance.\n     *\n     * @param other - The object to be copied.\n     *\n     * @returns reference to `this` object.\n     */\n    copy(other: TextLayoutStyle): TextLayoutStyle {\n        this.params = { ...other.params };\n        return this;\n    }\n}\n\n/**\n * Deduce alignment and placement attributes depending on the availability.\n *\n * If placement is defined it may override alignment settings, if no attributes are\n * provided they may be retrieved from defaults.\n *\n * @param hAlignment - The optional horizontal alignment.\n * @param vAlignment - The vertical alignment - optional.\n * @param placementsOpt - Possible text placements - optional.\n * @internal\n */\nexport function resolvePlacementAndAlignment(\n    hAlignment?: HorizontalAlignment,\n    vAlignment?: VerticalAlignment,\n    placementsOpt?: TextPlacements\n): {\n    horizontalAlignment: HorizontalAlignment;\n    verticalAlignment: VerticalAlignment;\n    placements: TextPlacements;\n} {\n    // Make a deep copy or create new array from defaults.\n    const placements: TextPlacements =\n        placementsOpt?.map(v => ({ ...v })) ??\n        DefaultTextStyle.DEFAULT_PLACEMENTS.map(v => ({ ...v }));\n    // Ignore alignment attributes when placements attributes are defined or provide default\n    // values if none of them are provided.\n    // NOTE: Alignment override may be removed if we decide to support both attributes.\n    const horizontalAlignment =\n        placements.length > 0\n            ? hAlignFromPlacement(placements[0].h)\n            : hAlignment ?? DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;\n\n    const verticalAlignment =\n        placements.length > 0\n            ? vAlignFromPlacement(placements[0].v)\n            : vAlignment ?? DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;\n\n    return { horizontalAlignment, verticalAlignment, placements };\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { QUAD_VERTEX_MEMORY_FOOTPRINT } from \"../rendering/TextGeometry\";\nimport { FontStyle, FontVariant, WrappingMode } from \"../rendering/TextStyle\";\nimport { TypesettingUtils } from \"../utils/TypesettingUtils\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { Typesetter, TypesettingParameters } from \"./Typesetter\";\n\n/**\n * [[Typesetter]] implementation that handles multi-line complex layout text.\n */\nexport class LineTypesetter implements Typesetter {\n    private readonly m_tempTransform: THREE.Matrix3;\n    private readonly m_tempCorners: THREE.Vector3[];\n    private m_tempLineDirection: UnicodeUtils.Direction;\n    private m_tempRunDirection: UnicodeUtils.Direction;\n    private m_tempPixelSize: number;\n    private m_tempPixelBgSize: number;\n    private m_tempScale: number;\n    private m_tempSmallCaps: boolean;\n\n    private m_currentParams?: TypesettingParameters;\n\n    /**\n     * Creates a `LineTypesetter` object.\n     *\n     * @returns New `LineTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n    }\n\n    /**\n     * Arranges the specified glyphs using this `LineTypesetter`. Text will be placed into multiple\n     * bidirectional lines, that will be generated taking into account [[textLayoutStyle]] features,\n     * such as:\n     * - Maximum line width.\n     * - Word and character wrapping.\n     * - Maximum number of lines.\n     * - Vertical and horizontal alignment.\n     * - Leading (spacing between lines).\n     *\n     * @param params - Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params: TypesettingParameters): boolean {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils.getPixelSize(\n            this.m_currentParams.textRenderStyle.fontSize.size,\n            this.m_currentParams.textRenderStyle.fontSize.unit,\n            this.m_currentParams.fontCatalog.size\n        );\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(\n            TypesettingUtils.getPixelSize(\n                this.m_currentParams.textRenderStyle.fontSize.backgroundSize,\n                this.m_currentParams.textRenderStyle.fontSize.unit,\n                this.m_currentParams.fontCatalog.size\n            ),\n            this.m_currentParams!.fontCatalog.distanceRange * this.m_tempScale\n        );\n        this.m_tempSmallCaps = this.m_currentParams!.smallCapsArray !== undefined;\n\n        this.m_currentParams.position.y +=\n            this.m_currentParams.textLayoutStyle.verticalAlignment *\n            this.m_currentParams.glyphs[0].font.metrics.capHeight *\n            this.m_tempScale;\n\n        const isOnlyMeasured =\n            this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n\n        // Compute line origin and height.\n        const origin = this.m_currentParams.position.x;\n        const lineHeight =\n            this.m_currentParams.glyphs[0].font.metrics.lineHeight +\n            this.m_currentParams.textLayoutStyle.leading;\n\n        // Initialize line-breaking and wrapping variables.\n        let lineStartIdx = 0;\n        let glyphWrapIdx = 0;\n        let wordWrapIdx = 0;\n        let lineStartX = 0;\n        let lineCurrX = 0;\n        let glyphWrapX = 0;\n        let wordWrapX = 0;\n\n        let lineCount = 0;\n        let isBidirectionalLine = false;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            if (lineCount > this.m_currentParams.textLayoutStyle.maxLines - 1) {\n                break;\n            }\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n\n            const isNewLine = UnicodeUtils.isNewLine(glyphData.codePoint);\n            const isWhiteSpace = UnicodeUtils.isWhiteSpace(glyphData.codePoint);\n\n            // Check if this line should be treated as bidirectional.\n            if (!isBidirectionalLine && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectionalLine = true;\n            }\n            // Advance the line's current X offset (only for printable characters).\n            if (UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                lineCurrX +=\n                    (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                    this.m_tempScale *\n                    (this.m_tempSmallCaps\n                        ? TypesettingUtils.getSmallCapsScale(\n                              this.m_currentParams.glyphs,\n                              this.m_currentParams.smallCapsArray!,\n                              i,\n                              this.m_currentParams.textRenderStyle.fontVariant\n                          )\n                        : 1.0);\n            }\n            // If this is the first character in a line, update the line's X offset values (needed\n            // to properly center and wrap).\n            if (i === lineStartIdx) {\n                lineStartX = lineCurrX;\n                glyphWrapX = lineCurrX;\n                wordWrapX = lineCurrX;\n            }\n\n            // Check if should break the current line.\n            if (\n                isNewLine ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Character &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth) ||\n                (this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Word &&\n                    lineCurrX > this.m_currentParams.textLayoutStyle.lineWidth &&\n                    wordWrapX !== lineStartX)\n            ) {\n                // Perform wrapping.\n                if (this.m_currentParams.textLayoutStyle.wrappingMode !== WrappingMode.None) {\n                    let wrapPointIdx = glyphWrapIdx;\n                    let wrapPointX = glyphWrapX;\n                    // Only wrap words when more than a single word fits into the current line.\n                    if (\n                        this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Word &&\n                        wordWrapX !== lineStartX\n                    ) {\n                        wrapPointIdx = wordWrapIdx;\n                        wrapPointX = wordWrapX;\n                    }\n\n                    lineCurrX = wrapPointX;\n                    i = Math.min(\n                        isNewLine ? (lineStartIdx === i ? wrapPointIdx : i) : wrapPointIdx,\n                        this.m_currentParams.glyphs.length - 1\n                    );\n                }\n\n                // Calculate the correct starting position for the line base on alignment, and place\n                // all glyphs in it.\n                const lineAlignment =\n                    this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine\n                        ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                        : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n                this.m_currentParams.position.x =\n                    this.m_currentParams.position.x + lineCurrX * lineAlignment;\n                if (\n                    !this.placeLine(lineStartIdx, i, this.m_tempLineDirection, isBidirectionalLine)\n                ) {\n                    return false;\n                }\n\n                // Update the line position.\n                this.m_currentParams.position.y -= lineHeight * this.m_tempScale;\n                this.m_currentParams.position.x = origin;\n\n                // Find the beginning of a new line (removing trailing white spaces).\n                while (\n                    i !== lineStartIdx &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint)\n                ) {\n                    ++i;\n                }\n                lineStartIdx = i + 1;\n                if (lineStartIdx === this.m_currentParams.glyphs.length) {\n                    break;\n                }\n\n                // Only reset the line's direction when a new line character is found (to keep\n                // correct bidirectional behaviour when a bidirectional run is placed between\n                // multiple lines).\n                if (isNewLine) {\n                    this.m_tempLineDirection = TypesettingUtils.getDirection(\n                        this.m_currentParams.glyphs,\n                        lineStartIdx\n                    );\n                    this.m_tempRunDirection = this.m_tempLineDirection;\n                }\n\n                // Reset the line placement parameters.\n                lineStartX = 0;\n                lineCurrX = 0;\n                glyphWrapIdx = lineStartIdx;\n                glyphWrapX = 0;\n                wordWrapIdx = lineStartIdx;\n                wordWrapX = 0;\n                isBidirectionalLine = false;\n                lineCount++;\n            }\n            // If not, should if we should record any new wrapping points.\n            else if (\n                this.m_currentParams.textLayoutStyle.wrappingMode !== WrappingMode.None &&\n                !isWhiteSpace\n            ) {\n                // Update the per-glyph wrapping point.\n                glyphWrapIdx = i;\n                glyphWrapX = lineCurrX;\n\n                // Update the word wrapping point (only if mode is correctly set and we are\n                // currently placed at the end of a word).\n                if (\n                    this.m_currentParams.textLayoutStyle.wrappingMode === WrappingMode.Word &&\n                    i + 1 < this.m_currentParams.glyphs.length &&\n                    (UnicodeUtils.isWhiteSpace(this.m_currentParams.glyphs[i + 1].codePoint) ||\n                        UnicodeUtils.isNewLine(this.m_currentParams.glyphs[i + 1].codePoint))\n                ) {\n                    wordWrapIdx = i;\n                    wordWrapX = lineCurrX;\n                }\n            }\n        }\n\n        // If we still haven't placed all characters, place a final line.\n        if (\n            lineCount <= this.m_currentParams.textLayoutStyle.maxLines - 1 &&\n            lineStartIdx <= this.m_currentParams.glyphs.length - 1\n        ) {\n            const offset =\n                this.m_tempLineDirection === UnicodeUtils.Direction.RTL && isBidirectionalLine\n                    ? 1.0 + this.m_currentParams.textLayoutStyle.horizontalAlignment\n                    : this.m_currentParams.textLayoutStyle.horizontalAlignment;\n            this.m_currentParams.position.setX(\n                this.m_currentParams.position.x + lineCurrX * offset\n            );\n            if (\n                !this.placeLine(\n                    lineStartIdx,\n                    this.m_currentParams.glyphs.length - 1,\n                    this.m_tempLineDirection,\n                    isBidirectionalLine\n                )\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Place characters alongside a line. Text direction is taken into account, and text is broken\n    // into directional runs.\n    private placeLine(\n        startIdx: number,\n        endIdx: number,\n        direction: UnicodeUtils.Direction,\n        isBidirectional: boolean\n    ): boolean {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(startIdx, endIdx, direction);\n        }\n\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n        const smallCapsArray = this.m_currentParams!.smallCapsArray;\n        const textRenderStyle = this.m_currentParams!.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams!.textLayoutStyle;\n        const position = this.m_currentParams!.position;\n\n        // Initialize line placement parameters.\n        const isRTL = direction === UnicodeUtils.Direction.RTL;\n        const origin = position.x;\n        let offset = 0;\n        let runStart = startIdx;\n\n        for (let i = startIdx; i <= endIdx; ++i) {\n            const glyphData = glyphDataArray[i];\n\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (isRTL) {\n                    position.x = origin + offset;\n                }\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n                if (!isRTL) {\n                    position.x = origin + offset;\n                }\n\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (\n                glyphData.direction === UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction\n            ) {\n                let neutralIdx = i;\n                while (\n                    neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1\n                ) {\n                    ++neutralIdx;\n                }\n\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (isRTL) {\n                        position.x = origin + offset;\n                    }\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n                    if (!isRTL) {\n                        position.x = origin + offset;\n                    }\n\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n\n            // Advance the offset position in the line.\n            offset +=\n                (glyphData.advanceX + textLayoutStyle.tracking) *\n                this.m_tempScale *\n                (this.m_tempSmallCaps\n                    ? TypesettingUtils.getSmallCapsScale(\n                          glyphDataArray,\n                          smallCapsArray!,\n                          i,\n                          textRenderStyle.fontVariant\n                      )\n                    : 1.0) *\n                direction;\n        }\n\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart <= endIdx) {\n            if (isRTL) {\n                position.x = origin + offset;\n            }\n            if (!this.placeRun(runStart, endIdx, this.m_tempRunDirection)) {\n                return false;\n            }\n            if (!isRTL) {\n                position.x = origin + offset;\n            }\n        }\n\n        return true;\n    }\n\n    // Place a directional run of index inside a line.\n    private placeRun(startIdx: number, endIdx: number, direction: UnicodeUtils.Direction): boolean {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n        const smallCapsArray = this.m_currentParams!.smallCapsArray;\n        const fontCatalog = this.m_currentParams!.fontCatalog;\n        const textRenderStyle = this.m_currentParams!.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams!.textLayoutStyle;\n        const position = this.m_currentParams!.position;\n        const geometry = this.m_currentParams!.geometry;\n        const globalBounds = this.m_currentParams!.globalBounds;\n        const individualBounds = this.m_currentParams!.individualBounds;\n        const vertexBuffer = this.m_currentParams!.vertexBuffer;\n\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (\n            let i = start;\n            direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end;\n            i += direction\n        ) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (\n                startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils.Direction.Weak\n            ) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (\n                    weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))\n                ) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);\n\n                i = weakRunStart;\n                continue;\n            }\n\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n\n            const isBoldEmulated =\n                (fontStyle === FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated =\n                (fontStyle === FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray![i] && textRenderStyle.fontVariant === FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n\n            const emulationWeight =\n                ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight =\n                (0.5 * this.m_tempPixelBgSize!) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored =\n                UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils.Direction.RTL;\n            const verticalOffset =\n                glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils.computeGlyphTransform(\n                this.m_tempTransform,\n                position,\n                glyphScale,\n                textLayoutStyle.canvasRotation,\n                textRenderStyle.rotation\n            );\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset =\n                    isItalicEmulated && j > 1\n                        ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                        : 0.0;\n                this.m_tempCorners[j].set(\n                    glyphVertexPosition.x + horizontalOffset,\n                    glyphVertexPosition.y - verticalOffset,\n                    glyphVertexPosition.z\n                );\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n            }\n\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (\n                    !geometry.add(\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    )\n                ) {\n                    return false;\n                }\n            } else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils.updateBounds(\n                        this.m_tempCorners,\n                        globalBounds,\n                        individualBounds\n                    );\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(\n                        vertexBuffer,\n                        i * QUAD_VERTEX_MEMORY_FOOTPRINT,\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    );\n                }\n            }\n\n            // Advance the current position and proceed to next glyph in the run.\n            position.set(\n                position.x +\n                    (glyphData.advanceX + textLayoutStyle.tracking) *\n                        glyphScale *\n                        Math.cos(textLayoutStyle.lineRotation),\n                position.y +\n                    (glyphData.advanceX + textLayoutStyle.tracking) *\n                        glyphScale *\n                        Math.sin(textLayoutStyle.lineRotation),\n                position.z\n            );\n        }\n\n        return true;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { QUAD_VERTEX_MEMORY_FOOTPRINT } from \"../rendering/TextGeometry\";\nimport { FontStyle, FontVariant } from \"../rendering/TextStyle\";\nimport { TypesettingUtils } from \"../utils/TypesettingUtils\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\nimport { Typesetter, TypesettingParameters } from \"./Typesetter\";\n\n/**\n * @hidden\n * Parameters passed when placing glyphs using [[PathTypesetter]]'s `arrangeGlyphs` function.\n */\nexport interface PathTypesettingParameters extends TypesettingParameters {\n    /**\n     * Path to be followed when arranging glyphs.\n     */\n    path: THREE.Path | THREE.CurvePath<THREE.Vector2>;\n\n    /**\n     * If `true`, text on a path will be placed even when its size its bigger than the path's size.\n     */\n    pathOverflow: boolean;\n}\n\n/**\n * [[Typesetter]] implementation that arranges glyphs alongside a specified path.\n */\nexport class PathTypesetter implements Typesetter {\n    private readonly m_tempTransform: THREE.Matrix3;\n    private readonly m_tempCorners: THREE.Vector3[];\n    private m_tempLineDirection: UnicodeUtils.Direction;\n    private m_tempRunDirection: UnicodeUtils.Direction;\n    private m_tempPixelSize: number;\n    private m_tempPixelBgSize: number;\n    private m_tempScale: number;\n    private m_tempSmallCaps: boolean;\n\n    private readonly m_tempPathPosition: THREE.Vector3;\n    private m_tempPathLength: number;\n    private m_tempPathOffset: number;\n\n    private m_currentParams?: PathTypesettingParameters;\n\n    /**\n     * Creates a `PathTypesetter` object.\n     *\n     * @returns New `PathTypesetter`.\n     */\n    constructor() {\n        this.m_tempTransform = new THREE.Matrix3();\n        this.m_tempCorners = [\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3(),\n            new THREE.Vector3()\n        ];\n        this.m_tempLineDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempRunDirection = UnicodeUtils.Direction.LTR;\n        this.m_tempPixelSize = 1.0;\n        this.m_tempPixelBgSize = 1.0;\n        this.m_tempScale = 1.0;\n        this.m_tempSmallCaps = false;\n\n        this.m_tempPathPosition = new THREE.Vector3();\n        this.m_tempPathLength = 0.0;\n        this.m_tempPathOffset = 0.0;\n    }\n\n    /**\n     * Arranges the specified glyphs using this `PathTypesetter`. Text will be placed into a single\n     * bidirectional line that follows the specified path. Characters will be orientated and placed\n     * alongside this path following [[TextLayout]]'s [[VerticalAlignment]] and\n     * [[HorizontalAlignment]].\n     *\n     * @param params - Typesetting parameters.\n     *\n     * @returns If `false`, some error occurred during execution and the output should be dismissed.\n     */\n    arrangeGlyphs(params: PathTypesettingParameters): boolean {\n        // Initializes common typesetting parameters (used across all functions in this class).\n        this.m_currentParams = params;\n        this.m_tempLineDirection = TypesettingUtils.getDirection(this.m_currentParams.glyphs, 0);\n        this.m_tempRunDirection = this.m_tempLineDirection;\n        this.m_tempPixelSize = TypesettingUtils.getPixelSize(\n            this.m_currentParams.textRenderStyle.fontSize.size,\n            this.m_currentParams.textRenderStyle.fontSize.unit,\n            this.m_currentParams.fontCatalog.size\n        );\n        this.m_tempScale = this.m_tempPixelSize / this.m_currentParams.fontCatalog.size;\n        this.m_tempPixelBgSize = Math.min(\n            TypesettingUtils.getPixelSize(\n                this.m_currentParams.textRenderStyle.fontSize.backgroundSize,\n                this.m_currentParams.textRenderStyle.fontSize.unit,\n                this.m_currentParams.fontCatalog.size\n            ),\n            this.m_currentParams!.fontCatalog.distanceRange * this.m_tempScale\n        );\n        this.m_tempSmallCaps = this.m_currentParams!.smallCapsArray !== undefined;\n\n        this.m_tempPathLength = this.m_currentParams.path.getLength();\n        this.m_tempPathOffset = 0.0;\n\n        const isOnlyMeasured =\n            this.m_currentParams.globalBounds !== undefined &&\n            this.m_currentParams.vertexBuffer === undefined;\n\n        // To be able to properly set the horizontal alignment on a path, we need to first retrieve\n        // how much of the path the input text covers, so we can calculate the correct initial\n        // offset.\n        let isBidirectional = false;\n        let pathWidth = 0.0;\n        for (let i = 0; i < this.m_currentParams.glyphs.length; ++i) {\n            const glyphData = this.m_currentParams.glyphs[i];\n            if (!glyphData.isInCache && !isOnlyMeasured) {\n                return false;\n            }\n\n            if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n            if (!isBidirectional && glyphData.direction === -this.m_tempLineDirection) {\n                isBidirectional = true;\n            }\n\n            pathWidth +=\n                (glyphData.advanceX + this.m_currentParams.textLayoutStyle.tracking) *\n                this.m_tempScale *\n                (this.m_tempSmallCaps\n                    ? TypesettingUtils.getSmallCapsScale(\n                          this.m_currentParams.glyphs,\n                          this.m_currentParams.smallCapsArray!,\n                          i,\n                          this.m_currentParams.textRenderStyle.fontVariant\n                      )\n                    : 1.0);\n        }\n        this.m_tempPathOffset = Math.min(\n            Math.max(\n                -this.m_currentParams.textLayoutStyle.horizontalAlignment +\n                    (this.m_currentParams.textLayoutStyle.horizontalAlignment * pathWidth) /\n                        this.m_tempPathLength,\n                0\n            ),\n            1\n        );\n\n        // Place the input text as a single path line.\n        return this.placeLine(this.m_tempLineDirection, isBidirectional);\n    }\n\n    // Place characters alongside a path line. Text direction is taken into account, and text is\n    // broken into directional runs.\n    private placeLine(direction: UnicodeUtils.Direction, isBidirectional: boolean): boolean {\n        // If the line is not bidirectional, place it as a single directional run.\n        if (!isBidirectional) {\n            return this.placeRun(0, this.m_currentParams!.glyphs.length - 1, direction);\n        }\n\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n\n        // Initialize line placement parameters.\n        let runStart = 0;\n        for (let i = runStart; i < glyphDataArray.length; ++i) {\n            const glyphData = glyphDataArray[i];\n\n            // If the current glyph changes the line direction, place the current run.\n            if (glyphData.direction === -this.m_tempRunDirection) {\n                if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                    return false;\n                }\n\n                runStart = i;\n                this.m_tempRunDirection *= -1.0;\n            }\n            // If the current glyph has neutral direction (i.e. white space) and we're in the middle\n            // of a run with direction opposite to the line's main direction, check for the closest\n            // strong direction in the run.\n            else if (\n                glyphData.direction === UnicodeUtils.Direction.Neutral &&\n                this.m_tempRunDirection === -direction\n            ) {\n                let neutralIdx = i;\n                while (\n                    neutralIdx + 1 < glyphDataArray.length &&\n                    Math.abs(glyphDataArray[neutralIdx].direction) !== 1\n                ) {\n                    ++neutralIdx;\n                }\n\n                // If the closest strong direction in the run is not the current run's direction,\n                // place the current run.\n                if (glyphDataArray[neutralIdx].direction !== this.m_tempRunDirection) {\n                    if (!this.placeRun(runStart, i - 1, this.m_tempRunDirection)) {\n                        return false;\n                    }\n\n                    runStart = i;\n                    this.m_tempRunDirection *= -1.0;\n                }\n            }\n        }\n\n        // If we still haven't placed all characters in the line, place a final run.\n        if (runStart < glyphDataArray.length) {\n            if (!this.placeRun(runStart, glyphDataArray.length - 1, this.m_tempRunDirection)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Place a directional run of index inside a path line.\n    private placeRun(startIdx: number, endIdx: number, direction: UnicodeUtils.Direction): boolean {\n        // Gather common typesetting parameters.\n        const glyphDataArray = this.m_currentParams!.glyphs;\n        const smallCapsArray = this.m_currentParams!.smallCapsArray;\n        const fontCatalog = this.m_currentParams!.fontCatalog;\n        const textRenderStyle = this.m_currentParams!.textRenderStyle;\n        const textLayoutStyle = this.m_currentParams!.textLayoutStyle;\n        const position = this.m_currentParams!.position;\n        const geometry = this.m_currentParams!.geometry;\n        const globalBounds = this.m_currentParams!.globalBounds;\n        const individualBounds = this.m_currentParams!.individualBounds;\n        const vertexBuffer = this.m_currentParams!.vertexBuffer;\n        const path = this.m_currentParams!.path;\n\n        const defaultGlyphRotation = textRenderStyle.rotation;\n        const normalDisplacement =\n            textLayoutStyle.verticalAlignment *\n            glyphDataArray[0].font.metrics.capHeight *\n            this.m_tempScale;\n\n        // Move through the glyph array following the run's direction (as the order of the glyphs in\n        // memory might not match the order on glyphs on scree).\n        const start = direction === UnicodeUtils.Direction.LTR ? startIdx : endIdx;\n        const end = direction === UnicodeUtils.Direction.LTR ? endIdx : startIdx;\n        for (\n            let i = start;\n            direction === UnicodeUtils.Direction.RTL ? i >= end : i <= end;\n            i += direction\n        ) {\n            // Only process printable characters.\n            const glyphData = glyphDataArray[i];\n            if (!UnicodeUtils.isPrintable(glyphData.codePoint)) {\n                continue;\n            }\n\n            // When placing a RTL run, we need to check for weak runs (numerical runs of characters\n            // that don't change the overall run direction, but should always be displayed as LTR\n            // text).\n            if (\n                startIdx !== endIdx &&\n                i !== 0 &&\n                direction === UnicodeUtils.Direction.RTL &&\n                glyphData.direction === UnicodeUtils.Direction.Weak\n            ) {\n                let weakRunStart = i;\n                let weakGlyph = glyphDataArray[weakRunStart - 1];\n                while (\n                    weakRunStart !== startIdx &&\n                    (weakGlyph.direction === UnicodeUtils.Direction.Weak ||\n                        (weakGlyph.direction === UnicodeUtils.Direction.Neutral &&\n                            !UnicodeUtils.isWhiteSpace(weakGlyph.codePoint)))\n                ) {\n                    --weakRunStart;\n                    weakGlyph = glyphDataArray[weakRunStart - 1];\n                }\n\n                this.placeRun(Math.max(weakRunStart, startIdx), i, UnicodeUtils.Direction.LTR);\n\n                i = weakRunStart;\n                continue;\n            }\n\n            // Compute various rendering parameters for this glyph.\n            const glyphFont = glyphData.font;\n            const glyphFontMetrics = glyphFont.metrics;\n            const fontStyle = textRenderStyle.fontStyle;\n\n            const isBoldEmulated =\n                (fontStyle === FontStyle.Bold && glyphFont.bold === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.bold === undefined &&\n                    glyphFont.boldItalic === undefined);\n            const isItalicEmulated =\n                (fontStyle === FontStyle.Italic && glyphFont.italic === undefined) ||\n                (fontStyle === FontStyle.BoldItalic &&\n                    glyphFont.italic === undefined &&\n                    glyphFont.boldItalic === undefined);\n\n            const isSmallCaps = this.m_tempSmallCaps\n                ? smallCapsArray![i] && textRenderStyle.fontVariant === FontVariant.SmallCaps\n                : false;\n            const smallCapsScale = isSmallCaps\n                ? glyphFontMetrics.xHeight / glyphFontMetrics.capHeight\n                : 1.0;\n            const glyphScale = this.m_tempScale * smallCapsScale;\n\n            const emulationWeight =\n                ((isBoldEmulated ? 0.02 : 0.0) + (isSmallCaps ? 0.01 : 0.0)) *\n                (fontCatalog.size / fontCatalog.distanceRange);\n            const bgWeight =\n                (0.5 * this.m_tempPixelBgSize!) /\n                (fontCatalog.distanceRange * Math.max(glyphScale, 1.0));\n            const isMirrored =\n                UnicodeUtils.isRtlMirrored(glyphData.codePoint) &&\n                direction === UnicodeUtils.Direction.RTL;\n\n            const verticalOffset =\n                glyphFontMetrics.lineHeight -\n                glyphFontMetrics.base -\n                glyphFontMetrics.distanceRange * 0.5;\n\n            // Update the current interpolated path position and angle.\n            const textPoint = path.getPoint(this.m_tempPathOffset);\n            if (textPoint === null) {\n                return this.m_currentParams!.pathOverflow;\n            }\n            const tangent = path.getTangent(this.m_tempPathOffset);\n            const normal = new THREE.Vector2(-tangent.y, tangent.x).multiplyScalar(\n                normalDisplacement\n            );\n            const angle = Math.atan2(tangent.y, tangent.x);\n            this.m_tempPathPosition.set(normal.x + textPoint.x, normal.y + textPoint.y, position.z);\n            textRenderStyle.rotation = defaultGlyphRotation + angle;\n\n            // Compute the glyphs transformation matrix and apply to all corners of a glyph.\n            TypesettingUtils.computeGlyphTransform(\n                this.m_tempTransform,\n                this.m_tempPathPosition,\n                glyphScale,\n                0.0,\n                textRenderStyle.rotation\n            );\n            for (let j = 0; j < 4; ++j) {\n                const glyphVertexPosition = glyphData.positions[j];\n                const horizontalOffset =\n                    isItalicEmulated && j > 1\n                        ? TypesettingUtils.OBLIQUE_OFFSET * glyphFontMetrics.size\n                        : 0.0;\n                this.m_tempCorners[j].set(\n                    glyphVertexPosition.x + horizontalOffset,\n                    glyphVertexPosition.y - verticalOffset,\n                    glyphVertexPosition.z\n                );\n                this.m_tempCorners[j].applyMatrix3(this.m_tempTransform);\n\n                this.m_tempCorners[j].x -= position.x;\n                this.m_tempCorners[j].y -= position.y;\n            }\n\n            // Depending on the typesetting options, add the computed glyph to the TextGeometry or\n            // update the text bounds.\n            if (globalBounds === undefined && vertexBuffer === undefined) {\n                if (\n                    !geometry.add(\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    )\n                ) {\n                    return false;\n                }\n            } else {\n                if (globalBounds !== undefined) {\n                    TypesettingUtils.updateBounds(\n                        this.m_tempCorners,\n                        globalBounds,\n                        individualBounds\n                    );\n                }\n                if (vertexBuffer !== undefined) {\n                    geometry.addToBuffer(\n                        vertexBuffer,\n                        i * QUAD_VERTEX_MEMORY_FOOTPRINT,\n                        glyphData,\n                        this.m_tempCorners,\n                        emulationWeight,\n                        emulationWeight + bgWeight,\n                        isMirrored,\n                        textRenderStyle\n                    );\n                }\n            }\n\n            // Restore the original glyph rotation.\n            textRenderStyle.rotation = defaultGlyphRotation;\n\n            // Advance the current position and proceed to next glyph in the run.\n            this.m_tempPathOffset +=\n                ((glyphData.advanceX + textLayoutStyle.tracking) * glyphScale) /\n                this.m_tempPathLength;\n        }\n\n        return true;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nenum ContextualForm {\n    Initial,\n    Medial,\n    Final\n}\n\nenum CombinedForm {\n    Isolated,\n    Connected\n}\n\n/**\n * Converter between arabic isolated forms (in Unicode Block 'Arabic') and their contextual forms\n * (in Unicode Block 'Arabic Presentation Forms-B').\n */\nexport class ContextualArabicConverter {\n    private static m_instance: ContextualArabicConverter;\n    static get instance(): ContextualArabicConverter {\n        if (this.m_instance === undefined) {\n            this.m_instance = new ContextualArabicConverter();\n        }\n        return this.m_instance;\n    }\n\n    private readonly m_singleCharactersMap: Map<\n        number,\n        ReadonlyArray<number | undefined>\n    > = new Map();\n\n    private readonly m_combinedCharactersMap: Map<\n        number,\n        Map<number, ReadonlyArray<number | undefined>>\n    > = new Map();\n\n    private readonly m_neutralCharacters: number[];\n\n    private constructor() {\n        // Single characters.\n        this.m_singleCharactersMap.set(0x0621, [undefined, undefined, undefined]); // HAMZA\n        this.m_singleCharactersMap.set(0x0622, [undefined, undefined, 0xfe82]); // ALEF_MADDA\n        this.m_singleCharactersMap.set(0x0623, [undefined, undefined, 0xfe84]); // ALEF_HAMZA_ABOVE\n        this.m_singleCharactersMap.set(0x0624, [undefined, undefined, 0xfe86]); // WAW_HAMZA\n        this.m_singleCharactersMap.set(0x0625, [undefined, undefined, 0xfe88]); // ALEF_HAMZA_BELOW\n        this.m_singleCharactersMap.set(0x0626, [0xfe8b, 0xfe8c, 0xfe8a]); // YEH_HAMZA\n        this.m_singleCharactersMap.set(0x0627, [undefined, undefined, 0xfe8e]); // ALEF\n        this.m_singleCharactersMap.set(0x0628, [0xfe91, 0xfe92, 0xfe90]); // BEH\n        this.m_singleCharactersMap.set(0x0629, [undefined, undefined, 0xfe94]); // TEH_MARBUTA\n        this.m_singleCharactersMap.set(0x062a, [0xfe97, 0xfe98, 0xfe96]); // TEH\n        this.m_singleCharactersMap.set(0x062b, [0xfe9b, 0xfe9c, 0xfe9a]); // THEH\n        this.m_singleCharactersMap.set(0x062c, [0xfe9f, 0xfea0, 0xfe9e]); // JEEM\n        this.m_singleCharactersMap.set(0x062d, [0xfea3, 0xfea4, 0xfea2]); // HAH\n        this.m_singleCharactersMap.set(0x062e, [0xfea7, 0xfea8, 0xfea6]); // KHAH\n        this.m_singleCharactersMap.set(0x062f, [undefined, undefined, 0xfeaa]); // DAL\n        this.m_singleCharactersMap.set(0x0630, [undefined, undefined, 0xfeac]); // THAL\n        this.m_singleCharactersMap.set(0x0631, [undefined, undefined, 0xfeae]); // REH\n        this.m_singleCharactersMap.set(0x0632, [undefined, undefined, 0xfeb0]); // ZAIN\n        this.m_singleCharactersMap.set(0x0633, [0xfeb3, 0xfeb4, 0xfeb2]); // SEEN\n        this.m_singleCharactersMap.set(0x0634, [0xfeb7, 0xfeb8, 0xfeb6]); // SHEEN\n        this.m_singleCharactersMap.set(0x0635, [0xfebb, 0xfebc, 0xfeba]); // SAD\n        this.m_singleCharactersMap.set(0x0636, [0xfebf, 0xfec0, 0xfebe]); // DAD\n        this.m_singleCharactersMap.set(0x0637, [0xfec3, 0xfec4, 0xfec2]); // TAH\n        this.m_singleCharactersMap.set(0x0638, [0xfec7, 0xfec8, 0xfec6]); // ZAH\n        this.m_singleCharactersMap.set(0x0639, [0xfecb, 0xfecc, 0xfeca]); // AIN\n        this.m_singleCharactersMap.set(0x063a, [0xfecf, 0xfed0, 0xfece]); // GHAIN\n        this.m_singleCharactersMap.set(0x0640, [0x0640, 0x0640, 0x0640]); // TATWEEL\n        this.m_singleCharactersMap.set(0x0641, [0xfed3, 0xfed4, 0xfed2]); // FEH\n        this.m_singleCharactersMap.set(0x0642, [0xfed7, 0xfed8, 0xfed6]); // QAF\n        this.m_singleCharactersMap.set(0x0643, [0xfedb, 0xfedc, 0xfeda]); // KAF\n        this.m_singleCharactersMap.set(0x0644, [0xfedf, 0xfee0, 0xfede]); // LAM\n        this.m_singleCharactersMap.set(0x0645, [0xfee3, 0xfee4, 0xfee2]); // MEEM\n        this.m_singleCharactersMap.set(0x0646, [0xfee7, 0xfee8, 0xfee6]); // NOON\n        this.m_singleCharactersMap.set(0x0647, [0xfeeb, 0xfeec, 0xfeea]); // HEH\n        this.m_singleCharactersMap.set(0x0648, [undefined, undefined, 0xfeee]); // WAW\n        this.m_singleCharactersMap.set(0x0649, [undefined, undefined, 0xfef0]); // ALEF_MAKSURA\n        this.m_singleCharactersMap.set(0x064a, [0xfef3, 0xfef4, 0xfef2]); // YEH\n        this.m_singleCharactersMap.set(0x067e, [0xfb58, 0xfb59, 0xfb57]); // PEH\n        this.m_singleCharactersMap.set(0x06cc, [0xfbfe, 0xfbff, 0xfbfd]); // Farsi Yeh\n        this.m_singleCharactersMap.set(0x0686, [0xfb7c, 0xfb7d, 0xfb7b]); // Tcheh\n        this.m_singleCharactersMap.set(0x06a9, [0xfb90, 0xfb91, 0xfb8f]); // Keheh\n        this.m_singleCharactersMap.set(0x06af, [0xfb94, 0xfb95, 0xfb93]); // Gaf\n        this.m_singleCharactersMap.set(0x0698, [undefined, undefined, 0xfb8b]); // Jeh\n\n        // Combined characters.\n        this.m_combinedCharactersMap.set(0x0644, new Map());\n        // LAM_ALEF_MADDA\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0622, [0xfef5, 0xfef6]);\n        // LAM_ALEF_HAMZA_ABOVE\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0623, [0xfef7, 0xfef8]);\n        // LAM_ALEF_HAMZA_BELOW\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0625, [0xfef9, 0xfefa]);\n        // LAM_ALEF\n        this.m_combinedCharactersMap.get(0x0644)!.set(0x0627, [0xfefb, 0xfefc]);\n\n        // Neutral characters.\n        this.m_neutralCharacters = [\n            0x0610, // ARABIC SIGN SALLALLAHOU ALAYHE WASSALLAM\n            0x0612, // ARABIC SIGN ALAYHE ASSALLAM\n            0x0613, // ARABIC SIGN RADI ALLAHOU ANHU\n            0x0614, // ARABIC SIGN TAKHALLUS\n            0x0615, // ARABIC SMALL HIGH TAH\n            0x064b, // ARABIC FATHATAN\n            0x064c, // ARABIC DAMMATAN\n            0x064d, // ARABIC KASRATAN\n            0x064e, // ARABIC FATHA\n            0x064f, // ARABIC DAMMA\n            0x0650, // ARABIC KASRA\n            0x0651, // ARABIC SHADDA\n            0x0652, // ARABIC SUKUN\n            0x0653, // ARABIC MADDAH ABOVE\n            0x0654, // ARABIC HAMZA ABOVE\n            0x0655, // ARABIC HAMZA BELOW\n            0x0656, // ARABIC SUBSCRIPT ALEF\n            0x0657, // ARABIC INVERTED DAMMA\n            0x0658, // ARABIC MARK NOON GHUNNA\n            0x0670, // ARABIC LETTER SUPERSCRIPT ALEF\n            0x06d6, // ARABIC SMALL HIGH LIGATURE SAD WITH LAM WITH ALEF MAKSURA\n            0x06d7, // ARABIC SMALL HIGH LIGATURE QAF WITH LAM WITH ALEF MAKSURA\n            0x06d8, // ARABIC SMALL HIGH MEEM INITIAL FORM\n            0x06d9, // ARABIC SMALL HIGH LAM ALEF\n            0x06da, // ARABIC SMALL HIGH JEEM\n            0x06db, // ARABIC SMALL HIGH THREE DOTS\n            0x06dc, // ARABIC SMALL HIGH SEEN\n            0x06df, // ARABIC SMALL HIGH ROUNDED ZERO\n            0x06e0, // ARABIC SMALL HIGH UPRIGHT RECTANGULAR ZERO\n            0x06e1, // ARABIC SMALL HIGH DOTLESS HEAD OF KHAH\n            0x06e2, // ARABIC SMALL HIGH MEEM ISOLATED FORM\n            0x06e3, // ARABIC SMALL LOW SEEN\n            0x06e4, // ARABIC SMALL HIGH MADDA\n            0x06e7, // ARABIC SMALL HIGH YEH\n            0x06e8, // ARABIC SMALL HIGH NOON\n            0x06ea, // ARABIC EMPTY CENTRE LOW STOP\n            0x06eb, // ARABIC EMPTY CENTRE HIGH STOP\n            0x06ec, // ARABIC ROUNDED HIGH STOP WITH FILLED CENTRE\n            0x06ed // ARABIC SMALL LOW MEEM\n        ];\n    }\n\n    /**\n     * Converts isolated arabic characters into their contextual form.\n     *\n     * @param input - String with isolated arabic characters.\n     */\n    convert(input: string): string {\n        let output = \"\";\n        for (let i = 0; i < input.length; ++i) {\n            const currentCodePoint = input.charCodeAt(i);\n\n            // Only process arabic characters in the map.\n            if (this.isArabicCharacter(currentCodePoint)) {\n                // Find the first previous non-neutral character.\n                let prevIndex = i - 1;\n                for (; prevIndex >= 0; --prevIndex) {\n                    if (!this.isNeutral(input.charCodeAt(prevIndex))) {\n                        break;\n                    }\n                }\n\n                // Check if the previous character has ligatures with following characters.\n                let prevCodePoint = prevIndex >= 0 ? input.charCodeAt(prevIndex) : undefined;\n                if (prevCodePoint !== undefined) {\n                    const prevMap = this.getCharacterMap(prevCodePoint);\n                    if (\n                        prevMap === undefined ||\n                        (prevMap[ContextualForm.Initial] === undefined &&\n                            prevMap[ContextualForm.Medial] === undefined)\n                    ) {\n                        prevCodePoint = undefined;\n                    }\n                }\n\n                // Find the first next non-neutral character.\n                let nextIndex = i + 1;\n                for (; nextIndex < input.length; ++nextIndex) {\n                    if (!this.isNeutral(input.charCodeAt(nextIndex))) {\n                        break;\n                    }\n                }\n\n                // Check if the next character has ligatures with previous characters.\n                let nextCodePoint =\n                    nextIndex < input.length ? input.charCodeAt(nextIndex) : undefined;\n                if (nextCodePoint !== undefined) {\n                    const nextMap = this.getCharacterMap(nextCodePoint);\n                    if (\n                        nextMap === undefined ||\n                        (nextMap[ContextualForm.Medial] === undefined &&\n                            nextMap[ContextualForm.Final] === undefined)\n                    ) {\n                        nextCodePoint = undefined;\n                    }\n                }\n\n                // Check for Lam Alef combinated forms.\n                if (\n                    currentCodePoint === 0x0644 &&\n                    nextCodePoint !== undefined &&\n                    (nextCodePoint === 0x0622 ||\n                        nextCodePoint === 0x0623 ||\n                        nextCodePoint === 0x0625 ||\n                        nextCodePoint === 0x0627)\n                ) {\n                    const combinedMap = this.getCombinedCharacterMap(\n                        currentCodePoint,\n                        nextCodePoint\n                    )!;\n                    if (prevCodePoint !== undefined) {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Connected]!);\n                    } else {\n                        output += String.fromCharCode(combinedMap[CombinedForm.Isolated]!);\n                    }\n\n                    // Skip the next character and continue.\n                    ++i;\n                    continue;\n                }\n\n                // Check for single character contextual forms.\n                const map = this.getCharacterMap(currentCodePoint)!;\n                // Intermediate.\n                if (\n                    prevCodePoint !== undefined &&\n                    nextCodePoint !== undefined &&\n                    map[ContextualForm.Medial] !== undefined\n                ) {\n                    output += String.fromCharCode(map[ContextualForm.Medial]!);\n                }\n                // Final.\n                else if (prevCodePoint !== undefined && map[ContextualForm.Final] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Final]!);\n                }\n                // Initial.\n                else if (nextCodePoint !== undefined && map[ContextualForm.Initial] !== undefined) {\n                    output += String.fromCharCode(map[ContextualForm.Initial]!);\n                }\n                // Isolated.\n                else {\n                    output += String.fromCharCode(currentCodePoint);\n                }\n            } else {\n                output += String.fromCharCode(currentCodePoint);\n            }\n        }\n\n        return output;\n    }\n\n    private isArabicCharacter(codePoint: number): boolean {\n        return this.m_singleCharactersMap.has(codePoint);\n    }\n\n    private getCharacterMap(codePoint: number): ReadonlyArray<number | undefined> | undefined {\n        return this.m_singleCharactersMap.get(codePoint);\n    }\n\n    private getCombinedCharacterMap(\n        codePoint: number,\n        nextCodePoint: number\n    ): ReadonlyArray<number | undefined> | undefined {\n        const map = this.m_combinedCharactersMap.get(codePoint);\n        if (map !== undefined) {\n            return map.get(nextCodePoint);\n        }\n        return undefined;\n    }\n\n    private isNeutral(codePoint: number): boolean {\n        for (const character of this.m_neutralCharacters) {\n            if (character === codePoint) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { FontCatalog } from \"../rendering/FontCatalog\";\nimport { SdfTextMaterial } from \"../rendering/TextMaterials\";\n\n/**\n * Material parameters passed on [[SdfTextMaterial]] creation when using the `\n * `createSdfTextMaterial` helper function.\n */\nexport interface SdfTextMaterialParameters {\n    fontCatalog: FontCatalog;\n    rendererCapabilities: THREE.WebGLCapabilities;\n    isBackground?: boolean;\n    vertexSource?: string;\n    fragmentSource?: string;\n}\n\n/**\n * Helper function designed to create [[SdfTextMaterials]] that can be rendered using\n * [[TextCanvas]].\n *\n * @param params - Material parameters.\n *\n * @returns New `SdfTextMaterial`.\n */\nexport function createSdfTextMaterial(params: SdfTextMaterialParameters): SdfTextMaterial {\n    return new SdfTextMaterial({\n        texture: params.fontCatalog.texture,\n        textureSize: params.fontCatalog.textureSize,\n        size: params.fontCatalog.size,\n        distanceRange: params.fontCatalog.distanceRange,\n        isMsdf: params.fontCatalog.type === \"msdf\",\n        isBackground: params.isBackground === true,\n        vertexSource: params.vertexSource,\n        fragmentSource: params.fragmentSource,\n        rendererCapabilities: params.rendererCapabilities\n    });\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as THREE from \"three\";\n\nimport { GlyphData } from \"../rendering/GlyphData\";\nimport { FontUnit, FontVariant } from \"../rendering/TextStyle\";\nimport { UnicodeUtils } from \"../utils/UnicodeUtils\";\n\n/**\n * Collection of different constants and utility functions used by [[Typesetter]]s.\n */\nexport namespace TypesettingUtils {\n    /**\n     * Ratio between EMs and Pixels.\n     */\n    export const EM_TO_PX = 16.0;\n\n    /**\n     * Ratio between Points and Pixels.\n     */\n    export const PT_TO_PX = 1.25;\n\n    /**\n     * Angle used when emulating italic fonts (oblique).\n     */\n    export const OBLIQUE_ANGLE = 0.174533;\n\n    /**\n     * Horizontal offset used when emulating italic fonts (oblique).\n     */\n    export const OBLIQUE_OFFSET = Math.tan(OBLIQUE_ANGLE);\n\n    /**\n     * Convert between any size specified in any [[FontUnit]] to pixels.\n     *\n     * @param size - Font size (specified in `unit`).\n     * @param unit - Size unit.\n     * @param originalSize - Original size (pixels)\n     *\n     * @returns Pixel size.\n     */\n    export function getPixelSize(size: number, unit: FontUnit, originalSize: number) {\n        let result = size;\n        switch (unit) {\n            case FontUnit.Em:\n                result *= EM_TO_PX;\n                break;\n            case FontUnit.Point:\n                result *= PT_TO_PX;\n                break;\n            case FontUnit.Percent:\n                result *= (1.0 / 100) * originalSize;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Gets the scale applied to a certain character when using the [[FontVariant]].`SmallCaps`.\n     *\n     * @param glyphs - Array containing [[TransformedGlyphData]].\n     * @param index - Index to `glyphDataArray`.\n     * @param fontVariant - Currently active [[FontVariant]].\n     *\n     * @returns Glyph `SmallCaps` scale.\n     */\n    export function getSmallCapsScale(\n        glyphs: GlyphData[],\n        smallCapsTransformations: boolean[],\n        index: number,\n        fontVariant: FontVariant\n    ): number {\n        const isSmallCaps =\n            smallCapsTransformations[index] && fontVariant === FontVariant.SmallCaps;\n        return isSmallCaps\n            ? glyphs[index].font.metrics.xHeight / glyphs[index].font.metrics.capHeight\n            : 1.0;\n    }\n\n    /**\n     * Returns the first strong direction (LTR or RTL) found for a given array of [[GlyphData]].\n     *\n     * @param glyphs - Array containing [[GlyphData]].\n     * @param offset - `glyphDataArray` offset.\n     *\n     * @returns Strong direction.\n     */\n    export function getDirection(glyphs: GlyphData[], offset: number): UnicodeUtils.Direction {\n        let result = UnicodeUtils.Direction.LTR;\n        let index = offset;\n        while (\n            glyphs[index].direction !== UnicodeUtils.Direction.LTR &&\n            glyphs[index].direction !== UnicodeUtils.Direction.RTL &&\n            index < glyphs.length - 1\n        ) {\n            ++index;\n        }\n\n        if (Math.abs(glyphs[index].direction) === 1.0) {\n            result = glyphs[index].direction;\n        }\n        return result;\n    }\n\n    /**\n     * Computes the transformation matrix for a glyph.\n     *\n     * @param transform - Matrix used to store the results.\n     * @param position - Glyph' position.\n     * @param scale - Glyph' scale.\n     * @param rotation - [[TextCanvas]] rotation.\n     * @param localRotation - Glyph' local rotation.\n     */\n    export function computeGlyphTransform(\n        transform: THREE.Matrix3,\n        position: THREE.Vector3,\n        scale: number,\n        rotation: number,\n        localRotation: number\n    ): void {\n        const cosAngle = Math.cos(rotation);\n        const sinAngle = Math.sin(rotation);\n        const localCosAngle = Math.cos(localRotation);\n        const localSinAngle = Math.sin(localRotation);\n        transform.set(\n            scale * localCosAngle,\n            scale * -localSinAngle,\n            cosAngle * position.x - sinAngle * position.y,\n            scale * localSinAngle,\n            scale * localCosAngle,\n            sinAngle * position.x + cosAngle * position.y,\n            0,\n            0,\n            1.0\n        );\n    }\n\n    /**\n     * Updates the supplied bounds with the computed screen-space corners for a given glyph.\n     *\n     * @param corners - Glyph' corners.\n     * @param globalBounds - Global text bounds.\n     * @param individualBounds - Individual per-character bounds.\n     */\n    export function updateBounds(\n        corners: THREE.Vector3[],\n        globalBounds: THREE.Box2,\n        individualBounds?: { array: THREE.Box2[]; offset: number }\n    ): void {\n        const minX = Math.min(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const maxX = Math.max(corners[0].x, corners[1].x, corners[2].x, corners[3].x);\n        const minY = Math.min(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n        const maxY = Math.max(corners[0].y, corners[1].y, corners[2].y, corners[3].y);\n\n        if (individualBounds !== undefined) {\n            if (individualBounds.array[individualBounds.offset] !== undefined) {\n                individualBounds.array[individualBounds.offset].min.set(minX, minY);\n                individualBounds.array[individualBounds.offset].max.set(maxX, maxY);\n            } else {\n                individualBounds.array.push(\n                    new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY))\n                );\n            }\n            ++individualBounds.offset;\n        }\n\n        globalBounds.min.set(\n            Math.min(globalBounds.min.x, minX),\n            Math.min(globalBounds.min.y, minY)\n        );\n        globalBounds.max.set(\n            Math.max(globalBounds.max.x, maxX),\n            Math.max(globalBounds.max.y, maxY)\n        );\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Namespace containing useful information when dealing with Unicode's code points.\n */\nexport namespace UnicodeUtils {\n    /**\n     * Range of Unicode code points considered as white space.\n     * https://en.wikipedia.org/wiki/Whitespace_character\n     */\n    export const whiteSpaceRanges = [\n        [0x0009, 0x0009],\n        [0x0020, 0x0020],\n        [0x1680, 0x1680],\n        [0x2000, 0x2006],\n        [0x2008, 0x200a],\n        [0x205f, 0x3000],\n        [0x180e, 0x180e],\n        [0x200b, 0x200d]\n    ];\n\n    /**\n     * Checks if a character should be considered as a white space.\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isWhiteSpace(codePoint: number) {\n        for (const range of whiteSpaceRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Range of Unicode code points considered as `NewLine`.\n     * https://en.wikipedia.org/wiki/Newline#Unicode\n     */\n    export const newLineRanges = [\n        [0x000a, 0x000d],\n        [0x0085, 0x0085],\n        [0x2028, 0x2029]\n    ];\n\n    /**\n     * Checks if a character should be considered as a new line.\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isNewLine(codePoint: number) {\n        for (const range of newLineRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Range of Unicode code points considered as non-printable.\n     * https://en.wikipedia.org/wiki/Unicode_control_characters\n     */\n    export const nonPrintableRanges = [\n        [0x0000, 0x001f],\n        [0x007f, 0x009f]\n    ];\n\n    /**\n     * Checks if a character's can be printed (rendered).\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isPrintable(codePoint: number) {\n        for (const range of nonPrintableRanges) {\n            if (codePoint >= range[0] && codePoint <= range[1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Unicode code point direction.\n     */\n    export enum Direction {\n        Neutral = 0.0,\n        Weak = 0.5,\n        LTR = 1.0,\n        RTL = -1.0\n    }\n\n    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).\n    /**\n     * Unicode Blocks which have inherent RTL direction.\n     * These blocks correspond to the scripts described here:\n     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts\n     */\n    export const rtlBlocks: string[] = [\n        \"Hebrew\",\n        \"Alphabetic Presentation Forms\",\n        \"Arabic\",\n        \"Arabic Supplement\",\n        \"Arabic Extended-A\",\n        \"Arabic Presentation Forms-A\",\n        \"Arabic Presentation Forms-B\",\n        \"Arabic Mathematical Alphabetic Symbols\",\n        \"Indic Siyaq Numbers\",\n        \"Rumi Numeral Symbols\",\n        \"Syriac\",\n        \"Syriac Supplement\",\n        \"Samaritan\",\n        \"Mandaic\",\n        \"Thaana\",\n        \"Mende Kikakui\",\n        \"NKo\",\n        \"Adlam\",\n        \"Hanifi Rohingya\"\n    ];\n\n    /**\n     * ASCII punctuation is considered to have neutral direction:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    export const neutralBidirectionalRanges = [\n        [0x0020, 0x002f],\n        [0x003a, 0x0040],\n        [0x005b, 0x0060],\n        [0x007b, 0x007e]\n    ];\n\n    /**\n     * Latin and arabic numerals are considered to have weak directionality:\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block\n     */\n    export const weakBidirectionalRanges = [\n        [0x0030, 0x0039],\n        [0x0660, 0x0669],\n        [0x06f0, 0x06f9]\n    ];\n\n    /**\n     * Returns the Unicode's character direction.\n     *\n     * @param codePoint - Character's Unicode code point.\n     * @param block - Character's Unicode block.\n     *\n     * @returns Character's direction.\n     */\n    export function getDirection(codePoint: number, block: string): Direction {\n        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).\n        for (const weakRange of weakBidirectionalRanges) {\n            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {\n                return Direction.Weak;\n            }\n        }\n        for (const neutralRange of neutralBidirectionalRanges) {\n            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {\n                return Direction.Neutral;\n            }\n        }\n\n        // Check for RTL/LTR.\n        const rtl = rtlBlocks.find(element => {\n            return element === block;\n        });\n        if (rtl !== undefined) {\n            return Direction.RTL;\n        } else {\n            return Direction.LTR;\n        }\n    }\n\n    /**\n     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering\n     * a RTL string to preserve their intrinsic meaning.\n     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters\n     */\n    export const rtlMirroredCodePoints = [\n        0x0028,\n        0x0029,\n        0x003c,\n        0x003e,\n        0x005b,\n        0x005d,\n        0x007b,\n        0x007d\n    ];\n\n    /**\n     * Checks if a character should be mirrored on an RTL run.\n     *\n     * @param codePoint - Character's Unicode code point.\n     *\n     * @returns Result of the test.\n     */\n    export function isRtlMirrored(codePoint: number): boolean {\n        return (\n            rtlMirroredCodePoints.find(element => {\n                return element === codePoint;\n            }) !== undefined\n        );\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Provides a manager that orchestrates downloading URLs, particularly static map resources.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./src/TransferManager\";\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n *\n * DeferredPromise takes an executor function for executing it later, when [[exec]] is called.\n * This class allows wrapping other promises or long running functions for later execution.\n * @internal\n * @hidden\n */\nexport class DeferredPromise<T> {\n    /**\n     * Internal promise to store the result of the deferred executor function.\n     */\n    readonly promise: Promise<T>;\n    private resolveFunc?: (result: T) => void;\n    private rejectFunc?: (reason?: any) => void;\n\n    /**\n     * Constructs a new [[DeferredPromise]]\n     * @param executor - Async function that should be executed at a later point in time.\n     */\n    constructor(private readonly executor: () => Promise<T>) {\n        this.promise = new Promise<T>((resolve, reject) => {\n            this.resolveFunc = resolve;\n            this.rejectFunc = reject;\n        });\n    }\n\n    /**\n     * When `exec` is called the deferred executor function is executed.\n     */\n    exec() {\n        this.executor()\n            .then(result => this.resolveFunc!(result))\n            .catch(error => this.rejectFunc!(error));\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** @module\n *\n * This module provides classes to ease downloading URLs. In particular, following redirects,\n * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.\n */\n\nimport \"@here/harp-fetch\";\n\nimport { DeferredPromise } from \"./DeferredPromise\";\n\n/**\n * Abstract interface for a transfer manager.\n *\n * Provides functionality for downloading JSON or ArrayBuffers.\n * Implementations typically implement retry on server congestion,\n * limit the maximum amount of parallel downloads or merge duplicate\n * downloads.\n */\nexport interface ITransferManager {\n    /**\n     * Downloads a JSON object.\n     * @param url - The URL to download\n     * @param init - Optional extra parameters for the download.\n     */\n    downloadJson<T>(url: RequestInfo, init?: RequestInit): Promise<T>;\n\n    /**\n     * Downloads a binary object.\n     * @param url - The URL to download\n     * @param init - Optional extra parameters for the download\n     */\n    downloadArrayBuffer(url: RequestInfo, init?: RequestInit): Promise<ArrayBuffer>;\n\n    /**\n     * Downloads a URL and returns the response.\n     * @param url - The URL to download.\n     * @param init - Optional extra parameters for the download.\n     */\n    download(url: RequestInfo, init?: RequestInit): Promise<Response>;\n}\n\n/**\n * `TransferManager` for downloading URLs.\n *\n * Features:\n *\n * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded\n *   once.\n * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that\n *   would otherwise stall the browser.\n * * Retries the downloads with an increasing timeout on HTTP 503 replies.\n *\n * The static method [[instance]] can be used to get a default constructed instance.\n */\nexport class TransferManager implements ITransferManager {\n    /**\n     * The timeout in milliseconds to wait between retries. This timeout is multiplied with the\n     * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and\n     * so on.\n     */\n    static readonly retryTimeout = 500;\n    /**\n     * The amount of maximum parallel downloads to allow.\n     */\n    static readonly maxParallelDownloads = 16;\n    /**\n     * Returns a default instance of [[TransferManager]].\n     */\n    static instance(): TransferManager {\n        return TransferManager.defaultInstance;\n    }\n\n    private static readonly defaultInstance = new TransferManager();\n    private static async fetchRepeatedly(\n        fetchFunction: typeof fetch,\n        retryCount: number,\n        maxRetries: number,\n        url: RequestInfo,\n        init?: RequestInit\n    ): Promise<Response> {\n        try {\n            if (retryCount < maxRetries) {\n                const response = await fetchFunction(url, init);\n                // Return response when successful or empty\n                if (response.status === 200 || response.status === 204) {\n                    return response;\n                } else if (response.status >= 400 && response.status < 500) {\n                    // Prevent further retries in case of a client error code\n                    retryCount = maxRetries;\n                    const responseText = await response.text();\n                    throw new Error(responseText);\n                }\n            } else {\n                throw new Error(\"Max number of retries reached\");\n            }\n        } catch (err) {\n            if (\n                err.hasOwnProperty(\"isCancelled\") ||\n                err.name === \"AbortError\" ||\n                retryCount >= maxRetries\n            ) {\n                throw err;\n            }\n        }\n        return await TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() =>\n            TransferManager.fetchRepeatedly(fetchFunction, retryCount + 1, maxRetries, url, init)\n        );\n    }\n\n    private static waitFor(milliseconds: number): Promise<void> {\n        return new Promise<void>(resolve => setTimeout(resolve, milliseconds));\n    }\n\n    private activeDownloadCount = 0;\n    private readonly downloadQueue = new Array<DeferredPromise<Response>>();\n    private readonly activeDownloads = new Map<RequestInfo, Promise<any>>();\n    /**\n     * Constructs a new [[TransferManager]].\n     *\n     * @param fetchFunction - The default fetch function to use.\n     * @param maxRetries - The maximum amount to try to re-fetch a resource.\n     */\n    constructor(readonly fetchFunction = fetch, readonly maxRetries: number = 5) {}\n    /**\n     * Downloads a JSON object. Merges downloads of string URLs if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same string URL to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url - The URL or RequestInfo to download\n     * @param init - Optional extra parameters for the download.\n     */\n    downloadJson<T>(url: RequestInfo, init?: RequestInit): Promise<T> {\n        return this.downloadAs<T>(response => response.json(), url, init);\n    }\n\n    /**\n     * Downloads a binary object. Merges downloads of string URLS if requested multiple times.\n     *\n     * Note: This method merges multiple downloads of the same string URL to\n     * only one request. The init parameter is ignored if the download is merged.\n     * Call [[download]] instead to download the resource without merging.\n     *\n     * @param url - The URL or RequestInfo to download\n     * @param init - Optional extra parameters for the download\n     */\n    downloadArrayBuffer(url: RequestInfo, init?: RequestInit): Promise<ArrayBuffer> {\n        return this.download(url, init).then(response => response.arrayBuffer());\n    }\n\n    /**\n     * Downloads a URL and returns the response.\n     *\n     * Does not merge multiple requests to the same URL.\n     *\n     * @param url - The URL or RequestInfo to download.\n     * @param init - Optional extra parameters for the download.\n     */\n    download(url: RequestInfo, init?: RequestInit): Promise<Response> {\n        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {\n            const deferred = new DeferredPromise<Response>(() => this.doDownload(url, init));\n            this.downloadQueue.push(deferred);\n            return deferred.promise;\n        }\n        return this.doDownload(url, init);\n    }\n\n    private async doDownload(url: RequestInfo, init?: RequestInit): Promise<Response> {\n        try {\n            ++this.activeDownloadCount;\n            const response = await TransferManager.fetchRepeatedly(\n                this.fetchFunction,\n                0,\n                this.maxRetries,\n                url,\n                init\n            );\n\n            this.onDownloadDone();\n            return response;\n        } catch (error) {\n            this.onDownloadDone();\n            throw error;\n        }\n    }\n\n    private onDownloadDone() {\n        --this.activeDownloadCount;\n        this.execDeferredDownload();\n    }\n\n    private execDeferredDownload() {\n        const future = this.downloadQueue.pop();\n        if (future === undefined) {\n            return;\n        }\n        future.exec();\n    }\n\n    private downloadAs<T>(\n        converter: (response: Response) => Promise<T>,\n        url: RequestInfo,\n        init?: RequestInit\n    ): Promise<T> {\n        const cacheKey = url;\n        const pendingFetch = this.activeDownloads.get(cacheKey);\n        if (pendingFetch !== undefined) {\n            return Promise.resolve(pendingFetch);\n        }\n        const newFetch = this.download(url, init)\n            .then(response => {\n                this.activeDownloads.delete(cacheKey);\n                if (response.ok) {\n                    return converter(response);\n                }\n                throw new Error(JSON.stringify(response));\n            })\n            .catch(err => {\n                this.activeDownloads.delete(cacheKey);\n                throw err;\n            });\n        this.activeDownloads.set(cacheKey, newFetch);\n        return newFetch;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./lib/DOMUtils\";\nexport * from \"./lib/GroupedPriorityList\";\nexport * from \"./lib/Logger\";\nexport * from \"./lib/Math2D\";\nexport * from \"./lib/MathUtils\";\nexport * from \"./lib/Mixins\";\nexport * from \"./lib/assert\";\nexport * from \"./lib/CachedResource\";\nexport * from \"./lib/ContextLogger\";\nexport * from \"./lib/PerformanceTimer\";\nexport * from \"./lib/ObjectUtils\";\nexport * from \"./lib/OptionsUtils\";\nexport * from \"./lib/TaskQueue\";\nexport * from \"./lib/UriResolver\";\nexport * from \"./lib/UrlUtils\";\nexport * from \"./lib/Functions\";\nexport * from \"./lib/SampleBilinear\";\nexport * from \"./lib/AuthenticationUtils\";\nexport * from \"./lib/GlslUtils\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Refinement of `console` interface only for important information i.e `info`, `warn` and `errors`.\n */\nexport interface ISimpleChannel {\n    info(message?: any, ...optionalParams: any[]): void;\n    warn(message?: any, ...optionalParams: any[]): void;\n    error(message?: any, ...optionalParams: any[]): void;\n}\n\n/**\n * Extension of {@link ISimpleChannel} to support contextual logging by adding stack of prefixes.\n */\nexport interface IContextLogger extends ISimpleChannel {\n    /**\n     * Push \"attribute-like\" context.\n     */\n    pushAttr(name: string): void;\n\n    /**\n     * Push \"index-like\" context.\n     *\n     * Following log messages will be prefixed with `[index]`.\n     */\n    pushIndex(index: string | number): void;\n\n    /**\n     * Remove current context from top of stack.\n     */\n    pop(): void;\n}\n\n/**\n * Context-aware logger that decorates log message with stack-based prefix, emits `headerMessage`\n * before first actual log message.\n */\nexport class ContextLogger implements IContextLogger {\n    private readonly context: string[] = [];\n    private m_headerLogged = false;\n\n    /**\n     * Construct a context-aware logger that logs to `m_logger`.\n     */\n    constructor(readonly m_logger: ISimpleChannel, readonly headerMessage: string) {}\n\n    /**\n     * Push \"attribute-like\" context.\n     *\n     * Following log messages will be prefixed with `name` or `.name` depending on current context.\n     */\n    pushAttr(name: string) {\n        this.context.push(`${this.context.length > 0 ? \".\" : \"\"}${name}`);\n    }\n\n    /**\n     * Push \"index-like\" context.\n     *\n     * Following log messages will be prefixed with `[index]`.\n     */\n    pushIndex(index: string | number) {\n        this.context.push(`[${index}]`);\n    }\n\n    pop() {\n        this.context.pop();\n    }\n\n    // They, are public member functions it's just tslint who doesn't understand this.\n\n    warn = this.createLogMethod(\"warn\");\n    info = this.createLogMethod(\"info\");\n    error = this.createLogMethod(\"error\");\n\n    private createLogMethod(severity: \"warn\" | \"info\" | \"error\") {\n        return (message: string, ...rest: any[]) => {\n            if (!this.m_headerLogged) {\n                this.m_logger.info(this.headerMessage);\n                this.m_headerLogged = true;\n            }\n            this.m_logger[severity](`${this.context.join(\"\")}: ${message}`, ...rest);\n        };\n    }\n}\n","/*\n * Copyright (C) 2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport namespace DOMUtils {\n    /**\n     * Gets language list used by the browser\n     *\n     * @returns Array of iso language codes\n     */\n    export function getBrowserLanguages(): string[] | undefined {\n        if (navigator.languages !== undefined && navigator.languages.length > 0) {\n            const languageList = [];\n            for (const lang of navigator.languages) {\n                languageList.push(getIsoLanguageCode(lang));\n            }\n            return languageList;\n        }\n        if (navigator.language !== undefined) {\n            return [getIsoLanguageCode(navigator.language)];\n        }\n        return undefined;\n    }\n\n    /**\n     * Gets ISO-639-1 language code from browser's code (ex. en for en-US)\n     */\n    function getIsoLanguageCode(language: string) {\n        return language.substring(0, 2);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Chains two functions for further assigning as one wrapped callback function\n */\nexport function chainCallbacks<T extends (this: unknown, ...args: any[]) => any>(\n    f1: T | null | undefined,\n    f2: T\n): T {\n    return function (this: any, ...args: any[]): ReturnType<T> {\n        if (f1) {\n            f1.apply(this, args);\n        }\n        return f2.apply(this, args);\n    } as T;\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Converts webgl1-compatible vertex shader glsl code to webgl2.\n *\n * @param vertexShader - String containing the vertex shader glsl code.\n * @returns the converted glsl code.\n */\nexport function convertVertexShaderToWebGL2(vertexShader: string): string {\n    return (\n        [\"#define attribute in\", \"#define varying out\", \"#define texture2D texture\"].join(\"\\n\") +\n        \"\\n\" +\n        vertexShader\n    );\n}\n\n/**\n * Converts webgl1-compatible fragment shader glsl code to webgl2.\n *\n * @param fragmentShader - String containing the fragment shader glsl code.\n * @returns the converted glsl code.\n */\nexport function convertFragmentShaderToWebGL2(fragmentShader: string): string {\n    return (\n        [\n            \"#define varying in\",\n            \"out highp vec4 pc_fragColor;\",\n            \"#define gl_FragColor pc_fragColor\",\n            \"#define gl_FragDepthEXT gl_FragDepth\",\n            \"#define texture2D texture\",\n            \"#define textureCube texture\",\n            \"#define texture2DProj textureProj\",\n            \"#define texture2DLodEXT textureLod\",\n            \"#define texture2DProjLodEXT textureProjLod\",\n            \"#define textureCubeLodEXT textureLod\",\n            \"#define texture2DGradEXT textureGrad\",\n            \"#define texture2DProjGradEXT textureProjGrad\",\n            \"#define textureCubeGradEXT textureGrad\"\n        ].join(\"\\n\") +\n        \"\\n\" +\n        fragmentShader\n    );\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * A `PriorityListElement` has a priority to assist in sorting. The idea is that the items in a\n * grouped priority list will not modify their priority during processing to such an amount, that\n * they will change into another group. Smaller lists are smaller to sort, and in case of resource\n * limitation (maximum number of rendered objects reached), not all items have to be sorted at all.\n */\nexport interface PriorityListElement {\n    /**\n     * The integer value of this priority is used to group objects of \"same\" priority.\n     */\n    priority: number;\n}\n\n/**\n * The `PriorityListGroup` contains a list of {@link PriorityListElement}s that all have the same\n * (integer) priority.\n */\nexport class PriorityListGroup<T extends PriorityListElement> {\n    constructor(readonly priority: number, public elements: T[] = new Array()) {}\n\n    /**\n     * Create and return a deep copy of the `PriorityListGroup<T>`.\n     *\n     * @returns A clone of the `PriorityListGroup<T>`.\n     */\n    clone(): PriorityListGroup<T> {\n        return new PriorityListGroup<T>(this.priority, this.elements.slice());\n    }\n\n    /**\n     * Removes an element from the group.\n     * @param element - The element to remove.\n     * @returns true if the element was removed, false if it was not found in the group.\n     */\n    remove(element: T): boolean {\n        const foundIndex = this.elements.indexOf(element);\n        if (foundIndex === -1) {\n            return false;\n        }\n        this.elements.splice(foundIndex, 1);\n        return true;\n    }\n}\n\n/**\n * The `PriorityListGroupMap` is a map to map the (integer) priority to a {@link PriorityListGroup}.\n */\nexport type PriorityListGroupMap<T extends PriorityListElement> = Map<number, PriorityListGroup<T>>;\n\n/**\n * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items\n * in priority groups.\n */\nexport class GroupedPriorityList<T extends PriorityListElement> {\n    readonly groups: PriorityListGroupMap<T> = new Map();\n    /**\n     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.\n     *\n     * @param element - Element to be added.\n     */\n    add(element: T): void {\n        this.getGroup(element.priority).elements.push(element);\n    }\n\n    /**\n     * Remove an element from the `GroupedPriorityList`.\n     *\n     * Note: It is required that the priority is the same as it was when the element has been added.\n     * Otherwise, the removal will fail.\n     *\n     * @param element - Element to be removed.\n     * @returns `True` if the element was removed, `false` otherwise.\n     */\n    remove(element: T): boolean {\n        const group = this.findGroup(element.priority);\n        if (group !== undefined && group.remove(element)) {\n            if (group.elements.length === 0) {\n                this.groups.delete(group.priority);\n            }\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Remove all internal {@link PriorityListGroup}s.\n     */\n    clear(): void {\n        this.groups.clear();\n    }\n\n    /**\n     * Merge another {@link GroupedPriorityList} into this one.\n     *\n     * @param other - Other group to merge.\n     */\n    merge(other: GroupedPriorityList<T>): GroupedPriorityList<T> {\n        for (const otherGroup of other.groups) {\n            const group = this.findGroup(otherGroup[1].priority);\n            if (group === undefined) {\n                this.groups.set(Math.floor(otherGroup[1].priority), otherGroup[1].clone());\n                continue;\n            }\n            group.elements = group.elements.concat(otherGroup[1].elements);\n        }\n        return this;\n    }\n\n    clone(): GroupedPriorityList<T> {\n        const clone = new GroupedPriorityList<T>();\n        for (const [priority, group] of this.groups) {\n            clone.groups.set(priority, group.clone());\n        }\n        return clone;\n    }\n\n    /**\n     * Apply function to all elements in this `GroupedPriorityList`.\n     *\n     * @param {(element: T) => void} fun Function to apply.\n     */\n    forEach(fun: (element: T) => void): void {\n        for (const group of this.groups) {\n            group[1].elements.forEach(fun);\n        }\n    }\n\n    /**\n     * Count the number of elements in this `GroupedPriorityList`.\n     */\n    count(): number {\n        let n = 0;\n        for (const group of this.groups) {\n            n += group[1].elements.length;\n        }\n        return n;\n    }\n\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority - The priority to retrieve all elements from.\n     */\n    private findGroup(priority: number): PriorityListGroup<T> | undefined {\n        const normalizedPriority = Math.floor(priority);\n        const group = this.groups.get(normalizedPriority);\n        return group;\n    }\n\n    /**\n     * Get group of elements that have the same (integer) priority.\n     *\n     * @param priority - The priority to retrieve all elements from.\n     */\n    private getGroup(priority: number): PriorityListGroup<T> {\n        let group = this.findGroup(priority);\n\n        if (group === undefined) {\n            const normalizedPriority = Math.floor(priority);\n            group = new PriorityListGroup<T>(normalizedPriority);\n            this.groups.set(group.priority, group);\n        }\n\n        return group;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/* eslint-disable no-console */\n\nimport { IChannel } from \"./IChannel\";\n\n/**\n * Class for the default console channel.\n */\n\nexport class ConsoleChannel implements IChannel {\n    error(message?: any, ...optionalParams: any[]) {\n        console.error(message, ...optionalParams);\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        console.debug(message, ...optionalParams);\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        console.info(message, ...optionalParams);\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        console.log(message, ...optionalParams);\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        console.trace(message, ...optionalParams);\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        console.warn(message, ...optionalParams);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\n\n/**\n * Enum log levels\n */\nexport enum LogLevel {\n    Trace,\n    Debug,\n    Log,\n    Info,\n    Warn,\n    Error,\n    None\n}\n\n/**\n * Logger options to configure logger\n */\nexport class LoggerOptions {\n    enabled?: boolean;\n    level?: LogLevel;\n}\n\n/**\n * Public interface for Logger class.\n */\nexport interface ILogger extends IChannel {\n    readonly name: string;\n\n    enabled: boolean;\n\n    level: LogLevel;\n\n    /**\n     * Update logger options\n     *\n     * @param  {LoggerOptions} options Set logger options and configure internal logger.\n     */\n    update(options: LoggerOptions): void;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\nimport { ILogger, LoggerOptions, LogLevel } from \"./ILogger\";\n\n/**\n * Logger class.\n */\nexport class Logger implements ILogger {\n    enabled: boolean = true;\n    level: LogLevel = LogLevel.Trace;\n\n    constructor(\n        readonly name: string,\n        private readonly m_channel: IChannel,\n        options?: LoggerOptions\n    ) {\n        if (options !== undefined) {\n            this.update(options);\n        }\n    }\n\n    error(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Error) {\n            this.m_channel.error(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Debug) {\n            this.m_channel.debug(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Info) {\n            this.m_channel.info(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Log) {\n            this.m_channel.log(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Trace) {\n            this.m_channel.trace(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        if (this.enabled && this.level <= LogLevel.Warn) {\n            this.m_channel.warn(this.prefix, message, ...optionalParams);\n        }\n    }\n\n    update(options: LoggerOptions) {\n        this.enabled = options.enabled === undefined ? this.enabled : options.enabled;\n        this.level = options.level === undefined ? this.level : options.level;\n    }\n\n    private get prefix(): string {\n        return this.name + \":\";\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ILoggerManager } from \"./ILoggerManager\";\nimport { LoggerManagerImpl } from \"./LoggerManagerImpl\";\n\n/**\n * The LoggerManager class implements a singleton object that handles logging.\n *\n * Example:\n *\n * ```typescript\n *\n * const logger = LoggerManager.instance.create(\"MyFontLoaderClass\");\n * if (missingFonts.length > 0) {\n *     logger.error(\"These fonts can not be loaded: \", missingFonts);\n * } else {\n *     logger.log(\"All fonts have been loaded.\");\n * }\n * ```\n */\nexport class LoggerManager {\n    private static m_instance: ILoggerManager;\n\n    static get instance(): ILoggerManager {\n        return this.m_instance || (this.m_instance = new LoggerManagerImpl());\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ConsoleChannel } from \"./ConsoleChannel\";\nimport { IChannel } from \"./IChannel\";\nimport { ILogger, LoggerOptions, LogLevel } from \"./ILogger\";\nimport { ILoggerManager } from \"./ILoggerManager\";\nimport { Logger } from \"./Logger\";\nimport { WorkerChannel } from \"./WorkerChannel\";\n\n/**\n * LoggerManagerImpl is the class for the singleton instance of the logger manager.\n * It handles channels and loggers.\n */\n\nexport class LoggerManagerImpl implements ILoggerManager {\n    channel: IChannel;\n    private readonly m_loggers: ILogger[] = [];\n    private m_levelSetForAll?: LogLevel;\n\n    constructor() {\n        this.channel =\n            typeof self === \"undefined\" || typeof self.document !== \"undefined\"\n                ? new ConsoleChannel()\n                : new WorkerChannel();\n    }\n\n    getLoggerNames(): string[] {\n        return this.m_loggers.map(logger => logger.name);\n    }\n\n    getLogger(name: string): ILogger | undefined {\n        return this.m_loggers.find(logger => logger.name === name);\n    }\n\n    create(loggerName: string, options: LoggerOptions = {}): ILogger {\n        if (\n            this.m_levelSetForAll !== undefined &&\n            (options.level === undefined || options.level < this.m_levelSetForAll)\n        ) {\n            options.level = this.m_levelSetForAll;\n        }\n        const logger = new Logger(loggerName, this.channel, options);\n        this.m_loggers.push(logger);\n        return logger;\n    }\n\n    dispose(logger: ILogger) {\n        const found = this.m_loggers.indexOf(logger);\n        if (found < 0) {\n            throw new Error(`Cannot unregister \"${logger}\" : no such logger registered.`);\n        }\n        this.m_loggers.splice(found, 1);\n    }\n\n    updateAll(options: LoggerOptions) {\n        for (const logger of this.m_loggers) {\n            logger.update(options);\n        }\n    }\n\n    update(loggerName: string, config: LoggerOptions) {\n        for (const logger of this.m_loggers) {\n            if (logger.name === loggerName) {\n                logger.update(config);\n            }\n        }\n    }\n\n    enableAll(enabled: boolean) {\n        for (const logger of this.m_loggers) {\n            logger.enabled = enabled;\n        }\n    }\n\n    enable(loggerName: string, value: boolean) {\n        this.update(loggerName, { enabled: value });\n    }\n\n    setLogLevelForAll(level: LogLevel) {\n        this.m_levelSetForAll = level;\n        for (const logger of this.m_loggers) {\n            logger.level = level;\n        }\n    }\n\n    setLogLevel(loggerName: string, level: LogLevel) {\n        this.update(loggerName, { level });\n    }\n\n    setChannel(channel: IChannel) {\n        this.channel = channel;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\n\n/**\n * Class allowing mixing several channels.\n */\nexport class MultiChannel implements IChannel {\n    private readonly channels: IChannel[] = [];\n    constructor(...channels: IChannel[]) {\n        this.channels = channels;\n    }\n\n    error(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.error(message, ...optionalParams);\n        }\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.debug(message, ...optionalParams);\n        }\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.info(message, ...optionalParams);\n        }\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.log(message, ...optionalParams);\n        }\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.trace(message, ...optionalParams);\n        }\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        for (const channel of this.channels) {\n            channel.warn(message, ...optionalParams);\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { IChannel } from \"./IChannel\";\nimport { LogLevel } from \"./ILogger\";\n\ndeclare let self: Worker;\n\nexport const WORKERCHANNEL_MSG_TYPE = \"worker-channel-message\";\n\n/**\n * The interface for the messages of the WorkerChannel.\n */\nexport interface IWorkerChannelMessage {\n    message: any[];\n    type: \"worker-channel-message\";\n    level: LogLevel;\n}\n\n/**\n * The class for the worker channel.\n */\nexport class WorkerChannel implements IChannel {\n    error(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Error\n        };\n        self.postMessage(workerMessage);\n    }\n\n    debug(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Debug\n        };\n        self.postMessage(workerMessage);\n    }\n\n    info(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Info\n        };\n        self.postMessage(workerMessage);\n    }\n\n    log(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Log\n        };\n        self.postMessage(workerMessage);\n    }\n\n    trace(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Trace\n        };\n        self.postMessage(workerMessage);\n    }\n\n    warn(message?: any, ...optionalParams: any[]) {\n        const workerMessage: IWorkerChannelMessage = {\n            message: [message, ...optionalParams],\n            type: WORKERCHANNEL_MSG_TYPE,\n            level: LogLevel.Warn\n        };\n        self.postMessage(workerMessage);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport * from \"./ConsoleChannel\";\nexport * from \"./IChannel\";\nexport * from \"./ILogger\";\nexport * from \"./Logger\";\nexport * from \"./LoggerManager\";\nexport * from \"./MultiChannel\";\nexport * from \"./WorkerChannel\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\ninterface Vec2Like {\n    x: number;\n    y: number;\n}\n\nexport namespace Math2D {\n    /**\n     * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n     * objects with two numbers each). Should be faster.\n     */\n    export class Box {\n        /**\n         * Alternative 2D box object with less memory impact (four numbers instead of two min/max\n         * objects with two numbers each). Should be faster.\n         *\n         * @param x - New X value.\n         * @param y - New y value.\n         * @param w - New w value.\n         * @param h - New h value.\n         */\n        constructor(public x = 0, public y = 0, public w = 0, public h = 0) {}\n\n        /**\n         * Set new values to all properties of the box.\n         *\n         * @param x - New X value.\n         * @param y - New y value.\n         * @param w - New w value.\n         * @param h - New h value.\n         */\n        set(x: number, y: number, w: number, h: number) {\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n        }\n\n        /**\n         * Copy values from another box.\n         *\n         * @param box - Another box.\n         */\n        copy(box: Box) {\n            this.x = box.x;\n            this.y = box.y;\n            this.w = box.w;\n            this.h = box.h;\n        }\n\n        /**\n         * Test box for inclusion of point.\n         *\n         * @param x - X coordinate of point.\n         * @param y - Y coordinate of point.\n         */\n        contains(x: number, y: number): boolean {\n            return this.x <= x && this.x + this.w >= x && this.y <= y && this.y + this.h >= y;\n        }\n\n        /**\n         * Test box for inclusion of another box.\n         *\n         * @param other - Box 2 to test for inclusion.\n         */\n        containsBox(other: Box): boolean {\n            const xmax = other.x + other.w;\n            const ymax = other.y + other.h;\n            return (\n                this.contains(other.x, other.y) &&\n                this.contains(xmax, other.y) &&\n                this.contains(other.x, ymax) &&\n                this.contains(xmax, ymax)\n            );\n        }\n\n        /**\n         * Test two boxes for intersection.\n         *\n         * @param other - Box 2 to test for intersection.\n         */\n        intersects(other: Box): boolean {\n            return (\n                this.x <= other.x + other.w &&\n                this.x + this.w >= other.x &&\n                this.y <= other.y + other.h &&\n                this.y + this.h >= other.y\n            );\n        }\n    }\n\n    /**\n     * Box to store UV coordinates.\n     */\n    export interface UvBox {\n        s0: number;\n        t0: number;\n        s1: number;\n        t1: number;\n    }\n\n    /**\n     * Compute squared distance between two 2D points `a` and `b`.\n     *\n     * @param ax - Point a.x\n     * @param ay - Point a.y\n     * @param bx - Point b.x\n     * @param by - Point b.y\n     * @returns Squared distance between the two points\n     */\n    export function distSquared(ax: number, ay: number, bx: number, by: number): number {\n        return (ax - bx) * (ax - bx) + (ay - by) * (ay - by);\n    }\n\n    /**\n     * Computes the squared length of a line.\n     *\n     * @param line - An array of that forms a line via [x,y,z,x,y,z,...] tuples.\n     */\n    export function computeSquaredLineLength(line: number[]): number {\n        let squaredLineLength: number = 0;\n\n        const length = line.length - 4;\n        for (let i = 0; i < length; i += 3) {\n            const xDiff = line[i + 3] - line[i];\n            const yDiff = line[i + 4] - line[i + 1];\n            squaredLineLength += xDiff * xDiff + yDiff * yDiff;\n        }\n        return squaredLineLength;\n    }\n\n    /**\n     * Compute squared distance between a 2D point and a 2D line segment.\n     *\n     * @param px - Test point X\n     * @param py - Test point y\n     * @param l0x - Line segment start X\n     * @param l0y - Line segment start Y\n     * @param l1x - Line segment end X\n     * @param l1y - Line segment end Y\n     * @returns Squared distance between point and line segment\n     */\n    export function distToSegmentSquared(\n        px: number,\n        py: number,\n        l0x: number,\n        l0y: number,\n        l1x: number,\n        l1y: number\n    ): number {\n        const lineLengthSuared = distSquared(l0x, l0y, l1x, l1y);\n        if (lineLengthSuared === 0) {\n            return distSquared(px, py, l0x, l0y);\n        }\n        let t = ((px - l0x) * (l1x - l0x) + (py - l0y) * (l1y - l0y)) / lineLengthSuared;\n        t = Math.max(0, Math.min(1, t));\n        return distSquared(px, py, l0x + t * (l1x - l0x), l0y + t * (l1y - l0y));\n    }\n\n    /**\n     * Finds the intersections of a line and a circle.\n     *\n     * @param xLine1 - abscissa of first line point.\n     * @param yLine1 - ordinate of second line point.\n     * @param xLine2 - abscissa of second line point.\n     * @param yLine2 - ordinate of second line point.\n     * @param radius - circle radius.\n     * @param xCenter - abscissa of circle center.\n     * @param yCenter - ordinate of circle center.\n     * @returns coordinates of the intersections (1 if the line is tangent to the circle, 2\n     * if it's secant) or undefined if there's no intersection.\n     */\n    export function intersectLineAndCircle(\n        xLine1: number,\n        yLine1: number,\n        xLine2: number,\n        yLine2: number,\n        radius: number,\n        xCenter: number = 0,\n        yCenter: number = 0\n    ): { x1: number; y1: number; x2?: number; y2?: number } | undefined {\n        // Line equation: dy*x - dx*y = c, c = dy*x1 - dx*y1 = x1*y2 - x2*y1\n        // Circle equation: (x-xCenter)^2 + (y-yCenter)^2 = r^2\n\n        // 1. Translate circle center to origin of coordinates:\n        // u = x - xCenter\n        // v = y - yCenter\n        // circle: u^2 + v^2 = r^2\n        // line: dy*u - dx*v = cp, cp = c - dy*xCenter - dx*yCenter\n\n        // 2. Intersections are solutions of a quadratic equation:\n        // ui = (cp*dy +/- sign(dy)*dx*discriminant / dSq\n        // vi = (-cp*dx +/- |dy|*discriminant / dSq\n        // discriminant = r^2*dSq - cp^2, dSq = dx^2 + dy^2\n        // The sign of the discriminant indicates the number of intersections.\n\n        // 3. Translate intersection coordinates back to original space:\n        // xi = xCenter + ui\n        // yi = yCenter + yi\n\n        const epsilon = 1e-10;\n        const dx = xLine2 - xLine1;\n        const dy = yLine2 - yLine1;\n        const dSq = dx * dx + dy * dy;\n        const rSq = radius * radius;\n        const c = xLine1 * yLine2 - xLine2 * yLine1;\n        const cp = c - dy * xCenter + dx * yCenter;\n        const discriminantSquared = rSq * dSq - cp * cp;\n\n        if (discriminantSquared < -epsilon) {\n            // no intersection\n            return undefined;\n        }\n\n        const xMid = cp * dy;\n        const yMid = -cp * dx;\n\n        if (discriminantSquared < epsilon) {\n            // 1 intersection (tangent line)\n            return { x1: xCenter + xMid / dSq, y1: yCenter + yMid / dSq };\n        }\n\n        const discriminant = Math.sqrt(discriminantSquared);\n\n        // 2 intersections (secant line)\n        const signDy = dy < 0 ? -1 : 1;\n        const absDy = Math.abs(dy);\n\n        const xDist = signDy * dx * discriminant;\n        const yDist = absDy * discriminant;\n\n        return {\n            x1: xCenter + (xMid + xDist) / dSq,\n            y1: yCenter + (yMid + yDist) / dSq,\n            x2: xCenter + (xMid - xDist) / dSq,\n            y2: yCenter + (yMid - yDist) / dSq\n        };\n    }\n\n    /**\n     * Computes the intersection point between two lines.\n     *\n     * @remarks\n     * This functions computes the\n     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection\n     *    | line-line intersection} of two lines given two points on each line.\n     *\n     * @param x1 - x coordinate of the first point of the first line.\n     * @param y1 - y coordinate of the first point of the first line.\n     * @param x2 - x coordinate of the second point of the first line.\n     * @param y2 - y coordinate of the second point of the first line.\n     * @param x3 - x coordinate of the first point of the second line.\n     * @param y3 - y coordinate of the first point of the second line.\n     * @param x4 - x coordinate of the second point of the second line.\n     * @param y4 - y coordinate of the second point of the second line.\n     * @param result - The resulting point.\n     */\n    export function intersectLines(\n        x1: number,\n        y1: number,\n        x2: number,\n        y2: number,\n        x3: number,\n        y3: number,\n        x4: number,\n        y4: number,\n        result: Vec2Like = { x: 0, y: 0 }\n    ): Vec2Like | undefined {\n        const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (d === 0) {\n            return undefined;\n        }\n        const px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;\n        const py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;\n        result.x = px;\n        result.y = py;\n        return result;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport namespace MathUtils {\n    /**\n     * Ensures that input value fits in a given range.\n     *\n     * @param value - The value to be clamped.\n     * @param min - Minimum value.\n     * @param max - Maximum value.\n     *\n     * @returns Clamped value.\n     */\n    export function clamp(value: number, min: number, max: number): number {\n        return value < min ? min : value > max ? max : value;\n    }\n\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0 -\n     * @param edge1 -\n     * @param x -\n     */\n    export function smoothStep(edge0: number, edge1: number, x: number) {\n        // Scale, bias and saturate x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * (3 - 2 * x);\n    }\n\n    /**\n     * Returns a smooth interpolation between the values edge0 and edge1 based on the interpolation\n     * factor x. `0 <= x <= 1`.\n     *\n     * Improved version by Ken Perlin, which has zero 1st- and 2nd-order derivatives at `x = 0` and\n     * `x = 1`:\n     *\n     * @see https://en.wikipedia.org/wiki/Smoothstep\n     *\n     * @param edge0 -\n     * @param edge1 -\n     * @param x -\n     */\n    export function smootherStep(edge0: number, edge1: number, x: number) {\n        // Scale, and clamp x to 0..1 range\n        x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n        // Evaluate polynomial\n        return x * x * x * (x * (x * 6 - 15) + 10);\n    }\n\n    /**\n     * Maps a number from one range to another.\n     *\n     * @param val - The incoming value to be converted.\n     * @param inMin - Lower bound of the value's current range.\n     * @param inMax - Upper bound of the value's current range.\n     * @param outMin - Lower bound of the value's target range.\n     * @param outMax - Upper bound of the value's target range.\n     */\n    export function map(val: number, inMin: number, inMax: number, outMin: number, outMax: number) {\n        return ((val - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n    }\n\n    /**\n     * Returns the smaller of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a - First number.\n     * @param b - Second number.\n     */\n    export function min2(a: number | undefined, b: number | undefined): number | undefined {\n        let result: number | undefined;\n\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.min(result, b);\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the larger of the two given numbers. Both numbers may be undefined, in which case\n     * the result is undefined. If only one of the numbers is undefined, the other number is\n     * returned.\n     *\n     * @param a - First number.\n     * @param b - Second number.\n     */\n    export function max2(a: number | undefined, b: number | undefined): number | undefined {\n        let result: number | undefined;\n\n        if (a !== undefined) {\n            result = a;\n        }\n        if (b !== undefined) {\n            result = result === undefined ? b : Math.max(result, b);\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the value of a given number is inside an upper or lower bound. The bounds may be\n     * undefined, in which case their value is ignored.\n     *\n     * @param value - Value to check.\n     * @param lowerBound - The lower bound to check the value against.\n     * @param upperBound - The upper bound to check the value against.\n     *\n     * @returns `true` if value is inside the bounds or if the bounds are `undefined`, `false`\n     *          otherwise.\n     */\n    export function isClamped(\n        value: number,\n        lowerBound: number | undefined,\n        upperBound: number | undefined\n    ): boolean {\n        if (lowerBound !== undefined && value < lowerBound) {\n            return false;\n        }\n        if (upperBound !== undefined && value > upperBound) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Smoothly interpolates between two values using cubic formula\n     *\n     * @param startValue -\n     * @param endValue -\n     * @param time -\n     * @returns Result of the interpolation within the range of `[startValue, endValue]`\n     */\n    export function easeInOutCubic(startValue: number, endValue: number, time: number): number {\n        const timeValue =\n            time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n        return startValue + (endValue - startValue) * timeValue;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Copy methods and properties from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor - Class to mix methods and properties into.\n * @param baseCtors - Class to take all methods and properties from.\n */\nexport function applyMixins(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            derivedCtor.prototype[name] = baseCtor.prototype[name];\n        });\n    });\n}\n\n/**\n * Copy methods from one prototype into another.\n *\n * @see https://www.typescriptlang.org/docs/handbook/mixins.html\n *\n * @param derivedCtor - Class to mix methods into.\n * @param baseCtors - Class to take all methods from.\n */\nexport function applyMixinsWithoutProperties(derivedCtor: any, baseCtors: any[]) {\n    baseCtors.forEach(baseCtor => {\n        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n            const descriptor = Object.getOwnPropertyDescriptor(baseCtor.prototype, name);\n            if (\n                descriptor !== undefined &&\n                descriptor.get === undefined &&\n                name !== \"constructor\"\n            ) {\n                derivedCtor.prototype[name] = baseCtor.prototype[name];\n            }\n        });\n    });\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Deep clone of object.\n *\n * Like `JSON.parse(JSON.stringify(obj))`, but supports basic javascript types (string, number,\n * object), `Date` and `RegExp`s and cycles.\n *\n * Throws error if enounters object with `prototype` assuming that in general class instances\n * cannot be reliably cloned by generic algorithm.\n */\nexport function cloneDeep<T>(obj: T): T {\n    const cache: Map<object, object> = new Map();\n    function cloneInternal(src: any): any {\n        if (src === null) {\n            return null;\n        } else if (typeof src === \"object\") {\n            const cached = cache.get(src);\n            if (cached !== undefined) {\n                return cached;\n            }\n\n            if (Array.isArray(src)) {\n                const result: any[] = [];\n                cache.set(src, result);\n                result.length = src.length;\n                for (let i = 0; i < result.length; ++i) {\n                    result[i] = cloneInternal(src[i]);\n                }\n                return result;\n            } else if (src instanceof Date) {\n                const result = new Date(src.getTime());\n                cache.set(src, result);\n                return result;\n            } else if (src instanceof RegExp) {\n                const result = new RegExp(src.source, src.flags);\n                cache.set(src, result);\n                return result;\n            } else if (src.constructor !== Object) {\n                throw new Error(\"cloneDeep doesn't support objects with custom prototypes\");\n            } else {\n                const result: typeof src = {};\n                cache.set(src, result);\n                for (const key in src) {\n                    if (src.hasOwnProperty(key)) {\n                        result[key] = cloneInternal(src[key]);\n                    }\n                }\n                return result;\n            }\n        } else {\n            // string, number, boolean, undefined and functions are returned as is\n            return src;\n        }\n    }\n\n    const r = cloneInternal(obj);\n    cache.clear();\n    return r;\n}\n\n/**\n * Pick `props` from `object.\n *\n * Runtime version of `Pick<T,K>`.\n */\nexport function pick<T extends object, K extends keyof T>(object: T, props: K[]): Pick<T, K> {\n    const result: any = {};\n    for (const propName of props) {\n        if (object.hasOwnProperty(propName)) {\n            result[propName] = object[propName];\n        }\n    }\n    return result;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Get first defined value.\n *\n * Specialized \"replacement\" for `a || b || c` used frequently to get value from various sources\n * (defaults, configs  constants).\n * In contrast to `||`, this function provides proper typing for usual use cases (constant as last\n * argument) and correct treatment of `null` and `undefined`.\n *\n * If last parameter is \"defined\" then return type is `T`, otherwise return type is `T | undefined`.\n *\n * Usage example:\n *\n *     interface Config {\n *         x?: number;\n *     }\n *     const someConfig: Config = {};\n *     const val: number | undefined = undefined;\n *     const DEFAULT = 5;\n *     const x = getOptionValue(val, someConfig.x, DEFAULT);\n *         // typeof x === 'number' because DEFAULT is defined\n *     const y = getOptionValue(val, someConfig.x);\n *         // typeof y === 'number | undefined' because someConfig.x is possibly undefined\n */\n// specialized overloads with last param defined params overload\nexport function getOptionValue<T>(a: T): T;\nexport function getOptionValue<T>(a: T | undefined, b: T): T;\nexport function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T): T;\nexport function getOptionValue<T>(a: T | undefined, b: T | undefined, c: T | undefined, d: T): T;\nexport function getOptionValue<T>(...values: Array<T | undefined>): T | undefined;\n\nexport function getOptionValue<T>(...values: Array<T | undefined>): T | undefined {\n    for (const candidate of values) {\n        if (candidate !== undefined && candidate !== null) {\n            return candidate;\n        }\n    }\n    return undefined;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * See:\n * https://developers.google.com/web/updates/2012/08/When-milliseconds-are-not-enough-performance-now\n */\n\nexport class PerformanceTimer {\n    /**\n     * Returns timestamp in milliseconds since page load.\n     *\n     * If the [[DOMHighResTimeStamp]] is supported, the resolution is up to 5 microseconds,\n     * otherwise it is in milliseconds. Timespans are computed by taking the difference between two\n     * samples.\n     *\n     * Example:\n     * ```typescript\n     * const now = PerformanceTimer.now();\n     * // call some expensive function for which you want to check the duration.\n     * const end = PerformanceTimer.now();\n     * const elapsedTime = end - now;\n     * ```\n     */\n    static now(): number {\n        return PerformanceTimer.nowFunc();\n    }\n\n    private static readonly instance = new PerformanceTimer();\n\n    private static readonly nowFunc: () => number = PerformanceTimer.getNowFunc();\n\n    private static getNowFunc() {\n        if (typeof performance !== \"undefined\" && typeof performance.now !== \"undefined\") {\n            return () => performance.now();\n        }\n\n        // fall back to Date.getTime()\n        return () => {\n            return new Date().getTime();\n        };\n    }\n}\n","/*\n * Copyright (C) 2020 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\ntype TypedArray =\n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Uint8ClampedArray\n    | Float32Array\n    | Float64Array;\n\n/**\n * Returns a bilinear-interpolated texture sample for a given texture.\n * @param texture - Two-dimensional texture to sample.\n * @param width - Texture width.\n * @param height - Texture height.\n * @param u - Number between 0 and 1 representing the location to sample in the width dimension.\n * @param v - Number between 0 and 1 representing the location to sample in the height dimension.\n */\nexport function sampleBilinear(\n    texture: TypedArray,\n    width: number,\n    height: number,\n    u: number,\n    v: number\n): number {\n    const maxXIndex = width - 1;\n    const maxYIndex = height - 1;\n    // Compute the x and y coordinates relative to the mesh size.\n    const xIndex = u * maxXIndex;\n    const xIndexFloor = Math.floor(xIndex);\n    const yIndex = v * maxYIndex;\n    const yIndexFloor = Math.floor(yIndex);\n    const swIndex = yIndexFloor * width + xIndexFloor;\n    const seIndex = xIndexFloor < maxXIndex ? swIndex + 1 : swIndex;\n    const nwIndex = yIndexFloor < maxYIndex ? swIndex + width : swIndex;\n    const neIndex = xIndexFloor < maxXIndex ? nwIndex + 1 : nwIndex;\n    const swElevation = texture[swIndex];\n    const seElevation = texture[seIndex];\n    const nwElevation = texture[nwIndex];\n    const neElevation = texture[neIndex];\n    // Get the fractional components to do bilinear interpolation.\n    const xFrac = Number.isInteger(xIndex) ? 0 : xIndex - xIndexFloor;\n    const xFracInverse = 1 - xFrac;\n    const yFrac = Number.isInteger(yIndex) ? 0 : yIndex - yIndexFloor;\n    const yFracInverse = 1 - yFrac;\n    // The interpolation is the sum of the four closest neighbours each\n    // multiplied by the diagonal areas.\n    const result =\n        swElevation * xFracInverse * yFracInverse +\n        seElevation * xFrac * yFracInverse +\n        nwElevation * xFracInverse * yFrac +\n        neElevation * xFrac * yFrac;\n    return result;\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Task that can be added to the [[TaskQueue]]\n */\nexport interface Task {\n    /**\n     * The Function that will be executed when the [[Task]] is processed\n     */\n    execute: () => void;\n\n    /**\n     * The group by which similar tasks in the TaskQueue are combined\n     */\n    group: string;\n\n    /**\n     * A function to retrieve the priority of the [[Task]], with 0 being\n     * the highest priority, and the first to be executed\n     */\n    getPriority: () => number;\n\n    /**\n     * An optional function that defines if a [[Task]] is alread expired\n     * and therefore can be removed from the [[TaskQueue]]\n     */\n    isExpired?: () => boolean;\n\n    /**\n     * An optional function that returns an estimated process time,\n     * this is not directly used by the [[TaskQueue]] but can be used\n     * by an Task Scheduler to schedule the processing\n     */\n    estimatedProcessTime?: () => number;\n}\n\nexport interface TaskQueueOptions {\n    //TODO: Use the max length\n    //maxLength?: number;\n    /**\n     * Groups to combine specific [[Task]]s in the [[TaskQueue]],\n     * [[Task]]s can only be added to the [[TaskQueue]] if their group is available\n     */\n    groups: string[];\n\n    /**\n     * Optional function to sort the priority, if set, i will override the internal TaskQueue.sort\n     * function.\n     *\n     * @remarks\n     * Caution, the {@link TaskQueue} uses the last element in the Arrays first, so the\n     * highest priorities should be ordered to the end\n     */\n    prioSortFn?: (a: Task, b: Task) => number;\n}\n\n/**\n * A Pull-TaskQueue sorted by priority and group-able {@link Task}s by {@link Task.group}.\n *\n * @remarks\n *\n * @example\n * Sample Usage\n * ```\n *  const taskQueue = new TaskQueue({\n *      group: [\"group1\"]\n *  })\n *  taskQueue.add({\n *     group: \"group1\",\n *     execute: () => {\n *         console.log(\"task of group1 executed\");\n *     },\n *     getPrio: () => {\n *         return 0;\n *     }\n *   });\n *\n * taskQueue.update();\n * taskQueue.processNext(\"group1\");\n *\n *  ```\n */\nexport class TaskQueue {\n    private readonly m_taskLists: Map<string, Task[]> = new Map();\n\n    constructor(private readonly m_options: TaskQueueOptions) {\n        this.m_options.groups?.forEach(group => {\n            this.m_taskLists.set(group, []);\n        });\n        if (this.m_options.prioSortFn) {\n            this.sort = this.m_options.prioSortFn;\n        }\n    }\n\n    /**\n     * Updates the lists in the queue depending on their priority functions and removes\n     * expired Tasks, based on their isExpired functions result.\n     *\n     * @param group The Group to update, if not set all groups will be updated.\n     */\n    update(group?: string) {\n        if (group === undefined) {\n            this.m_taskLists.forEach(taskList => {\n                this.updateTaskList(taskList);\n            });\n        } else {\n            const taskList = this.getTaskList(group);\n            if (taskList) {\n                this.updateTaskList(taskList);\n            }\n        }\n    }\n\n    /**\n     * Adds a Task to the Queue\n     *\n     * @param task\n     * @returns true if succesfully added, otherwise false\n     */\n    add(task: Task): boolean {\n        if (this.m_taskLists.has(task.group)) {\n            const taskList = this.m_taskLists.get(task.group);\n            if (!taskList?.includes(task)) {\n                this.m_taskLists.get(task.group)?.push(task);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Removes a Task from the Queue\n     *\n     * @param task\n     * @returns true if succesfully removed, otherwise false\n     */\n    remove(task: Task): boolean {\n        if (this.m_taskLists.has(task.group)) {\n            const index = this.m_taskLists.get(task.group)?.indexOf(task);\n            if (index !== -1) {\n                this.m_taskLists.get(task.group)?.splice(index as number, 1);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns the number of remaining tasks.\n     *\n     * @param group if group is set, it will return only the remaining tasks for this group,\n     * otherwise it will return the complete amount of tasks left.\n     */\n    numItemsLeft(group?: string): number {\n        let numLeft: number = 0;\n        if (group === undefined) {\n            this.m_taskLists.forEach(tasklist => {\n                numLeft += tasklist.length;\n            });\n        } else {\n            numLeft += this.getTaskList(group)?.length ?? 0;\n        }\n        return numLeft;\n    }\n\n    /**\n     * Processes the next Tasks for a group\n     *\n     * @param group The group the Tasks are pulled from.\n     * @param shouldProcess A condition that, if set will be executed before the task is processed,\n     * if returns true, the task will run\n     * @param n The amount of tasks that should be pulled, @defaults to 1\n     * @returns false if thte list was empty\n     */\n    processNext(group: string, shouldProcess?: (task: Task) => boolean, n: number = 1): boolean {\n        if (!this.getTaskList(group) || this.numItemsLeft(group) <= 0) {\n            return false;\n        }\n        for (let i = 0; i < n && this.numItemsLeft(group) > 0; i++) {\n            const nextTask = this.pull(group, true);\n            if (nextTask !== undefined) {\n                //if a condition is set, execute it\n                if (!shouldProcess || shouldProcess?.(nextTask)) {\n                    nextTask.execute();\n                } else {\n                    //as the task was not executed but already pulled, add it back\n                    //TODO: dont even pull it if it will not execute, this currently\n                    // interferes with the skipping and removal of expired tasks on this.pull\n                    this.add(nextTask);\n                }\n            }\n        }\n        return true;\n    }\n\n    clear() {\n        this.m_taskLists.clear();\n    }\n\n    private pull(group: string, checkIfExpired: boolean = false): Task | undefined {\n        const taskList = this.getTaskList(group);\n        let nextTask;\n        if (taskList) {\n            nextTask = this.getTaskList(group)?.pop();\n            if (checkIfExpired && nextTask && nextTask.isExpired?.()) {\n                return this.pull(group, checkIfExpired);\n            }\n        }\n        return nextTask;\n    }\n\n    private sort(a: Task, b: Task): number {\n        // the highest number in the beginning as the last in the array with\n        // highest priority which equals 0 will start to be processed\n        return b.getPriority() - a.getPriority();\n    }\n\n    private getTaskList(group: string): Task[] | undefined {\n        return this.m_taskLists.get(group);\n    }\n\n    private updateTaskList(taskList: Task[]) {\n        for (let i = 0; i < taskList.length; i++) {\n            const task = taskList[i];\n            if (task?.isExpired?.()) {\n                taskList.splice(i, 1);\n                i--;\n            }\n        }\n        taskList.sort(this.sort);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { resolveReferenceUri } from \"./UrlUtils\";\n\n/**\n * Custom, app-specific URI resolver interface.\n */\nexport interface UriResolver {\n    /**\n     * Attempt to resolve `URI` to `URL`.\n     *\n     * If given resolver doesn't know about this specific kind of `URI`, it should return string as\n     * received.\n     *\n     * @param input - `URI`\n     * @returns actual `URL` if this handler knows how locate given `uri` or original `uri`\n     */\n    resolveUri(uri: string): string;\n}\n\nexport interface PrefixUriResolverDefinition {\n    [prefix: string]: string;\n}\n\n/**\n * Basic, import-map like {@link UriResolver}.\n *\n * Resolves `uris` basing on exact or prefix match of `key` from `definitions`.\n *\n * In definitions, `key` is matched against input uri with following strategy:\n *  - `key` without trailing `/` -> `key` and input `uri` must be identical\n *  - `key` with trailing `/`, -> `key` is treated as \"package prefix\", so `uri` must start with\n *    `key`\n *\n * Example:\n * ```\n * {\n *     \"local://poiMasterList\": \"/assets/poiMasterList.json\"\n *        // will match only 'local://poiMasterList' and resolve `/assets/poiMasterList.json`\n *     \"local://icons/\": \"/assets/icons/\"\n *        // will match only 'local://icons/ANYPATH' (and similar) and resolve to\n *        // `/assets/icons/ANYPATH\n * }\n * ```\n * Inspired by [`WICG` import maps proposal](https://github.com/WICG/import-maps#the-import-map).\n */\nexport class PrefixMapUriResolver implements UriResolver {\n    constructor(readonly definitions: PrefixUriResolverDefinition) {}\n\n    resolveUri(uri: string) {\n        return Object.keys(this.definitions).reduce((r, key) => {\n            if (key.endsWith(\"/\") && r.startsWith(key)) {\n                const newPrefix = this.definitions[key];\n                return newPrefix + r.substr(key.length);\n            } else if (r === key) {\n                return this.definitions[key];\n            }\n            return r;\n        }, uri);\n    }\n}\n\n/**\n * [UriResolver] that resolve relative `uri`s against to parent resource `uri`.\n */\nexport class RelativeUriResolver implements UriResolver {\n    constructor(readonly parentUri: string) {}\n\n    resolveUri(uri: string) {\n        return resolveReferenceUri(this.parentUri, uri);\n    }\n}\n\n/**\n * Compose URI resolvers.\n *\n * Creates new {@link UriResolver} that applies resolvers in orders or arguments.\n *\n * Example:\n *\n *     const themeUrl = ...; // url of parent object\n *     const childUrlResolver = composeUrlResolvers(\n *           new RelativeUriResolver(themeUrl),\n *           defaultUrlResolver\n *     );\n */\nexport function composeUriResolvers(...resolvers: Array<UriResolver | undefined>): UriResolver {\n    return {\n        resolveUri(originalUrl: string) {\n            return resolvers.reduce((url, resolver) => {\n                if (resolver !== undefined) {\n                    return resolver.resolveUri(url);\n                } else {\n                    return url;\n                }\n            }, originalUrl);\n        }\n    };\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { baseUrl } from \"./UrlUtils\";\n\n/**\n * Get base URL for from where relative URLs will be loaded.\n *\n * * In browser, it resolves to `baseUrl(location.href)` i.e document's base URL\n * (see: https://www.w3.org/TR/WD-html40-970917/htmlweb.html#h-5.1.2).\n *\n * * In node, it resolves to `file://${process.cwd()}`.\n */\nexport function getAppBaseUrl() {\n    if (typeof window === \"undefined\") {\n        return `file://${process.cwd()}/`;\n    }\n    return baseUrl(window.location.href);\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Resolve URI of referenced object w.r.t parent URI.\n *\n * Resolves `childUri` as it would be loaded from location specified by `parentUri`.\n *\n * If `childUri` is absolute, then it is returned unchanged.\n * If `childUri` is origin-absolute path, then only origin path is taken from `parentUri`.\n *\n * See [[baseUri]] for reference how base URL of `parentUri` is determined.\n *\n * Supports `http:`, `https:`, `file:`, `data:` schemes.\n *\n * Examples:\n *\n *     // normal case, child is sibling\n *     https://foo.com/themes/day.json + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent is \"folder\", so child is just located in this folder\n *     https://foo.com/themes/ + images/foo.png -> https://foo.com/themes/images/foo.png\n *\n *     // parent looks like leaf, so last component is stripped\n *     https://foo.com/themes + images/foo.png -> https://foo.com/images/foo.png\n *\n *     // origin-absolute URL, takes only origin from parent\n *     https://foo.com/themes/day.json + /fonts/foo.json -> https://foo.com/fonts/foo.json\n *\n * @param parentUri - URI of parent resource\n * @param childUri - URI of child as referenced from parent resource\n * @return `childUrl` as if anchored in location of `parentUrl`\n */\nexport function resolveReferenceUri(parentUri: string | undefined, childUri: string): string {\n    if (absoluteUrlWithOriginRe.test(childUri)) {\n        return childUri;\n    } else if (childUri.startsWith(\"/\")) {\n        const origin = getUrlOrigin(parentUri);\n        return origin + childUri;\n    } else {\n        if (childUri.startsWith(\"./\")) {\n            childUri = childUri.substr(2);\n        }\n        const parentBaseUrl = baseUrl(parentUri);\n        return parentBaseUrl + childUri;\n    }\n}\n\nconst absoluteUrlWithOriginRe = new RegExp(\"^(((?:[a-z]+:)?//)|(file:/)|(data:))\", \"i\");\n\n/**\n * Returns base URL of given resource URL.\n *\n * `Url` with trailing slash are considered genuine 'locations', they are returned as is, however if\n * `url` ends with name component it is treated as \"leaf\", so last path component is removed.\n *\n * Standalone files (without any folder structure) are considered relative to `./`.\n *\n * Examples:\n * ```\n *     https://foo.com/themes/a.json -> https://foo.com/themes/\n *     https://foo.com/themes/ -> https://foo.com/themes/\n *     https://foo.com/themes -> https://foo.com/ // note, themes is treated as leaf\n *     themes/day.json -> themes/\n *     themes -> ./\n * ```\n */\nexport function baseUrl(url: string | undefined) {\n    if (url === undefined) {\n        return \"./\";\n    }\n    let idx = url.indexOf(\"#\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.indexOf(\"?\");\n    if (idx !== -1) {\n        url = url.slice(0, idx);\n    }\n    idx = url.lastIndexOf(\"/\");\n    if (idx === -1) {\n        return \"./\";\n    } else {\n        return url.substring(0, idx + 1);\n    }\n}\n\n/**\n * Get `origin` part of URL.\n *\n * @example\n *    https://example.com/foo -> https://example.com\n *    //example.com:8080/ -> //example.com:8080\n *    file:///etc/hosts ->\n *\n * @param url - input URL\n * @return origin of given URL\n */\nexport function getUrlOrigin(url: string | undefined): string {\n    if (url === undefined) {\n        return \"\";\n    }\n    const parsed = getUrlHostAndProtocol(url);\n    if (parsed.protocol === \"file:\") {\n        return \"file://\";\n    } else if (parsed.host && parsed.protocol) {\n        return parsed.protocol + \"//\" + parsed.host;\n    } else if (parsed.host) {\n        return \"//\" + parsed.host;\n    } else if (parsed.protocol) {\n        return parsed.protocol + \"//\";\n    } else {\n        return \"\";\n    }\n}\n\n/**\n * Parse `host` and `protocol` part from URL.\n */\nexport function getUrlHostAndProtocol(\n    url: string\n): {\n    protocol: string;\n    host: string;\n} {\n    const urlOriginRe = new RegExp(/^(?:([a-z]+:))?\\/\\/([^\\/]*)/, \"i\");\n\n    const match = url.match(urlOriginRe);\n    if (!match) {\n        throw new Error(`getUrlHostAndProtocol: unable to parse URL '${url}'`);\n    }\n    return {\n        protocol: match[1],\n        host: match[2]\n    };\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\ndeclare const process: any;\n\n// cache value, because access to process.env.NODE_ENV is SLOW!\nconst isProduction = process.env.NODE_ENV === \"production\";\n\n//TODO: Make assertHandler configurable\n\n/**\n * Implementation of assert as a development help\n *\n * Note - this is deliberately a global function so that minimizers remove the\n * entire call when building for production.\n *\n * @hidden\n * @param condition - Condition to match, if false, throws an Error(message)\n * @param message - Optional message, defaults to \"ASSERTION failed\"\n */\nexport function assert(condition: boolean, message?: string): void {\n    if (!isProduction) {\n        if (!condition) {\n            throw new Error(message !== undefined ? message : \"ASSERTION failed\");\n        }\n    }\n}\n\nexport function assertExists<T>(element: T | undefined, message?: string): T {\n    if (!isProduction) {\n        if (element === undefined || element === null) {\n            throw new Error(\n                message !== undefined ? message : \"ASSERTION failed: Element is undefined or null\"\n            );\n        }\n    }\n    return element!;\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * HERE OMV Data source.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/OmvDataFilter\";\nexport * from \"./lib/VectorTileDataSource\";\nexport * from \"./lib/OmvDecoderDefs\";\nexport * from \"./lib/OmvDebugLabelsTile\";\nexport * from \"./lib/OmvRestClient\";\nexport * from \"./lib/GeoJsonDataProvider\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport \"@here/harp-fetch\";\n\nimport { GeoJson, ITiler, WorkerServiceProtocol } from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils\";\nimport { ConcurrentTilerFacade } from \"@here/harp-mapview\";\nimport { DataProvider } from \"@here/harp-mapview-decoder\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nimport { GEOJSON_TILER_SERVICE_TYPE } from \"./OmvDecoderDefs\";\n\nconst logger = LoggerManager.instance.create(\"GeoJsonDataProvider\");\n\nconst INVALIDATED = \"invalidated\";\n\nexport interface GeoJsonDataProviderOptions {\n    /**\n     * Worker script hosting `Tiler` service.\n     * @default `./decoder.bundle.ts`\n     */\n    workerTilerUrl?: string;\n\n    /**\n     * Custom tiler instance.\n     *\n     * @remarks\n     * If not provided, {@link GeoJsonDataProvider} will obtain `WorkerBasedTiler`\n     * from `ConcurrentTilerFacade`.\n     */\n    tiler?: ITiler;\n\n    /**\n     * Timeout for connecting to the web worker in seconds. Default to 10s, search for:\n     * DEFAULT_WORKER_INITIALIZATION_TIMEOUT\n     */\n    workerConnectionTimeout?: number;\n}\n\nlet missingTilerServiceInfoEmitted: boolean = false;\n\n/**\n * GeoJson {@link @here/harp-mapview-decoder@DataProvider}.\n *\n * @remarks\n * Automatically handles tiling and simplification of static GeoJson.\n */\nexport class GeoJsonDataProvider extends DataProvider {\n    private readonly m_tiler: ITiler;\n    private m_registered = false;\n\n    /**\n     * Constructs a new `GeoJsonDataProvider`.\n     *\n     * @param name - Name to be used to reference this `DataProvider`\n     * @param input - URL of the GeoJSON, or a GeoJSON.\n     * @param options - Optional\n     * @returns New `GeoJsonDataProvider`.\n     */\n    constructor(\n        readonly name: string,\n        public input: URL | GeoJson,\n        options?: GeoJsonDataProviderOptions\n    ) {\n        super();\n\n        this.m_tiler =\n            options?.tiler ??\n            ConcurrentTilerFacade.getTiler(\n                GEOJSON_TILER_SERVICE_TYPE,\n                options?.workerTilerUrl,\n                options?.workerConnectionTimeout\n            );\n    }\n\n    async connect(): Promise<void> {\n        try {\n            await this.m_tiler.connect();\n        } catch (error) {\n            if (\n                WorkerServiceProtocol.isUnknownServiceError(error) &&\n                !missingTilerServiceInfoEmitted\n            ) {\n                logger.info(\n                    \"Unable to start GeoJson tiler service in worker. Use \" +\n                        \" 'OmvTilerService.start();' in decoder script.\"\n                );\n                missingTilerServiceInfoEmitted = true;\n            }\n            throw error;\n        }\n\n        await this.m_tiler.registerIndex(this.name, this.input);\n        this.m_registered = true;\n    }\n\n    updateInput(input: URL | GeoJson) {\n        this.input = input;\n        this.m_tiler.updateIndex(this.name, this.input);\n        this.dispatchEvent({ type: INVALIDATED });\n    }\n\n    ready(): boolean {\n        return this.m_registered;\n    }\n\n    async getTile(tileKey: TileKey): Promise<{}> {\n        return await this.m_tiler.getTile(this.name, tileKey);\n    }\n\n    onDidInvalidate(listener: () => void) {\n        this.addEventListener(INVALIDATED, listener);\n        return () => this.removeEventListener(INVALIDATED, listener);\n    }\n\n    /**\n     * Destroys this `GeoJsonDataProvider`.\n     */\n    dispose() {\n        this.m_tiler.dispose();\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { GeometryKind, GeometryKindSet } from \"@here/harp-datasource-protocol\";\nimport { MapEnv } from \"@here/harp-datasource-protocol/index-decoder\";\n\nimport {\n    OmvFeatureFilterDescription,\n    OmvFilterDescription,\n    OmvFilterFeatureAttribute,\n    OmvFilterString,\n    OmvGeometryType,\n    OmvLayerFilterDescription\n} from \"./OmvDecoderDefs\";\n\n/**\n * The `OmvFeatureFilter` is designed to work in an `OmvVisitor`/`visitOmv` combination (for\n * example, `OmvDecoder`).\n *\n * @remarks\n * Returning `false` from any of the calls terminates processing of that\n * layer or feature.\n *\n * The `OmvFeatureFilter` is an \"early-opt-out\" filter, which cannot filter individual features,\n * because at that point the features are not really decoded. Use the [[OmvFeatureModifier]] to\n * filter for individual features.\n */\nexport interface OmvFeatureFilter {\n    /**\n     * Returns `true` if the filter contains rules for specific kinds.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    hasKindFilter: boolean;\n\n    /**\n     * Return `false` if the layer should not be processed.\n     *\n     * @param layer - Current layer.\n     * @param level - Level of tile.\n     */\n    wantsLayer(layer: string, level: number): boolean;\n\n    /**\n     * Return `false` if the point feature should not be processed.\n     *\n     * @param layer - Current layer.\n     * @param feature - Current feature.\n     * @param level - Level of tile.\n     */\n    wantsPointFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean;\n\n    /**\n     * Return `false` if the line feature should not be processed.\n     *\n     * @param layer - Current layer.\n     * @param feature - Current feature.\n     * @param level - Level of tile.\n     */\n    wantsLineFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean;\n\n    /**\n     * Return `false` if the polygon feature should not be processed.\n     *\n     * @param layer - Current layer.\n     * @param feature - Current feature.\n     * @param level - Level of tile.\n     */\n    wantsPolygonFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean;\n\n    /**\n     * Return `false` if kind of object is not enabled and the geometry should not be created.\n     *\n     * @param {(string | string[])} kind Tag \"kind\" of the tag.\n     * @returns {boolean}\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    wantsKind(kind: string | string[]): boolean;\n}\n\n/**\n * The `OmvFeatureModifier` can be used to filter individual features.\n *\n * @remarks\n * It gets passed in the `Env`\n * of the feature, which contains all the values that can be searched for in a style. If a filter\n * function returns false, the feature is ignored, and no geometry is being created.\n *\n * In addition to pure filtering, the `OmvFeatureModifier` can also modify the [[Env]] of the\n * feature, or even add new properties to the feature, for example, traffic states. The\n * `OmvFeatureModifier` is executed before the styles are selected, so the geometry is created with\n * the modified feature properties.\n */\nexport interface OmvFeatureModifier {\n    /**\n     * Check if the point feature described by `env` should be processed. The properties can be\n     * modified or added to.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of point feature.\n     * @param level - Level of tile.\n     * @returns `false` to ignore feature.\n     */\n    doProcessPointFeature(layer: string, env: MapEnv, level: number): boolean;\n\n    /**\n     * Check if the line feature described by `env` should be processed. The properties can be\n     * modified or added to.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of line feature.\n     * @param level - Level of tile.\n     * @returns `false` to ignore feature.\n     */\n    doProcessLineFeature(layer: string, env: MapEnv, level: number): boolean;\n\n    /**\n     * Check if the polygon feature described by `env` should be processed. The properties can be\n     * modified or added to.\n     *\n     * @param layer - Current layer.\n     * @param env - Properties of polygon feature.\n     * @param level - Level of tile.\n     * @returns `false` to ignore feature.\n     */\n    doProcessPolygonFeature(layer: string, env: MapEnv, level: number): boolean;\n}\n\n/**\n * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as well\n * as an [[OmvFeatureModifier]].\n *\n */\nexport class OmvFeatureFilterDescriptionBuilder {\n    private readonly m_processLayersDefault: boolean = true;\n    private readonly m_processPointsDefault: boolean = true;\n    private readonly m_processLinesDefault: boolean = true;\n    private readonly m_processPolygonsDefault: boolean = true;\n\n    private readonly m_layersToProcess = new Array<OmvLayerFilterDescription>();\n    private readonly m_layersToIgnore = new Array<OmvLayerFilterDescription>();\n    private readonly m_pointsToProcess = new Array<OmvFilterDescription>();\n    private readonly m_ignoredPoints = new Array<OmvFilterDescription>();\n    private readonly m_linesToProcess = new Array<OmvFilterDescription>();\n    private readonly m_linesToIgnore = new Array<OmvFilterDescription>();\n    private readonly m_polygonsToProcess = new Array<OmvFilterDescription>();\n    private readonly m_polygonsToIgnore = new Array<OmvFilterDescription>();\n\n    private m_kindsToProcess: string[] = [];\n    private m_kindsToIgnore: string[] = [];\n\n    /**\n     * Builds an `OmvFilterDescription` (internal type) that specifies an [[OmvFeatureFilter]] as\n     * well as an [[OmvFeatureModifier]].\n     *\n     * @param processLayersDefault - If `true`, all unspecified layers will be processed.\n     * If `false`, all unspecified layers will be ignored.\n     * @param processPointsDefault - If `true`, all unspecified point features will be processed. If\n     * `false`, all unspecified point features will be ignored.\n     * @param processLinesDefault - If `true`, all unspecified line features will be processed. If\n     * `false`, all unspecified line features will be ignored.\n     * @param processPolygonsDefault - If `true`, all unspecified polygon features will be\n     * processed. If `false`, all unspecified polygon features will be ignored.\n     */\n    constructor(\n        options?: OmvFeatureFilterDescriptionBuilder.OmvFeatureFilterDescriptionBuilderOptions\n    ) {\n        if (options) {\n            this.m_processLayersDefault =\n                options.processLayersDefault !== undefined ? options.processLayersDefault : true;\n            this.m_processPointsDefault =\n                options.processPointsDefault !== undefined ? options.processPointsDefault : true;\n            this.m_processLinesDefault =\n                options.processLinesDefault !== undefined ? options.processLinesDefault : true;\n            this.m_processPolygonsDefault =\n                options.processPolygonsDefault !== undefined\n                    ? options.processPolygonsDefault\n                    : true;\n        }\n    }\n\n    /**\n     * Add a layer that should be processed.\n     *\n     * @param layer - Layer name to be matched.\n     * @param match - Match condition.\n     */\n    processLayer(\n        layer: string,\n        match = OmvFilterString.StringMatch.Match,\n        minLevel: number = 0,\n        maxLevel: number = Infinity\n    ) {\n        this.m_layersToProcess.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n\n    /**\n     * Add a layer that should be ignored.\n     *\n     * @param layer - Layer name to be matched.\n     * @param match - Match condition.\n     */\n    ignoreLayer(\n        layer: string,\n        match = OmvFilterString.StringMatch.Match,\n        minLevel: number = 0,\n        maxLevel: number = Infinity\n    ) {\n        this.m_layersToIgnore.push({\n            name: { value: layer, match },\n            minLevel,\n            maxLevel\n        });\n    }\n\n    /**\n     * Add a valid point feature.\n     *\n     * @param options - Feature options.\n     */\n    processPoint(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_pointsToProcess, options);\n    }\n\n    /**\n     * Add valid point features.\n     *\n     * @param options - Multi feature options.\n     */\n    processPoints(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_pointsToProcess, options);\n    }\n\n    /**\n     * Add a point feature that should be ignored.\n     *\n     * @param options - Feature options.\n     */\n    ignorePoint(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_ignoredPoints, options);\n    }\n\n    /**\n     * Add point features that should be ignored.\n     *\n     * @param options - Multi feature options.\n     */\n    ignorePoints(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_ignoredPoints, options);\n    }\n\n    /**\n     * Add a valid line feature.\n     *\n     * @param options - Feature options.\n     */\n    processLine(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_linesToProcess, options);\n    }\n\n    /**\n     * Add valid line features.\n     *\n     * @param options - Multi feature options.\n     */\n    processLines(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_linesToProcess, options);\n    }\n\n    /**\n     * Ignore a line feature.\n     *\n     * @param options - Feature options.\n     */\n    ignoreLine(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_linesToIgnore, options);\n    }\n\n    /**\n     * Ignore line features.\n     *\n     * @param options - Multi feature options.\n     */\n    ignoreLines(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_linesToIgnore, options);\n    }\n\n    /**\n     * Add a valid polygon feature.\n     *\n     * @param options - Feature options.\n     */\n    processPolygon(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_polygonsToProcess, options);\n    }\n\n    /**\n     * Add valid polygon features.\n     *\n     * @param options - Multi feature options.\n     */\n    processPolygons(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_polygonsToProcess, options);\n    }\n\n    /**\n     * Ignore a valid polygon feature.\n     *\n     * @param options - Feature options.\n     */\n    ignorePolygon(options: OmvFeatureFilterDescriptionBuilder.FeatureOption) {\n        this.addItem(this.m_polygonsToIgnore, options);\n    }\n\n    /**\n     * Ignore polygon features.\n     *\n     * @param options - Multi feature options.\n     */\n    ignorePolygons(options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption) {\n        this.addItems(this.m_polygonsToIgnore, options);\n    }\n\n    /**\n     * Add all the specified strings as \"enabledKinds\".\n     *\n     * @param {string[]} enabledKinds List of kinds that should be generated.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    processKinds(enabledKinds: string[]) {\n        this.m_kindsToProcess = this.m_kindsToProcess.concat(enabledKinds);\n    }\n\n    /**\n     * Add all the specified strings as \"disabledKinds\".\n     *\n     * @param {string[]} disabledKinds List of kinds that should _not_ be generated.\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    ignoreKinds(disabledKinds: string[]) {\n        this.m_kindsToIgnore = this.m_kindsToIgnore.concat(disabledKinds);\n    }\n\n    /**\n     * Create a filter description that can be passed as an option to the [[OmvDataSource]].\n     */\n    createDescription(): OmvFeatureFilterDescription {\n        return {\n            processLayersDefault: this.m_processLayersDefault,\n            processPointsDefault: this.m_processPointsDefault,\n            processLinesDefault: this.m_processLinesDefault,\n            processPolygonsDefault: this.m_processPolygonsDefault,\n\n            layersToProcess: this.m_layersToProcess,\n            layersToIgnore: this.m_layersToIgnore,\n            pointsToProcess: this.m_pointsToProcess,\n            pointsToIgnore: this.m_ignoredPoints,\n            linesToProcess: this.m_linesToProcess,\n            linesToIgnore: this.m_linesToIgnore,\n            polygonsToProcess: this.m_polygonsToProcess,\n            polygonsToIgnore: this.m_polygonsToIgnore,\n\n            kindsToProcess: this.m_kindsToProcess,\n            kindsToIgnore: this.m_kindsToIgnore\n        };\n    }\n\n    private addItem(\n        items: OmvFilterDescription[],\n        options: OmvFeatureFilterDescriptionBuilder.FeatureOption\n    ) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n\n        const item: OmvFilterDescription = {\n            layerName: {\n                value: options.layer,\n                match:\n                    options.matchLayer === undefined\n                        ? OmvFilterString.StringMatch.Match\n                        : options.matchLayer\n            },\n            geometryTypes:\n                options.geomType !== undefined\n                    ? Array.isArray(options.geomType)\n                        ? options.geomType\n                        : [options.geomType]\n                    : undefined,\n            classes: [\n                {\n                    value: options.featureClass,\n                    match:\n                        options.matchClass === undefined\n                            ? OmvFilterString.StringMatch.Match\n                            : options.matchClass\n                }\n            ],\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n\n        items.push(item);\n    }\n\n    private addItems(\n        items: OmvFilterDescription[],\n        options: OmvFeatureFilterDescriptionBuilder.MultiFeatureOption\n    ) {\n        if (options.minLevel === undefined || isNaN(options.minLevel)) {\n            options.minLevel = 0;\n        }\n        if (options.maxLevel === undefined || isNaN(options.maxLevel)) {\n            options.maxLevel = Infinity;\n        }\n\n        const item: OmvFilterDescription = {\n            layerName: {\n                value: options.layer,\n                match:\n                    options.matchLayer === undefined\n                        ? OmvFilterString.StringMatch.Match\n                        : options.matchLayer\n            },\n            geometryTypes:\n                options.geomTypes !== undefined\n                    ? Array.isArray(options.geomTypes)\n                        ? options.geomTypes\n                        : [options.geomTypes]\n                    : undefined,\n            classes: options.featureClasses,\n            minLevel: options.minLevel,\n            maxLevel: options.maxLevel,\n            featureAttribute: options.featureAttribute\n        };\n\n        items.push(item);\n    }\n}\n\nexport namespace OmvFeatureFilterDescriptionBuilder {\n    /**\n     * Options for `OmvFeatureFilterDescriptionBuilder`.\n     */\n    export interface OmvFeatureFilterDescriptionBuilderOptions {\n        /**\n         * If `true`, all unspecified layers will be processed. If `false`, all unspecified layers\n         * will be ignored.\n         */\n        processLayersDefault?: boolean;\n        /**\n         * If `true`, all unspecified point features will be processed. If `false`, all unspecified\n         * point features will be ignored.\n         */\n        processPointsDefault?: boolean;\n        /**\n         * If `true`, all unspecified line features will be processed. If `false`, all unspecified\n         * line\n         * features will be ignored.\n         */\n        processLinesDefault?: boolean;\n        /**\n         * If `true`, all unspecified polygon features will be processed. If `false`, all\n         * unspecified polygon features will be ignored.\n         */\n        processPolygonsDefault?: boolean;\n    }\n\n    /**\n     * Description of a single feature.\n     */\n    export interface FeatureOption {\n        /**\n         * Layer name to be matched.\n         */\n        layer: string;\n        /**\n         * Optional geometry type to be limited to. If specified, but does not match, the feature is\n         * ignored.\n         */\n        geomType: OmvGeometryType | OmvGeometryType[] | undefined;\n        /**\n         * Optional class to match. If specified, but does not match, the feature is ignored.\n         */\n        featureClass: string;\n        /**\n         * Match condition for the layer name.\n         */\n        matchLayer?: OmvFilterString.StringMatch;\n        /**\n         * Match condition for `featureClass`.\n         */\n        matchClass?: OmvFilterString.StringMatch;\n        /**\n         * Minimum tile level to match.\n         */\n        minLevel?: number;\n        /**\n         * Maximum tile level to match.\n         */\n        maxLevel?: number;\n        /**\n         * Feature attribute to match.\n         */\n        featureAttribute?: OmvFilterFeatureAttribute;\n    }\n\n    /**\n     * Description for multiple features.\n     */\n    export interface MultiFeatureOption {\n        /**\n         * Layer name to be matched.\n         */\n        layer: string;\n        /**\n         * Optional geometry type to be limited to. If specified, but does not match, the feature is\n         * ignored.\n         */\n        geomTypes?: OmvGeometryType | OmvGeometryType[] | undefined;\n        /**\n         * Optional classes to match. If specified, but does not match, the feature is ignored.\n         */\n        featureClasses?: OmvFilterString[];\n        /**\n         * Match condition for the layer name.\n         */\n        matchLayer?: OmvFilterString.StringMatch;\n        /**\n         * Minimum tile level to match.\n         */\n        minLevel?: number;\n        /**\n         * Maximum tile level to match.\n         */\n        maxLevel?: number;\n        /**\n         * Feature attribute to match.\n         */\n        featureAttribute?: OmvFilterFeatureAttribute;\n    }\n}\n\n/**\n * `OmvFeatureFilter` implementation that uses a `OmvFeatureFilterDescription` to filter `TileData`\n * features before they are completely decoded.\n *\n * @internal\n */\nexport class OmvGenericFeatureFilter implements OmvFeatureFilter {\n    private static matchLayer(\n        layer: string,\n        layerItems: OmvLayerFilterDescription[],\n        level: number\n    ): boolean {\n        for (const layerItem of layerItems) {\n            if (level < layerItem.minLevel || level > layerItem.maxLevel) {\n                continue;\n            }\n\n            if (OmvFilterString.matchString(layer, layerItem.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private readonly disabledKinds: GeometryKindSet | undefined;\n    private readonly enabledKinds: GeometryKindSet | undefined;\n\n    constructor(private readonly description: OmvFeatureFilterDescription) {\n        if (this.description.kindsToProcess.length > 0) {\n            this.enabledKinds = new GeometryKindSet(\n                this.description.kindsToProcess as GeometryKind[]\n            );\n        }\n        if (this.description.kindsToIgnore.length > 0) {\n            this.disabledKinds = new GeometryKindSet(\n                this.description.kindsToIgnore as GeometryKind[]\n            );\n        }\n    }\n\n    wantsLayer(layer: string, level: number): boolean {\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToProcess, level)) {\n            return true;\n        }\n\n        if (OmvGenericFeatureFilter.matchLayer(layer, this.description.layersToIgnore, level)) {\n            return false;\n        }\n\n        return this.description.processLayersDefault;\n    }\n\n    wantsPointFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.wantsFeature(\n            this.description.pointsToProcess,\n            this.description.pointsToIgnore,\n            layer,\n            geometryType,\n            level,\n            this.description.processPointsDefault\n        );\n    }\n\n    wantsLineFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.wantsFeature(\n            this.description.linesToProcess,\n            this.description.linesToIgnore,\n            layer,\n            geometryType,\n            level,\n            this.description.processLinesDefault\n        );\n    }\n\n    wantsPolygonFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.wantsFeature(\n            this.description.polygonsToProcess,\n            this.description.polygonsToIgnore,\n            layer,\n            geometryType,\n            level,\n            this.description.processPolygonsDefault\n        );\n    }\n\n    /**\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    wantsKind(kind: string | string[]): boolean {\n        // undefined -> no way to filter\n        if (kind === undefined) {\n            return true;\n        }\n\n        return (\n            !(\n                this.disabledKinds !== undefined &&\n                this.disabledKinds.hasOrIntersects(kind as GeometryKind)\n            ) ||\n            (this.enabledKinds !== undefined &&\n                this.enabledKinds.hasOrIntersects(kind as GeometryKind))\n        );\n    }\n\n    /**\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    get hasKindFilter(): boolean {\n        return this.enabledKinds !== undefined || this.disabledKinds !== undefined;\n    }\n\n    private wantsFeature(\n        itemsToProcess: OmvFilterDescription[],\n        itemsToIgnore: OmvFilterDescription[],\n        layer: string,\n        geometryType: OmvGeometryType,\n        level: number,\n        defaultResult: boolean\n    ): boolean {\n        for (const item of itemsToProcess) {\n            if (level < item.minLevel || level > item.maxLevel) {\n                continue;\n            }\n\n            if (!OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n\n            if (item.geometryTypes !== undefined && item.geometryTypes.includes(geometryType)) {\n                return true;\n            }\n        }\n\n        for (const item of itemsToIgnore) {\n            if (!OmvFilterString.matchString(layer, item.layerName)) {\n                // this rule is not for this layer\n                continue;\n            }\n\n            if (item.geometryTypes !== undefined && item.geometryTypes.includes(geometryType)) {\n                return false;\n            }\n        }\n\n        return defaultResult;\n    }\n}\n\n/**\n * An [[OmvFeatureFilter]] implementation that delegates all filter decision\n * returning `true` for any predicate if all delegates return `true`.\n *\n * @internal\n */\nexport class ComposedDataFilter implements OmvFeatureFilter {\n    constructor(readonly filters: OmvFeatureFilter[]) {}\n\n    /**\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    get hasKindFilter() {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result || filter.hasKindFilter,\n            true\n        );\n    }\n\n    wantsLayer(layer: string, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsLayer(layer, level),\n            true\n        );\n    }\n\n    wantsPointFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsPointFeature(layer, geometryType, level),\n            true\n        );\n    }\n\n    wantsLineFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsLineFeature(layer, geometryType, level),\n            true\n        );\n    }\n\n    wantsPolygonFeature(layer: string, geometryType: OmvGeometryType, level: number): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsPolygonFeature(layer, geometryType, level),\n            true\n        );\n    }\n\n    /**\n     * @deprecated See {@link @here/here-datasource-protocol/BaseTechniqueParams.kind}.\n     */\n    wantsKind(kind: string | string[]): boolean {\n        return this.filters.reduce<boolean>(\n            (result, filter) => result && filter.wantsKind(kind),\n            true\n        );\n    }\n}\n/**\n * `OmvFeatureModifier` implementation that uses a `OmvFeatureFilterDescription` to filter\n * `TileData` features before they are completely decoded.\n *\n * @internal\n */\nexport class OmvGenericFeatureModifier implements OmvFeatureModifier {\n    static matchItems(\n        layerName: string,\n        featureClass: string,\n        items: OmvFilterDescription[]\n    ): boolean {\n        for (const item of items) {\n            if (item.classes !== undefined) {\n                if (!OmvFilterString.matchString(layerName, item.layerName)) {\n                    continue;\n                }\n                for (const matchClass of item.classes) {\n                    if (OmvFilterString.matchString(featureClass, matchClass)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    static matchAttribute(layerName: string, env: MapEnv, items: OmvFilterDescription[]): boolean {\n        for (const item of items) {\n            if (item.featureAttribute !== undefined) {\n                if (\n                    OmvFilterString.matchString(layerName, item.layerName) &&\n                    env.lookup(item.featureAttribute.key) === item.featureAttribute.value\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    constructor(private readonly description: OmvFeatureFilterDescription) {}\n\n    doProcessPointFeature(layer: string, env: MapEnv): boolean {\n        return this.doProcessFeature(\n            this.description.pointsToProcess,\n            this.description.pointsToIgnore,\n            layer,\n            env,\n            this.description.processPointsDefault\n        );\n    }\n\n    doProcessLineFeature(layer: string, env: MapEnv): boolean {\n        return this.doProcessFeature(\n            this.description.linesToProcess,\n            this.description.linesToIgnore,\n            layer,\n            env,\n            this.description.processLinesDefault\n        );\n    }\n\n    doProcessPolygonFeature(layer: string, env: MapEnv): boolean {\n        return this.doProcessFeature(\n            this.description.polygonsToProcess,\n            this.description.polygonsToIgnore,\n            layer,\n            env,\n            this.description.processPolygonsDefault\n        );\n    }\n\n    protected doProcessFeature(\n        itemsToProcess: OmvFilterDescription[],\n        itemsToIgnore: OmvFilterDescription[],\n        layer: string,\n        env: MapEnv,\n        defaultResult: boolean\n    ): boolean {\n        if (layer === undefined || (itemsToProcess.length === 0 && itemsToIgnore.length === 0)) {\n            return defaultResult;\n        }\n\n        let featureClass: string | undefined;\n        const featureClassThing = env.lookup(\"class\");\n\n        if (featureClassThing !== undefined && featureClassThing !== null) {\n            featureClass = featureClassThing.toString();\n        }\n\n        if (\n            featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToProcess)\n        ) {\n            return true;\n        }\n\n        if (\n            featureClass &&\n            OmvGenericFeatureModifier.matchItems(layer, featureClass, itemsToIgnore)\n        ) {\n            return false;\n        }\n\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToProcess)) {\n            return true;\n        }\n\n        if (OmvGenericFeatureModifier.matchAttribute(layer, env, itemsToIgnore)) {\n            return false;\n        }\n\n        return defaultResult;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { getPropertyValue, isTextTechnique } from \"@here/harp-datasource-protocol\";\nimport { TileKey } from \"@here/harp-geoutils/lib/tiling/TileKey\";\nimport { DataSource, TextElement, Tile } from \"@here/harp-mapview\";\nimport { debugContext } from \"@here/harp-mapview/lib/DebugContext\";\nimport { TileGeometryCreator } from \"@here/harp-mapview/lib/geometry/TileGeometryCreator\";\nimport { TextElementType } from \"@here/harp-mapview/lib/text/TextElementType\";\nimport {\n    ContextualArabicConverter,\n    FontUnit,\n    TextLayoutStyle,\n    TextRenderStyle\n} from \"@here/harp-text-canvas\";\nimport * as THREE from \"three\";\n\nconst debugMaterial = new THREE.LineBasicMaterial({\n    color: 0x000000,\n    linewidth: 1,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\n\nconst debugCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\n\nconst debugCircleMaterialWF = new THREE.MeshBasicMaterial({\n    color: 0xff0000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterialWF.wireframe = true;\n\nconst debugCircleMaterial2WF = new THREE.MeshBasicMaterial({\n    color: 0x8080ff,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\ndebugCircleMaterial2WF.wireframe = true;\n\nconst debugBlackCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0x000000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth\n});\n\nconst debugBlueCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0x0000ff,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth,\n    opacity: 0.75,\n    transparent: true\n});\n\nconst debugOrangeCircleMaterial = new THREE.MeshBasicMaterial({\n    color: 0xa07000,\n    depthTest: false,\n    depthFunc: THREE.NeverDepth,\n    opacity: 0.75,\n    transparent: true\n});\n\nconst textRenderStyle = new TextRenderStyle();\nconst textLayoutStyle = new TextLayoutStyle();\n\ntextRenderStyle.fontSize = {\n    unit: FontUnit.Point,\n    size: 9,\n    backgroundSize: 0\n};\ntextRenderStyle.opacity = 0.75;\ntextRenderStyle.backgroundOpacity = 0.75;\ntextRenderStyle.color = new THREE.Color(0.8, 0.2, 0.2);\n\n// Set maximum priority.\nconst PRIORITY_ALWAYS = Number.MAX_SAFE_INTEGER;\n\nclass DebugGeometry {\n    geometry = new THREE.BufferGeometry();\n    indices = new Array<number>();\n    positions = new Array<number>();\n}\n\nfunction addPoint(\n    xPos: number,\n    yPos: number,\n    zPos: number,\n    size: number,\n    debugGeometry: DebugGeometry\n) {\n    debugGeometry.positions.push(xPos, yPos - size, zPos);\n    debugGeometry.positions.push(xPos + size, yPos, zPos);\n    debugGeometry.positions.push(xPos, yPos + size, zPos);\n    debugGeometry.positions.push(xPos - size, yPos, zPos);\n\n    const index = debugGeometry.positions.length / 3;\n\n    debugGeometry.indices.push(index - 4);\n    debugGeometry.indices.push(index - 3);\n    debugGeometry.indices.push(index - 2);\n    debugGeometry.indices.push(index - 4);\n    debugGeometry.indices.push(index - 2);\n    debugGeometry.indices.push(index - 1);\n}\n\nfunction addObject(\n    objects: THREE.Object3D[],\n    debugGeometry: DebugGeometry,\n    priorityOffset: number = 0,\n    factory: (geom: THREE.BufferGeometry) => THREE.Object3D\n) {\n    if (debugGeometry.indices.length > 0) {\n        debugGeometry.geometry.addGroup(0, debugGeometry.indices.length, 0);\n\n        debugGeometry.geometry.setAttribute(\n            \"position\",\n            new THREE.BufferAttribute(new Float32Array(debugGeometry.positions), 3)\n        );\n\n        debugGeometry.geometry.setIndex(\n            new THREE.BufferAttribute(new Uint32Array(debugGeometry.indices), 1)\n        );\n        const mesh = factory(debugGeometry.geometry);\n        mesh.renderOrder = PRIORITY_ALWAYS - priorityOffset;\n        objects.push(mesh);\n    }\n}\n\nexport class OmvDebugLabelsTile extends Tile {\n    constructor(dataSource: DataSource, tileKey: TileKey) {\n        super(dataSource, tileKey);\n    }\n\n    /**\n     * @override\n     * Create [[TextElement]] objects for label debugging.\n     */\n    loadingFinished() {\n        // activate in the browser with:\n        // window.__debugContext.setValue(\"DEBUG_TEXT_PATHS\", true)\n        const debugTextPaths = debugContext.getValue(\"DEBUG_TEXT_PATHS\");\n        const debugTextPathsFull = debugContext.getValue(\"DEBUG_TEXT_PATHS_FULL\");\n        const debugTextPoisFull = debugContext.getValue(\"DEBUG_TEXT_POIS_FULL\");\n        const debugLineMarkers = debugContext.getValue(\"DEBUG_TEXT_LINE_MARKER\");\n\n        if (\n            !(debugTextPaths || debugTextPathsFull || debugLineMarkers) ||\n            this.decodedTile === undefined\n        ) {\n            return;\n        }\n\n        const tileGeometryCreator = TileGeometryCreator.instance;\n        const decodedTile = this.decodedTile!;\n        const colorMap = new Map<number, THREE.Color>();\n\n        // allow limiting to specific names and/or index. There can be many paths with the\n        // same text\n        const textFilter = debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.TEXT\");\n        const indexFilter = debugContext.getValue(\"DEBUG_TEXT_PATHS.FILTER.INDEX\");\n        const env = this.mapView.env;\n\n        if (decodedTile.textPathGeometries !== undefined) {\n            this.preparedTextPaths = tileGeometryCreator.prepareTextPaths(\n                decodedTile.textPathGeometries,\n                decodedTile\n            );\n        }\n\n        const centerX = this.center.x;\n        const centerY = this.center.y;\n        const centerZ = this.center.z;\n        const pointScale = this.mapView.pixelToWorld;\n        const worldOffsetX = this.computeWorldOffsetX();\n        const zHeight = 10;\n\n        let pointLabelIndex = 0;\n\n        if (this.textElementGroups.count() > 0) {\n            const bluePoints = new DebugGeometry();\n            const orangePoints = new DebugGeometry();\n            const addedTextElements: TextElement[] = [];\n\n            this.textElementGroups.forEach((textElement: TextElement) => {\n                if (\n                    textElement.type !== TextElementType.LineMarker &&\n                    textElement.type !== TextElementType.PoiLabel\n                ) {\n                    return;\n                }\n\n                const isLineMarker = textElement.type === TextElementType.LineMarker;\n                const geometry = isLineMarker ? orangePoints : bluePoints;\n                const pointSize = pointScale * 5;\n\n                const addLabel = (x: number, y: number, z: number) => {\n                    addPoint(x, y, z, pointSize, geometry);\n\n                    if (debugTextPoisFull || debugLineMarkers) {\n                        const offsetXY = pointSize * 0.5;\n                        const label: string = `${textElement.text} [${pointLabelIndex}]`;\n\n                        const labelElement = new TextElement(\n                            ContextualArabicConverter.instance.convert(label),\n                            new THREE.Vector3(\n                                x + worldOffsetX + centerX + offsetXY,\n                                y + centerY + offsetXY,\n                                z + centerZ\n                            ),\n                            textRenderStyle,\n                            textLayoutStyle,\n                            PRIORITY_ALWAYS,\n                            0.0,\n                            0.0\n                        );\n                        labelElement.minZoomLevel = 0;\n                        labelElement.mayOverlap = true;\n                        labelElement.reserveSpace = false;\n                        labelElement.alwaysOnTop = true;\n                        labelElement.ignoreDistance = true;\n                        labelElement.priority = TextElement.HIGHEST_PRIORITY;\n\n                        (labelElement as any)._isDebug = true;\n\n                        addedTextElements.push(labelElement);\n                    }\n\n                    pointLabelIndex++;\n                };\n\n                if (textElement.path !== undefined && Array.isArray(textElement.path)) {\n                    for (let i = 0; i < textElement.path.length; i++) {\n                        const pos = textElement.path[i];\n                        const x = pos.x - centerX;\n                        const y = pos.y - centerY;\n                        const z = zHeight + pos.z + i * 5 - centerZ;\n                        addLabel(x, y, z);\n                    }\n                } else if (debugTextPoisFull) {\n                    const x = textElement.position.x - centerX;\n                    const y = textElement.position.y - centerY;\n                    const z = 5 - centerZ;\n                    addLabel(x, y, z);\n                }\n            });\n\n            for (const labelElement of addedTextElements) {\n                this.addTextElement(labelElement);\n            }\n\n            addObject(\n                this.objects,\n                bluePoints,\n                0,\n                (geometry: THREE.BufferGeometry): THREE.Object3D => {\n                    return new THREE.Mesh(geometry, debugBlueCircleMaterial);\n                }\n            );\n            addObject(\n                this.objects,\n                orangePoints,\n                0,\n                (geometry: THREE.BufferGeometry): THREE.Object3D => {\n                    return new THREE.Mesh(geometry, debugOrangeCircleMaterial);\n                }\n            );\n        }\n\n        if (this.preparedTextPaths !== undefined) {\n            const lines = new DebugGeometry();\n            const redPoints = new DebugGeometry();\n            const blackPoints = new DebugGeometry();\n\n            let baseVertex = 0;\n\n            for (const textPath of this.preparedTextPaths) {\n                const technique = decodedTile.techniques[textPath.technique];\n                if (!isTextTechnique(technique) || (textPath as any)._isDebug !== undefined) {\n                    continue;\n                }\n                if (technique.color !== undefined) {\n                    colorMap.set(\n                        textPath.technique,\n                        new THREE.Color(getPropertyValue(technique.color, env))\n                    );\n                }\n\n                baseVertex = lines.positions.length / 3;\n\n                const text = textPath.text;\n\n                const elementIndex = this.preparedTextPaths.indexOf(textPath);\n\n                const createDebugInfo =\n                    (!textFilter || (text && text.includes(textFilter))) &&\n                    (indexFilter === undefined || indexFilter === elementIndex);\n\n                if (createDebugInfo) {\n                    for (let i = 0; i < textPath.path.length; i += 3) {\n                        const pathIndex = i / 3;\n                        const x = textPath.path[i] - centerX;\n                        const y = textPath.path[i + 1] - centerY;\n                        // raise it a bit, so we get identify connectivity visually by tilting\n                        const z = zHeight + textPath.path[i + 2] + i / 3 - centerZ;\n\n                        if (debugTextPaths) {\n                            lines.positions.push(x, y, z);\n                        }\n\n                        const isRedPoint = i === 0 && debugTextPaths;\n\n                        if (debugTextPathsFull || isRedPoint) {\n                            const pointSize = pointScale * (isRedPoint ? 6 : 4);\n                            const geometry = isRedPoint ? redPoints : blackPoints;\n\n                            addPoint(x, y, z, pointSize, geometry);\n\n                            if (debugTextPathsFull) {\n                                const xOffset = technique.xOffset ?? 0.0;\n                                const yOffset = technique.yOffset ?? 0.0;\n                                const minZoomLevel = technique.minZoomLevel;\n                                // give point index a label\n                                const label: string =\n                                    pathIndex % 5 === 0\n                                        ? text + \":\" + pathIndex\n                                        : Number(pathIndex).toString();\n                                const labelElement = new TextElement(\n                                    ContextualArabicConverter.instance.convert(label),\n                                    new THREE.Vector3(\n                                        x + worldOffsetX + centerX,\n                                        y + centerY,\n                                        z + centerZ\n                                    ),\n                                    textRenderStyle,\n                                    textLayoutStyle,\n                                    getPropertyValue(technique.priority ?? 0, env),\n                                    xOffset,\n                                    yOffset\n                                );\n                                labelElement.minZoomLevel = getPropertyValue(minZoomLevel, env);\n                                labelElement.mayOverlap = true;\n                                labelElement.reserveSpace = false;\n                                labelElement.alwaysOnTop = true;\n                                labelElement.ignoreDistance = true;\n                                labelElement.priority = TextElement.HIGHEST_PRIORITY;\n                                this.addTextElement(labelElement);\n                            }\n                        }\n                    }\n\n                    // the lines of a path share a common geometry\n                    const N = textPath.path.length / 3;\n                    for (let i = 0; i < N; ++i) {\n                        if (i > 0) {\n                            lines.indices.push(baseVertex + i);\n                        }\n                        if (i + 1 < N) {\n                            lines.indices.push(baseVertex + i);\n                        }\n                    }\n                }\n            }\n\n            addObject(\n                this.objects,\n                lines,\n                -2,\n                (geometry: THREE.BufferGeometry): THREE.Object3D => {\n                    return new THREE.LineSegments(geometry, debugMaterial);\n                }\n            );\n            addObject(\n                this.objects,\n                redPoints,\n                0,\n                (geometry: THREE.BufferGeometry): THREE.Object3D => {\n                    return new THREE.Mesh(geometry, debugCircleMaterial);\n                }\n            );\n            addObject(\n                this.objects,\n                blackPoints,\n                -1,\n                (geometry: THREE.BufferGeometry): THREE.Object3D => {\n                    return new THREE.Mesh(geometry, debugBlackCircleMaterial);\n                }\n            );\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { Value } from \"@here/harp-datasource-protocol/index-decoder\";\n\n/**\n * Feature Modifier ids to choose which OmvFeatureModifer should be used in OmvDecoder.\n */\nexport enum FeatureModifierId {\n    /**\n     * Generic feature modifier used when no other modifiers are defined.\n     *\n     * @note You do not need to specify it in [[OmvDataSourceParameters]] as it is added by default\n     * if no other feature modifier is used.\n     */\n    default\n}\n\n/**\n * Definition of a filter.\n */\nexport interface OmvFilterString {\n    /**  String value */\n    value: string;\n    /** Match condition */\n    match: OmvFilterString.StringMatch;\n}\n\n/**\n * Adding the match condition type and the matching function to the namespace of `OmvFilterString`.\n */\nexport namespace OmvFilterString {\n    /**\n     * Match condition.\n     */\n    export enum StringMatch {\n        /** Matches any. */\n        Any,\n        /** Exact match. */\n        Match,\n        /** Matches if a test string starts with a filter string. */\n        StartsWith,\n        /** Matches if a test string contains a filter string. */\n        Contains,\n        /** Matches if a test string ends with a filter string. */\n        EndsWith\n    }\n\n    /**\n     * Check for a string against a filter.\n     *\n     * @param str - The string to check against a filter.\n     * @param filterString - The filter containing the match condition.\n     * @returns `true` if the match condition is satisfied.\n     *\n     * @internal\n     */\n    export function matchString(str: string, filterString: OmvFilterString): boolean {\n        switch (filterString.match) {\n            case OmvFilterString.StringMatch.Any:\n                return true;\n            case OmvFilterString.StringMatch.Match:\n                return str === filterString.value;\n            case OmvFilterString.StringMatch.StartsWith:\n                return filterString.value.startsWith(str);\n            case OmvFilterString.StringMatch.EndsWith:\n                return filterString.value.endsWith(str);\n            default:\n                return str.includes(filterString.value);\n        }\n    }\n}\n\n/**\n * Definition of a filter for a feature attribute\n */\nexport interface OmvFilterFeatureAttribute {\n    key: string;\n    value: Value;\n}\n\nexport enum OmvGeometryType {\n    UNKNOWN = 0,\n    POINT = 1,\n    LINESTRING = 2,\n    POLYGON = 3\n}\n\n/**\n * Internal type of a layer filter description, Should not be publicly available.\n *\n * @hidden\n */\nexport interface OmvLayerFilterDescription {\n    name: OmvFilterString;\n    minLevel: number;\n    maxLevel: number;\n}\n\n/**\n * Internal type of a single filter description, Should not be publicly available.\n *\n * @hidden\n */\nexport interface OmvFilterDescription {\n    layerName: OmvFilterString;\n    geometryTypes?: OmvGeometryType[];\n    classes?: OmvFilterString[];\n    minLevel: number;\n    maxLevel: number;\n    featureAttribute?: OmvFilterFeatureAttribute;\n}\n\n/**\n * Internal type of a complete [[OmvFeatureFilter]] description, should not be publicly available.\n *\n * @hidden\n */\nexport interface OmvFeatureFilterDescription {\n    processLayersDefault: boolean;\n    processPointsDefault: boolean;\n    processLinesDefault: boolean;\n    processPolygonsDefault: boolean;\n\n    layersToProcess: OmvLayerFilterDescription[];\n    layersToIgnore: OmvLayerFilterDescription[];\n    pointsToProcess: OmvFilterDescription[];\n    pointsToIgnore: OmvFilterDescription[];\n    linesToProcess: OmvFilterDescription[];\n    linesToIgnore: OmvFilterDescription[];\n    polygonsToProcess: OmvFilterDescription[];\n    polygonsToIgnore: OmvFilterDescription[];\n\n    // enabledKinds and disabledKinds\n    kindsToProcess: string[];\n    kindsToIgnore: string[];\n}\n\n/**\n * Internal interface for options passed from the [[OmvDataSource]] to the decoder.\n *\n * @internal\n */\nexport interface OmvDecoderOptions {\n    /**\n     * If true, features that have no technique in the theme will be printed to the console (can be\n     * excessive!).\n     */\n    showMissingTechniques?: boolean;\n\n    /**\n     * Gather feature attributes from [[OmvData]]. Defaults to false.\n     */\n    gatherFeatureAttributes?: boolean;\n\n    /**\n     * @deprecated Tile info is not decoded anymore. The same information can be generated\n     * implementing a [[IGeometryProcessor]] and using [[OmvProtobufDataAdapter]] to decode OMV\n     * data.\n     */\n    createTileInfo?: boolean;\n\n    /**\n     * @deprecated Tile info is not decoded anymore. The same information can be generated\n     * implementing a [[IGeometryProcessor]] and using [[OmvProtobufDataAdapter]] to decode OMV\n     * data.\n     */\n    gatherRoadSegments?: boolean;\n\n    /**\n     * Optional storage level offset for [[Tile]]s. Default is -2.\n     */\n    storageLevelOffset?: number;\n\n    /**\n     * If not set to `false` very short text labels will be skipped during decoding based on a\n     * heuristic.\n     */\n    skipShortLabels?: boolean;\n\n    /**\n     * A description for the feature filter which can be safely passed down to the web workers.\n     * It has to be generated with the help of the [[OmvFeatureFilterDescriptionBuilder]] (to\n     * guarantee the correctness).\n     */\n    filterDescription?: OmvFeatureFilterDescription | null;\n\n    // NOTE: Consider using OmvFeatureModifiers objects already instead of ids, this way we could\n    // get rid of politicalView property as properly configured feature modifier (with country\n    // code), would be already defined here.\n    /**\n     * List of user specified [[OmvFeatureModifier]]s, list order declares the order of processing.\n     *\n     * Each identifier is used to choose corresponding OmvFeatureModifier, if undefined at least\n     * [[OmvGenericFeatureModifier]] is added to decoder.\n     */\n    featureModifiers?: FeatureModifierId[];\n\n    /**\n     * Country code (lower-case ISO 3166-1 alpha-2) defining optional point of view to be used.\n     * Set to empty string (\"\") if you want to use default (widely accepted) point of view.\n     * If set to `undefined` leaves current political view decoder configuration.\n     */\n    politicalView?: string;\n\n    enableElevationOverlay?: boolean;\n\n    roundUpCoordinatesIfNeeded?: boolean;\n}\n\n/**\n * Vector tile decoder service type id.\n *\n * @remarks\n * Used for requesting decoder services using `WorkerServiceManager`.\n *\n * @internal\n */\nexport const VECTOR_TILE_DECODER_SERVICE_TYPE = \"vector-tile-decoder\";\n\n/**\n * GeoJson tiler service type id.\n *\n * @remarks\n * Used for requesting tiler services using `WorkerServiceManager`.\n *\n * @internal\n */\nexport const GEOJSON_TILER_SERVICE_TYPE = \"geojson-tiler\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport \"@here/harp-fetch\";\n\nimport { TileKey, TilingScheme } from \"@here/harp-geoutils\";\nimport { DataProvider } from \"@here/harp-mapview-decoder\";\nimport { ITransferManager, TransferManager } from \"@here/harp-transfer-manager\";\nimport { LoggerManager } from \"@here/harp-utils\";\n\nconst logger = LoggerManager.instance.create(\"OmvRestClient\");\n\ninterface QueryParameters {\n    [key: string]: string;\n}\n\nexport enum APIFormat {\n    /**\n     * Use the REST API format of HERE Vector Tiles Server component version 1.\n     *\n     * @remarks\n     * Documentation:\n     *  https://developer.here.com/documentation/vector-tiles-api/dev_guide/index.html\n     *\n     * Usage:\n     *\n     *     <OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>/omv\n     *\n     * If [[OmvRestClientParams.authenticationToken]] is provided, it will be added as HTTP header:\n     *\n     *     Authorization: Bearer $authenticationToken\n     *\n     * Format definition:\n     * `//http|s://<base-url>/{API version}/{layers}/{projection}/{z}/{x}/{y}/{format}`\n     *\n     * Default authentication method used: [[AuthenticationTypeBearer]].\n     */\n    HereV1,\n\n    /**\n     * Use the REST API format of Mapbox Vector Tile API v4.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/v4/{map_id}/{z}/{x}/{y}{@2x}.{format}?[style]&access_token={access_token}`\n     *\n     * Sample URL:\n     * `http://a.tiles.mapbox.com/v4/mapbox.mapbox-streets-v7/14/4823/6160.mvt?access_token=your-mapbox-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    MapboxV4,\n\n    /**\n     * Use the REST API format of XYZ Vector Tile API in MVT format.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.mvt?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZMVT,\n\n    /**\n     * Use the REST API format of XYZ Vector Tile API in JSON format.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/omsbase/256/<zoom>/<X>/<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/{layers}/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/osmbase/256/all/16/19293/24641.json?access_token=your-xyz-api-key`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZJson,\n\n    /**\n     * Use the REST API format of XYZ Vector Tile API in OMV format.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/tiles/herebase.02/<zoom>/<X>/<Y>/omv?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/tiles/herebase.02/{z}/{x}/{y}/{format}?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/tiles/herebase.02/14/2649/6338/omv?access_token=your-xyz-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZOMV,\n\n    /**\n     * Use the REST API format of Tomtoms Vector Tile API v1.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/<zoom>/<X>/<Y>.pbf?key=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `<http|https>://<baseURL>/map/<versionNumber>/tile/<layer>/<style>/<zoom>/<X>/<Y>.<format>?key=<apiKey>[&view=<view>][&language=<language>]`\n     *\n     * Sample URL:\n     * `http://api.tomtom.com/map/1/tile/basic/main/0/0/0.pbf?key=<apiKey>`\n     *\n     * Default authentication method used: [[AuthenticationTypeTomTomV1]].\n     */\n    TomtomV1,\n\n    /**\n     * Use the REST API format of XYZ Space Vector Tile API in OMV format.\n     *\n     * @remarks\n     * Usage:\n     * `<OmvRestClientParams.baseUrl>/hub/spaces/<space-id>/tile/web/<zoom>_<X>_<Y>.mvt?access_token=<OmvRestClientParams.authenticationCode>`\n     *\n     * Format definition:\n     * `http|s://<base-url>/hub/spaces/{spaceId}/tile/web/{z}_{x}_{y}.mvt?access_token={access_token}`\n     *\n     * Sample URL:\n     * `https://xyz.api.here.com/hub/spaces/your-space-id/tile/web/{z}_{x}_{y}.mvt?access_token=your-access-token`\n     *\n     * Default authentication method used: [[AuthenticationTypeAccessToken]].\n     */\n    XYZSpace\n}\n\n/**\n * Authentication token/code provider used by [[OmvRestClient]] before each call to currently valid\n * authentication code/token.\n */\nexport type AuthenticationCodeProvider = () => Promise<string>;\n\nexport enum AuthenticationMethod {\n    QueryString,\n    AuthorizationHeader\n}\n\nexport interface AuthenticationMethodInfo {\n    method: AuthenticationMethod;\n    name?: string;\n}\n\n/**\n * Authentication method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexport const AuthenticationTypeBearer: AuthenticationMethodInfo = {\n    method: AuthenticationMethod.AuthorizationHeader,\n    name: \"Bearer\"\n};\n\n/**\n * TomTomV1 API compatible authorization method, where token will be provided as HTTP Header:\n *\n *    Authorization: Bearer $authenticationToken\n */\nexport const AuthenticationTypeTomTomV1: AuthenticationMethodInfo = {\n    method: AuthenticationMethod.QueryString,\n    name: \"key\"\n};\n\nexport const AuthenticationTypeAccessToken: AuthenticationMethodInfo = {\n    method: AuthenticationMethod.QueryString,\n    name: \"access_token\"\n};\n\nexport interface OmvRestClientParameters {\n    /**\n     * `URL` pattern used to fetch tile files.\n     *\n     * @remarks\n     * `URL` with special keywords replaced to retrieve specific tile:\n     *  - `{z}` - zoom level of tile, @see {@link @here/harp-geoutils#TileKey.level}\n     *  - `{x}` - horizontal coordinate of tile (column number),\n     *            see {@link @here/harp-geoutils#TileKey.column}\n     *  - `{y}` - vertical coordinate of Tile (row number),\n     *            see {@link @here/harp-geoutils#TileKey.row}\n     *\n     * Examples of `url` patterns:\n     * ```\n     *   https://my-base-url.com/vector-tiles/{z}/{x}/{y}.mvt\n     *   https://xyz.api.here.com/tiles/herebase.02/{z}/{x}/{y}/omv\n     *   https://xyz.api.here.com/tiles/osmbase/512/all/{z}/{x}/{y}.mvt\n     * ```\n     *\n     * Note: To add authentication headers and/or query params, use [[authMethod]], [[urlParams]]\n     * properties or embed token directly in `url`.\n     *\n     * Complete examples:\n     * ```\n     * // XYZ OSM with authentication using query param\n     * {\n     *     url: \"https://xyz.api.here.com/tiles/osmbase/512/all/{z}/{x}/{y}.mvt\",\n     *     urlParams: {\n     *           access_token: accessToken\n     *     },\n     * }\n     * // HERE Vector Tile with authentication using bearer token retrieved by callback\n     * {\n     *     url: \"https://vector.hereapi.com/v2/vectortiles/base/mc/{z}/{x}/{y}/omv\",\n     *     authenticationMethod: AuthenticationTypeBearer,\n     *     authenticationCode: () => getBearerToken()\n     * }\n     * ```\n     */\n    url?: string;\n\n    /**\n     * The base URL of the REST Tile Service.\n     * @see [[APIFormat]] for the definition of `baseUrl`.\n     */\n    baseUrl?: string;\n\n    /**\n     * Authentication code used for the different APIs.\n     *\n     * @remarks\n     * When [[AuthenticationCodeProvider]] is is used as value, the provider is called before each\n     * to get currently valid authentication code/token.\n     *\n     * @see [[APIFormat]] for the query parameter this is used with.\n     */\n    authenticationCode?: string | AuthenticationCodeProvider;\n\n    /**\n     * Specifies [[AuthMethod]] to be used when requesting tiles.\n     *\n     * @remarks\n     * Defaults for each [[APIFormat]] are documented with each format type.\n     */\n    authenticationMethod?: AuthenticationMethodInfo;\n\n    /**\n     * The REST API format to use for the tile path generation, will default to the HERE Vector Tile\n     * API.\n     */\n    apiFormat?: APIFormat;\n\n    /**\n     * Tiling scheme is used in some of the APIs, not implemented yet.\n     */\n    tilingScheme?: TilingScheme;\n\n    /**\n     * Transfer Manager to use; creates an own instance if none passed.\n     */\n    downloadManager?: ITransferManager;\n\n    /**\n     * Function to retrieve the Bearer Token\n     *\n     * @deprecated Please use [[authenticationCode]].\n     */\n    getBearerToken?: () => Promise<string>;\n\n    /**\n     * Array of query parameters to be appended at the end of the url.\n     * It is empty by default.\n     */\n    urlParams?: { [key: string]: string };\n}\n\n/**\n * REST client supporting getting protobuf OMV Tile from REST-based servers.\n */\nexport class OmvRestClient extends DataProvider {\n    private readonly downloadManager: ITransferManager;\n    private readonly urlParams: { [key: string]: string };\n\n    constructor(readonly params: OmvRestClientParameters) {\n        super();\n        this.downloadManager =\n            params.downloadManager === undefined\n                ? TransferManager.instance()\n                : params.downloadManager;\n        this.urlParams = params.urlParams === undefined ? {} : params.urlParams;\n    }\n\n    /** Overriding abstract method, in this case doing nothing. */\n    async connect(): Promise<void> {\n        // not needed\n    }\n\n    /** Overriding abstract method, in this case always returning `true`. */\n    ready(): boolean {\n        return true;\n    }\n\n    /**\n     * Asynchronously fetches a tile from this restful server.\n     *\n     * @remarks\n     * **Note:** In case of an HTTP Error, rejected promise is returned\n     * with an error.\n     *\n     * @example\n     * ```typescript\n     * const response = layer.getTile(tileKey);\n     * if (!response.ok) {\n     *     // a network error happened\n     *     console.error(\"Unable to download tile\", response.statusText);\n     *     return;\n     * }\n     *\n     * // the response is ok and contains data, access it e.g. as arrayBuffer:\n     * const payload = await response.arrayBuffer();\n     * ```\n     *\n     * @param tileKey - The tile key of the tile.\n     * @param tileRequestInit - Optional request options to be passed to fetch when downloading a\n     * tile.\n     * @returns A `Promise` of the HTTP response that contains the payload of the requested tile.\n     */\n    async getTile(\n        tileKey: TileKey,\n        abortSignal?: AbortSignal | undefined\n    ): Promise<ArrayBufferLike | {}> {\n        const init: RequestInit = { signal: abortSignal };\n\n        let tileUrl = this.dataUrl(tileKey);\n\n        const authenticationCode = await this.getActualAuthenticationCode();\n\n        tileUrl = this.applyAuthCode(tileUrl, init, authenticationCode);\n        tileUrl = this.addQueryParams(tileUrl, this.urlParams);\n\n        if (this.params.apiFormat === APIFormat.XYZJson) {\n            return await this.downloadManager.downloadJson(tileUrl, init);\n        }\n\n        return await this.downloadManager.downloadArrayBuffer(tileUrl, init);\n    }\n\n    /**\n     * Destroys this `OmvRestClient`.\n     */\n    dispose() {\n        // to be overloaded by subclasses\n    }\n\n    /**\n     * Get actual authentication code/token for this request according to configuration.\n     */\n    private async getActualAuthenticationCode() {\n        if (typeof this.params.authenticationCode === \"string\") {\n            return this.params.authenticationCode;\n        } else if (this.params.authenticationCode !== undefined) {\n            return await this.params.authenticationCode();\n        } else if (this.params.getBearerToken !== undefined) {\n            return await this.params.getBearerToken();\n        } else {\n            return undefined;\n        }\n    }\n\n    /**\n     * Get default authentication method basing on apiFormat and other params.\n     */\n    private getDefaultAuthMethod() {\n        if (this.params.getBearerToken !== undefined) {\n            return AuthenticationTypeBearer;\n        }\n\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n                return AuthenticationTypeBearer;\n            case APIFormat.MapboxV4:\n            case APIFormat.XYZOMV:\n            case APIFormat.XYZMVT:\n            case APIFormat.XYZSpace:\n            case APIFormat.XYZJson:\n                return AuthenticationTypeAccessToken;\n            case APIFormat.TomtomV1:\n                return AuthenticationTypeTomTomV1;\n            default:\n                logger.warn(\n                    `#getDefaultAuthMethod: Not supported API format: ${this.params.apiFormat}`\n                );\n                return undefined;\n        }\n    }\n\n    /**\n     * Apply authentication code/token using configured (or default) authentication method.\n     *\n     * @param url -\n     * @param init - request extra data\n     * @param authenticationCode - authentication/token to be applied\n     * @return new url to be used\n     */\n    private applyAuthCode(url: string, init: RequestInit, authenticationCode: string | undefined) {\n        if (authenticationCode === undefined) {\n            return url;\n        }\n        const authMethod = this.params.authenticationMethod ?? this.getDefaultAuthMethod();\n        if (authMethod === undefined) {\n            return url;\n        }\n\n        if (authMethod.method === AuthenticationMethod.AuthorizationHeader) {\n            if (init.headers === undefined) {\n                init.headers = new Headers();\n            }\n            const authType = authMethod.name ?? \"Bearer\";\n            (init.headers as Headers).append(\"Authorization\", `${authType} ${authenticationCode}`);\n        } else if (authMethod.method === AuthenticationMethod.QueryString) {\n            const attrName: string = authMethod.name ?? \"access_token\";\n            const authParams: { [key: string]: string } = {};\n            authParams[attrName] = authenticationCode;\n            url = this.addQueryParams(url, authParams);\n        }\n        return url;\n    }\n\n    /**\n     * Get actual tile URL depending on configured API format.\n     */\n    private dataUrl(tileKey: TileKey): string {\n        if (this.params.url !== undefined) {\n            return this.params.url\n                .replace(\"{x}\", String(tileKey.column))\n                .replace(\"{y}\", String(tileKey.row))\n                .replace(\"{z}\", String(tileKey.level));\n        }\n        let path = [`/${tileKey.level}`, tileKey.column, tileKey.row].join(\n            this.params.apiFormat === APIFormat.XYZSpace ||\n                this.params.apiFormat === APIFormat.XYZJson\n                ? \"_\"\n                : \"/\"\n        );\n        switch (this.params.apiFormat) {\n            case APIFormat.HereV1:\n            case APIFormat.XYZOMV:\n                path += \"/omv\";\n                break;\n            case APIFormat.MapboxV4:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZMVT:\n                path += \".mvt\";\n                break;\n            case APIFormat.XYZJson:\n                break;\n            case APIFormat.XYZSpace:\n                path += \".mvt\";\n                break;\n            case APIFormat.TomtomV1:\n                path += \".pbf\";\n                break;\n            default:\n                logger.warn(`Not supported API format: ${this.params.apiFormat}`);\n                break;\n        }\n\n        return this.params.baseUrl + path;\n    }\n\n    private addQueryParams(url: string, queryParams: QueryParameters): string {\n        let queryString = \"\";\n        let sep = url.includes(\"?\") ? \"&\" : \"?\";\n        for (const prop in queryParams) {\n            if (!queryParams.hasOwnProperty(prop)) {\n                continue;\n            }\n            queryString += `${sep}${encodeURIComponent(prop)}=${encodeURIComponent(\n                queryParams[prop]\n            )}`;\n            if (sep === \"?\") {\n                sep = \"&\";\n            }\n        }\n        return url + queryString;\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { DecoderOptions, OptionsMap, WorkerServiceProtocol } from \"@here/harp-datasource-protocol\";\nimport { EarthConstants, TileKey, webMercatorTilingScheme } from \"@here/harp-geoutils\";\nimport { DataSourceOptions, Tile } from \"@here/harp-mapview\";\nimport {\n    DataProvider,\n    TileDataSource,\n    TileDataSourceOptions,\n    TileFactory\n} from \"@here/harp-mapview-decoder\";\nimport { getOptionValue, LoggerManager } from \"@here/harp-utils\";\n\nimport {\n    FeatureModifierId,\n    OmvDecoderOptions,\n    OmvFeatureFilterDescription,\n    VECTOR_TILE_DECODER_SERVICE_TYPE\n} from \"./OmvDecoderDefs\";\nimport {\n    APIFormat,\n    AuthenticationMethod,\n    OmvRestClient,\n    OmvRestClientParameters\n} from \"./OmvRestClient\";\n\nconst logger = LoggerManager.instance.create(\"VectorTileDataSource\");\n\nexport interface VectorTileFactory {\n    /** Create an instance of {@link @here/harp-mapview#Tile} or a subclass. */\n    createTile(dataSource: VectorTileDataSource, tileKey: TileKey): Tile;\n}\n\nexport interface VectorTileDataSourceParameters\n    extends DataSourceOptions,\n        // These parameters have to be handled specially, see: completeDataSourceParameters\n        Omit<TileDataSourceOptions, \"dataProvider\" | \"tilingScheme\"> {\n    /**\n     * If set to `true`, features that have no technique in the theme will be printed to the console\n     * (can be excessive!).\n     */\n    showMissingTechniques?: boolean;\n\n    /**\n     * @deprecated Tile info is not decoded anymore. The same information can be generated\n     * implementing a [[IGeometryProcessor]] and using [[OmvProtobufDataAdapter]] to decode OMV\n     * data.\n     */\n    createTileInfo?: boolean;\n\n    /**\n     * Optionally specify the DataProvider that should be used.\n     */\n    dataProvider?: DataProvider;\n\n    /**\n     * Gather feature IDs from `OmvData`. Defaults to `false`.\n     * @deprecated FeatureIds are always gathered, use [[gatherFeatureAttributes]] to gather\n     * all feature attributes.\n     */\n    gatherFeatureIds?: boolean;\n\n    /**\n     * Gather feature attributes from `OmvData`. Defaults to `false`.\n     */\n    gatherFeatureAttributes?: boolean;\n\n    /**\n     * @deprecated Tile info is not decoded anymore. The same information can be generated\n     * implementing a [[IGeometryProcessor]] and using [[OmvProtobufDataAdapter]] to decode OMV\n     * data.\n     */\n    gatherRoadSegments?: boolean;\n\n    /**\n     * If not set to `false`, very short text labels will be skipped during decoding based on a\n     * heuristic.\n     */\n    skipShortLabels?: boolean;\n\n    /**\n     * A description for the feature filter that can be safely passed down to the web workers.\n     *\n     * @remarks\n     * It has to be generated with the help of the [[OmvFeatureFilterDescriptionBuilder]]\n     * (to guarantee correctness). This parameter gets applied to the decoder used in the\n     * {@link VectorTileDataSource} which might be shared between\n     * various {@link VectorTileDataSource}s.\n     */\n    filterDescr?: OmvFeatureFilterDescription;\n\n    /**\n     * Optional, custom factory for {@link @here/harp-mapview#Tile} instances created\n     * by this {@link VectorTileDataSource}.\n     */\n    tileFactory?: TileFactory<Tile>;\n\n    /**\n     * Identifier used to choose [[OmvFeatureModifier]]s to be applied.\n     *\n     * @remarks\n     * If left `undefined` at least [[OmvGenericFeatureModifier]] will be applied.\n     * The list of feature modifiers may be extended internally by some data source options\n     * such as [[politicalView]] which adds [[OmvPoliticalViewFeatureModifier]].\n     *\n     * @note This parameter gets applied to the decoder used in the {@link VectorTileDataSource}\n     * which might be shared between various {@link VectorTileDataSource}s.\n     */\n    featureModifierId?: FeatureModifierId;\n\n    /**\n     * Expresses specific country point of view that is used when rendering disputed features,\n     * like borders, names, etc. If undefined \"defacto\" or most widely accepted political view\n     * will be presented.\n     *\n     * @see featureModifiers\n     */\n    politicalView?: string;\n\n    /**\n     * Indicates whether overlay on elevation is enabled. Defaults to `false`.\n     */\n    enableElevationOverlay?: boolean;\n\n    /**\n     * Indicates whether to add a ground plane to cover the tile completely.\n     *\n     * @remarks\n     * This is necessary for the fallback logic, such that the parent fall back tiles don't\n     * overlap the children tiles.\n     * Default is true (i.e. if not defined it is taken to be true)\n     */\n    addGroundPlane?: boolean;\n\n    /**\n     * Indicates whether the decoder is allowed to adjust the coordinates to\n     * avoid possible glitches at the 180th meridian.\n     *\n     * @defaultValue `true` if the data service is\n     *               `https://vector.hereapi.com/v2/vectortiles/base/mc`,\n     *               `false` otherwise.\n     */\n    roundUpCoordinatesIfNeeded?: boolean;\n}\n\n/**\n * A helper function to retrieve the [[DataProvider]] from the\n * {@link VectorTileDataSource}s parameters.\n *\n * @param params - The parameters passed into the OmvDataSource.\n */\nfunction getDataProvider(params: OmvWithRestClientParams | OmvWithCustomDataProvider) {\n    if ((params as OmvWithCustomDataProvider).dataProvider) {\n        return (params as OmvWithCustomDataProvider).dataProvider;\n    } else if (\n        (params as OmvWithRestClientParams).baseUrl ??\n        (params as OmvWithRestClientParams).url\n    ) {\n        return new OmvRestClient(params as OmvRestClientParameters);\n    } else {\n        throw new Error(\"OmvDataSource: missing url, baseUrl or dataProvider params\");\n    }\n}\n\nexport type OmvWithRestClientParams = VectorTileDataSourceParameters & OmvRestClientParameters;\n\nexport type OmvWithCustomDataProvider = VectorTileDataSourceParameters & {\n    dataProvider: DataProvider;\n};\n\nlet missingOmvDecoderServiceInfoEmitted: boolean = false;\n\n/**\n * The default vector tile service.\n */\nconst hereVectorTileBaseUrl = \"https://vector.hereapi.com/v2/vectortiles/base/mc\";\n\n/**\n * Default options for the HERE Vector Tile service.\n */\nconst hereVectorTileDefaultOptions: OmvWithRestClientParams = {\n    baseUrl: hereVectorTileBaseUrl,\n    apiFormat: APIFormat.XYZOMV,\n    styleSetName: \"tilezen\",\n    authenticationMethod: {\n        method: AuthenticationMethod.QueryString,\n        name: \"apikey\"\n    },\n    copyrightInfo: [\n        {\n            id: \"here.com\",\n            year: new Date().getFullYear(),\n            label: \"HERE\",\n            link: \"https://legal.here.com/terms\"\n        }\n    ]\n};\n\nconst defaultOptions = new Map<string, OmvWithRestClientParams>([\n    [hereVectorTileBaseUrl, hereVectorTileDefaultOptions]\n]);\n\n/**\n * Tests if the given object has custom data provider.\n * @param object -\n */\nfunction hasCustomDataProvider(\n    object: Partial<OmvWithCustomDataProvider>\n): object is OmvWithCustomDataProvider {\n    return object.dataProvider !== undefined;\n}\n\n/**\n * Add service specific default values.\n *\n * @param params - The configuration settings of the data source.\n */\nfunction completeDataSourceParameters(\n    params: OmvWithRestClientParams | OmvWithCustomDataProvider\n): TileDataSourceOptions {\n    if (!hasCustomDataProvider(params) && params.url === undefined) {\n        const baseUrl = params.baseUrl ?? hereVectorTileBaseUrl;\n\n        const completedParams = {\n            ...defaultOptions.get(baseUrl),\n            ...params\n        };\n\n        return {\n            ...completedParams,\n            tilingScheme: webMercatorTilingScheme,\n            dataProvider: new OmvRestClient(completedParams)\n        };\n    }\n\n    return {\n        ...params,\n        tilingScheme: webMercatorTilingScheme,\n        dataProvider: getDataProvider(params)\n    };\n}\n\n/**\n * `VectorTileDataSource` is used for the visualization of vector tiles.\n *\n * @example\n * ```typescript\n *    const dataSource = new VectorTileDataSource({\n *        baseUrl: \"https://vector.hereapi.com/v2/vectortiles/base/mc\",\n *        authenticationCode: apikey\n *    });\n *    mapView.addDataSource(dataSource);\n *   ```\n */\nexport class VectorTileDataSource extends TileDataSource {\n    private readonly m_decoderOptions: OmvDecoderOptions;\n\n    constructor(private readonly m_params: OmvWithRestClientParams | OmvWithCustomDataProvider) {\n        super(m_params.tileFactory ?? new TileFactory(Tile), {\n            styleSetName: m_params.styleSetName ?? \"omv\",\n            concurrentDecoderServiceName:\n                m_params.concurrentDecoderServiceName ?? VECTOR_TILE_DECODER_SERVICE_TYPE,\n            minDataLevel: m_params.minDataLevel ?? 1,\n            maxDataLevel: m_params.maxDataLevel ?? 17,\n            storageLevelOffset: m_params.storageLevelOffset ?? -1,\n            ...completeDataSourceParameters(m_params)\n        });\n\n        this.cacheable = true;\n        this.addGroundPlane =\n            m_params.addGroundPlane === undefined || m_params.addGroundPlane === true;\n\n        let roundUpCoordinatesIfNeeded = m_params.roundUpCoordinatesIfNeeded;\n\n        if (\n            roundUpCoordinatesIfNeeded === undefined &&\n            (m_params as Partial<OmvWithRestClientParams>)?.baseUrl === hereVectorTileBaseUrl\n        ) {\n            roundUpCoordinatesIfNeeded = true;\n        }\n\n        this.m_decoderOptions = {\n            showMissingTechniques: this.m_params.showMissingTechniques === true,\n            filterDescription: this.m_params.filterDescr,\n            gatherFeatureAttributes: this.m_params.gatherFeatureAttributes === true,\n            featureModifiers: this.m_params.featureModifierId\n                ? [this.m_params.featureModifierId]\n                : undefined,\n            politicalView: this.m_params.politicalView,\n            skipShortLabels: this.m_params.skipShortLabels,\n            storageLevelOffset: m_params.storageLevelOffset ?? -1,\n            enableElevationOverlay: this.m_params.enableElevationOverlay === true,\n            roundUpCoordinatesIfNeeded\n        };\n\n        this.maxGeometryHeight = getOptionValue(\n            m_params.maxGeometryHeight,\n            EarthConstants.MAX_BUILDING_HEIGHT\n        );\n\n        this.minGeometryHeight = getOptionValue(m_params.minGeometryHeight, 0);\n    }\n\n    /** @override */\n    async connect() {\n        try {\n            await super.connect();\n        } catch (error) {\n            // error is a string if the promise was rejected.\n            if (\n                error.message &&\n                WorkerServiceProtocol.isUnknownServiceError(error) &&\n                !missingOmvDecoderServiceInfoEmitted\n            ) {\n                logger.info(\n                    \"Unable to create decoder service in worker. Use \" +\n                        \" 'OmvTileDecoderService.start();' in decoder script.\"\n                );\n                missingOmvDecoderServiceInfoEmitted = true;\n            }\n            throw typeof error === \"string\" ? new Error(error) : error;\n        }\n        this.configureDecoder(undefined, this.m_decoderOptions);\n    }\n\n    /**\n     * Remove the current data filter.\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     */\n    removeDataFilter(): void {\n        this.configureDecoder(undefined, {\n            filterDescription: null\n        });\n    }\n\n    /**\n     * Set a new data filter. Can also be done during\n     * the creation of an {@link VectorTileDataSource}.\n     * Will be applied to the decoder, which might be shared with other omv datasources.\n     *\n     * @param filterDescription - Data filter description created with\n     * [[OmvFeatureFilterDescriptionBuilder]].\n     */\n    setDataFilter(filterDescription: OmvFeatureFilterDescription): void {\n        this.m_decoderOptions.filterDescription =\n            filterDescription !== null ? filterDescription : undefined;\n\n        this.configureDecoder(undefined, {\n            filterDescription,\n            featureModifiers: this.m_decoderOptions.featureModifiers,\n            politicalView: this.m_decoderOptions.politicalView\n        });\n    }\n\n    /** @override */\n    shouldPreloadTiles(): boolean {\n        return true;\n    }\n\n    /** @override */\n    setPoliticalView(politicalView?: string): void {\n        // Just in case users mess with letters' casing.\n        politicalView = politicalView?.toLowerCase();\n        if (this.m_decoderOptions.politicalView !== politicalView) {\n            this.m_decoderOptions.politicalView = politicalView;\n            this.configureDecoder(undefined, {\n                filterDescription: this.m_decoderOptions.filterDescription,\n                featureModifiers: this.m_decoderOptions.featureModifiers,\n                politicalView: politicalView !== undefined ? politicalView : \"\"\n            });\n        }\n    }\n\n    /** @override */\n    get storageLevelOffset() {\n        return super.storageLevelOffset;\n    }\n\n    /** @override */\n    set storageLevelOffset(levelOffset: number) {\n        super.storageLevelOffset = levelOffset;\n        this.m_decoderOptions.storageLevelOffset = this.storageLevelOffset;\n        this.configureDecoder(undefined, {\n            storageLevelOffset: this.storageLevelOffset\n        });\n    }\n\n    /** @override */\n    setEnableElevationOverlay(enable: boolean) {\n        if (this.m_decoderOptions.enableElevationOverlay !== enable) {\n            this.m_decoderOptions.enableElevationOverlay = enable;\n            this.configureDecoder(undefined, {\n                enableElevationOverlay: enable\n            });\n        }\n    }\n\n    private configureDecoder(options?: DecoderOptions, customOptions?: OptionsMap) {\n        this.clearCache();\n        this.decoder.configure(options, customOptions);\n        this.mapView.markTilesDirty(this);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * HERE WebTile Data source.\n *\n * @remarks\n *\n * @packageDocumentation\n */\n\nexport * from \"./lib/WebTileDataSource\";\nexport * from \"./lib/HereWebTileDataSource\";\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {\n    CopyrightInfo,\n    RequestHeaders,\n    TextureLoader,\n    Tile,\n    UrlCopyrightProvider\n} from \"@here/harp-mapview\";\nimport {\n    ApiKeyAuthentication,\n    AppIdAuthentication,\n    getOptionValue,\n    TokenAuthentication\n} from \"@here/harp-utils\";\nimport { Texture } from \"three\";\n\nimport {\n    WebTileDataProvider,\n    WebTileDataSource,\n    WebTileDataSourceOptions\n} from \"./WebTileDataSource\";\n\nconst textureLoader = new TextureLoader();\n\n/**\n * Options for {@link HereWebTileDataSource}.\n */\ninterface HereWebTileDataSourceOptions extends Omit<WebTileDataSourceOptions, \"dataProvider\"> {\n    /**\n     * Base URL.\n     *\n     * @remarks\n     * This parameter specifies static part of the final Web Tile URL:\n     *  * base url without protocol and load-balancing (`{1-4}.`) prefix\n     *  * path,\n     *  * resource (tile type)\n     *  * map version,\n     *  * scheme\n     *\n     * See [Map Tile API]\n     * (https://developer.here.com/documentation/map-tile/topics/request-constructing.html) for\n     * details.\n     *\n     * For example, given final url presented in documentation\n     * (https://developer.here.com/documentation/map-tile/topics/examples-base.html):\n     *\n     *     https://\n     *       2.base.maps.ls.hereapi.com/maptile/2.1/maptile/newest/normal.day/11/525/761/256/png8\n     *       ?apikey={YOUR_API_KEY}\n     *\n     * `tileBaseAddress` should be:\n     *\n     *      base.maps.ls.hereapi.com/maptile/2.1/maptile/newest/normal.day\n     *\n     * Rest of parameters are added by [[WebTileDataSource]].\n     *\n     * @see [Map Tile API]\n     * (https://developer.here.com/documentation/map-tile/topics/introduction.html)\n     * @default [[HereTileProvider.TILE_BASE_NORMAL]]\n     * @see [[HereTileProvider.TILE_BASE_NORMAL]]\n     * @see [[HereTileProvider.TILE_AERIAL_HYBRID]]\n     * @see [[HereTileProvider.TILE_AERIAL_SATELLITE]]\n     * @see [[HereTileProvider.TILE_TRAFFIC_NORMAL]]\n     */\n    tileBaseAddress?: string;\n\n    /**\n     * String which is appended to the tile request url, e.g. to add additional parameters\n     * to the tile requests as described in\n     * @see https://developer.here.com/documentation/map-tile/topics/resource-base-basetile.html\n     */\n    additionalRequestParameters?: string;\n\n    /**\n     * ppi parameter which impacts font/icon sizes, road width and other content\n     * of the map tiles. For valid values and restrictions see\n     * @see https://developer.here.com/documentation/map-tile/topics/resource-base-basetile.html#ppi\n     * By default it is not used.\n     */\n    ppi?: WebTileDataSource.ppiValue;\n\n    /**\n     * Whether to provide copyright info.\n     *\n     * @default `true`\n     */\n    gatherCopyrightInfo?: boolean;\n}\n\n/**\n * An interface for the type of options that can be passed to the [[WebTileDataSource]].\n */\nexport type HereWebTileDataSourceParameters = HereWebTileDataSourceOptions &\n    (ApiKeyAuthentication | AppIdAuthentication | TokenAuthentication);\n\n/**\n * Mapping from ISO-639-1 language codes to codes used by HERE Map Tile API (MARC)\n *\n * @see https://developer.here.com/documentation/map-tile/topics/resource-base-maptile.html\n * @see [MARC Code List for Languages](https://www.loc.gov/marc/languages/)\n */\nconst WEBTILE_LANGUAGE_DICTIONARY: { [s: string]: string } = {\n    eu: \"baq\",\n    ca: \"cat\",\n    zh: \"chi\",\n    cs: \"cze\",\n    da: \"dan\",\n    nl: \"dut\",\n    en: \"eng\",\n    fi: \"fin\",\n    fr: \"fre\",\n    de: \"ger\",\n    ga: \"gle\",\n    el: \"gre\",\n    he: \"heb\",\n    hi: \"hin\",\n    id: \"ind\",\n    it: \"ita\",\n    no: \"nor\",\n    fa: \"per\",\n    pl: \"pol\",\n    pt: \"por\",\n    ru: \"rus\",\n    si: \"sin\",\n    es: \"spa\",\n    sv: \"swe\",\n    th: \"tha\",\n    tr: \"tur\",\n    uk: \"ukr\",\n    ur: \"urd\",\n    vi: \"vie\",\n    cy: \"wel\"\n};\n\n/**\n * Map Tile request params.\n *\n * @see https://developer.here.com/documentation/map-tile/topics/request-constructing.html\n */\ninterface MapTileParams {\n    /**\n     * Baseurl without load-balancing prefix and scheme.\n     */\n    baseUrl: string;\n\n    /**\n     * Path, should be `/maptile/2.1`\n     */\n    path: string;\n\n    /**\n     * Tile type (`basetile`, `maptile` etc).\n     *\n     * @see https://developer.here.com/documentation/map-tile/topics/request-constructing.html\n     */\n    tileType: string;\n\n    /**\n     * Map version - `newest` or `hash` value\n     *\n     * @default `newest`\n     */\n    mapVersion?: string;\n\n    /**\n     * Scheme\n     *\n     * @default `normal.day`\n     */\n    scheme?: string;\n}\n\nexport class HereTileProvider implements WebTileDataProvider {\n    /**\n     * Base address for Base Map rendered using `normal.day` scheme.\n     * @see https://developer.here.com/documentation/map-tile/topics/example-normal-day-view.html\n     */\n    static readonly TILE_BASE_NORMAL =\n        \"base.maps.ls.hereapi.com/maptile/2.1/maptile/newest/normal.day\";\n\n    /**\n     * Base address for Aerial Map rendered using `hybrid.day` scheme.\n     * @see https://developer.here.com/documentation/map-tile/topics/example-hybrid-map.html\n     */\n    static readonly TILE_AERIAL_HYBRID =\n        \"aerial.maps.ls.hereapi.com/maptile/2.1/maptile/newest/hybrid.day\";\n\n    /**\n     * Base address for Aerial Map rendered using `satellite.day` scheme.\n     * @see https://developer.here.com/documentation/map-tile/topics/example-satellite-map.html\n     */\n    static readonly TILE_AERIAL_SATELLITE =\n        \"aerial.maps.ls.hereapi.com/maptile/2.1/maptile/newest/satellite.day\";\n\n    /**\n     * Base address for Traffic Map rendered using `normal.day` scheme.\n     * @see https://developer.here.com/documentation/map-tile/topics/example-traffic.html\n     */\n    static readonly TILE_TRAFFIC_NORMAL =\n        \"traffic.maps.ls.hereapi.com/maptile/2.1/traffictile/newest/normal.day\";\n\n    /** Copyright provider instance. */\n    private readonly m_copyrightProvider: UrlCopyrightProvider;\n    private readonly m_ppi: WebTileDataSource.ppiValue;\n    private readonly m_resolution: WebTileDataSource.resolutionValue;\n    private readonly m_tileBaseAddress: string;\n    private m_languages?: string[];\n\n    /** Predefined fixed HERE copyright info. */\n    private readonly HERE_COPYRIGHT_INFO: CopyrightInfo = {\n        id: \"here.com\",\n        year: new Date().getFullYear(),\n        label: \"HERE\",\n        link: \"https://legal.here.com/terms\"\n    };\n\n    constructor(private readonly m_options: HereWebTileDataSourceParameters) {\n        this.m_ppi = getOptionValue(m_options.ppi, WebTileDataSource.ppiValue.ppi72);\n        this.m_resolution = getOptionValue(\n            m_options.resolution,\n            WebTileDataSource.resolutionValue.resolution512\n        );\n        this.m_tileBaseAddress = m_options.tileBaseAddress ?? HereTileProvider.TILE_BASE_NORMAL;\n        if (\n            this.m_tileBaseAddress === HereTileProvider.TILE_AERIAL_SATELLITE &&\n            this.m_ppi !== WebTileDataSource.ppiValue.ppi72\n        ) {\n            throw new Error(\"Requested combination of scheme satellite.day and ppi is not valid\");\n        }\n\n        const mapTileParams = this.parseBaseUrl(this.m_tileBaseAddress);\n        const baseHostName = mapTileParams.baseUrl;\n        const mapId = getOptionValue(mapTileParams.mapVersion, \"newest\");\n        const scheme = mapTileParams.scheme ?? \"normal.day\";\n        const baseScheme = scheme.split(\".\")[0] || \"normal\";\n\n        const url =\n            `https://1.${baseHostName}/maptile/2.1/copyright/${mapId}` +\n            `${this.getCopyrightRequestParams()}`;\n        this.m_copyrightProvider = new UrlCopyrightProvider(url, baseScheme);\n    }\n\n    /** @override */\n    async getTexture(tile: Tile, abortSignal?: AbortSignal): Promise<[Texture, CopyrightInfo[]]> {\n        const column = tile.tileKey.column;\n        const row = tile.tileKey.row;\n        const level = tile.tileKey.level;\n        const quadKey = tile.tileKey.toQuadKey();\n        const server = parseInt(quadKey[quadKey.length - 1], 10) + 1;\n\n        const url =\n            `https://${server}.${this.m_tileBaseAddress}/` +\n            `${level}/${column}/${row}/${this.m_resolution}/png8` +\n            `${this.getImageRequestParams()}`;\n\n        return await this.getRequestHeaders().then(headers => {\n            return Promise.all([\n                textureLoader.load(url, headers, abortSignal),\n                this.getTileCopyright(tile, headers, abortSignal)\n            ]);\n        });\n    }\n\n    mapIsoLanguageToWebTile(languages: string[]): void {\n        this.m_languages = [];\n        for (const language of languages) {\n            if (WEBTILE_LANGUAGE_DICTIONARY[language] !== undefined) {\n                this.m_languages.push(WEBTILE_LANGUAGE_DICTIONARY[language]);\n            }\n        }\n    }\n\n    private async getRequestHeaders(): Promise<RequestHeaders | undefined> {\n        const { authenticationCode } = this.m_options as TokenAuthentication;\n\n        let token: string | undefined;\n        if (typeof authenticationCode === \"string\") {\n            token = authenticationCode;\n        } else if (authenticationCode !== undefined) {\n            token = await authenticationCode();\n        }\n\n        if (token !== undefined) {\n            return {\n                Authorization: `Bearer ${token}`\n            };\n        }\n\n        return undefined;\n    }\n\n    private async getTileCopyright(\n        tile: Tile,\n        requestHeaders: RequestHeaders | undefined,\n        abortSignal?: AbortSignal\n    ): Promise<CopyrightInfo[]> {\n        if (this.m_options.gatherCopyrightInfo === false) {\n            return [this.HERE_COPYRIGHT_INFO];\n        }\n\n        this.m_copyrightProvider.setRequestHeaders(requestHeaders);\n        return await this.m_copyrightProvider.getCopyrights(tile.geoBox, tile.tileKey.level);\n    }\n\n    private parseBaseUrl(url: string): MapTileParams {\n        const parsed = new URL(url.startsWith(\"https:\") ? url : `https://${url}`);\n        const fullPath = parsed.pathname;\n        const maptilePathRegexp = new RegExp(\"^(/maptile/2.1/)([^/]+)/([^/]+)/([^/]+)\");\n        const match = fullPath.match(maptilePathRegexp);\n        if (!match) {\n            throw new Error(`HereWebTileDataSource: invalid baseUrl: ${url}`);\n        }\n        return {\n            baseUrl: parsed.host,\n            path: match[1],\n            tileType: match[2],\n            mapVersion: match[3],\n            scheme: match[4]\n        };\n    }\n\n    private getAuthParams(): string[] {\n        const { apikey } = this.m_options as ApiKeyAuthentication;\n        const { appId, appCode } = this.m_options as AppIdAuthentication;\n        const { authenticationCode } = this.m_options as TokenAuthentication;\n\n        const useAuthenticationCode = authenticationCode !== undefined;\n        const useApiKey = apikey !== undefined;\n        const useAppId = appId !== undefined && appCode !== undefined;\n\n        if (useAuthenticationCode) {\n            return [];\n        } else if (useApiKey) {\n            return [`apikey=${apikey}`];\n        } else if (useAppId) {\n            return [`app_id=${appId}`, `app_code=${appCode}`];\n        }\n\n        throw new Error(\"Neither apiKey, appId/appCode nor authenticationCode are defined.\");\n    }\n\n    private getCopyrightRequestParams(): string {\n        const requestParams = [\"output=json\", ...this.getAuthParams()];\n\n        return `?${requestParams.join(\"&\")}`;\n    }\n\n    private getImageRequestParams(): string {\n        const requestParams = this.getAuthParams();\n\n        if (this.m_options.additionalRequestParameters !== undefined) {\n            requestParams.push(this.m_options.additionalRequestParameters);\n        }\n        if (this.m_ppi !== WebTileDataSource.ppiValue.ppi72) {\n            // because ppi=72 is default, we do not include it in the request\n            requestParams.push(`ppi=${this.m_ppi}`);\n        }\n        if (this.m_languages !== undefined && this.m_languages[0] !== undefined) {\n            requestParams.push(`lg=${this.m_languages[0]}`);\n        }\n\n        if (this.m_languages !== undefined && this.m_languages[1] !== undefined) {\n            requestParams.push(`lg2=${this.m_languages[1]}`);\n        }\n\n        if (requestParams.length > 0) {\n            return `?${requestParams.join(\"&\")}`;\n        }\n\n        return \"\";\n    }\n}\n\n/**\n * Instances of `HereWebTileDataSource` can be used to add Web Tile to [[MapView]].\n *\n * Example:\n *\n * ```typescript\n * const hereWebTileDataSource = new HereWebTileDataSource({\n *     authenticationCode: <authenticationCode>\n * });\n * ```\n * @see [[DataSource]], [[OmvDataSource]].\n */\nexport class HereWebTileDataSource extends WebTileDataSource {\n    /**\n     * Constructs a new `HereWebTileDataSource`.\n     *\n     * @param m_options - Represents the [[HereWebTileDataSourceParameters]].\n     */\n    constructor(m_options: HereWebTileDataSourceParameters) {\n        super({\n            ...m_options,\n            minDataLevel: 1,\n            maxDataLevel: 20,\n            resolution: m_options.resolution,\n            dataProvider: new HereTileProvider(m_options),\n            storageLevelOffset: m_options.storageLevelOffset ?? -1\n        });\n        this.cacheable = true;\n        if (this.resolution === WebTileDataSource.resolutionValue.resolution512) {\n            this.maxDataLevel = 19; // 512x512 tiles do not have z19\n        }\n    }\n\n    /** @override */\n    setLanguages(languages?: string[]): void {\n        if (languages !== undefined) {\n            (this.dataProvider as HereTileProvider).mapIsoLanguageToWebTile(languages);\n            this.mapView.markTilesDirty(this);\n        }\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { TileKey, TilingScheme, webMercatorTilingScheme } from \"@here/harp-geoutils\";\nimport { CopyrightInfo, DataSource, DataSourceOptions, Tile } from \"@here/harp-mapview\";\nimport { getOptionValue } from \"@here/harp-utils\";\nimport THREE = require(\"three\");\nimport { WebTileLoader } from \"./WebTileLoader\";\n\n/**\n * An interface for the rendering options that can be passed to the [[WebTileDataSource]].\n */\nexport interface WebTileRenderingOptions {\n    /**\n     * Opacity of the rendered images.\n     * @defaultValue 1.0\n     */\n    opacity?: number;\n\n    /**\n     * Force Material to use transparency from texture if available\n     * @defaultValue false\n     */\n    transparent?: boolean;\n\n    /**\n     * RenderOrder for order in which to render WebTileDataSouurces\n     * @defaultValue 0\n     * @deprecated Use instead `dataSourceOrder` on {@link DataSource}\n     */\n    renderOrder?: number;\n}\n\nexport interface WebTileDataProvider {\n    /**\n     * The method to create the Texture that will be applied to the Tile\n     *\n     * If the Promise is resolved with an undefined Texture, the Tile is considered loaded\n     * and having no data.\n     * If the Promise is rejected, it is considered a temporary failure and the tile will be\n     * disposed and recreated if visible again.\n     * @param tile - Tile to which the texture will be applied.\n     * @param abortSignal - Optional AbortSignal to cancel the request.\n     */\n    getTexture: (\n        tile: Tile,\n        abortSignal?: AbortSignal\n    ) => Promise<[THREE.Texture | undefined, CopyrightInfo[]] | undefined>;\n}\n\n/**\n * Options for [[WebTileDataSource]].\n */\nexport interface WebTileDataSourceOptions\n    extends Omit<DataSourceOptions, \"enablePicking\" | \"styleSetName\"> {\n    /**\n     * A DataProvider that will provide the tiles.\n     */\n    dataProvider: WebTileDataProvider;\n\n    /**\n     * The resolution of Web Tile images, defaults to 512.\n     */\n    resolution?: WebTileDataSource.resolutionValue;\n\n    /**\n     * Options affecting the rendering of the web tiles.\n     */\n    renderingOptions?: WebTileRenderingOptions;\n}\n\n/**\n * Instances of `WebTileDataSource` can be used to add Web Tile to [[MapView]].\n *\n * Example:\n *\n * ```typescript\n * const webTileDataSource = new WebTileDataSource({\n *     dataProvider: {\n *         getTexture: <your custom implementation>\n *     }\n * });\n * ```\n * @see {@links DataSource}\n */\nexport class WebTileDataSource extends DataSource {\n    protected readonly m_resolution: WebTileDataSource.resolutionValue;\n    protected dataProvider: WebTileDataProvider;\n\n    private m_opacity: number = 1;\n    private readonly m_renderOrder: number = 0;\n    private m_transparent: boolean = false;\n\n    /**\n     * Constructs a new `WebTileDataSource`.\n     *\n     * @param m_options - Represents the [[WebTileDataSourceParameters]].\n     */\n    constructor(protected readonly m_options: WebTileDataSourceOptions) {\n        super(m_options);\n\n        this.dataProvider = this.m_options.dataProvider;\n        this.cacheable = true;\n        this.m_opacity = this.m_options.renderingOptions?.opacity ?? 1;\n        this.m_transparent =\n            this.m_options.renderingOptions?.transparent === true || this.m_opacity < 1;\n        this.m_renderOrder = this.m_options.renderingOptions?.renderOrder ?? 0;\n        this.m_resolution = getOptionValue(\n            m_options.resolution,\n            WebTileDataSource.resolutionValue.resolution512\n        );\n    }\n\n    /**\n     * Sets the opacity for the WebTileDataSource, will only affect not yet loaded or not cached\n     * tiles.\n     *\n     * Use WebTileDataSource:clearCache and MapView:markTilesDirty to reload all tiles with the\n     * new opacity setting.\n     */\n    set opacity(value: number) {\n        this.m_opacity = value;\n        if (this.m_opacity < 1) {\n            this.m_transparent = true;\n        } else if (this.m_options.renderingOptions?.transparent !== true) {\n            this.m_transparent = false;\n        }\n    }\n\n    /**\n     * Gets the opacity of the WebTileDataSource.\n     */\n    get opacity(): number {\n        return this.m_opacity;\n    }\n\n    get resolution(): WebTileDataSource.resolutionValue {\n        return this.m_resolution as WebTileDataSource.resolutionValue;\n    }\n\n    /**\n     * Gets the renderOrder of the WebTileDataSource.\n     *\n     * @deprecated Use instead the `dataSourceOrder` on {@link DataSource}\n     */\n    get renderOrder(): number {\n        return this.m_renderOrder;\n    }\n\n    /**\n     * Gets whether tiles of this WebTileDataSource are transparent.\n     */\n    get transparent(): boolean {\n        return this.m_transparent;\n    }\n\n    /** @override */\n    shouldPreloadTiles(): boolean {\n        return true;\n    }\n\n    /** @override */\n    getTilingScheme(): TilingScheme {\n        return webMercatorTilingScheme;\n    }\n\n    /** @override */\n    getTile(tileKey: TileKey) {\n        const tile: Tile = new Tile(this, tileKey);\n        tile.tileLoader = new WebTileLoader(this, tile, this.dataProvider);\n        return tile;\n    }\n\n    /** @override */\n    isFullyCovering(): boolean {\n        return true;\n    }\n}\n/**\n * Definitions of variable values to be used with `WebTileDataSource`\n */\nexport namespace WebTileDataSource {\n    export enum ppiValue {\n        ppi72 = 72,\n        ppi250 = 250,\n        ppi320 = 320,\n        ppi500 = 500\n    }\n    export enum resolutionValue {\n        resolution256 = 256,\n        resolution512 = 512\n    }\n}\n","/*\n * Copyright (C) 2020-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { BaseTileLoader, Tile, TileLoaderState } from \"@here/harp-mapview\";\nimport { addGroundPlane } from \"@here/harp-mapview/lib/geometry/AddGroundPlane\";\nimport { enableBlending } from \"@here/harp-materials\";\nimport * as THREE from \"three\";\n\nimport { WebTileDataProvider, WebTileDataSource } from \"./WebTileDataSource\";\n\n/**\n * TileLoader used by `WebTileDataSource`.\n */\nexport class WebTileLoader extends BaseTileLoader {\n    /**\n     * Set up loading of a single [[Tile]].\n     *\n     * @param dataSource - The [[DataSource]] the tile belongs to.\n     * @param tileKey - The quadtree address of a [[Tile]].\n     * @param dataProvider - The [[DataProvider]] that retrieves the binary tile data.\n     */\n    constructor(\n        protected dataSource: WebTileDataSource,\n        private readonly tile: Tile,\n        private readonly dataProvider: WebTileDataProvider\n    ) {\n        super(dataSource, tile.tileKey);\n    }\n\n    /**\n     * @override\n     */\n    protected loadImpl(\n        abortSignal: AbortSignal,\n        onDone: (doneState: TileLoaderState) => void,\n        onError: (error: Error) => void\n    ): void {\n        this.dataProvider\n            .getTexture(this.tile, abortSignal)\n            .then(value => {\n                if (value === undefined || value[0] === undefined) {\n                    this.tile.forceHasGeometry(true);\n                    onDone(TileLoaderState.Ready);\n                    return;\n                }\n\n                const [texture, copyrightInfo] = value;\n                if (copyrightInfo !== undefined) {\n                    this.tile.copyrightInfo = copyrightInfo;\n                }\n\n                texture.minFilter = THREE.LinearFilter;\n                texture.magFilter = THREE.LinearFilter;\n                texture.generateMipmaps = false;\n                // This is required because the WebTileDataSource uses the default setting of\n                // useGeometryLoader on the DataSource, so it has to clear the tile's objects\n                // manually.\n                this.tile.clear();\n                this.tile.addOwnedTexture(texture);\n                const planeMesh = addGroundPlane(\n                    this.tile,\n                    this.dataSource.renderOrder,\n                    0xffffff,\n                    this.dataSource.opacity,\n                    true\n                );\n                const planeMaterial = planeMesh.material as THREE.MeshBasicMaterial;\n                planeMaterial.map = texture;\n                if (this.dataSource.transparent) {\n                    enableBlending(planeMaterial);\n                }\n                planeMaterial.depthTest = false;\n\n                this.tile.invalidateResourceInfo();\n                this.dataSource.requestUpdate();\n                onDone(TileLoaderState.Ready);\n            }, onError)\n            .catch(onError);\n    }\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { ConcurrentDecoderFacade, ConcurrentTilerFacade } from \"@here/harp-mapview\";\nimport { WorkerLoader } from \"@here/harp-mapview/lib/workers/WorkerLoader\";\nimport { baseUrl, UriResolver } from \"@here/harp-utils\";\n\n/**\n * Default decoder url for bundled map component.\n */\nexport const DEFAULT_DECODER_SCRIPT_URL = \"harp.js-bundle://harp-decoders.js\";\n\n/**\n * Basename of map bundle script - used by [[getBundleScriptUrl]] as fallback, when\n * `document.currentScript` is not present.\n *\n * @hidden\n */\nexport const BUNDLE_SCRIPT_BASENAME = \"harp\";\n\n/**\n * Guess `harp(.min).js` script URL.\n *\n * Required to find default URLs `harp-decoders.js` which are hosted together, not necessarily with\n * base URL of current page.\n *\n * @see https://stackoverflow.com/questions/2976651\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/currentScript\n * @hidden\n */\nexport function getBundleScriptUrl(): string | undefined | null {\n    if (bundleScriptUrl !== undefined) {\n        return bundleScriptUrl;\n    }\n\n    const currentScript = document.currentScript as HTMLScriptElement | null;\n    const baseScriptUrl =\n        currentScript !== null &&\n        typeof currentScript.src === \"string\" &&\n        (currentScript.src.endsWith(BUNDLE_SCRIPT_BASENAME + \".js\") ||\n            currentScript.src.endsWith(BUNDLE_SCRIPT_BASENAME + \".min.js\"))\n            ? currentScript.src\n            : getScriptUrl(BUNDLE_SCRIPT_BASENAME);\n\n    if (baseScriptUrl) {\n        bundleScriptUrl = baseScriptUrl;\n        return bundleScriptUrl;\n    } else {\n        bundleScriptUrl = null;\n        return undefined;\n    }\n}\n\n/**\n * Memoizes result of [[getBundleScriptUrl]].\n * @hidden\n */\nlet bundleScriptUrl: string | undefined | null;\n\n/**\n * Get script URL assumet it's already loaded in DOM.\n *\n * Required to find default URLs `harp.(min.)js` and `three().min).js` which are required to\n * properly start decoder bundle.\n *\n * @see https://stackoverflow.com/questions/2976651\n * @hidden\n */\nexport function getScriptUrl(name: string): string | undefined | null {\n    const scriptElement =\n        document.querySelector(`script[src*='/${name}.min.js']`) ??\n        document.querySelector(`script[src='${name}.min.js']`) ??\n        document.querySelector(`script[src*='/${name}.js']`) ??\n        document.querySelector(`script[src='${name}.js']`);\n\n    if (scriptElement) {\n        return (scriptElement as HTMLScriptElement).src;\n    } else {\n        return undefined;\n    }\n}\n\nconst HARP_GL_BUNDLED_ASSETS_PREFIX = \"harp.js-bundle://\";\n\n/**\n * Resolve URLs with support for `harp.gl` bundle specific URLs.\n *\n * URLs with prefix `harp.gl:` are resolved relatively to `harp.js` bundle's base URL.\n *\n * @hidden\n */\nexport class BundledUriResolver implements UriResolver {\n    resolveUri(uri: string) {\n        if (uri.startsWith(HARP_GL_BUNDLED_ASSETS_PREFIX)) {\n            const bundleSriptUrl = getBundleScriptUrl();\n            if (bundleSriptUrl === null || bundleSriptUrl === undefined) {\n                throw new Error(\n                    `harp.js: cannot resolve ${uri} because 'harp.gl' base url is not set.`\n                );\n            } else {\n                uri = uri.substring(HARP_GL_BUNDLED_ASSETS_PREFIX.length);\n                if (uri.startsWith(\"/\")) {\n                    uri = uri.substring(1);\n                }\n                return baseUrl(bundleSriptUrl) + uri;\n            }\n        }\n        return uri;\n    }\n}\nconst bundledUriResolver = new BundledUriResolver();\n\nconst getActualDecoderScriptUrl = () => {\n    const baseScriptUrl = getBundleScriptUrl();\n    if (!baseScriptUrl) {\n        // eslint-disable-next-line no-console\n        console.error(\n            `harp.js: Unable to determine default location of 'harp-decoders(min).js'. ` +\n                `See https://github.com/heremaps/harp.gl/@here/harp.gl.`\n        );\n    }\n    if (!WorkerLoader.dependencyUrlMapping.three) {\n        // eslint-disable-next-line no-console\n        console.error(\n            `harp.js: Unable to determine location of 'three(.min).js'. ` +\n                \"`See https://github.com/heremaps/harp.gl/@here/harp.gl.`\"\n        );\n    }\n    const isMinified = baseScriptUrl && baseScriptUrl.endsWith(\".min.js\");\n\n    const decoderScriptName = !isMinified\n        ? DEFAULT_DECODER_SCRIPT_URL\n        : DEFAULT_DECODER_SCRIPT_URL.replace(/\\.js$/, \".min.js\");\n    return bundledUriResolver.resolveUri(decoderScriptName);\n};\n\n/**\n * Guess decoder script URL.\n *\n * Assumes that decoder script - `harp-decoders.js` is in same place as main bundle and calculates\n * it's URL.\n *\n * Minified version of `harp.js` bundle loads minified version of decoder.\n * Hooks in [[ConcurrentDecoderFacade]] to use this URL as default `defaultScriptUrl`.\n *\n * @hidden\n */\nfunction installDefaultDecoderUrlHook() {\n    ConcurrentDecoderFacade.defaultScriptUrl = \"\";\n    ConcurrentTilerFacade.defaultScriptUrl = \"\";\n\n    const threeUrl = getScriptUrl(\"three\")!;\n\n    WorkerLoader.dependencyUrlMapping.three = threeUrl;\n\n    const oldDecoderGetWorkerSet = ConcurrentDecoderFacade.getWorkerSet;\n    ConcurrentDecoderFacade.getWorkerSet = (scriptUrl?: string) => {\n        if (scriptUrl === undefined && ConcurrentDecoderFacade.defaultScriptUrl === \"\") {\n            const newScriptUrl = getActualDecoderScriptUrl();\n\n            ConcurrentDecoderFacade.defaultScriptUrl = newScriptUrl;\n        }\n        return oldDecoderGetWorkerSet.apply(ConcurrentDecoderFacade, [scriptUrl]);\n    };\n\n    const oldTilerGetWorkerSet = ConcurrentTilerFacade.getWorkerSet;\n    ConcurrentTilerFacade.getWorkerSet = (scriptUrl?: string) => {\n        if (scriptUrl === undefined && ConcurrentTilerFacade.defaultScriptUrl === \"\") {\n            const newScriptUrl = getActualDecoderScriptUrl();\n\n            ConcurrentTilerFacade.defaultScriptUrl = newScriptUrl;\n        }\n        return oldTilerGetWorkerSet.apply(ConcurrentTilerFacade, [scriptUrl]);\n    };\n}\n\n/**\n * Initialize `harp.gl` bundle.\n *\n * Install specific default decoder urls into [[ConcurrentDecoderFacade]].\n * @hidden\n */\nexport function mapBundleMain() {\n    getBundleScriptUrl();\n    installDefaultDecoderUrlHook();\n}\n","/*\n * Copyright (C) 2019-2021 HERE Europe B.V.\n * Licensed under Apache 2.0, see full license in LICENSE\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport { mapBundleMain } from \"./BundleMain\";\n\nif (!(window as any).THREE) {\n    // eslint-disable-next-line no-console\n    console.warn(\n        \"harp.js: It looks like 'three.js' is not loaded. This script requires 'THREE' object to \" +\n            \"be defined. See https://github.com/heremaps/harp.gl/@here/harp.gl.\"\n    );\n}\n\nexport * from \"@here/harp-mapview\";\nexport * from \"@here/harp-vectortile-datasource\";\nexport * from \"@here/harp-omv-datasource\";\nexport * from \"@here/harp-debug-datasource\";\nexport * from \"@here/harp-geojson-datasource\";\nexport * from \"@here/harp-features-datasource\";\nexport * from \"@here/harp-webtile-datasource\";\nexport * from \"@here/harp-map-controls/lib/MapControls\";\nexport * from \"@here/harp-map-controls/lib/MapControlsUI\";\nexport * from \"@here/harp-datasource-protocol\";\nexport * from \"@here/harp-geoutils\";\nexport * from \"@here/harp-mapview-decoder\";\n\nmapBundleMain();\n","module.exports = THREE;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(1206);\n"],"sourceRoot":""}