"use strict";
/*
 * Copyright (C) 2019-2021 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LongPressHandler = void 0;
/**
 * Class that can be used to track long presses on an HTML Element. A long press is a press that
 * lasts a minimum duration (see the [[timeout]] member) while the pointer is not moved more than a
 * certain threshold (see the [[moveThreshold]] member).
 */
class LongPressHandler {
    /**
     * Default constructor.
     *
     * @param element - The HTML element to track.
     * @param onLongPress - The callback to call when a long press occurred.
     * @param onTap - Optional callback to call on a tap, i.e. when the press ends before the
     * specified timeout.
     */
    constructor(element, onLongPress, onTap) {
        this.element = element;
        this.onLongPress = onLongPress;
        this.onTap = onTap;
        /**
         * How long to wait (in ms) until a press is considered a long press.
         */
        this.timeout = 500;
        /**
         * If the cursor moves more than the given number of pixels, it is not a long-press, but a pan.
         */
        this.moveThreshold = 5;
        /**
         * Mouse button id that should be handled by this event.
         */
        this.buttonId = 0;
        this.m_pressEvent = undefined;
        this.m_timerId = undefined;
        this.m_moveHandlerRegistered = false;
        this.m_boundPointerMoveHandler = this.onPointerMove.bind(this);
        this.m_boundMouseDownHandler = this.onMouseDown.bind(this);
        this.m_boundTouchStartHandler = this.onTouchStart.bind(this);
        this.m_boundMouseUpHandler = this.onMouseUp.bind(this);
        this.m_boundTouchEndHandler = this.onTouchEnd.bind(this);
        this.element.addEventListener("mousedown", this.m_boundMouseDownHandler);
        this.element.addEventListener("touchstart", this.m_boundTouchStartHandler);
        this.element.addEventListener("mouseup", this.m_boundMouseUpHandler);
        this.element.addEventListener("touchend", this.m_boundTouchEndHandler);
    }
    /**
     * Removes all events listeners. No more events will be sent.
     */
    dispose() {
        this.cancel();
        this.element.removeEventListener("mousedown", this.m_boundMouseDownHandler);
        this.element.removeEventListener("touchstart", this.m_boundTouchStartHandler);
        this.element.removeEventListener("mouseup", this.m_boundMouseUpHandler);
        this.element.removeEventListener("touchend", this.m_boundTouchEndHandler);
    }
    startPress(event) {
        var _a, _b;
        this.cancelTimer();
        this.m_pressEvent = (_b = (_a = event.changedTouches) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : event;
        this.m_timerId = setTimeout(() => this.onTimeout(), this.timeout);
        this.addPointerMoveHandler();
    }
    onMouseDown(event) {
        if (event.button === this.buttonId) {
            this.startPress(event);
        }
    }
    onTouchStart(event) {
        if (this.m_pressEvent) {
            // Cancel long press if a second touch starts while holding the first one.
            this.cancel();
            return;
        }
        if (event.changedTouches.length === 1) {
            this.startPress(event);
        }
    }
    onMouseUp(event) {
        var _a;
        if (this.m_pressEvent && event.button === this.buttonId) {
            this.cancel();
            (_a = this.onTap) === null || _a === void 0 ? void 0 : _a.call(this, event);
        }
    }
    onTouchEnd(event) {
        var _a;
        if (event.changedTouches.length === 1 &&
            event.changedTouches[0].identifier === this.m_pressEvent.identifier) {
            this.cancel();
            (_a = this.onTap) === null || _a === void 0 ? void 0 : _a.call(this, event.changedTouches[0]);
        }
    }
    onPointerMove(event) {
        var _a, _b;
        if (this.m_pressEvent === undefined) {
            return; // Must not happen
        }
        const { clientX, clientY } = (_b = (_a = event.changedTouches) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : event;
        const manhattanLength = Math.abs(clientX - this.m_pressEvent.clientX) +
            Math.abs(clientY - this.m_pressEvent.clientY);
        if (manhattanLength > this.moveThreshold) {
            this.cancel();
        }
    }
    cancel() {
        this.m_pressEvent = undefined;
        this.cancelTimer();
        this.removePointerMoveHandler();
    }
    cancelTimer() {
        if (this.m_timerId === undefined) {
            return;
        }
        clearTimeout(this.m_timerId);
        this.m_timerId = undefined;
    }
    addPointerMoveHandler() {
        if (this.m_moveHandlerRegistered) {
            return;
        }
        this.element.addEventListener("mousemove", this.m_boundPointerMoveHandler);
        this.element.addEventListener("touchmove", this.m_boundPointerMoveHandler);
        this.m_moveHandlerRegistered = true;
    }
    removePointerMoveHandler() {
        if (!this.m_moveHandlerRegistered) {
            return;
        }
        this.element.removeEventListener("mousemove", this.m_boundPointerMoveHandler);
        this.element.removeEventListener("touchmove", this.m_boundPointerMoveHandler);
        this.m_moveHandlerRegistered = false;
    }
    onTimeout() {
        const event = this.m_pressEvent;
        this.m_timerId = undefined;
        this.cancel();
        if (event !== undefined) {
            this.onLongPress(event);
        }
    }
}
exports.LongPressHandler = LongPressHandler;
//# sourceMappingURL=LongPressHandler.js.map